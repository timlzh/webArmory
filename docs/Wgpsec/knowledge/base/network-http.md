---
title: 【网络基础】HTTP协议
---

# HTTP协议概述

HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接” ；HTTP/1.1 默认使用长连接(持久化连接)

**与HTTPS的主要区别**

> HTTP是明文传输；HTTPS是SSL加密传输
>
> HTTP是无状态的，简单但不安全；HTTPS需要身份认证，加密传输，比HTTP安全
>

#### 当你输入一个网址，点击访问，会发生什么？

**查找DNS记录**

1. 查看浏览器缓存
2. 查看系统缓存
3. 查看路由器缓存
4. 查找ISP DNS缓存
5. 递归搜索。根据网址，发送一个DNS请求，UDP请求，端口为543，会请求一个DNS服务器，DNS服务器会不断递归查找这个网址的IP

**建立连接**

1. 跟获取到的IP建立TCP连接，在TCP连接(80端口)上发送HTTP报文；根据规则， 只有低层协议建立之后才能，才能进行高层协议的连接 
2. 发送请求行，`GET  /dir/xx.php HTTP/1.1`
3. 发送请求头，浏览器发送一行空白行来告知服务器结束请求头信息发送
4. 服务器响应， `HTTP/1.1 200 OK`（协议版本号和HTTP状态码）
5. 服务器发送响应头，服务器自己的相关信息（同样用空白行表示结束响应头）
6.  服务器向浏览器发送数据， 以`Content-Type`响应头信息所描述的格式发送用户所请求的实际数据 
7. 服务器关闭TCP连接，如果请求头或响应头加了这行 `Connection:keep-alive` 代码，会保持连接

**请求方法**

> **GET：**用于请求已被URL识别的资源
>
> **POST：**用于向服务器传输数据，例如提交表单、文件上传
>
> **OPTIONS**：查询相应URL支持的HTTP方法 
>
> **HEAD：** 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效 
>
> **PUT：** 上传文件，报文主体中包含文件内容，保存到对应URL位置 
>
> **DELETE**：删除文件，与PUT方法相反，删除对应URI位置的文件 
>
> **TRACE：** 用于诊断，响应中返回收到请求消息的具体内容

# 常见请求头

#### 通用首部字段（请求报文与响应报文都会使用的首部字段）

> Date：报文创建时间
> **Connection：**连接的管理，告诉通信另一端完成HTTP传输后，是关闭TCP连接，还是保持连接以接受其它消息
> Cache-Control：缓存的控制
> Transfer-Encoding：报文主体的传输编码方式

#### 请求首部字段（请求报文会使用的首部字段）

> Host：请求资源所在服务器和端口号
> Accept：可处理的媒体类型
> Accept-Charset：可接收的字符集
> Accept-Encoding：可接受的内容编码
> Accept-Language：可接受的自然语言
>
> **Cookie：**用于向服务器提交它以前发布的cookie
>
> **If-Modified-Since：** 用于说明最后一次收到所请求资源的时间
>
> 如果自那之后资源没有变化，服务器会返回一个状态码304的响应，指示客户端使用资源的缓存副本
>
> **If-None-Match：**用于指定一个实体标签
>
> 当最后一次收到所请的求资源时，浏览器提交服务器发布的实体标签
>
> 服务器可以使用实体标签，确认浏览器是否使用资源的缓存副本
>
> **Origin：** 用在Ajax跨域请求中，用于指示提出请求的域
>
> **Referer：**指示发出当前请求的原始URL
>
> **User-Agent**	提供生成请求客户端软件的有关信息

#### 响应首部字段（响应报文会使用的首部字段）

> Allow：资源可支持的HTTP方法
> Location：在重定向响应中，说明重定向的目标
> Server：提供所使用的Web服务器软件的信息
>
> Accept-Ranges：可接受的字节范围

#### 实体首部字段（请求报文与响应报文的消息主体部分使用的首部字段）

> **Content-Type**：规定消息主体的类型
> **Content-Encoding：**实体主体适用的编码方式，一些应用程序用它压缩响应加快传输
> Content-Language：实体主体的自然语言
> **Content-Length：**规定消息主体的字节长度 (HEAD方法例外)
> Content-Range：实体主体的位置范围，一般用于发出部分请求时使用
>
> **Transfer-Encoding：** chunked 分块传输；常用它指定块编码，它是指定HTTP传输对消息主体使用的任何编码的
>
> **Access-Control-Allow-Origin：**指示可否通过跨域Ajax请求获取资源
>
> **ETag：**用于指定一个实体标签。
>
> 客户端可在将来的请求中提交这个标识符，获取和If-None-Match消息头中相同的资源
>
> 通知服务器浏览器当前缓存中保存的是哪个版本的资源
>
> **Expirses：** 用于向浏览器说明消息主体内容的有效时间，在这个时间内浏览器可以使用这个资源的缓存副本
>
> **Pragma**	指示浏览器不要将响应保存在缓存中(no-cache)
>
> **Set-Cookie：**用于向浏览器发布Cookie，浏览器会在随后的请求中将其返回给服务器
>
> **WWW-Authenticate：**在带401状态码的响应中，提供与服务器所支持的身份验证类型的有关信息 (如基础认证)
>
> X-Frame-Options：指示浏览器框架是否加载以及如何加载当前响应

#### **Cookie**

HTTP协议是无状态的，为使用正确的状态数据处理每个请求，常用Cookie对用户会话进行唯一标识。

```javascript
document.cookie	//获取cookie
```

Cookie 一般由一个 `名/值` 对组成(id=12345)，也可以包含任何不含空格的字符串。

除Cookie的实际值外，Set-Cookie消息头还可以包含以下可选属性，用它们控制浏览器处理Cookie的方式。

> **expires：**用于设定Cookie有效时间，此时间内cookie一直有效
>
> 如果没设这个属性cookie仅在当前浏览器会话中有用，关闭浏览器将失效
>
> **domain：**用于指定cookie的有效域，这个域必须和收到Cookie的域相同，或是它的父域
>
> path：指定cookie的有效URL路径
>
> secure：如果设置这个属性，则仅在HTTPS请求中提交Cookie
>
> HTTPOnly：如果设置这个属性，将无法通过客户端javascript直接访问Cookie

# 常见状态码

> 100：表示收到请求消息头，客户端应继续发送主体
>
> 200：请求被正常处理
>
> 201：PUT请求返回这个状态码，表示请求已成功提交
>
> 204：请求被受理但没有资源可以返回
> 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
> 301：永久性重定向
> 302：临时重定向
> 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
> 304：发送附带条件的请求时，条件不满足时返回，指示浏览器使用缓存中所请求资源的副本
> 307：临时重定向，与302类似，只是强制要求使用POST方法
> 400：请求报文语法有误，服务器无法识别
> 401：请求需要认证
> 403：请求的对应资源禁止被访问
> 404：服务器无法找到对应资源
>
> 405：不支持请求中使用的请求方法
>
> 413：请求主体过长，服务器无法处理 (探查缓冲区溢出时会有)
>
> 414：请求URL过长，服务器无法处理
>
> 500：服务器内部错误
> 503：服务器正忙，用来说明服务器现在无法为请求提供服务，但将来可以 (服务器负载过大)

# HTTP/1.1新特性

一、 默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求 

二、 管线化 ( pipelining )，客户端可以同时发出多个HTTP请求，而不用一个个等待响应 

三、 断点续传。实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输 

(利用新特性有两种绕过WAF的方法)



# HTTP优化方案有哪些呢？

**TCP复用：**

TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。

前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。

**内容缓存：**将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。

**压缩：**将文本数据进行压缩，减少带宽

**SSL加速（SSL Acceleration）：**使用SSL协议对HTTP协议进行加密，在通道内加密并加速

**TCP缓冲：**通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担



# HTTP代理

当配置浏览器使用代理服务器时，它会将所有的请求提交到代理服务器，代理服务器再将请求转给Web服务器。

常用的代理服务器软件有BurpSuite和Fiddler。

**如果使用代理服务器，HTTP工作机制会出现两方面差异：**

> **(1)** 当使用代理服务器发布HTTP请求时，它会将完整的URL插入请求中
>
> ​	  代理服务器将提取主机名和端口，用这些信息将请求指向正确的目标Web服务器
>
> **(2)** 当使用HTTPS时，浏览器无法与代理服务器进行SSL握手，因为这样会破坏隧道，使通信遭受拦截攻击
>
> ​	  因此浏览器必须将代理作为一个纯粹的TCP中继，一直开放TCP连接



# HTTP身份验证

**Basic：**基础认证，在请求消息头中随每条消息以base64编码字符串的形式发送用户证书。

使用BurpSuite的Intruder模块自定义迭代器base64编码payload后请求或使用co2插件都可攻击基础认证。

**NTML：**这是一种质询-响应式机制，使用某个Windows NTML协议版本，很大程度上已被 Kerberos 取代。

**Digest：**这是一种质询-响应式机制，随用户证书一起使用一个随机值MD5校验和

HTTP Basic 与 HTTP Digest 认证现在已经合并成一个标准， 即 RFC2617。