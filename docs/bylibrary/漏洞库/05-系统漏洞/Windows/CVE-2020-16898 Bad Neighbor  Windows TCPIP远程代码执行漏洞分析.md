## CVE-2020-16898 "Bad Neighbor " Windows TCP/IP远程代码执行漏洞分析

该漏洞主要是由于Windows  TCP/IP堆栈在处理选项类型为25(0x19，递归DNS服务器选项)且长度字段值为偶数的ICMPv6的路由广播数据包时，处理逻辑存在纰漏，导致存在远程代码执行漏洞。成功利用该漏洞的攻击者可以在目标机器（主机或服务器）上执行任意代码。

**一、漏洞信息**

**1. 漏洞简述**

-  漏洞名称：Windows TCP/IP Remote Code Execution Vulnerability
-  漏洞编号：CVE-2020-16898
-  漏洞类型：Design Weakness
-  漏洞影响：Code Execution
-  CVSS评分：9.8
-  利用难度：Medium
-  基础权限：不需要

**2. 组件概述**

TCP/IP是Internet上使用的通信协议。   在Windows的早期版本中，TCP/IP是一个单独的可选组件，可以像其他任何协议一样删除或添加。从Windows XP/Server   2003开始，TCP/IP成为操作系统的核心组件，无法删除。  将TCP/IP作为Windows的核心组件是非常有意义的，因为它的功能在Microsoft  Windows  Server上对网络操作和Active Directory域环境尤为重要。 整个Active   Directory架构基于DNS层次结构，依赖于TCP/IP 传输协议 。

Microsoft  Windows中的TCP/IP功能在内核级别运行，并由驱动程序tcpip.sys提供。该驱动程序处理所有传入和传出的TCP/IP通信信息，包括解析从网络接口接收到的数据包，以及解释此数据并将其传递给更高级别的组件。

**3. 漏洞利用**

该漏洞主要是由于Windows   TCP/IP堆栈在处理选项类型为25(0x19，递归DNS服务器选项)且长度字段值为偶数的ICMPv6的路由广播数据包时，处理逻辑存在纰漏，导致存在远程代码执行漏洞。成功利用该漏洞的攻击者可以在目标机器(主机或服务器)上执行任意代码。

**4. 漏洞影响**

-  Microsoft Windows 10 1709
-  Microsoft Windows 10 1803
-  Microsoft Windows 10 1809
-  Microsoft Windows 10 1903
-  Microsoft Windows 10 1909
-  Microsoft Windows 10 2004
-  Microsoft Windows Server 2019
-  Microsoft Windows Server, version 1903
-  Microsoft Windows Server, version 1909
-  Microsoft Windows Server, version 2004

**5. 解决方案**

官方解决方案：微软官方针对该漏洞已发布安全更新补丁，补丁地址：https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-16898

临时解决方案：

管理员启动powershell或cmd，输入以下命令检查所有网络IPv6接口的列表以及相应的索引号：

netsh int ipv6 sh int

样例输出如下：

 [![img](https://s6.51cto.com/oss/202010/19/d884b2bf8c0e30377ad7239f16e509ee.jpg)](https://s6.51cto.com/oss/202010/19/d884b2bf8c0e30377ad7239f16e509ee.jpg)

确认网络接口的RDNSS功能开启情况：

netsh int ipv6 sh int Idx number

 [![img](https://s6.51cto.com/oss/202010/19/7391948e0fa33687b21f2f0fee998f42.jpg)](https://s6.51cto.com/oss/202010/19/7391948e0fa33687b21f2f0fee998f42.jpg)

执行以下命令关闭RDNSS功能(将Idx number替换为要关闭的网络接口的Idx值)：

netsh int ipv6 set int Idx number rabaseddnsconfig=disable

样例输出如下：

 [![img](https://s2.51cto.com/oss/202010/19/733a08f83e67ca7639d86f2c54e37da9.jpg)](https://s2.51cto.com/oss/202010/19/733a08f83e67ca7639d86f2c54e37da9.jpg)

此时再次确认接口的RDNSS开启情况，RDNSS功能已被关闭：

 [![img](https://s2.51cto.com/oss/202010/19/4ca85e8058ef9e79c6955ff7e35d1af5.jpg)](https://s2.51cto.com/oss/202010/19/4ca85e8058ef9e79c6955ff7e35d1af5.jpg)

**二、漏洞复现**

**1. 环境搭建**

l 靶机：Windows 10 1809 x64

l 靶机操作：无需任何操作，可正常与攻击机通信即可

**2. 复现过程**

\1. 通过各种手段获取目标主机的IPv6地址和MAC地址(具体方法可自行探索，较为简单)

\2. 攻击机python3运行poc：

 [![img](https://s6.51cto.com/oss/202010/19/47626a2b071c1c87608a488e19dd1e69.jpg)](https://s6.51cto.com/oss/202010/19/47626a2b071c1c87608a488e19dd1e69.jpg)

\3. 靶机crash：

 [![img](https://s4.51cto.com/oss/202010/19/53121a26663428435db7bf9718292d9b.jpg)](https://s4.51cto.com/oss/202010/19/53121a26663428435db7bf9718292d9b.jpg)

**三、漏洞分析**

**1. 基本信息**

-  漏洞文件：tcpip.sys
-  漏洞函数：Ipv6pUpdateRDNSS()函数
-  漏洞对象：ICMPv6路由广播中的option结构

**2. 背景知识**

限于篇幅问题，此处不对用于DNS配置的IPv6路由广播进行详细介绍，更详细资料可参考RFC8106。

**1. 基本知识**

IPv6 Router Advertisment (RA) options，也称为DNS RA   options，允许IPv6的路由器向IPv6的主机广播DNS Recursive Server  Address(DNS递归路由器地址)列表和DNS  Search  List(DNS搜索列表)，其主要用途为在IPv6的主机上进行DNS名称解析以及域后缀的处理。

IPv6 Neighbor Discovery(ND，IPv6邻居发现)和IPv6 Stateless Address   Autoconfiguratioin(SLAAC，IPv6无状态地址自动配置)提供了使用一个或多个IPv6地址，默认路由器以及一些其他参数配置固定节点或移动节点的方法。

当漫游主机每次连接到另一个网络时，无法进行手动配置。 虽然可以进行静态配置，但是在诸如笔记本电脑之类的通用主机上通常不建议这样操作。   例如，如果主机运行直接连接到全局DNS的自己的递归名称服务器，那么本地定义的名称空间对主机来说就不可用了。  访问DNS是几乎所有主机的基本要求，因此IPv6  SLAAC在没有任何DNS配置支持的情况下，不能在任何实际的网络环境中单独作为替代部署模型。

对于IPv4环境中的DNS服务器来说，这些问题都很容易解决。但是对于IPv6的网络环境，这些问题显得比较棘手。因此，RFC8106定义了一种基于DNS  RA选项的机制，以允许IPv6主机执行自动DNS配置。

在通过IPv6   SLAAC自动配置IPv6主机地址并且没有DHCPv6基础结构或一些主机没有DHCPv6客户端的网络环境中，可以使用基于RA的DNS配置作为替代。  但是，对于需要分发其他信息的网络，可能仍然会使用DHCPv6。 在这些网络中，可能不需要基于RA的DNS配置。   基于RA的DNS配置允许IPv6主机获取主机连接到的链接的DNS配置(即DNS递归服务器地址和DNSSL)。   此外，主机会从提供链接配置信息的同一RA消息中学习此DNS配置。

**2. 名词解释**

-  Recursive DNS Server  (RDNSS)：递归DNS服务器，提供递归DNS解析服务的服务器，用于将域名转换为IP地址或解析成RFC1034和RFC1035中定义的PTR记录。
-  RDNSS Option：一个用于向IPv6主机传送RDNSS信息的IPv6的RA option【RFC4861】。
-  DNS Search List (DNSSL)：Pv6主机在执行DNS查询搜索时使用的DNS后缀域名列表，用于搜索简短的不合格域名。
-  DNSSL Option：一个IPv6 RA选项，用于将DNSSL信息传递到IPv6主机。

**3. 详细分析**

\1. 基础分析

RFC8106标准化了RDNSS option，其中包含RDNSSes的地址。该信息使用现有ND  message(例如RA)作为载体。IPv6主机可以通过RA消息配置一个或多个RDNSS的IPv6地址。

(1) 邻居发现扩展

RFC8106中定义的在邻居发现中使用的IPv6 DNS配置算法需要用到2种ND options：RDNSS option和DNSSL  option。与该漏洞相关的是RDNSS option，另外一种则与 CVE-2020-16899相关。

(2)RDNSS Option Structure

RDNSS option总体结构如下：

 [![img](https://s2.51cto.com/oss/202010/19/93aa22fc9486b4a8b7d7f0f96c1e7a2e.jpg)](https://s2.51cto.com/oss/202010/19/93aa22fc9486b4a8b7d7f0f96c1e7a2e.jpg)

对于Length字段，如果该选项中仅包含一个IPv6地址，则最小值为3。  每增加一个RDNSS地址，长度就会增加2。接收的主机使用该字段来确定选项中IPv6地址的数量。

(3)Procedure in IPv6 Hosts

当主机接收到RA消息中的DNS的options时，其处理过程如下：

-  首先检查Lengh字段的合法性：是否大于等于最小值3，以及是否满足(Length - 1) % 2 == 0;
-  对于RDNSS option，还会检查Address字段是否为一个单播地址;
-  如果以上验证通过，则主机应按顺序将选项的值复制到DNS存储库和解析器存储库中。 否则，主机必须丢弃这些选项。

(4)Crash分析

首先分析dmp文件，查看crash现场：

 [![img](https://s2.51cto.com/oss/202010/19/77b54238ba6dc46e3c02d16546ba4759.jpg-wh_600x-s_4023632721.jpg)](https://s2.51cto.com/oss/202010/19/77b54238ba6dc46e3c02d16546ba4759.jpg-wh_600x-s_4023632721.jpg)

 [![img](https://s5.51cto.com/oss/202010/19/ce04c296d2a68e76e0c7ea5bd9ce3077.jpg-wh_600x-s_1542234750.jpg)](https://s5.51cto.com/oss/202010/19/ce04c296d2a68e76e0c7ea5bd9ce3077.jpg-wh_600x-s_1542234750.jpg)

 [![img](https://s6.51cto.com/oss/202010/19/945f81c845574e2fadb2598e2230e98d.jpg-wh_600x-s_3142226080.jpg)](https://s6.51cto.com/oss/202010/19/945f81c845574e2fadb2598e2230e98d.jpg-wh_600x-s_3142226080.jpg)

并没有发现明显的较为有价值的Call Stack信息，但是发现最终的crash原因的是GS机制的Security   Cookie校验失败，也就是说该值被覆盖掉了。那么很有可能是一个溢出。除此之外，只发现了tcpip!Ipv6pHandleRouterAdvertisement+0x1269函数，再往后就直接报gsfailure了。

\2. 静态分析

分析使用的文件为Windows 10 1809 x64的tcpip.sys文件，版本为10.0.17763.316。

(1)函数调用链

根据crash现场信息，获取到关键函数tcpip!Ipv6pHandleRouterAdvertisement()，首先确认该函数到漏洞函数的前后调用链。

首先查看其交叉引用关系：

 [![img](https://s5.51cto.com/oss/202010/19/928fd4cd662ff0f3027bd8675de9feb8.jpg-wh_600x-s_527420695.jpg)](https://s5.51cto.com/oss/202010/19/928fd4cd662ff0f3027bd8675de9feb8.jpg-wh_600x-s_527420695.jpg)

其上层调用函数为Icmpv6ReceiveDatagrams()，跟进，并查看交叉引用关系：

 [![img](https://s4.51cto.com/oss/202010/19/d77104d66392a6e87be3f82afdc3b204.jpg-wh_600x-s_1874134964.jpg)](https://s4.51cto.com/oss/202010/19/d77104d66392a6e87be3f82afdc3b204.jpg-wh_600x-s_1874134964.jpg)

没有再发现显式的函数调用。转而向tcpip!Ipv6pHandleRouterAdvertisement()的下层搜索：

 [![img](https://s3.51cto.com/oss/202010/19/b1be39ecfbbfea49217726f63000e6b3.jpg-wh_600x-s_2639473300.jpg)](https://s3.51cto.com/oss/202010/19/b1be39ecfbbfea49217726f63000e6b3.jpg-wh_600x-s_2639473300.jpg)

发现漏洞函数调用。至此，函数调用链可以简单概括为：

```
Icmpv6ReceiveDatagrams() -> tcpip!Ipv6pHandleRouterAdvertisement() -> Ipv6pUpdateRDNSS() 
```

(2)漏洞函数分析

经过简单分析可以明确，调用链的顶层函数Icmpv6ReceiveDatagrams()没有发现实质性的与该漏洞相关的处理代码，而在tcpip!Ipv6pHandleRouterAdvertisement()   函数中发现了对漏洞函数Ipv6pUpdateRDNSS()的调用。根据crash分析，最后报了gsfailure，而且关键函数为tcpip!Ipv6pHandleRouterAdvertisement()，在该函数的起始位置确实发现了GS校验：

 [![img](https://s4.51cto.com/oss/202010/19/38925f4988e0bdd34ea7b0f3e1b1760b.jpg-wh_600x-s_1119263524.jpg)](https://s4.51cto.com/oss/202010/19/38925f4988e0bdd34ea7b0f3e1b1760b.jpg-wh_600x-s_1119263524.jpg)

那么很有可能是在漏洞函数Ipv6pUpdateRDNSS()中发生了溢出，导致了其调用函数tcpip!Ipv6pHandleRouterAdvertisement()的GS校验失败。

进入漏洞函数Ipv6pUpdateRDNSS()：

 [![img](https://s4.51cto.com/oss/202010/19/ef594be67110e9336c64b9523c52cadb.jpg-wh_600x-s_2313729715.jpg)](https://s4.51cto.com/oss/202010/19/ef594be67110e9336c64b9523c52cadb.jpg-wh_600x-s_2313729715.jpg)

首先获取到RDNSS option结构，然后读取Length字段来计算Address字段有几个Address值。

 [![img](https://s5.51cto.com/oss/202010/19/0f27f22c727e997e9da6f275ed5b7d8d.jpg-wh_600x-s_651727782.jpg)](https://s5.51cto.com/oss/202010/19/0f27f22c727e997e9da6f275ed5b7d8d.jpg-wh_600x-s_651727782.jpg)

确认有多少Address之后，进入循环，对每个Address进行处理，最关键的是分配合适的内存。这里还有一个判断，如果不是单播地址，直接忽略。

在进行处理时，存在一个问题：假设Length的长度为4，那么计算结束之后，AddressCount的值应该为1。此时，按照正常逻辑，Ipv6pUpdateRDNSS()函数应该增加32字节(4*8)的缓冲区，但是后续在分配缓冲区时只分配了24字节：sizeof(ND_OPTION_RDNSS)  + sizeof(IN6_ADDR) = 8 + 16 = 24，从而导致了缓冲区的溢出。

根据RFC8106的标准，Length字段的值应该满足最小为3的奇数的情况。当提供一个偶数Length值时，Windows   TCP/IP堆栈错误地将buffer前进了8个字节。这主要是因为堆栈在内部以16字节为增量进行计数，并且没有使用非RFC兼容长度值的处理代码。这种不匹配导致堆栈将当前选项的最后8个字节解释为第二个选项的开始，最终导致缓冲区溢出和潜在的RCE。

**4. 利用思路**

\1. 利用条件

基本条件

-  attacker需要获取target的IPv6和MAC地址

触发过程

-  attacker需要搭配其他内存泄漏或信息泄漏漏洞来实现RCE
-  attacker需要想办法绕过tcpip.sys的GS保护机制

\2. 利用过程

attacker直接发送特制的ICMPv6路由广播数据包给target：

[ Attacker ]

\3. 攻击向量

建立连接后，利用IPv6直接发送攻击数据包即可。

**5. 流量分析**

因为该漏洞直接走的IPv6，所以对于一些部署在IP层以上的防火墙方案就无法针对该漏洞进行流量检测，但是具备IP层流量检测的防火墙可以轻松检测恶意流量：

 [![img](https://s6.51cto.com/oss/202010/19/0f70a3cba0596223686a199ca81e2d0c.jpg-wh_600x-s_1336469658.jpg)](https://s6.51cto.com/oss/202010/19/0f70a3cba0596223686a199ca81e2d0c.jpg-wh_600x-s_1336469658.jpg)

在流量中可以明显看出，第一个Option结构的Address字段错误识别计算了一个Recursive DNS Server的值：

 [![img](https://s3.51cto.com/oss/202010/19/3a3186f0bf382dd8a4a4180582d4918f.jpg-wh_600x-s_1811782046.jpg)](https://s3.51cto.com/oss/202010/19/3a3186f0bf382dd8a4a4180582d4918f.jpg-wh_600x-s_1811782046.jpg)

第1个Recursive DNS Server的地址为0018-0027，后续的8个字节不应该再进行识别。选中第2个Recursive DNS  Server时情况如下：

 [![img](https://s3.51cto.com/oss/202010/19/7d520c65eea04b6aa4ff5f40ac133140.jpg)](https://s3.51cto.com/oss/202010/19/7d520c65eea04b6aa4ff5f40ac133140.jpg)

第2个Recursive DNS Server的地址为0028-0037。但是该16个字节中的后8个字节很明显为下一个ICMPv6  Option结构的内容：

 [![img](https://s6.51cto.com/oss/202010/19/a60c0ac394670aed77b9ca5de035aa36.jpg)](https://s6.51cto.com/oss/202010/19/a60c0ac394670aed77b9ca5de035aa36.jpg)

**四、参考文献**

-  https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-16898
-  https://tools.ietf.org/html/rfc8106
-  https://www.mcafee.com/blogs/other-blogs/mcafee-labs/cve-2020-16898-bad-neighbor/